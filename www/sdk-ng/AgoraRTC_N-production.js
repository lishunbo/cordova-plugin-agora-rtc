/**
 * AgoraWebSDK_N-v4.1.1-58-gfdaff12-dirty Copyright AgoraInc.
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('cordova-plugin-agora-rtc.NativePlayer')) :
	typeof define === 'function' && define.amd ? define(['cordova-plugin-agora-rtc.NativePlayer'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.AgoraRTC = factory(global.cordovaPluginAgoraRtc_NativePlayer));
}(this, (function (cordovaPluginAgoraRtc_NativePlayer) { 'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule(fn, basedir, module) {
		return module = {
		  path: basedir,
		  exports: {},
		  require: function (path, base) {
	      return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
	    }
		}, fn(module, module.exports), module.exports;
	}

	function commonjsRequire () {
		throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
	}

	var check = function (it) {
	  return it && it.Math == Math && it;
	};

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global_1 =
	  // eslint-disable-next-line no-undef
	  check(typeof globalThis == 'object' && globalThis) ||
	  check(typeof window == 'object' && window) ||
	  check(typeof self == 'object' && self) ||
	  check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||
	  // eslint-disable-next-line no-new-func
	  Function('return this')();

	var fails = function (exec) {
	  try {
	    return !!exec();
	  } catch (error) {
	    return true;
	  }
	};

	// Thank's IE8 for his funny defineProperty
	var descriptors = !fails(function () {
	  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
	});

	var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
	var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	// Nashorn ~ JDK8 bug
	var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);

	// `Object.prototype.propertyIsEnumerable` method implementation
	// https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable
	var f = NASHORN_BUG ? function propertyIsEnumerable(V) {
	  var descriptor = getOwnPropertyDescriptor(this, V);
	  return !!descriptor && descriptor.enumerable;
	} : nativePropertyIsEnumerable;

	var objectPropertyIsEnumerable = {
		f: f
	};

	var createPropertyDescriptor = function (bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};

	var toString = {}.toString;

	var classofRaw = function (it) {
	  return toString.call(it).slice(8, -1);
	};

	var split = ''.split;

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var indexedObject = fails(function () {
	  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
	  // eslint-disable-next-line no-prototype-builtins
	  return !Object('z').propertyIsEnumerable(0);
	}) ? function (it) {
	  return classofRaw(it) == 'String' ? split.call(it, '') : Object(it);
	} : Object;

	// `RequireObjectCoercible` abstract operation
	// https://tc39.github.io/ecma262/#sec-requireobjectcoercible
	var requireObjectCoercible = function (it) {
	  if (it == undefined) throw TypeError("Can't call method on " + it);
	  return it;
	};

	// toObject with fallback for non-array-like ES3 strings



	var toIndexedObject = function (it) {
	  return indexedObject(requireObjectCoercible(it));
	};

	var isObject = function (it) {
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

	// `ToPrimitive` abstract operation
	// https://tc39.github.io/ecma262/#sec-toprimitive
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	var toPrimitive = function (input, PREFERRED_STRING) {
	  if (!isObject(input)) return input;
	  var fn, val;
	  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
	  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
	  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
	  throw TypeError("Can't convert object to primitive value");
	};

	var hasOwnProperty = {}.hasOwnProperty;

	var has = function (it, key) {
	  return hasOwnProperty.call(it, key);
	};

	var document$1 = global_1.document;
	// typeof document.createElement is 'object' in old IE
	var EXISTS = isObject(document$1) && isObject(document$1.createElement);

	var documentCreateElement = function (it) {
	  return EXISTS ? document$1.createElement(it) : {};
	};

	// Thank's IE8 for his funny defineProperty
	var ie8DomDefine = !descriptors && !fails(function () {
	  return Object.defineProperty(documentCreateElement('div'), 'a', {
	    get: function () { return 7; }
	  }).a != 7;
	});

	var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	// `Object.getOwnPropertyDescriptor` method
	// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
	var f$1 = descriptors ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
	  O = toIndexedObject(O);
	  P = toPrimitive(P, true);
	  if (ie8DomDefine) try {
	    return nativeGetOwnPropertyDescriptor(O, P);
	  } catch (error) { /* empty */ }
	  if (has(O, P)) return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]);
	};

	var objectGetOwnPropertyDescriptor = {
		f: f$1
	};

	var replacement = /#|\.prototype\./;

	var isForced = function (feature, detection) {
	  var value = data[normalize(feature)];
	  return value == POLYFILL ? true
	    : value == NATIVE ? false
	    : typeof detection == 'function' ? fails(detection)
	    : !!detection;
	};

	var normalize = isForced.normalize = function (string) {
	  return String(string).replace(replacement, '.').toLowerCase();
	};

	var data = isForced.data = {};
	var NATIVE = isForced.NATIVE = 'N';
	var POLYFILL = isForced.POLYFILL = 'P';

	var isForced_1 = isForced;

	var path = {};

	var aFunction = function (it) {
	  if (typeof it != 'function') {
	    throw TypeError(String(it) + ' is not a function');
	  } return it;
	};

	// optional / simple context binding
	var bindContext = function (fn, that, length) {
	  aFunction(fn);
	  if (that === undefined) return fn;
	  switch (length) {
	    case 0: return function () {
	      return fn.call(that);
	    };
	    case 1: return function (a) {
	      return fn.call(that, a);
	    };
	    case 2: return function (a, b) {
	      return fn.call(that, a, b);
	    };
	    case 3: return function (a, b, c) {
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function (/* ...args */) {
	    return fn.apply(that, arguments);
	  };
	};

	var anObject = function (it) {
	  if (!isObject(it)) {
	    throw TypeError(String(it) + ' is not an object');
	  } return it;
	};

	var nativeDefineProperty = Object.defineProperty;

	// `Object.defineProperty` method
	// https://tc39.github.io/ecma262/#sec-object.defineproperty
	var f$2 = descriptors ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if (ie8DomDefine) try {
	    return nativeDefineProperty(O, P, Attributes);
	  } catch (error) { /* empty */ }
	  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
	  if ('value' in Attributes) O[P] = Attributes.value;
	  return O;
	};

	var objectDefineProperty = {
		f: f$2
	};

	var createNonEnumerableProperty = descriptors ? function (object, key, value) {
	  return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};

	var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;






	var wrapConstructor = function (NativeConstructor) {
	  var Wrapper = function (a, b, c) {
	    if (this instanceof NativeConstructor) {
	      switch (arguments.length) {
	        case 0: return new NativeConstructor();
	        case 1: return new NativeConstructor(a);
	        case 2: return new NativeConstructor(a, b);
	      } return new NativeConstructor(a, b, c);
	    } return NativeConstructor.apply(this, arguments);
	  };
	  Wrapper.prototype = NativeConstructor.prototype;
	  return Wrapper;
	};

	/*
	  options.target      - name of the target object
	  options.global      - target is the global object
	  options.stat        - export as static methods of target
	  options.proto       - export as prototype methods of target
	  options.real        - real prototype method for the `pure` version
	  options.forced      - export even if the native feature is available
	  options.bind        - bind methods to the target, required for the `pure` version
	  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
	  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
	  options.sham        - add a flag to not completely full polyfills
	  options.enumerable  - export as enumerable property
	  options.noTargetGet - prevent calling a getter on target
	*/
	var _export = function (options, source) {
	  var TARGET = options.target;
	  var GLOBAL = options.global;
	  var STATIC = options.stat;
	  var PROTO = options.proto;

	  var nativeSource = GLOBAL ? global_1 : STATIC ? global_1[TARGET] : (global_1[TARGET] || {}).prototype;

	  var target = GLOBAL ? path : path[TARGET] || (path[TARGET] = {});
	  var targetPrototype = target.prototype;

	  var FORCED, USE_NATIVE, VIRTUAL_PROTOTYPE;
	  var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;

	  for (key in source) {
	    FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
	    // contains in native
	    USE_NATIVE = !FORCED && nativeSource && has(nativeSource, key);

	    targetProperty = target[key];

	    if (USE_NATIVE) if (options.noTargetGet) {
	      descriptor = getOwnPropertyDescriptor$1(nativeSource, key);
	      nativeProperty = descriptor && descriptor.value;
	    } else nativeProperty = nativeSource[key];

	    // export native or implementation
	    sourceProperty = (USE_NATIVE && nativeProperty) ? nativeProperty : source[key];

	    if (USE_NATIVE && typeof targetProperty === typeof sourceProperty) continue;

	    // bind timers to global for call from export context
	    if (options.bind && USE_NATIVE) resultProperty = bindContext(sourceProperty, global_1);
	    // wrap global constructors for prevent changs in this version
	    else if (options.wrap && USE_NATIVE) resultProperty = wrapConstructor(sourceProperty);
	    // make static versions for prototype methods
	    else if (PROTO && typeof sourceProperty == 'function') resultProperty = bindContext(Function.call, sourceProperty);
	    // default case
	    else resultProperty = sourceProperty;

	    // add a flag to not completely full polyfills
	    if (options.sham || (sourceProperty && sourceProperty.sham) || (targetProperty && targetProperty.sham)) {
	      createNonEnumerableProperty(resultProperty, 'sham', true);
	    }

	    target[key] = resultProperty;

	    if (PROTO) {
	      VIRTUAL_PROTOTYPE = TARGET + 'Prototype';
	      if (!has(path, VIRTUAL_PROTOTYPE)) {
	        createNonEnumerableProperty(path, VIRTUAL_PROTOTYPE, {});
	      }
	      // export virtual prototype methods
	      path[VIRTUAL_PROTOTYPE][key] = sourceProperty;
	      // export real prototype methods
	      if (options.real && targetPrototype && !targetPrototype[key]) {
	        createNonEnumerableProperty(targetPrototype, key, sourceProperty);
	      }
	    }
	  }
	};

	var aFunction$1 = function (variable) {
	  return typeof variable == 'function' ? variable : undefined;
	};

	var getBuiltIn = function (namespace, method) {
	  return arguments.length < 2 ? aFunction$1(path[namespace]) || aFunction$1(global_1[namespace])
	    : path[namespace] && path[namespace][method] || global_1[namespace] && global_1[namespace][method];
	};

	var $stringify = getBuiltIn('JSON', 'stringify');
	var re = /[\uD800-\uDFFF]/g;
	var low = /^[\uD800-\uDBFF]$/;
	var hi = /^[\uDC00-\uDFFF]$/;

	var fix = function (match, offset, string) {
	  var prev = string.charAt(offset - 1);
	  var next = string.charAt(offset + 1);
	  if ((low.test(match) && !hi.test(next)) || (hi.test(match) && !low.test(prev))) {
	    return '\\u' + match.charCodeAt(0).toString(16);
	  } return match;
	};

	var FORCED = fails(function () {
	  return $stringify('\uDF06\uD834') !== '"\\udf06\\ud834"'
	    || $stringify('\uDEAD') !== '"\\udead"';
	});

	if ($stringify) {
	  // https://github.com/tc39/proposal-well-formed-stringify
	  _export({ target: 'JSON', stat: true, forced: FORCED }, {
	    // eslint-disable-next-line no-unused-vars
	    stringify: function stringify(it, replacer, space) {
	      var result = $stringify.apply(null, arguments);
	      return typeof result == 'string' ? result.replace(re, fix) : result;
	    }
	  });
	}

	if (!path.JSON) path.JSON = { stringify: JSON.stringify };

	// eslint-disable-next-line no-unused-vars
	var stringify = function stringify(it, replacer, space) {
	  return path.JSON.stringify.apply(null, arguments);
	};

	var stringify$1 = stringify;

	var stringify$2 = stringify$1;

	window.process = {
	  env: {
	    DEBUG: undefined
	  }
	};

	var hiddenKeys = {};

	var id = 0;
	var postfix = Math.random();

	var uid = function (key) {
	  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
	};

	var freezing = !fails(function () {
	  return Object.isExtensible(Object.preventExtensions({}));
	});

	var internalMetadata = createCommonjsModule(function (module) {
	var defineProperty = objectDefineProperty.f;



	var METADATA = uid('meta');
	var id = 0;

	var isExtensible = Object.isExtensible || function () {
	  return true;
	};

	var setMetadata = function (it) {
	  defineProperty(it, METADATA, { value: {
	    objectID: 'O' + ++id, // object ID
	    weakData: {}          // weak collections IDs
	  } });
	};

	var fastKey = function (it, create) {
	  // return a primitive with prefix
	  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if (!has(it, METADATA)) {
	    // can't set metadata to uncaught frozen object
	    if (!isExtensible(it)) return 'F';
	    // not necessary to add metadata
	    if (!create) return 'E';
	    // add missing metadata
	    setMetadata(it);
	  // return object ID
	  } return it[METADATA].objectID;
	};

	var getWeakData = function (it, create) {
	  if (!has(it, METADATA)) {
	    // can't set metadata to uncaught frozen object
	    if (!isExtensible(it)) return true;
	    // not necessary to add metadata
	    if (!create) return false;
	    // add missing metadata
	    setMetadata(it);
	  // return the store of weak collections IDs
	  } return it[METADATA].weakData;
	};

	// add metadata on freeze-family methods calling
	var onFreeze = function (it) {
	  if (freezing && meta.REQUIRED && isExtensible(it) && !has(it, METADATA)) setMetadata(it);
	  return it;
	};

	var meta = module.exports = {
	  REQUIRED: false,
	  fastKey: fastKey,
	  getWeakData: getWeakData,
	  onFreeze: onFreeze
	};

	hiddenKeys[METADATA] = true;
	});

	var isPure = true;

	var setGlobal = function (key, value) {
	  try {
	    createNonEnumerableProperty(global_1, key, value);
	  } catch (error) {
	    global_1[key] = value;
	  } return value;
	};

	var SHARED = '__core-js_shared__';
	var store = global_1[SHARED] || setGlobal(SHARED, {});

	var sharedStore = store;

	var shared = createCommonjsModule(function (module) {
	(module.exports = function (key, value) {
	  return sharedStore[key] || (sharedStore[key] = value !== undefined ? value : {});
	})('versions', []).push({
	  version: '3.4.3',
	  mode:  'pure' ,
	  copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
	});
	});

	var nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function () {
	  // Chrome 38 Symbol has incorrect toString conversion
	  // eslint-disable-next-line no-undef
	  return !String(Symbol());
	});

	var useSymbolAsUid = nativeSymbol
	  // eslint-disable-next-line no-undef
	  && !Symbol.sham
	  // eslint-disable-next-line no-undef
	  && typeof Symbol() == 'symbol';

	var WellKnownSymbolsStore = shared('wks');
	var Symbol$1 = global_1.Symbol;
	var createWellKnownSymbol = useSymbolAsUid ? Symbol$1 : uid;

	var wellKnownSymbol = function (name) {
	  if (!has(WellKnownSymbolsStore, name)) {
	    if (nativeSymbol && has(Symbol$1, name)) WellKnownSymbolsStore[name] = Symbol$1[name];
	    else WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
	  } return WellKnownSymbolsStore[name];
	};

	var iterators = {};

	var ITERATOR = wellKnownSymbol('iterator');
	var ArrayPrototype = Array.prototype;

	// check on default Array iterator
	var isArrayIteratorMethod = function (it) {
	  return it !== undefined && (iterators.Array === it || ArrayPrototype[ITERATOR] === it);
	};

	var ceil = Math.ceil;
	var floor = Math.floor;

	// `ToInteger` abstract operation
	// https://tc39.github.io/ecma262/#sec-tointeger
	var toInteger = function (argument) {
	  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
	};

	var min = Math.min;

	// `ToLength` abstract operation
	// https://tc39.github.io/ecma262/#sec-tolength
	var toLength = function (argument) {
	  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
	};

	var TO_STRING_TAG = wellKnownSymbol('toStringTag');
	var test = {};

	test[TO_STRING_TAG] = 'z';

	var toStringTagSupport = String(test) === '[object z]';

	var TO_STRING_TAG$1 = wellKnownSymbol('toStringTag');
	// ES3 wrong here
	var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

	// fallback for IE11 Script Access Denied error
	var tryGet = function (it, key) {
	  try {
	    return it[key];
	  } catch (error) { /* empty */ }
	};

	// getting tag from ES6+ `Object.prototype.toString`
	var classof = toStringTagSupport ? classofRaw : function (it) {
	  var O, tag, result;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG$1)) == 'string' ? tag
	    // builtinTag case
	    : CORRECT_ARGUMENTS ? classofRaw(O)
	    // ES3 arguments fallback
	    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
	};

	var ITERATOR$1 = wellKnownSymbol('iterator');

	var getIteratorMethod = function (it) {
	  if (it != undefined) return it[ITERATOR$1]
	    || it['@@iterator']
	    || iterators[classof(it)];
	};

	// call something on iterator step with safe closing on error
	var callWithSafeIterationClosing = function (iterator, fn, value, ENTRIES) {
	  try {
	    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch (error) {
	    var returnMethod = iterator['return'];
	    if (returnMethod !== undefined) anObject(returnMethod.call(iterator));
	    throw error;
	  }
	};

	var iterate_1 = createCommonjsModule(function (module) {
	var Result = function (stopped, result) {
	  this.stopped = stopped;
	  this.result = result;
	};

	var iterate = module.exports = function (iterable, fn, that, AS_ENTRIES, IS_ITERATOR) {
	  var boundFunction = bindContext(fn, that, AS_ENTRIES ? 2 : 1);
	  var iterator, iterFn, index, length, result, next, step;

	  if (IS_ITERATOR) {
	    iterator = iterable;
	  } else {
	    iterFn = getIteratorMethod(iterable);
	    if (typeof iterFn != 'function') throw TypeError('Target is not iterable');
	    // optimisation for array iterators
	    if (isArrayIteratorMethod(iterFn)) {
	      for (index = 0, length = toLength(iterable.length); length > index; index++) {
	        result = AS_ENTRIES
	          ? boundFunction(anObject(step = iterable[index])[0], step[1])
	          : boundFunction(iterable[index]);
	        if (result && result instanceof Result) return result;
	      } return new Result(false);
	    }
	    iterator = iterFn.call(iterable);
	  }

	  next = iterator.next;
	  while (!(step = next.call(iterator)).done) {
	    result = callWithSafeIterationClosing(iterator, boundFunction, step.value, AS_ENTRIES);
	    if (typeof result == 'object' && result && result instanceof Result) return result;
	  } return new Result(false);
	};

	iterate.stop = function (result) {
	  return new Result(true, result);
	};
	});

	var anInstance = function (it, Constructor, name) {
	  if (!(it instanceof Constructor)) {
	    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
	  } return it;
	};

	// `Object.prototype.toString` method implementation
	// https://tc39.github.io/ecma262/#sec-object.prototype.tostring
	var objectToString = toStringTagSupport ? {}.toString : function toString() {
	  return '[object ' + classof(this) + ']';
	};

	var defineProperty = objectDefineProperty.f;





	var TO_STRING_TAG$2 = wellKnownSymbol('toStringTag');

	var setToStringTag = function (it, TAG, STATIC, SET_METHOD) {
	  if (it) {
	    var target = STATIC ? it : it.prototype;
	    if (!has(target, TO_STRING_TAG$2)) {
	      defineProperty(target, TO_STRING_TAG$2, { configurable: true, value: TAG });
	    }
	    if (SET_METHOD && !toStringTagSupport) {
	      createNonEnumerableProperty(target, 'toString', objectToString);
	    }
	  }
	};

	// `ToObject` abstract operation
	// https://tc39.github.io/ecma262/#sec-toobject
	var toObject = function (argument) {
	  return Object(requireObjectCoercible(argument));
	};

	// `IsArray` abstract operation
	// https://tc39.github.io/ecma262/#sec-isarray
	var isArray = Array.isArray || function isArray(arg) {
	  return classofRaw(arg) == 'Array';
	};

	var SPECIES = wellKnownSymbol('species');

	// `ArraySpeciesCreate` abstract operation
	// https://tc39.github.io/ecma262/#sec-arrayspeciescreate
	var arraySpeciesCreate = function (originalArray, length) {
	  var C;
	  if (isArray(originalArray)) {
	    C = originalArray.constructor;
	    // cross-realm fallback
	    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
	    else if (isObject(C)) {
	      C = C[SPECIES];
	      if (C === null) C = undefined;
	    }
	  } return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
	};

	var push = [].push;

	// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex }` methods implementation
	var createMethod = function (TYPE) {
	  var IS_MAP = TYPE == 1;
	  var IS_FILTER = TYPE == 2;
	  var IS_SOME = TYPE == 3;
	  var IS_EVERY = TYPE == 4;
	  var IS_FIND_INDEX = TYPE == 6;
	  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
	  return function ($this, callbackfn, that, specificCreate) {
	    var O = toObject($this);
	    var self = indexedObject(O);
	    var boundFunction = bindContext(callbackfn, that, 3);
	    var length = toLength(self.length);
	    var index = 0;
	    var create = specificCreate || arraySpeciesCreate;
	    var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
	    var value, result;
	    for (;length > index; index++) if (NO_HOLES || index in self) {
	      value = self[index];
	      result = boundFunction(value, index, O);
	      if (TYPE) {
	        if (IS_MAP) target[index] = result; // map
	        else if (result) switch (TYPE) {
	          case 3: return true;              // some
	          case 5: return value;             // find
	          case 6: return index;             // findIndex
	          case 2: push.call(target, value); // filter
	        } else if (IS_EVERY) return false;  // every
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
	  };
	};

	var arrayIteration = {
	  // `Array.prototype.forEach` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
	  forEach: createMethod(0),
	  // `Array.prototype.map` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.map
	  map: createMethod(1),
	  // `Array.prototype.filter` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.filter
	  filter: createMethod(2),
	  // `Array.prototype.some` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.some
	  some: createMethod(3),
	  // `Array.prototype.every` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.every
	  every: createMethod(4),
	  // `Array.prototype.find` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.find
	  find: createMethod(5),
	  // `Array.prototype.findIndex` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
	  findIndex: createMethod(6)
	};

	var functionToString = shared('native-function-to-string', Function.toString);

	var WeakMap = global_1.WeakMap;

	var nativeWeakMap = typeof WeakMap === 'function' && /native code/.test(functionToString.call(WeakMap));

	var keys = shared('keys');

	var sharedKey = function (key) {
	  return keys[key] || (keys[key] = uid(key));
	};

	var WeakMap$1 = global_1.WeakMap;
	var set, get, has$1;

	var enforce = function (it) {
	  return has$1(it) ? get(it) : set(it, {});
	};

	var getterFor = function (TYPE) {
	  return function (it) {
	    var state;
	    if (!isObject(it) || (state = get(it)).type !== TYPE) {
	      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
	    } return state;
	  };
	};

	if (nativeWeakMap) {
	  var store$1 = new WeakMap$1();
	  var wmget = store$1.get;
	  var wmhas = store$1.has;
	  var wmset = store$1.set;
	  set = function (it, metadata) {
	    wmset.call(store$1, it, metadata);
	    return metadata;
	  };
	  get = function (it) {
	    return wmget.call(store$1, it) || {};
	  };
	  has$1 = function (it) {
	    return wmhas.call(store$1, it);
	  };
	} else {
	  var STATE = sharedKey('state');
	  hiddenKeys[STATE] = true;
	  set = function (it, metadata) {
	    createNonEnumerableProperty(it, STATE, metadata);
	    return metadata;
	  };
	  get = function (it) {
	    return has(it, STATE) ? it[STATE] : {};
	  };
	  has$1 = function (it) {
	    return has(it, STATE);
	  };
	}

	var internalState = {
	  set: set,
	  get: get,
	  has: has$1,
	  enforce: enforce,
	  getterFor: getterFor
	};

	var defineProperty$1 = objectDefineProperty.f;
	var forEach = arrayIteration.forEach;



	var setInternalState = internalState.set;
	var internalStateGetterFor = internalState.getterFor;

	var collection = function (CONSTRUCTOR_NAME, wrapper, common) {
	  var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
	  var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
	  var ADDER = IS_MAP ? 'set' : 'add';
	  var NativeConstructor = global_1[CONSTRUCTOR_NAME];
	  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
	  var exported = {};
	  var Constructor;

	  if (!descriptors || typeof NativeConstructor != 'function'
	    || !(IS_WEAK || NativePrototype.forEach && !fails(function () { new NativeConstructor().entries().next(); }))
	  ) {
	    // create collection constructor
	    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
	    internalMetadata.REQUIRED = true;
	  } else {
	    Constructor = wrapper(function (target, iterable) {
	      setInternalState(anInstance(target, Constructor, CONSTRUCTOR_NAME), {
	        type: CONSTRUCTOR_NAME,
	        collection: new NativeConstructor()
	      });
	      if (iterable != undefined) iterate_1(iterable, target[ADDER], target, IS_MAP);
	    });

	    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

	    forEach(['add', 'clear', 'delete', 'forEach', 'get', 'has', 'set', 'keys', 'values', 'entries'], function (KEY) {
	      var IS_ADDER = KEY == 'add' || KEY == 'set';
	      if (KEY in NativePrototype && !(IS_WEAK && KEY == 'clear')) {
	        createNonEnumerableProperty(Constructor.prototype, KEY, function (a, b) {
	          var collection = getInternalState(this).collection;
	          if (!IS_ADDER && IS_WEAK && !isObject(a)) return KEY == 'get' ? undefined : false;
	          var result = collection[KEY](a === 0 ? 0 : a, b);
	          return IS_ADDER ? this : result;
	        });
	      }
	    });

	    IS_WEAK || defineProperty$1(Constructor.prototype, 'size', {
	      configurable: true,
	      get: function () {
	        return getInternalState(this).collection.size;
	      }
	    });
	  }

	  setToStringTag(Constructor, CONSTRUCTOR_NAME, false, true);

	  exported[CONSTRUCTOR_NAME] = Constructor;
	  _export({ global: true, forced: true }, exported);

	  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);

	  return Constructor;
	};

	var max = Math.max;
	var min$1 = Math.min;

	// Helper for a popular repeating case of the spec:
	// Let integer be ? ToInteger(index).
	// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
	var toAbsoluteIndex = function (index, length) {
	  var integer = toInteger(index);
	  return integer < 0 ? max(integer + length, 0) : min$1(integer, length);
	};

	// `Array.prototype.{ indexOf, includes }` methods implementation
	var createMethod$1 = function (IS_INCLUDES) {
	  return function ($this, el, fromIndex) {
	    var O = toIndexedObject($this);
	    var length = toLength(O.length);
	    var index = toAbsoluteIndex(fromIndex, length);
	    var value;
	    // Array#includes uses SameValueZero equality algorithm
	    // eslint-disable-next-line no-self-compare
	    if (IS_INCLUDES && el != el) while (length > index) {
	      value = O[index++];
	      // eslint-disable-next-line no-self-compare
	      if (value != value) return true;
	    // Array#indexOf ignores holes, Array#includes - not
	    } else for (;length > index; index++) {
	      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

	var arrayIncludes = {
	  // `Array.prototype.includes` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.includes
	  includes: createMethod$1(true),
	  // `Array.prototype.indexOf` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
	  indexOf: createMethod$1(false)
	};

	var indexOf = arrayIncludes.indexOf;


	var objectKeysInternal = function (object, names) {
	  var O = toIndexedObject(object);
	  var i = 0;
	  var result = [];
	  var key;
	  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while (names.length > i) if (has(O, key = names[i++])) {
	    ~indexOf(result, key) || result.push(key);
	  }
	  return result;
	};

	// IE8- don't enum bug keys
	var enumBugKeys = [
	  'constructor',
	  'hasOwnProperty',
	  'isPrototypeOf',
	  'propertyIsEnumerable',
	  'toLocaleString',
	  'toString',
	  'valueOf'
	];

	// `Object.keys` method
	// https://tc39.github.io/ecma262/#sec-object.keys
	var objectKeys = Object.keys || function keys(O) {
	  return objectKeysInternal(O, enumBugKeys);
	};

	// `Object.defineProperties` method
	// https://tc39.github.io/ecma262/#sec-object.defineproperties
	var objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
	  anObject(O);
	  var keys = objectKeys(Properties);
	  var length = keys.length;
	  var index = 0;
	  var key;
	  while (length > index) objectDefineProperty.f(O, key = keys[index++], Properties[key]);
	  return O;
	};

	var html = getBuiltIn('document', 'documentElement');

	var IE_PROTO = sharedKey('IE_PROTO');

	var PROTOTYPE = 'prototype';
	var Empty = function () { /* empty */ };

	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function () {
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = documentCreateElement('iframe');
	  var length = enumBugKeys.length;
	  var lt = '<';
	  var script = 'script';
	  var gt = '>';
	  var js = 'java' + script + ':';
	  var iframeDocument;
	  iframe.style.display = 'none';
	  html.appendChild(iframe);
	  iframe.src = String(js);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(lt + script + gt + 'document.F=Object' + lt + '/' + script + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while (length--) delete createDict[PROTOTYPE][enumBugKeys[length]];
	  return createDict();
	};

	// `Object.create` method
	// https://tc39.github.io/ecma262/#sec-object.create
	var objectCreate = Object.create || function create(O, Properties) {
	  var result;
	  if (O !== null) {
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty();
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : objectDefineProperties(result, Properties);
	};

	hiddenKeys[IE_PROTO] = true;

	var redefine = function (target, key, value, options) {
	  if (options && options.enumerable) target[key] = value;
	  else createNonEnumerableProperty(target, key, value);
	};

	var redefineAll = function (target, src, options) {
	  for (var key in src) {
	    if (options && options.unsafe && target[key]) target[key] = src[key];
	    else redefine(target, key, src[key], options);
	  } return target;
	};

	var correctPrototypeGetter = !fails(function () {
	  function F() { /* empty */ }
	  F.prototype.constructor = null;
	  return Object.getPrototypeOf(new F()) !== F.prototype;
	});

	var IE_PROTO$1 = sharedKey('IE_PROTO');
	var ObjectPrototype = Object.prototype;

	// `Object.getPrototypeOf` method
	// https://tc39.github.io/ecma262/#sec-object.getprototypeof
	var objectGetPrototypeOf = correctPrototypeGetter ? Object.getPrototypeOf : function (O) {
	  O = toObject(O);
	  if (has(O, IE_PROTO$1)) return O[IE_PROTO$1];
	  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectPrototype : null;
	};

	var ITERATOR$2 = wellKnownSymbol('iterator');
	var BUGGY_SAFARI_ITERATORS = false;

	// `%IteratorPrototype%` object
	// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object
	var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

	if ([].keys) {
	  arrayIterator = [].keys();
	  // Safari 8 has buggy iterators w/o `next`
	  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
	  else {
	    PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));
	    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
	  }
	}

	if (IteratorPrototype == undefined) IteratorPrototype = {};

	var iteratorsCore = {
	  IteratorPrototype: IteratorPrototype,
	  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
	};

	var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;





	var returnThis = function () { return this; };

	var createIteratorConstructor = function (IteratorConstructor, NAME, next) {
	  var TO_STRING_TAG = NAME + ' Iterator';
	  IteratorConstructor.prototype = objectCreate(IteratorPrototype$1, { next: createPropertyDescriptor(1, next) });
	  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
	  iterators[TO_STRING_TAG] = returnThis;
	  return IteratorConstructor;
	};

	var aPossiblePrototype = function (it) {
	  if (!isObject(it) && it !== null) {
	    throw TypeError("Can't set " + String(it) + ' as a prototype');
	  } return it;
	};

	// `Object.setPrototypeOf` method
	// https://tc39.github.io/ecma262/#sec-object.setprototypeof
	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
	  var CORRECT_SETTER = false;
	  var test = {};
	  var setter;
	  try {
	    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
	    setter.call(test, []);
	    CORRECT_SETTER = test instanceof Array;
	  } catch (error) { /* empty */ }
	  return function setPrototypeOf(O, proto) {
	    anObject(O);
	    aPossiblePrototype(proto);
	    if (CORRECT_SETTER) setter.call(O, proto);
	    else O.__proto__ = proto;
	    return O;
	  };
	}() : undefined);

	var IteratorPrototype$2 = iteratorsCore.IteratorPrototype;
	var BUGGY_SAFARI_ITERATORS$1 = iteratorsCore.BUGGY_SAFARI_ITERATORS;
	var ITERATOR$3 = wellKnownSymbol('iterator');
	var KEYS = 'keys';
	var VALUES = 'values';
	var ENTRIES = 'entries';

	var returnThis$1 = function () { return this; };

	var defineIterator = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
	  createIteratorConstructor(IteratorConstructor, NAME, next);

	  var getIterationMethod = function (KIND) {
	    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
	    if (!BUGGY_SAFARI_ITERATORS$1 && KIND in IterablePrototype) return IterablePrototype[KIND];
	    switch (KIND) {
	      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
	      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
	      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
	    } return function () { return new IteratorConstructor(this); };
	  };

	  var TO_STRING_TAG = NAME + ' Iterator';
	  var INCORRECT_VALUES_NAME = false;
	  var IterablePrototype = Iterable.prototype;
	  var nativeIterator = IterablePrototype[ITERATOR$3]
	    || IterablePrototype['@@iterator']
	    || DEFAULT && IterablePrototype[DEFAULT];
	  var defaultIterator = !BUGGY_SAFARI_ITERATORS$1 && nativeIterator || getIterationMethod(DEFAULT);
	  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
	  var CurrentIteratorPrototype, methods, KEY;

	  // fix native
	  if (anyNativeIterator) {
	    CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));
	    if (IteratorPrototype$2 !== Object.prototype && CurrentIteratorPrototype.next) {
	      // Set @@toStringTag to native iterators
	      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
	      iterators[TO_STRING_TAG] = returnThis$1;
	    }
	  }

	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
	    INCORRECT_VALUES_NAME = true;
	    defaultIterator = function values() { return nativeIterator.call(this); };
	  }

	  // define iterator
	  if (( FORCED) && IterablePrototype[ITERATOR$3] !== defaultIterator) {
	    createNonEnumerableProperty(IterablePrototype, ITERATOR$3, defaultIterator);
	  }
	  iterators[NAME] = defaultIterator;

	  // export additional methods
	  if (DEFAULT) {
	    methods = {
	      values: getIterationMethod(VALUES),
	      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
	      entries: getIterationMethod(ENTRIES)
	    };
	    if (FORCED) for (KEY in methods) {
	      if (BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
	        redefine(IterablePrototype, KEY, methods[KEY]);
	      }
	    } else _export({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME }, methods);
	  }

	  return methods;
	};

	var SPECIES$1 = wellKnownSymbol('species');

	var setSpecies = function (CONSTRUCTOR_NAME) {
	  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
	  var defineProperty = objectDefineProperty.f;

	  if (descriptors && Constructor && !Constructor[SPECIES$1]) {
	    defineProperty(Constructor, SPECIES$1, {
	      configurable: true,
	      get: function () { return this; }
	    });
	  }
	};

	var defineProperty$2 = objectDefineProperty.f;








	var fastKey = internalMetadata.fastKey;


	var setInternalState$1 = internalState.set;
	var internalStateGetterFor$1 = internalState.getterFor;

	var collectionStrong = {
	  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
	    var C = wrapper(function (that, iterable) {
	      anInstance(that, C, CONSTRUCTOR_NAME);
	      setInternalState$1(that, {
	        type: CONSTRUCTOR_NAME,
	        index: objectCreate(null),
	        first: undefined,
	        last: undefined,
	        size: 0
	      });
	      if (!descriptors) that.size = 0;
	      if (iterable != undefined) iterate_1(iterable, that[ADDER], that, IS_MAP);
	    });

	    var getInternalState = internalStateGetterFor$1(CONSTRUCTOR_NAME);

	    var define = function (that, key, value) {
	      var state = getInternalState(that);
	      var entry = getEntry(that, key);
	      var previous, index;
	      // change existing entry
	      if (entry) {
	        entry.value = value;
	      // create new entry
	      } else {
	        state.last = entry = {
	          index: index = fastKey(key, true),
	          key: key,
	          value: value,
	          previous: previous = state.last,
	          next: undefined,
	          removed: false
	        };
	        if (!state.first) state.first = entry;
	        if (previous) previous.next = entry;
	        if (descriptors) state.size++;
	        else that.size++;
	        // add to index
	        if (index !== 'F') state.index[index] = entry;
	      } return that;
	    };

	    var getEntry = function (that, key) {
	      var state = getInternalState(that);
	      // fast case
	      var index = fastKey(key);
	      var entry;
	      if (index !== 'F') return state.index[index];
	      // frozen object case
	      for (entry = state.first; entry; entry = entry.next) {
	        if (entry.key == key) return entry;
	      }
	    };

	    redefineAll(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear() {
	        var that = this;
	        var state = getInternalState(that);
	        var data = state.index;
	        var entry = state.first;
	        while (entry) {
	          entry.removed = true;
	          if (entry.previous) entry.previous = entry.previous.next = undefined;
	          delete data[entry.index];
	          entry = entry.next;
	        }
	        state.first = state.last = undefined;
	        if (descriptors) state.size = 0;
	        else that.size = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function (key) {
	        var that = this;
	        var state = getInternalState(that);
	        var entry = getEntry(that, key);
	        if (entry) {
	          var next = entry.next;
	          var prev = entry.previous;
	          delete state.index[entry.index];
	          entry.removed = true;
	          if (prev) prev.next = next;
	          if (next) next.previous = prev;
	          if (state.first == entry) state.first = next;
	          if (state.last == entry) state.last = prev;
	          if (descriptors) state.size--;
	          else that.size--;
	        } return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /* , that = undefined */) {
	        var state = getInternalState(this);
	        var boundFunction = bindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
	        var entry;
	        while (entry = entry ? entry.next : state.first) {
	          boundFunction(entry.value, entry.key, this);
	          // revert to the last existing entry
	          while (entry && entry.removed) entry = entry.previous;
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key) {
	        return !!getEntry(this, key);
	      }
	    });

	    redefineAll(C.prototype, IS_MAP ? {
	      // 23.1.3.6 Map.prototype.get(key)
	      get: function get(key) {
	        var entry = getEntry(this, key);
	        return entry && entry.value;
	      },
	      // 23.1.3.9 Map.prototype.set(key, value)
	      set: function set(key, value) {
	        return define(this, key === 0 ? 0 : key, value);
	      }
	    } : {
	      // 23.2.3.1 Set.prototype.add(value)
	      add: function add(value) {
	        return define(this, value = value === 0 ? 0 : value, value);
	      }
	    });
	    if (descriptors) defineProperty$2(C.prototype, 'size', {
	      get: function () {
	        return getInternalState(this).size;
	      }
	    });
	    return C;
	  },
	  setStrong: function (C, CONSTRUCTOR_NAME, IS_MAP) {
	    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
	    var getInternalCollectionState = internalStateGetterFor$1(CONSTRUCTOR_NAME);
	    var getInternalIteratorState = internalStateGetterFor$1(ITERATOR_NAME);
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    defineIterator(C, CONSTRUCTOR_NAME, function (iterated, kind) {
	      setInternalState$1(this, {
	        type: ITERATOR_NAME,
	        target: iterated,
	        state: getInternalCollectionState(iterated),
	        kind: kind,
	        last: undefined
	      });
	    }, function () {
	      var state = getInternalIteratorState(this);
	      var kind = state.kind;
	      var entry = state.last;
	      // revert to the last existing entry
	      while (entry && entry.removed) entry = entry.previous;
	      // get next entry
	      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
	        // or finish the iteration
	        state.target = undefined;
	        return { value: undefined, done: true };
	      }
	      // return step by kind
	      if (kind == 'keys') return { value: entry.key, done: false };
	      if (kind == 'values') return { value: entry.value, done: false };
	      return { value: [entry.key, entry.value], done: false };
	    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

	    // add [@@species], 23.1.2.2, 23.2.2.2
	    setSpecies(CONSTRUCTOR_NAME);
	  }
	};

	// `Map` constructor
	// https://tc39.github.io/ecma262/#sec-map-objects
	var es_map = collection('Map', function (init) {
	  return function Map() { return init(this, arguments.length ? arguments[0] : undefined); };
	}, collectionStrong);

	// `String.prototype.{ codePointAt, at }` methods implementation
	var createMethod$2 = function (CONVERT_TO_STRING) {
	  return function ($this, pos) {
	    var S = String(requireObjectCoercible($this));
	    var position = toInteger(pos);
	    var size = S.length;
	    var first, second;
	    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
	    first = S.charCodeAt(position);
	    return first < 0xD800 || first > 0xDBFF || position + 1 === size
	      || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF
	        ? CONVERT_TO_STRING ? S.charAt(position) : first
	        : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
	  };
	};

	var stringMultibyte = {
	  // `String.prototype.codePointAt` method
	  // https://tc39.github.io/ecma262/#sec-string.prototype.codepointat
	  codeAt: createMethod$2(false),
	  // `String.prototype.at` method
	  // https://github.com/mathiasbynens/String.prototype.at
	  charAt: createMethod$2(true)
	};

	var charAt = stringMultibyte.charAt;



	var STRING_ITERATOR = 'String Iterator';
	var setInternalState$2 = internalState.set;
	var getInternalState = internalState.getterFor(STRING_ITERATOR);

	// `String.prototype[@@iterator]` method
	// https://tc39.github.io/ecma262/#sec-string.prototype-@@iterator
	defineIterator(String, 'String', function (iterated) {
	  setInternalState$2(this, {
	    type: STRING_ITERATOR,
	    string: String(iterated),
	    index: 0
	  });
	// `%StringIteratorPrototype%.next` method
	// https://tc39.github.io/ecma262/#sec-%stringiteratorprototype%.next
	}, function next() {
	  var state = getInternalState(this);
	  var string = state.string;
	  var index = state.index;
	  var point;
	  if (index >= string.length) return { value: undefined, done: true };
	  point = charAt(string, index);
	  state.index += point.length;
	  return { value: point, done: false };
	});

	var ARRAY_ITERATOR = 'Array Iterator';
	var setInternalState$3 = internalState.set;
	var getInternalState$1 = internalState.getterFor(ARRAY_ITERATOR);

	// `Array.prototype.entries` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.entries
	// `Array.prototype.keys` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.keys
	// `Array.prototype.values` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.values
	// `Array.prototype[@@iterator]` method
	// https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator
	// `CreateArrayIterator` internal method
	// https://tc39.github.io/ecma262/#sec-createarrayiterator
	var es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {
	  setInternalState$3(this, {
	    type: ARRAY_ITERATOR,
	    target: toIndexedObject(iterated), // target
	    index: 0,                          // next index
	    kind: kind                         // kind
	  });
	// `%ArrayIteratorPrototype%.next` method
	// https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next
	}, function () {
	  var state = getInternalState$1(this);
	  var target = state.target;
	  var kind = state.kind;
	  var index = state.index++;
	  if (!target || index >= target.length) {
	    state.target = undefined;
	    return { value: undefined, done: true };
	  }
	  if (kind == 'keys') return { value: index, done: false };
	  if (kind == 'values') return { value: target[index], done: false };
	  return { value: [index, target[index]], done: false };
	}, 'values');

	// argumentsList[@@iterator] is %ArrayProto_values%
	// https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject
	// https://tc39.github.io/ecma262/#sec-createmappedargumentsobject
	iterators.Arguments = iterators.Array;

	// iterable DOM collections
	// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
	var domIterables = {
	  CSSRuleList: 0,
	  CSSStyleDeclaration: 0,
	  CSSValueList: 0,
	  ClientRectList: 0,
	  DOMRectList: 0,
	  DOMStringList: 0,
	  DOMTokenList: 1,
	  DataTransferItemList: 0,
	  FileList: 0,
	  HTMLAllCollection: 0,
	  HTMLCollection: 0,
	  HTMLFormElement: 0,
	  HTMLSelectElement: 0,
	  MediaList: 0,
	  MimeTypeArray: 0,
	  NamedNodeMap: 0,
	  NodeList: 1,
	  PaintRequestList: 0,
	  Plugin: 0,
	  PluginArray: 0,
	  SVGLengthList: 0,
	  SVGNumberList: 0,
	  SVGPathSegList: 0,
	  SVGPointList: 0,
	  SVGStringList: 0,
	  SVGTransformList: 0,
	  SourceBufferList: 0,
	  StyleSheetList: 0,
	  TextTrackCueList: 0,
	  TextTrackList: 0,
	  TouchList: 0
	};

	var TO_STRING_TAG$3 = wellKnownSymbol('toStringTag');

	for (var COLLECTION_NAME in domIterables) {
	  var Collection = global_1[COLLECTION_NAME];
	  var CollectionPrototype = Collection && Collection.prototype;
	  if (CollectionPrototype && !CollectionPrototype[TO_STRING_TAG$3]) {
	    createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG$3, COLLECTION_NAME);
	  }
	  iterators[COLLECTION_NAME] = iterators.Array;
	}

	var map = path.Map;

	var map$1 = map;

	var map$2 = map$1;

	var MATCH = wellKnownSymbol('match');

	// `IsRegExp` abstract operation
	// https://tc39.github.io/ecma262/#sec-isregexp
	var isRegexp = function (it) {
	  var isRegExp;
	  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classofRaw(it) == 'RegExp');
	};

	var notARegexp = function (it) {
	  if (isRegexp(it)) {
	    throw TypeError("The method doesn't accept regular expressions");
	  } return it;
	};

	var MATCH$1 = wellKnownSymbol('match');

	var correctIsRegexpLogic = function (METHOD_NAME) {
	  var regexp = /./;
	  try {
	    '/./'[METHOD_NAME](regexp);
	  } catch (e) {
	    try {
	      regexp[MATCH$1] = false;
	      return '/./'[METHOD_NAME](regexp);
	    } catch (f) { /* empty */ }
	  } return false;
	};

	var nativeEndsWith = ''.endsWith;
	var min$2 = Math.min;

	var CORRECT_IS_REGEXP_LOGIC = correctIsRegexpLogic('endsWith');

	// `String.prototype.endsWith` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.endswith
	_export({ target: 'String', proto: true, forced:  !CORRECT_IS_REGEXP_LOGIC }, {
	  endsWith: function endsWith(searchString /* , endPosition = @length */) {
	    var that = String(requireObjectCoercible(this));
	    notARegexp(searchString);
	    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
	    var len = toLength(that.length);
	    var end = endPosition === undefined ? len : min$2(toLength(endPosition), len);
	    var search = String(searchString);
	    return nativeEndsWith
	      ? nativeEndsWith.call(that, search, end)
	      : that.slice(end - search.length, end) === search;
	  }
	});

	var entryVirtual = function (CONSTRUCTOR) {
	  return path[CONSTRUCTOR + 'Prototype'];
	};

	var endsWith = entryVirtual('String').endsWith;

	var StringPrototype = String.prototype;

	var endsWith_1 = function (it) {
	  var own = it.endsWith;
	  return typeof it === 'string' || it === StringPrototype
	    || (it instanceof String && own === StringPrototype.endsWith) ? endsWith : own;
	};

	var endsWith$1 = endsWith_1;

	var endsWith$2 = endsWith$1;

	var sloppyArrayMethod = function (METHOD_NAME, argument) {
	  var method = [][METHOD_NAME];
	  return !method || !fails(function () {
	    // eslint-disable-next-line no-useless-call,no-throw-literal
	    method.call(null, argument || function () { throw 1; }, 1);
	  });
	};

	var $forEach = arrayIteration.forEach;


	// `Array.prototype.forEach` method implementation
	// https://tc39.github.io/ecma262/#sec-array.prototype.foreach
	var arrayForEach = sloppyArrayMethod('forEach') ? function forEach(callbackfn /* , thisArg */) {
	  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	} : [].forEach;

	// `Array.prototype.forEach` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.foreach
	_export({ target: 'Array', proto: true, forced: [].forEach != arrayForEach }, {
	  forEach: arrayForEach
	});

	var forEach$1 = entryVirtual('Array').forEach;

	var forEach$2 = forEach$1;

	var ArrayPrototype$1 = Array.prototype;

	var DOMIterables = {
	  DOMTokenList: true,
	  NodeList: true
	};

	var forEach_1 = function (it) {
	  var own = it.forEach;
	  return it === ArrayPrototype$1 || (it instanceof Array && own === ArrayPrototype$1.forEach)
	    // eslint-disable-next-line no-prototype-builtins
	    || DOMIterables.hasOwnProperty(classof(it)) ? forEach$2 : own;
	};

	var forEach$3 = forEach_1;

	var f$3 = Object.getOwnPropertySymbols;

	var objectGetOwnPropertySymbols = {
		f: f$3
	};

	var nativeAssign = Object.assign;

	// `Object.assign` method
	// https://tc39.github.io/ecma262/#sec-object.assign
	// should work with symbols and should have deterministic property order (V8 bug)
	var objectAssign = !nativeAssign || fails(function () {
	  var A = {};
	  var B = {};
	  // eslint-disable-next-line no-undef
	  var symbol = Symbol();
	  var alphabet = 'abcdefghijklmnopqrst';
	  A[symbol] = 7;
	  alphabet.split('').forEach(function (chr) { B[chr] = chr; });
	  return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;
	}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
	  var T = toObject(target);
	  var argumentsLength = arguments.length;
	  var index = 1;
	  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
	  var propertyIsEnumerable = objectPropertyIsEnumerable.f;
	  while (argumentsLength > index) {
	    var S = indexedObject(arguments[index++]);
	    var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);
	    var length = keys.length;
	    var j = 0;
	    var key;
	    while (length > j) {
	      key = keys[j++];
	      if (!descriptors || propertyIsEnumerable.call(S, key)) T[key] = S[key];
	    }
	  } return T;
	} : nativeAssign;

	// `Object.assign` method
	// https://tc39.github.io/ecma262/#sec-object.assign
	_export({ target: 'Object', stat: true, forced: Object.assign !== objectAssign }, {
	  assign: objectAssign
	});

	var assign = path.Object.assign;

	var assign$1 = assign;

	var assign$2 = assign$1;

	var FAILS_ON_PRIMITIVES = fails(function () { objectKeys(1); });

	// `Object.keys` method
	// https://tc39.github.io/ecma262/#sec-object.keys
	_export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
	  keys: function keys(it) {
	    return objectKeys(toObject(it));
	  }
	});

	var keys$1 = path.Object.keys;

	var keys$2 = keys$1;

	var keys$3 = keys$2;

	// `Array.prototype.{ reduce, reduceRight }` methods implementation
	var createMethod$3 = function (IS_RIGHT) {
	  return function (that, callbackfn, argumentsLength, memo) {
	    aFunction(callbackfn);
	    var O = toObject(that);
	    var self = indexedObject(O);
	    var length = toLength(O.length);
	    var index = IS_RIGHT ? length - 1 : 0;
	    var i = IS_RIGHT ? -1 : 1;
	    if (argumentsLength < 2) while (true) {
	      if (index in self) {
	        memo = self[index];
	        index += i;
	        break;
	      }
	      index += i;
	      if (IS_RIGHT ? index < 0 : length <= index) {
	        throw TypeError('Reduce of empty array with no initial value');
	      }
	    }
	    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
	      memo = callbackfn(memo, self[index], index, O);
	    }
	    return memo;
	  };
	};

	var arrayReduce = {
	  // `Array.prototype.reduce` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.reduce
	  left: createMethod$3(false),
	  // `Array.prototype.reduceRight` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
	  right: createMethod$3(true)
	};

	var $reduce = arrayReduce.left;


	// `Array.prototype.reduce` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.reduce
	_export({ target: 'Array', proto: true, forced: sloppyArrayMethod('reduce') }, {
	  reduce: function reduce(callbackfn /* , initialValue */) {
	    return $reduce(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var reduce = entryVirtual('Array').reduce;

	var ArrayPrototype$2 = Array.prototype;

	var reduce_1 = function (it) {
	  var own = it.reduce;
	  return it === ArrayPrototype$2 || (it instanceof Array && own === ArrayPrototype$2.reduce) ? reduce : own;
	};

	var reduce$1 = reduce_1;

	var reduce$2 = reduce$1;

	// `Object.defineProperty` method
	// https://tc39.github.io/ecma262/#sec-object.defineproperty
	_export({ target: 'Object', stat: true, forced: !descriptors, sham: !descriptors }, {
	  defineProperty: objectDefineProperty.f
	});

	var defineProperty_1 = createCommonjsModule(function (module) {
	var Object = path.Object;

	var defineProperty = module.exports = function defineProperty(it, key, desc) {
	  return Object.defineProperty(it, key, desc);
	};

	if (Object.defineProperty.sham) defineProperty.sham = true;
	});

	var defineProperty$3 = defineProperty_1;

	var defineProperty$4 = defineProperty$3;

	// a string of all valid unicode whitespaces
	// eslint-disable-next-line max-len
	var whitespaces = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

	var whitespace = '[' + whitespaces + ']';
	var ltrim = RegExp('^' + whitespace + whitespace + '*');
	var rtrim = RegExp(whitespace + whitespace + '*$');

	// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
	var createMethod$4 = function (TYPE) {
	  return function ($this) {
	    var string = String(requireObjectCoercible($this));
	    if (TYPE & 1) string = string.replace(ltrim, '');
	    if (TYPE & 2) string = string.replace(rtrim, '');
	    return string;
	  };
	};

	var stringTrim = {
	  // `String.prototype.{ trimLeft, trimStart }` methods
	  // https://tc39.github.io/ecma262/#sec-string.prototype.trimstart
	  start: createMethod$4(1),
	  // `String.prototype.{ trimRight, trimEnd }` methods
	  // https://tc39.github.io/ecma262/#sec-string.prototype.trimend
	  end: createMethod$4(2),
	  // `String.prototype.trim` method
	  // https://tc39.github.io/ecma262/#sec-string.prototype.trim
	  trim: createMethod$4(3)
	};

	var trim = stringTrim.trim;


	var nativeParseInt = global_1.parseInt;
	var hex = /^[+-]?0[Xx]/;
	var FORCED$1 = nativeParseInt(whitespaces + '08') !== 8 || nativeParseInt(whitespaces + '0x16') !== 22;

	// `parseInt` method
	// https://tc39.github.io/ecma262/#sec-parseint-string-radix
	var _parseInt = FORCED$1 ? function parseInt(string, radix) {
	  var S = trim(String(string));
	  return nativeParseInt(S, (radix >>> 0) || (hex.test(S) ? 16 : 10));
	} : nativeParseInt;

	// `parseInt` method
	// https://tc39.github.io/ecma262/#sec-parseint-string-radix
	_export({ global: true, forced: parseInt != _parseInt }, {
	  parseInt: _parseInt
	});

	var _parseInt$1 = path.parseInt;

	var _parseInt$2 = _parseInt$1;

	var _parseInt$3 = _parseInt$2;

	/*
	 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
	 *
	 *  Use of this source code is governed by a BSD-style license
	 *  that can be found in the LICENSE file in the root of the source
	 *  tree.
	 */
	let logDisabled_ = true;
	let deprecationWarnings_ = true;
	/**
	 * Extract browser version out of the provided user agent string.
	 *
	 * @param {!string} uastring userAgent string.
	 * @param {!string} expr Regular expression used as match criteria.
	 * @param {!number} pos position in the version string to be returned.
	 * @return {!number} browser version.
	 */

	function extractVersion(uastring, expr, pos) {
	  const match = uastring.match(expr);
	  return match && match.length >= pos && _parseInt$3(match[pos], 10);
	} // Wraps the peerconnection event eventNameToWrap in a function
	// which returns the modified event object (or false to prevent
	// the event).

	function wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {
	  if (!window.RTCPeerConnection) {
	    return;
	  }

	  const proto = window.RTCPeerConnection.prototype;
	  const nativeAddEventListener = proto.addEventListener;

	  proto.addEventListener = function (nativeEventName, cb) {
	    if (nativeEventName !== eventNameToWrap) {
	      return nativeAddEventListener.apply(this, arguments);
	    }

	    const wrappedCallback = e => {
	      const modifiedEvent = wrapper(e);

	      if (modifiedEvent) {
	        cb(modifiedEvent);
	      }
	    };

	    this._eventMap = this._eventMap || {};
	    this._eventMap[cb] = wrappedCallback;
	    return nativeAddEventListener.apply(this, [nativeEventName, wrappedCallback]);
	  };

	  const nativeRemoveEventListener = proto.removeEventListener;

	  proto.removeEventListener = function (nativeEventName, cb) {
	    if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[cb]) {
	      return nativeRemoveEventListener.apply(this, arguments);
	    }

	    const unwrappedCb = this._eventMap[cb];
	    delete this._eventMap[cb];
	    return nativeRemoveEventListener.apply(this, [nativeEventName, unwrappedCb]);
	  };

	  defineProperty$4(proto, 'on' + eventNameToWrap, {
	    get() {
	      return this['_on' + eventNameToWrap];
	    },

	    set(cb) {
	      if (this['_on' + eventNameToWrap]) {
	        this.removeEventListener(eventNameToWrap, this['_on' + eventNameToWrap]);
	        delete this['_on' + eventNameToWrap];
	      }

	      if (cb) {
	        this.addEventListener(eventNameToWrap, this['_on' + eventNameToWrap] = cb);
	      }
	    },

	    enumerable: true,
	    configurable: true
	  });
	}
	function disableLog(bool) {
	  if (typeof bool !== 'boolean') {
	    return new Error('Argument type: ' + typeof bool + '. Please use a boolean.');
	  }

	  logDisabled_ = bool;
	  return bool ? 'adapter.js logging disabled' : 'adapter.js logging enabled';
	}
	/**
	 * Disable or enable deprecation warnings
	 * @param {!boolean} bool set to true to disable warnings.
	 */

	function disableWarnings(bool) {
	  if (typeof bool !== 'boolean') {
	    return new Error('Argument type: ' + typeof bool + '. Please use a boolean.');
	  }

	  deprecationWarnings_ = !bool;
	  return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');
	}
	function log() {
	  if (typeof window === 'object') {
	    if (logDisabled_) {
	      return;
	    }

	    if (typeof console !== 'undefined' && typeof console.log === 'function') {
	      console.log.apply(console, arguments);
	    }
	  }
	}
	/**
	 * Shows a deprecation warning suggesting the modern and spec-compatible API.
	 */

	function deprecated(oldMethod, newMethod) {
	  if (!deprecationWarnings_) {
	    return;
	  }

	  console.warn(oldMethod + ' is deprecated, please use ' + newMethod + ' instead.');
	}
	/**
	 * Browser detector.
	 *
	 * @return {object} result containing browser and version
	 *     properties.
	 */

	function detectBrowser(window) {
	  const {
	    navigator
	  } = window; // Returned result object.

	  const result = {
	    browser: null,
	    version: null
	  }; // Fail early if it's not a browser

	  if (typeof window === 'undefined' || !window.navigator) {
	    result.browser = 'Not a browser.';
	    return result;
	  }

	  if (navigator.mozGetUserMedia) {
	    // Firefox.
	    result.browser = 'firefox';
	    result.version = extractVersion(navigator.userAgent, /Firefox\/(\d+)\./, 1);
	  } else if (navigator.webkitGetUserMedia || window.isSecureContext === false && window.webkitRTCPeerConnection && !window.RTCIceGatherer) {
	    // Chrome, Chromium, Webview, Opera.
	    // Version matches Chrome/WebRTC version.
	    // Chrome 74 removed webkitGetUserMedia on http as well so we need the
	    // more complicated fallback to webkitRTCPeerConnection.
	    result.browser = 'chrome';
	    result.version = extractVersion(navigator.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
	  } else if (navigator.mediaDevices && navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)) {
	    // Edge.
	    result.browser = 'edge';
	    result.version = extractVersion(navigator.userAgent, /Edge\/(\d+).(\d+)$/, 2);
	  } else if (window.RTCPeerConnection && navigator.userAgent.match(/AppleWebKit\/(\d+)\./)) {
	    // Safari.
	    result.browser = 'safari';
	    result.version = extractVersion(navigator.userAgent, /AppleWebKit\/(\d+)\./, 1);
	    result.supportsUnifiedPlan = window.RTCRtpTransceiver && 'currentDirection' in window.RTCRtpTransceiver.prototype;
	  } else {
	    // Default fallthrough: not supported.
	    result.browser = 'Not a supported browser.';
	    return result;
	  }

	  return result;
	}
	/**
	 * Checks if something is an object.
	 *
	 * @param {*} val The something you want to check.
	 * @return true if val is an object, false otherwise.
	 */

	function isObject$1(val) {
	  return Object.prototype.toString.call(val) === '[object Object]';
	}
	/**
	 * Remove all empty objects and undefined values
	 * from a nested object -- an enhanced and vanilla version
	 * of Lodash's `compact`.
	 */


	function compactObject(data) {
	  var _context;

	  if (!isObject$1(data)) {
	    return data;
	  }

	  return reduce$2(_context = keys$3(data)).call(_context, function (accumulator, key) {
	    const isObj = isObject$1(data[key]);
	    const value = isObj ? compactObject(data[key]) : data[key];
	    const isEmptyObject = isObj && !keys$3(value).length;

	    if (value === undefined || isEmptyObject) {
	      return accumulator;
	    }

	    return assign$2(accumulator, {
	      [key]: value
	    });
	  }, {});
	}
	/* iterates the stats graph recursively. */

	function walkStats(stats, base, resultSet) {
	  var _context2;

	  if (!base || resultSet.has(base.id)) {
	    return;
	  }

	  resultSet.set(base.id, base);

	  forEach$3(_context2 = keys$3(base)).call(_context2, name => {
	    if (endsWith$2(name).call(name, 'Id')) {
	      walkStats(stats, stats.get(base[name]), resultSet);
	    } else if (endsWith$2(name).call(name, 'Ids')) {
	      var _context3;

	      forEach$3(_context3 = base[name]).call(_context3, id => {
	        walkStats(stats, stats.get(id), resultSet);
	      });
	    }
	  });
	}
	/* filter getStats for a sender/receiver track. */

	function filterStats(result, track, outbound) {
	  const streamStatsType = outbound ? 'outbound-rtp' : 'inbound-rtp';
	  const filteredResult = new map$2();

	  if (track === null) {
	    return filteredResult;
	  }

	  const trackStats = [];

	  forEach$3(result).call(result, value => {
	    if (value.type === 'track' && value.trackIdentifier === track.id) {
	      trackStats.push(value);
	    }
	  });

	  forEach$3(trackStats).call(trackStats, trackStat => {
	    forEach$3(result).call(result, stats => {
	      if (stats.type === streamStatsType && stats.trackId === trackStat.id) {
	        walkStats(result, stats, filteredResult);
	      }
	    });
	  });

	  return filteredResult;
	}

	var nativeGetOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;


	var FAILS_ON_PRIMITIVES$1 = fails(function () { nativeGetOwnPropertyDescriptor$1(1); });
	var FORCED$2 = !descriptors || FAILS_ON_PRIMITIVES$1;

	// `Object.getOwnPropertyDescriptor` method
	// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
	_export({ target: 'Object', stat: true, forced: FORCED$2, sham: !descriptors }, {
	  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
	    return nativeGetOwnPropertyDescriptor$1(toIndexedObject(it), key);
	  }
	});

	var getOwnPropertyDescriptor_1 = createCommonjsModule(function (module) {
	var Object = path.Object;

	var getOwnPropertyDescriptor = module.exports = function getOwnPropertyDescriptor(it, key) {
	  return Object.getOwnPropertyDescriptor(it, key);
	};

	if (Object.getOwnPropertyDescriptor.sham) getOwnPropertyDescriptor.sham = true;
	});

	var getOwnPropertyDescriptor$2 = getOwnPropertyDescriptor_1;

	var getOwnPropertyDescriptor$3 = getOwnPropertyDescriptor$2;

	var createProperty = function (object, key, value) {
	  var propertyKey = toPrimitive(key);
	  if (propertyKey in object) objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value));
	  else object[propertyKey] = value;
	};

	var userAgent = getBuiltIn('navigator', 'userAgent') || '';

	var process$1 = global_1.process;
	var versions = process$1 && process$1.versions;
	var v8 = versions && versions.v8;
	var match, version;

	if (v8) {
	  match = v8.split('.');
	  version = match[0] + match[1];
	} else if (userAgent) {
	  match = userAgent.match(/Edge\/(\d+)/);
	  if (!match || match[1] >= 74) {
	    match = userAgent.match(/Chrome\/(\d+)/);
	    if (match) version = match[1];
	  }
	}

	var v8Version = version && +version;

	var SPECIES$2 = wellKnownSymbol('species');

	var arrayMethodHasSpeciesSupport = function (METHOD_NAME) {
	  // We can't use this feature detection in V8 since it causes
	  // deoptimization and serious performance degradation
	  // https://github.com/zloirock/core-js/issues/677
	  return v8Version >= 51 || !fails(function () {
	    var array = [];
	    var constructor = array.constructor = {};
	    constructor[SPECIES$2] = function () {
	      return { foo: 1 };
	    };
	    return array[METHOD_NAME](Boolean).foo !== 1;
	  });
	};

	var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');
	var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
	var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';

	// We can't use this feature detection in V8 since it causes
	// deoptimization and serious performance degradation
	// https://github.com/zloirock/core-js/issues/679
	var IS_CONCAT_SPREADABLE_SUPPORT = v8Version >= 51 || !fails(function () {
	  var array = [];
	  array[IS_CONCAT_SPREADABLE] = false;
	  return array.concat()[0] !== array;
	});

	var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');

	var isConcatSpreadable = function (O) {
	  if (!isObject(O)) return false;
	  var spreadable = O[IS_CONCAT_SPREADABLE];
	  return spreadable !== undefined ? !!spreadable : isArray(O);
	};

	var FORCED$3 = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;

	// `Array.prototype.concat` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.concat
	// with adding support of @@isConcatSpreadable and @@species
	_export({ target: 'Array', proto: true, forced: FORCED$3 }, {
	  concat: function concat(arg) { // eslint-disable-line no-unused-vars
	    var O = toObject(this);
	    var A = arraySpeciesCreate(O, 0);
	    var n = 0;
	    var i, k, length, len, E;
	    for (i = -1, length = arguments.length; i < length; i++) {
	      E = i === -1 ? O : arguments[i];
	      if (isConcatSpreadable(E)) {
	        len = toLength(E.length);
	        if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
	        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
	      } else {
	        if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
	        createProperty(A, n++, E);
	      }
	    }
	    A.length = n;
	    return A;
	  }
	});

	var concat = entryVirtual('Array').concat;

	var ArrayPrototype$3 = Array.prototype;

	var concat_1 = function (it) {
	  var own = it.concat;
	  return it === ArrayPrototype$3 || (it instanceof Array && own === ArrayPrototype$3.concat) ? concat : own;
	};

	var concat$1 = concat_1;

	var concat$2 = concat$1;

	var $filter = arrayIteration.filter;


	// `Array.prototype.filter` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.filter
	// with adding support of @@species
	_export({ target: 'Array', proto: true, forced: !arrayMethodHasSpeciesSupport('filter') }, {
	  filter: function filter(callbackfn /* , thisArg */) {
	    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var filter = entryVirtual('Array').filter;

	var ArrayPrototype$4 = Array.prototype;

	var filter_1 = function (it) {
	  var own = it.filter;
	  return it === ArrayPrototype$4 || (it instanceof Array && own === ArrayPrototype$4.filter) ? filter : own;
	};

	var filter$1 = filter_1;

	var filter$2 = filter$1;

	var nativePromiseConstructor = global_1.Promise;

	var ITERATOR$4 = wellKnownSymbol('iterator');
	var SAFE_CLOSING = false;

	try {
	  var called = 0;
	  var iteratorWithReturn = {
	    next: function () {
	      return { done: !!called++ };
	    },
	    'return': function () {
	      SAFE_CLOSING = true;
	    }
	  };
	  iteratorWithReturn[ITERATOR$4] = function () {
	    return this;
	  };
	  // eslint-disable-next-line no-throw-literal
	  Array.from(iteratorWithReturn, function () { throw 2; });
	} catch (error) { /* empty */ }

	var checkCorrectnessOfIteration = function (exec, SKIP_CLOSING) {
	  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
	  var ITERATION_SUPPORT = false;
	  try {
	    var object = {};
	    object[ITERATOR$4] = function () {
	      return {
	        next: function () {
	          return { done: ITERATION_SUPPORT = true };
	        }
	      };
	    };
	    exec(object);
	  } catch (error) { /* empty */ }
	  return ITERATION_SUPPORT;
	};

	var SPECIES$3 = wellKnownSymbol('species');

	// `SpeciesConstructor` abstract operation
	// https://tc39.github.io/ecma262/#sec-speciesconstructor
	var speciesConstructor = function (O, defaultConstructor) {
	  var C = anObject(O).constructor;
	  var S;
	  return C === undefined || (S = anObject(C)[SPECIES$3]) == undefined ? defaultConstructor : aFunction(S);
	};

	var isIos = /(iphone|ipod|ipad).*applewebkit/i.test(userAgent);

	var location$1 = global_1.location;
	var set$1 = global_1.setImmediate;
	var clear = global_1.clearImmediate;
	var process$2 = global_1.process;
	var MessageChannel = global_1.MessageChannel;
	var Dispatch = global_1.Dispatch;
	var counter = 0;
	var queue = {};
	var ONREADYSTATECHANGE = 'onreadystatechange';
	var defer, channel, port;

	var run = function (id) {
	  // eslint-disable-next-line no-prototype-builtins
	  if (queue.hasOwnProperty(id)) {
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};

	var runner = function (id) {
	  return function () {
	    run(id);
	  };
	};

	var listener = function (event) {
	  run(event.data);
	};

	var post = function (id) {
	  // old engines have not location.origin
	  global_1.postMessage(id + '', location$1.protocol + '//' + location$1.host);
	};

	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if (!set$1 || !clear) {
	  set$1 = function setImmediate(fn) {
	    var args = [];
	    var i = 1;
	    while (arguments.length > i) args.push(arguments[i++]);
	    queue[++counter] = function () {
	      // eslint-disable-next-line no-new-func
	      (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clear = function clearImmediate(id) {
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if (classofRaw(process$2) == 'process') {
	    defer = function (id) {
	      process$2.nextTick(runner(id));
	    };
	  // Sphere (JS game engine) Dispatch API
	  } else if (Dispatch && Dispatch.now) {
	    defer = function (id) {
	      Dispatch.now(runner(id));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  // except iOS - https://github.com/zloirock/core-js/issues/624
	  } else if (MessageChannel && !isIos) {
	    channel = new MessageChannel();
	    port = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = bindContext(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if (global_1.addEventListener && typeof postMessage == 'function' && !global_1.importScripts && !fails(post)) {
	    defer = post;
	    global_1.addEventListener('message', listener, false);
	  // IE8-
	  } else if (ONREADYSTATECHANGE in documentCreateElement('script')) {
	    defer = function (id) {
	      html.appendChild(documentCreateElement('script'))[ONREADYSTATECHANGE] = function () {
	        html.removeChild(this);
	        run(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function (id) {
	      setTimeout(runner(id), 0);
	    };
	  }
	}

	var task = {
	  set: set$1,
	  clear: clear
	};

	var getOwnPropertyDescriptor$4 = objectGetOwnPropertyDescriptor.f;

	var macrotask = task.set;


	var MutationObserver = global_1.MutationObserver || global_1.WebKitMutationObserver;
	var process$3 = global_1.process;
	var Promise$1 = global_1.Promise;
	var IS_NODE = classofRaw(process$3) == 'process';
	// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
	var queueMicrotaskDescriptor = getOwnPropertyDescriptor$4(global_1, 'queueMicrotask');
	var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;

	var flush, head, last, notify, toggle, node, promise, then;

	// modern engines have queueMicrotask method
	if (!queueMicrotask) {
	  flush = function () {
	    var parent, fn;
	    if (IS_NODE && (parent = process$3.domain)) parent.exit();
	    while (head) {
	      fn = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch (error) {
	        if (head) notify();
	        else last = undefined;
	        throw error;
	      }
	    } last = undefined;
	    if (parent) parent.enter();
	  };

	  // Node.js
	  if (IS_NODE) {
	    notify = function () {
	      process$3.nextTick(flush);
	    };
	  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
	  } else if (MutationObserver && !isIos) {
	    toggle = true;
	    node = document.createTextNode('');
	    new MutationObserver(flush).observe(node, { characterData: true });
	    notify = function () {
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if (Promise$1 && Promise$1.resolve) {
	    // Promise.resolve without an argument throws an error in LG WebOS 2
	    promise = Promise$1.resolve(undefined);
	    then = promise.then;
	    notify = function () {
	      then.call(promise, flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify = function () {
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(global_1, flush);
	    };
	  }
	}

	var microtask = queueMicrotask || function (fn) {
	  var task = { fn: fn, next: undefined };
	  if (last) last.next = task;
	  if (!head) {
	    head = task;
	    notify();
	  } last = task;
	};

	var PromiseCapability = function (C) {
	  var resolve, reject;
	  this.promise = new C(function ($$resolve, $$reject) {
	    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject = $$reject;
	  });
	  this.resolve = aFunction(resolve);
	  this.reject = aFunction(reject);
	};

	// 25.4.1.5 NewPromiseCapability(C)
	var f$4 = function (C) {
	  return new PromiseCapability(C);
	};

	var newPromiseCapability = {
		f: f$4
	};

	var promiseResolve = function (C, x) {
	  anObject(C);
	  if (isObject(x) && x.constructor === C) return x;
	  var promiseCapability = newPromiseCapability.f(C);
	  var resolve = promiseCapability.resolve;
	  resolve(x);
	  return promiseCapability.promise;
	};

	var hostReportErrors = function (a, b) {
	  var console = global_1.console;
	  if (console && console.error) {
	    arguments.length === 1 ? console.error(a) : console.error(a, b);
	  }
	};

	var perform = function (exec) {
	  try {
	    return { error: false, value: exec() };
	  } catch (error) {
	    return { error: true, value: error };
	  }
	};

	var task$1 = task.set;










	var SPECIES$4 = wellKnownSymbol('species');
	var PROMISE = 'Promise';
	var getInternalState$2 = internalState.get;
	var setInternalState$4 = internalState.set;
	var getInternalPromiseState = internalState.getterFor(PROMISE);
	var PromiseConstructor = nativePromiseConstructor;
	var TypeError$1 = global_1.TypeError;
	var document$2 = global_1.document;
	var process$4 = global_1.process;
	var inspectSource = shared('inspectSource');
	var $fetch = getBuiltIn('fetch');
	var newPromiseCapability$1 = newPromiseCapability.f;
	var newGenericPromiseCapability = newPromiseCapability$1;
	var IS_NODE$1 = classofRaw(process$4) == 'process';
	var DISPATCH_EVENT = !!(document$2 && document$2.createEvent && global_1.dispatchEvent);
	var UNHANDLED_REJECTION = 'unhandledrejection';
	var REJECTION_HANDLED = 'rejectionhandled';
	var PENDING = 0;
	var FULFILLED = 1;
	var REJECTED = 2;
	var HANDLED = 1;
	var UNHANDLED = 2;
	var Internal, OwnPromiseCapability, PromiseWrapper;

	var FORCED$4 = isForced_1(PROMISE, function () {
	  var GLOBAL_CORE_JS_PROMISE = inspectSource(PromiseConstructor) !== String(PromiseConstructor);
	  if (!GLOBAL_CORE_JS_PROMISE) {
	    // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
	    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
	    // We can't detect it synchronously, so just check versions
	    if (v8Version === 66) return true;
	    // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    if (!IS_NODE$1 && typeof PromiseRejectionEvent != 'function') return true;
	  }
	  // We need Promise#finally in the pure version for preventing prototype pollution
	  if ( !PromiseConstructor.prototype['finally']) return true;
	  // We can't use @@species feature detection in V8 since it causes
	  // deoptimization and performance degradation
	  // https://github.com/zloirock/core-js/issues/679
	  if (v8Version >= 51 && /native code/.test(PromiseConstructor)) return false;
	  // Detect correctness of subclassing with @@species support
	  var promise = PromiseConstructor.resolve(1);
	  var FakePromise = function (exec) {
	    exec(function () { /* empty */ }, function () { /* empty */ });
	  };
	  var constructor = promise.constructor = {};
	  constructor[SPECIES$4] = FakePromise;
	  return !(promise.then(function () { /* empty */ }) instanceof FakePromise);
	});

	var INCORRECT_ITERATION = FORCED$4 || !checkCorrectnessOfIteration(function (iterable) {
	  PromiseConstructor.all(iterable)['catch'](function () { /* empty */ });
	});

	// helpers
	var isThenable = function (it) {
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};

	var notify$1 = function (promise, state, isReject) {
	  if (state.notified) return;
	  state.notified = true;
	  var chain = state.reactions;
	  microtask(function () {
	    var value = state.value;
	    var ok = state.state == FULFILLED;
	    var index = 0;
	    // variable length - can't use forEach
	    while (chain.length > index) {
	      var reaction = chain[index++];
	      var handler = ok ? reaction.ok : reaction.fail;
	      var resolve = reaction.resolve;
	      var reject = reaction.reject;
	      var domain = reaction.domain;
	      var result, then, exited;
	      try {
	        if (handler) {
	          if (!ok) {
	            if (state.rejection === UNHANDLED) onHandleUnhandled(promise, state);
	            state.rejection = HANDLED;
	          }
	          if (handler === true) result = value;
	          else {
	            if (domain) domain.enter();
	            result = handler(value); // can throw
	            if (domain) {
	              domain.exit();
	              exited = true;
	            }
	          }
	          if (result === reaction.promise) {
	            reject(TypeError$1('Promise-chain cycle'));
	          } else if (then = isThenable(result)) {
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch (error) {
	        if (domain && !exited) domain.exit();
	        reject(error);
	      }
	    }
	    state.reactions = [];
	    state.notified = false;
	    if (isReject && !state.rejection) onUnhandled(promise, state);
	  });
	};

	var dispatchEvent = function (name, promise, reason) {
	  var event, handler;
	  if (DISPATCH_EVENT) {
	    event = document$2.createEvent('Event');
	    event.promise = promise;
	    event.reason = reason;
	    event.initEvent(name, false, true);
	    global_1.dispatchEvent(event);
	  } else event = { promise: promise, reason: reason };
	  if (handler = global_1['on' + name]) handler(event);
	  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
	};

	var onUnhandled = function (promise, state) {
	  task$1.call(global_1, function () {
	    var value = state.value;
	    var IS_UNHANDLED = isUnhandled(state);
	    var result;
	    if (IS_UNHANDLED) {
	      result = perform(function () {
	        if (IS_NODE$1) {
	          process$4.emit('unhandledRejection', value, promise);
	        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      state.rejection = IS_NODE$1 || isUnhandled(state) ? UNHANDLED : HANDLED;
	      if (result.error) throw result.value;
	    }
	  });
	};

	var isUnhandled = function (state) {
	  return state.rejection !== HANDLED && !state.parent;
	};

	var onHandleUnhandled = function (promise, state) {
	  task$1.call(global_1, function () {
	    if (IS_NODE$1) {
	      process$4.emit('rejectionHandled', promise);
	    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
	  });
	};

	var bind = function (fn, promise, state, unwrap) {
	  return function (value) {
	    fn(promise, state, value, unwrap);
	  };
	};

	var internalReject = function (promise, state, value, unwrap) {
	  if (state.done) return;
	  state.done = true;
	  if (unwrap) state = unwrap;
	  state.value = value;
	  state.state = REJECTED;
	  notify$1(promise, state, true);
	};

	var internalResolve = function (promise, state, value, unwrap) {
	  if (state.done) return;
	  state.done = true;
	  if (unwrap) state = unwrap;
	  try {
	    if (promise === value) throw TypeError$1("Promise can't be resolved itself");
	    var then = isThenable(value);
	    if (then) {
	      microtask(function () {
	        var wrapper = { done: false };
	        try {
	          then.call(value,
	            bind(internalResolve, promise, wrapper, state),
	            bind(internalReject, promise, wrapper, state)
	          );
	        } catch (error) {
	          internalReject(promise, wrapper, error, state);
	        }
	      });
	    } else {
	      state.value = value;
	      state.state = FULFILLED;
	      notify$1(promise, state, false);
	    }
	  } catch (error) {
	    internalReject(promise, { done: false }, error, state);
	  }
	};

	// constructor polyfill
	if (FORCED$4) {
	  // 25.4.3.1 Promise(executor)
	  PromiseConstructor = function Promise(executor) {
	    anInstance(this, PromiseConstructor, PROMISE);
	    aFunction(executor);
	    Internal.call(this);
	    var state = getInternalState$2(this);
	    try {
	      executor(bind(internalResolve, this, state), bind(internalReject, this, state));
	    } catch (error) {
	      internalReject(this, state, error);
	    }
	  };
	  // eslint-disable-next-line no-unused-vars
	  Internal = function Promise(executor) {
	    setInternalState$4(this, {
	      type: PROMISE,
	      done: false,
	      notified: false,
	      parent: false,
	      reactions: [],
	      rejection: false,
	      state: PENDING,
	      value: undefined
	    });
	  };
	  Internal.prototype = redefineAll(PromiseConstructor.prototype, {
	    // `Promise.prototype.then` method
	    // https://tc39.github.io/ecma262/#sec-promise.prototype.then
	    then: function then(onFulfilled, onRejected) {
	      var state = getInternalPromiseState(this);
	      var reaction = newPromiseCapability$1(speciesConstructor(this, PromiseConstructor));
	      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail = typeof onRejected == 'function' && onRejected;
	      reaction.domain = IS_NODE$1 ? process$4.domain : undefined;
	      state.parent = true;
	      state.reactions.push(reaction);
	      if (state.state != PENDING) notify$1(this, state, false);
	      return reaction.promise;
	    },
	    // `Promise.prototype.catch` method
	    // https://tc39.github.io/ecma262/#sec-promise.prototype.catch
	    'catch': function (onRejected) {
	      return this.then(undefined, onRejected);
	    }
	  });
	  OwnPromiseCapability = function () {
	    var promise = new Internal();
	    var state = getInternalState$2(promise);
	    this.promise = promise;
	    this.resolve = bind(internalResolve, promise, state);
	    this.reject = bind(internalReject, promise, state);
	  };
	  newPromiseCapability.f = newPromiseCapability$1 = function (C) {
	    return C === PromiseConstructor || C === PromiseWrapper
	      ? new OwnPromiseCapability(C)
	      : newGenericPromiseCapability(C);
	  };
	}

	_export({ global: true, wrap: true, forced: FORCED$4 }, {
	  Promise: PromiseConstructor
	});

	setToStringTag(PromiseConstructor, PROMISE, false, true);
	setSpecies(PROMISE);

	PromiseWrapper = getBuiltIn(PROMISE);

	// statics
	_export({ target: PROMISE, stat: true, forced: FORCED$4 }, {
	  // `Promise.reject` method
	  // https://tc39.github.io/ecma262/#sec-promise.reject
	  reject: function reject(r) {
	    var capability = newPromiseCapability$1(this);
	    capability.reject.call(undefined, r);
	    return capability.promise;
	  }
	});

	_export({ target: PROMISE, stat: true, forced: isPure  }, {
	  // `Promise.resolve` method
	  // https://tc39.github.io/ecma262/#sec-promise.resolve
	  resolve: function resolve(x) {
	    return promiseResolve( this === PromiseWrapper ? PromiseConstructor : this, x);
	  }
	});

	_export({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION }, {
	  // `Promise.all` method
	  // https://tc39.github.io/ecma262/#sec-promise.all
	  all: function all(iterable) {
	    var C = this;
	    var capability = newPromiseCapability$1(C);
	    var resolve = capability.resolve;
	    var reject = capability.reject;
	    var result = perform(function () {
	      var $promiseResolve = aFunction(C.resolve);
	      var values = [];
	      var counter = 0;
	      var remaining = 1;
	      iterate_1(iterable, function (promise) {
	        var index = counter++;
	        var alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        $promiseResolve.call(C, promise).then(function (value) {
	          if (alreadyCalled) return;
	          alreadyCalled = true;
	          values[index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if (result.error) reject(result.value);
	    return capability.promise;
	  },
	  // `Promise.race` method
	  // https://tc39.github.io/ecma262/#sec-promise.race
	  race: function race(iterable) {
	    var C = this;
	    var capability = newPromiseCapability$1(C);
	    var reject = capability.reject;
	    var result = perform(function () {
	      var $promiseResolve = aFunction(C.resolve);
	      iterate_1(iterable, function (promise) {
	        $promiseResolve.call(C, promise).then(capability.resolve, reject);
	      });
	    });
	    if (result.error) reject(result.value);
	    return capability.promise;
	  }
	});

	// `Promise.allSettled` method
	// https://github.com/tc39/proposal-promise-allSettled
	_export({ target: 'Promise', stat: true }, {
	  allSettled: function allSettled(iterable) {
	    var C = this;
	    var capability = newPromiseCapability.f(C);
	    var resolve = capability.resolve;
	    var reject = capability.reject;
	    var result = perform(function () {
	      var promiseResolve = aFunction(C.resolve);
	      var values = [];
	      var counter = 0;
	      var remaining = 1;
	      iterate_1(iterable, function (promise) {
	        var index = counter++;
	        var alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        promiseResolve.call(C, promise).then(function (value) {
	          if (alreadyCalled) return;
	          alreadyCalled = true;
	          values[index] = { status: 'fulfilled', value: value };
	          --remaining || resolve(values);
	        }, function (e) {
	          if (alreadyCalled) return;
	          alreadyCalled = true;
	          values[index] = { status: 'rejected', reason: e };
	          --remaining || resolve(values);
	        });
	      });
	      --remaining || resolve(values);
	    });
	    if (result.error) reject(result.value);
	    return capability.promise;
	  }
	});

	// `Promise.prototype.finally` method
	// https://tc39.github.io/ecma262/#sec-promise.prototype.finally
	_export({ target: 'Promise', proto: true, real: true }, {
	  'finally': function (onFinally) {
	    var C = speciesConstructor(this, getBuiltIn('Promise'));
	    var isFunction = typeof onFinally == 'function';
	    return this.then(
	      isFunction ? function (x) {
	        return promiseResolve(C, onFinally()).then(function () { return x; });
	      } : onFinally,
	      isFunction ? function (e) {
	        return promiseResolve(C, onFinally()).then(function () { throw e; });
	      } : onFinally
	    );
	  }
	});

	var promise$1 = path.Promise;

	var promise$2 = promise$1;

	var promise$3 = promise$2;

	var $map = arrayIteration.map;


	// `Array.prototype.map` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.map
	// with adding support of @@species
	_export({ target: 'Array', proto: true, forced: !arrayMethodHasSpeciesSupport('map') }, {
	  map: function map(callbackfn /* , thisArg */) {
	    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var map$3 = entryVirtual('Array').map;

	var ArrayPrototype$5 = Array.prototype;

	var map_1 = function (it) {
	  var own = it.map;
	  return it === ArrayPrototype$5 || (it instanceof Array && own === ArrayPrototype$5.map) ? map$3 : own;
	};

	var map$4 = map_1;

	var map$5 = map$4;

	var max$1 = Math.max;
	var min$3 = Math.min;
	var MAX_SAFE_INTEGER$1 = 0x1FFFFFFFFFFFFF;
	var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded';

	// `Array.prototype.splice` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.splice
	// with adding support of @@species
	_export({ target: 'Array', proto: true, forced: !arrayMethodHasSpeciesSupport('splice') }, {
	  splice: function splice(start, deleteCount /* , ...items */) {
	    var O = toObject(this);
	    var len = toLength(O.length);
	    var actualStart = toAbsoluteIndex(start, len);
	    var argumentsLength = arguments.length;
	    var insertCount, actualDeleteCount, A, k, from, to;
	    if (argumentsLength === 0) {
	      insertCount = actualDeleteCount = 0;
	    } else if (argumentsLength === 1) {
	      insertCount = 0;
	      actualDeleteCount = len - actualStart;
	    } else {
	      insertCount = argumentsLength - 2;
	      actualDeleteCount = min$3(max$1(toInteger(deleteCount), 0), len - actualStart);
	    }
	    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER$1) {
	      throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
	    }
	    A = arraySpeciesCreate(O, actualDeleteCount);
	    for (k = 0; k < actualDeleteCount; k++) {
	      from = actualStart + k;
	      if (from in O) createProperty(A, k, O[from]);
	    }
	    A.length = actualDeleteCount;
	    if (insertCount < actualDeleteCount) {
	      for (k = actualStart; k < len - actualDeleteCount; k++) {
	        from = k + actualDeleteCount;
	        to = k + insertCount;
	        if (from in O) O[to] = O[from];
	        else delete O[to];
	      }
	      for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];
	    } else if (insertCount > actualDeleteCount) {
	      for (k = len - actualDeleteCount; k > actualStart; k--) {
	        from = k + actualDeleteCount - 1;
	        to = k + insertCount - 1;
	        if (from in O) O[to] = O[from];
	        else delete O[to];
	      }
	    }
	    for (k = 0; k < insertCount; k++) {
	      O[k + actualStart] = arguments[k + 2];
	    }
	    O.length = len - actualDeleteCount + insertCount;
	    return A;
	  }
	});

	var splice = entryVirtual('Array').splice;

	var ArrayPrototype$6 = Array.prototype;

	var splice_1 = function (it) {
	  var own = it.splice;
	  return it === ArrayPrototype$6 || (it instanceof Array && own === ArrayPrototype$6.splice) ? splice : own;
	};

	var splice$1 = splice_1;

	var splice$2 = splice$1;

	var $indexOf = arrayIncludes.indexOf;


	var nativeIndexOf = [].indexOf;

	var NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;
	var SLOPPY_METHOD = sloppyArrayMethod('indexOf');

	// `Array.prototype.indexOf` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.indexof
	_export({ target: 'Array', proto: true, forced: NEGATIVE_ZERO || SLOPPY_METHOD }, {
	  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
	    return NEGATIVE_ZERO
	      // convert -0 to +0
	      ? nativeIndexOf.apply(this, arguments) || 0
	      : $indexOf(this, searchElement, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var indexOf$1 = entryVirtual('Array').indexOf;

	var ArrayPrototype$7 = Array.prototype;

	var indexOf_1 = function (it) {
	  var own = it.indexOf;
	  return it === ArrayPrototype$7 || (it instanceof Array && own === ArrayPrototype$7.indexOf) ? indexOf$1 : own;
	};

	var indexOf$2 = indexOf_1;

	var indexOf$3 = indexOf$2;

	var SPECIES$5 = wellKnownSymbol('species');
	var nativeSlice = [].slice;
	var max$2 = Math.max;

	// `Array.prototype.slice` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.slice
	// fallback for not array-like ES3 strings and DOM objects
	_export({ target: 'Array', proto: true, forced: !arrayMethodHasSpeciesSupport('slice') }, {
	  slice: function slice(start, end) {
	    var O = toIndexedObject(this);
	    var length = toLength(O.length);
	    var k = toAbsoluteIndex(start, length);
	    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
	    // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
	    var Constructor, result, n;
	    if (isArray(O)) {
	      Constructor = O.constructor;
	      // cross-realm fallback
	      if (typeof Constructor == 'function' && (Constructor === Array || isArray(Constructor.prototype))) {
	        Constructor = undefined;
	      } else if (isObject(Constructor)) {
	        Constructor = Constructor[SPECIES$5];
	        if (Constructor === null) Constructor = undefined;
	      }
	      if (Constructor === Array || Constructor === undefined) {
	        return nativeSlice.call(O, k, fin);
	      }
	    }
	    result = new (Constructor === undefined ? Array : Constructor)(max$2(fin - k, 0));
	    for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
	    result.length = n;
	    return result;
	  }
	});

	var slice = entryVirtual('Array').slice;

	var ArrayPrototype$8 = Array.prototype;

	var slice_1 = function (it) {
	  var own = it.slice;
	  return it === ArrayPrototype$8 || (it instanceof Array && own === ArrayPrototype$8.slice) ? slice : own;
	};

	var slice$1 = slice_1;

	var slice$2 = slice$1;

	var $find = arrayIteration.find;


	var FIND = 'find';
	var SKIPS_HOLES = true;

	// Shouldn't skip holes
	if (FIND in []) Array(1)[FIND](function () { SKIPS_HOLES = false; });

	// `Array.prototype.find` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.find
	_export({ target: 'Array', proto: true, forced: SKIPS_HOLES }, {
	  find: function find(callbackfn /* , that = undefined */) {
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var find = entryVirtual('Array').find;

	var ArrayPrototype$9 = Array.prototype;

	var find_1 = function (it) {
	  var own = it.find;
	  return it === ArrayPrototype$9 || (it instanceof Array && own === ArrayPrototype$9.find) ? find : own;
	};

	var find$1 = find_1;

	var find$2 = find$1;

	var slice$3 = [].slice;
	var factories = {};

	var construct = function (C, argsLength, args) {
	  if (!(argsLength in factories)) {
	    for (var list = [], i = 0; i < argsLength; i++) list[i] = 'a[' + i + ']';
	    // eslint-disable-next-line no-new-func
	    factories[argsLength] = Function('C,a', 'return new C(' + list.join(',') + ')');
	  } return factories[argsLength](C, args);
	};

	// `Function.prototype.bind` method implementation
	// https://tc39.github.io/ecma262/#sec-function.prototype.bind
	var functionBind = Function.bind || function bind(that /* , ...args */) {
	  var fn = aFunction(this);
	  var partArgs = slice$3.call(arguments, 1);
	  var boundFunction = function bound(/* args... */) {
	    var args = partArgs.concat(slice$3.call(arguments));
	    return this instanceof boundFunction ? construct(fn, args.length, args) : fn.apply(that, args);
	  };
	  if (isObject(fn.prototype)) boundFunction.prototype = fn.prototype;
	  return boundFunction;
	};

	// `Function.prototype.bind` method
	// https://tc39.github.io/ecma262/#sec-function.prototype.bind
	_export({ target: 'Function', proto: true }, {
	  bind: functionBind
	});

	var bind$1 = entryVirtual('Function').bind;

	var FunctionPrototype = Function.prototype;

	var bind_1 = function (it) {
	  var own = it.bind;
	  return it === FunctionPrototype || (it instanceof Function && own === FunctionPrototype.bind) ? bind$1 : own;
	};

	var bind$2 = bind_1;

	var bind$3 = bind$2;

	var $includes = arrayIncludes.includes;


	// `Array.prototype.includes` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.includes
	_export({ target: 'Array', proto: true }, {
	  includes: function includes(el /* , fromIndex = 0 */) {
	    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var includes = entryVirtual('Array').includes;

	// `String.prototype.includes` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.includes
	_export({ target: 'String', proto: true, forced: !correctIsRegexpLogic('includes') }, {
	  includes: function includes(searchString /* , position = 0 */) {
	    return !!~String(requireObjectCoercible(this))
	      .indexOf(notARegexp(searchString), arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var includes$1 = entryVirtual('String').includes;

	var ArrayPrototype$a = Array.prototype;
	var StringPrototype$1 = String.prototype;

	var includes$2 = function (it) {
	  var own = it.includes;
	  if (it === ArrayPrototype$a || (it instanceof Array && own === ArrayPrototype$a.includes)) return includes;
	  if (typeof it === 'string' || it === StringPrototype$1 || (it instanceof String && own === StringPrototype$1.includes)) {
	    return includes$1;
	  } return own;
	};

	var includes$3 = includes$2;

	var includes$4 = includes$3;

	var $some = arrayIteration.some;


	// `Array.prototype.some` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.some
	_export({ target: 'Array', proto: true, forced: sloppyArrayMethod('some') }, {
	  some: function some(callbackfn /* , thisArg */) {
	    return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var some = entryVirtual('Array').some;

	var ArrayPrototype$b = Array.prototype;

	var some_1 = function (it) {
	  var own = it.some;
	  return it === ArrayPrototype$b || (it instanceof Array && own === ArrayPrototype$b.some) ? some : own;
	};

	var some$1 = some_1;

	var some$2 = some$1;

	/*
	 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
	 *
	 *  Use of this source code is governed by a BSD-style license
	 *  that can be found in the LICENSE file in the root of the source
	 *  tree.
	 */
	const logging = log;
	function shimGetUserMedia(window) {
	  const navigator = window && window.navigator;

	  if (!navigator.mediaDevices) {
	    return;
	  }

	  const browserDetails = detectBrowser(window);

	  const constraintsToChrome_ = function (c) {
	    var _context;

	    if (typeof c !== 'object' || c.mandatory || c.optional) {
	      return c;
	    }

	    const cc = {};

	    forEach$3(_context = keys$3(c)).call(_context, key => {
	      if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
	        return;
	      }

	      const r = typeof c[key] === 'object' ? c[key] : {
	        ideal: c[key]
	      };

	      if (r.exact !== undefined && typeof r.exact === 'number') {
	        r.min = r.max = r.exact;
	      }

	      const oldname_ = function (prefix, name) {
	        if (prefix) {
	          return prefix + name.charAt(0).toUpperCase() + slice$2(name).call(name, 1);
	        }

	        return name === 'deviceId' ? 'sourceId' : name;
	      };

	      if (r.ideal !== undefined) {
	        cc.optional = cc.optional || [];
	        let oc = {};

	        if (typeof r.ideal === 'number') {
	          oc[oldname_('min', key)] = r.ideal;
	          cc.optional.push(oc);
	          oc = {};
	          oc[oldname_('max', key)] = r.ideal;
	          cc.optional.push(oc);
	        } else {
	          oc[oldname_('', key)] = r.ideal;
	          cc.optional.push(oc);
	        }
	      }

	      if (r.exact !== undefined && typeof r.exact !== 'number') {
	        cc.mandatory = cc.mandatory || {};
	        cc.mandatory[oldname_('', key)] = r.exact;
	      } else {
	        var _context2;

	        forEach$3(_context2 = ['min', 'max']).call(_context2, mix => {
	          if (r[mix] !== undefined) {
	            cc.mandatory = cc.mandatory || {};
	            cc.mandatory[oldname_(mix, key)] = r[mix];
	          }
	        });
	      }
	    });

	    if (c.advanced) {
	      var _context3;

	      cc.optional = concat$2(_context3 = cc.optional || []).call(_context3, c.advanced);
	    }

	    return cc;
	  };

	  const shimConstraints_ = function (constraints, func) {
	    if (browserDetails.version >= 61) {
	      return func(constraints);
	    }

	    constraints = JSON.parse(stringify$2(constraints));

	    if (constraints && typeof constraints.audio === 'object') {
	      const remap = function (obj, a, b) {
	        if (a in obj && !(b in obj)) {
	          obj[b] = obj[a];
	          delete obj[a];
	        }
	      };

	      constraints = JSON.parse(stringify$2(constraints));
	      remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');
	      remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');
	      constraints.audio = constraintsToChrome_(constraints.audio);
	    }

	    if (constraints && typeof constraints.video === 'object') {
	      // Shim facingMode for mobile & surface pro.
	      let face = constraints.video.facingMode;
	      face = face && (typeof face === 'object' ? face : {
	        ideal: face
	      });
	      const getSupportedFacingModeLies = browserDetails.version < 66;

	      if (face && (face.exact === 'user' || face.exact === 'environment' || face.ideal === 'user' || face.ideal === 'environment') && !(navigator.mediaDevices.getSupportedConstraints && navigator.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {
	        delete constraints.video.facingMode;
	        let matches;

	        if (face.exact === 'environment' || face.ideal === 'environment') {
	          matches = ['back', 'rear'];
	        } else if (face.exact === 'user' || face.ideal === 'user') {
	          matches = ['front'];
	        }

	        if (matches) {
	          // Look for matches in label, or use last cam for back (typical).
	          return navigator.mediaDevices.enumerateDevices().then(devices => {
	            devices = filter$2(devices).call(devices, d => d.kind === 'videoinput');

	            let dev = find$2(devices).call(devices, d => some$2(matches).call(matches, match => {
	              var _context4;

	              return includes$4(_context4 = d.label.toLowerCase()).call(_context4, match);
	            }));

	            if (!dev && devices.length && includes$4(matches).call(matches, 'back')) {
	              dev = devices[devices.length - 1]; // more likely the back cam
	            }

	            if (dev) {
	              constraints.video.deviceId = face.exact ? {
	                exact: dev.deviceId
	              } : {
	                ideal: dev.deviceId
	              };
	            }

	            constraints.video = constraintsToChrome_(constraints.video);
	            logging('chrome: ' + stringify$2(constraints));
	            return func(constraints);
	          });
	        }
	      }

	      constraints.video = constraintsToChrome_(constraints.video);
	    }

	    logging('chrome: ' + stringify$2(constraints));
	    return func(constraints);
	  };

	  const shimError_ = function (e) {
	    if (browserDetails.version >= 64) {
	      return e;
	    }

	    return {
	      name: {
	        PermissionDeniedError: 'NotAllowedError',
	        PermissionDismissedError: 'NotAllowedError',
	        InvalidStateError: 'NotAllowedError',
	        DevicesNotFoundError: 'NotFoundError',
	        ConstraintNotSatisfiedError: 'OverconstrainedError',
	        TrackStartError: 'NotReadableError',
	        MediaDeviceFailedDueToShutdown: 'NotAllowedError',
	        MediaDeviceKillSwitchOn: 'NotAllowedError',
	        TabCaptureError: 'AbortError',
	        ScreenCaptureError: 'AbortError',
	        DeviceCaptureError: 'AbortError'
	      }[e.name] || e.name,
	      message: e.message,
	      constraint: e.constraint || e.constraintName,

	      toString() {
	        return this.name + (this.message && ': ') + this.message;
	      }

	    };
	  };

	  const getUserMedia_ = function (constraints, onSuccess, onError) {
	    shimConstraints_(constraints, c => {
	      navigator.webkitGetUserMedia(c, onSuccess, e => {
	        if (onError) {
	          onError(shimError_(e));
	        }
	      });
	    });
	  };

	  navigator.getUserMedia = bind$3(getUserMedia_).call(getUserMedia_, navigator); // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia
	  // function which returns a Promise, it does not accept spec-style
	  // constraints.

	  if (navigator.mediaDevices.getUserMedia) {
	    var _context5;

	    const origGetUserMedia = bind$3(_context5 = navigator.mediaDevices.getUserMedia).call(_context5, navigator.mediaDevices);

	    navigator.mediaDevices.getUserMedia = function (cs) {
	      return shimConstraints_(cs, c => origGetUserMedia(c).then(stream => {
	        if (c.audio && !stream.getAudioTracks().length || c.video && !stream.getVideoTracks().length) {
	          var _context6;

	          forEach$3(_context6 = stream.getTracks()).call(_context6, track => {
	            track.stop();
	          });

	          throw new DOMException('', 'NotFoundError');
	        }

	        return stream;
	      }, e => promise$3.reject(shimError_(e))));
	    };
	  }
	}

	/*
	 *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
	 *
	 *  Use of this source code is governed by a BSD-style license
	 *  that can be found in the LICENSE file in the root of the source
	 *  tree.
	 */

	function shimGetDisplayMedia(window, getSourceId) {
	  if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {
	    return;
	  }

	  if (!window.navigator.mediaDevices) {
	    return;
	  } // getSourceId is a function that returns a promise resolving with
	  // the sourceId of the screen/window/tab to be shared.


	  if (typeof getSourceId !== 'function') {
	    console.error('shimGetDisplayMedia: getSourceId argument is not ' + 'a function');
	    return;
	  }

	  window.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {
	    return getSourceId(constraints).then(sourceId => {
	      const widthSpecified = constraints.video && constraints.video.width;
	      const heightSpecified = constraints.video && constraints.video.height;
	      const frameRateSpecified = constraints.video && constraints.video.frameRate;
	      constraints.video = {
	        mandatory: {
	          chromeMediaSource: 'desktop',
	          chromeMediaSourceId: sourceId,
	          maxFrameRate: frameRateSpecified || 3
	        }
	      };

	      if (widthSpecified) {
	        constraints.video.mandatory.maxWidth = widthSpecified;
	      }

	      if (heightSpecified) {
	        constraints.video.mandatory.maxHeight = heightSpecified;
	      }

	      return window.navigator.mediaDevices.getUserMedia(constraints);
	    });
	  };
	}

	/*
	 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
	 *
	 *  Use of this source code is governed by a BSD-style license
	 *  that can be found in the LICENSE file in the root of the source
	 *  tree.
	 */
	function shimMediaStream(window) {
	  window.MediaStream = window.MediaStream || window.webkitMediaStream;
	}
	function shimOnTrack(window) {
	  if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in window.RTCPeerConnection.prototype)) {
	    defineProperty$4(window.RTCPeerConnection.prototype, 'ontrack', {
	      get() {
	        return this._ontrack;
	      },

	      set(f) {
	        if (this._ontrack) {
	          this.removeEventListener('track', this._ontrack);
	        }

	        this.addEventListener('track', this._ontrack = f);
	      },

	      enumerable: true,
	      configurable: true
	    });

	    const origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;

	    window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
	      if (!this._ontrackpoly) {
	        this._ontrackpoly = e => {
	          var _context2;

	          // onaddstream does not fire when a track is added to an existing
	          // stream. But stream.onaddtrack is implemented so we use that.
	          e.stream.addEventListener('addtrack', te => {
	            let receiver;

	            if (window.RTCPeerConnection.prototype.getReceivers) {
	              var _context;

	              receiver = find$2(_context = this.getReceivers()).call(_context, r => r.track && r.track.id === te.track.id);
	            } else {
	              receiver = {
	                track: te.track
	              };
	            }

	            const event = new Event('track');
	            event.track = te.track;
	            event.receiver = receiver;
	            event.transceiver = {
	              receiver
	            };
	            event.streams = [e.stream];
	            this.dispatchEvent(event);
	          });

	          forEach$3(_context2 = e.stream.getTracks()).call(_context2, track => {
	            let receiver;

	            if (window.RTCPeerConnection.prototype.getReceivers) {
	              var _context3;

	              receiver = find$2(_context3 = this.getReceivers()).call(_context3, r => r.track && r.track.id === track.id);
	            } else {
	              receiver = {
	                track
	              };
	            }

	            const event = new Event('track');
	            event.track = track;
	            event.receiver = receiver;
	            event.transceiver = {
	              receiver
	            };
	            event.streams = [e.stream];
	            this.dispatchEvent(event);
	          });
	        };

	        this.addEventListener('addstream', this._ontrackpoly);
	      }

	      return origSetRemoteDescription.apply(this, arguments);
	    };
	  } else {
	    // even if RTCRtpTransceiver is in window, it is only used and
	    // emitted in unified-plan. Unfortunately this means we need
	    // to unconditionally wrap the event.
	    wrapPeerConnectionEvent(window, 'track', e => {
	      if (!e.transceiver) {
	        defineProperty$4(e, 'transceiver', {
	          value: {
	            receiver: e.receiver
	          }
	        });
	      }

	      return e;
	    });
	  }
	}
	function shimGetSendersWithDtmf(window) {
	  // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.
	  if (typeof window === 'object' && window.RTCPeerConnection && !('getSenders' in window.RTCPeerConnection.prototype) && 'createDTMFSender' in window.RTCPeerConnection.prototype) {
	    const shimSenderWithDtmf = function (pc, track) {
	      return {
	        track,

	        get dtmf() {
	          if (this._dtmf === undefined) {
	            if (track.kind === 'audio') {
	              this._dtmf = pc.createDTMFSender(track);
	            } else {
	              this._dtmf = null;
	            }
	          }

	          return this._dtmf;
	        },

	        _pc: pc
	      };
	    }; // augment addTrack when getSenders is not available.


	    if (!window.RTCPeerConnection.prototype.getSenders) {
	      window.RTCPeerConnection.prototype.getSenders = function getSenders() {
	        var _context4;

	        this._senders = this._senders || [];
	        return slice$2(_context4 = this._senders).call(_context4); // return a copy of the internal state.
	      };

	      const origAddTrack = window.RTCPeerConnection.prototype.addTrack;

	      window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
	        let sender = origAddTrack.apply(this, arguments);

	        if (!sender) {
	          sender = shimSenderWithDtmf(this, track);

	          this._senders.push(sender);
	        }

	        return sender;
	      };

	      const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;

	      window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
	        var _context5;

	        origRemoveTrack.apply(this, arguments);

	        const idx = indexOf$3(_context5 = this._senders).call(_context5, sender);

	        if (idx !== -1) {
	          var _context6;

	          splice$2(_context6 = this._senders).call(_context6, idx, 1);
	        }
	      };
	    }

	    const origAddStream = window.RTCPeerConnection.prototype.addStream;

	    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
	      var _context7;

	      this._senders = this._senders || [];
	      origAddStream.apply(this, [stream]);

	      forEach$3(_context7 = stream.getTracks()).call(_context7, track => {
	        this._senders.push(shimSenderWithDtmf(this, track));
	      });
	    };

	    const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;

	    window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
	      var _context8;

	      this._senders = this._senders || [];
	      origRemoveStream.apply(this, [stream]);

	      forEach$3(_context8 = stream.getTracks()).call(_context8, track => {
	        var _context9;

	        const sender = find$2(_context9 = this._senders).call(_context9, s => s.track === track);

	        if (sender) {
	          var _context10, _context11;

	          // remove sender
	          splice$2(_context10 = this._senders).call(_context10, indexOf$3(_context11 = this._senders).call(_context11, sender), 1);
	        }
	      });
	    };
	  } else if (typeof window === 'object' && window.RTCPeerConnection && 'getSenders' in window.RTCPeerConnection.prototype && 'createDTMFSender' in window.RTCPeerConnection.prototype && window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {
	    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;

	    window.RTCPeerConnection.prototype.getSenders = function getSenders() {
	      const senders = origGetSenders.apply(this, []);

	      forEach$3(senders).call(senders, sender => sender._pc = this);

	      return senders;
	    };

	    defineProperty$4(window.RTCRtpSender.prototype, 'dtmf', {
	      get() {
	        if (this._dtmf === undefined) {
	          if (this.track.kind === 'audio') {
	            this._dtmf = this._pc.createDTMFSender(this.track);
	          } else {
	            this._dtmf = null;
	          }
	        }

	        return this._dtmf;
	      }

	    });
	  }
	}
	function shimGetStats(window) {
	  if (!window.RTCPeerConnection) {
	    return;
	  }

	  const origGetStats = window.RTCPeerConnection.prototype.getStats;

	  window.RTCPeerConnection.prototype.getStats = function getStats() {
	    const [selector, onSucc, onErr] = arguments; // If selector is a function then we are in the old style stats so just
	    // pass back the original getStats format to avoid breaking old users.

	    if (arguments.length > 0 && typeof selector === 'function') {
	      return origGetStats.apply(this, arguments);
	    } // When spec-style getStats is supported, return those when called with
	    // either no arguments or the selector argument is null.


	    if (origGetStats.length === 0 && (arguments.length === 0 || typeof selector !== 'function')) {
	      return origGetStats.apply(this, []);
	    }

	    const fixChromeStats_ = function (response) {
	      const standardReport = {};
	      const reports = response.result();

	      forEach$3(reports).call(reports, report => {
	        var _context12;

	        const standardStats = {
	          id: report.id,
	          timestamp: report.timestamp,
	          type: {
	            localcandidate: 'local-candidate',
	            remotecandidate: 'remote-candidate'
	          }[report.type] || report.type
	        };

	        forEach$3(_context12 = report.names()).call(_context12, name => {
	          standardStats[name] = report.stat(name);
	        });

	        standardReport[standardStats.id] = standardStats;
	      });

	      return standardReport;
	    }; // shim getStats with maplike support


	    const makeMapStats = function (stats) {
	      var _context13;

	      return new map$2(map$5(_context13 = keys$3(stats)).call(_context13, key => [key, stats[key]]));
	    };

	    if (arguments.length >= 2) {
	      const successCallbackWrapper_ = function (response) {
	        onSucc(makeMapStats(fixChromeStats_(response)));
	      };

	      return origGetStats.apply(this, [successCallbackWrapper_, selector]);
	    } // promise-support


	    return new promise$3((resolve, reject) => {
	      origGetStats.apply(this, [function (response) {
	        resolve(makeMapStats(fixChromeStats_(response)));
	      }, reject]);
	    }).then(onSucc, onErr);
	  };
	}
	function shimSenderReceiverGetStats(window) {
	  if (!(typeof window === 'object' && window.RTCPeerConnection && window.RTCRtpSender && window.RTCRtpReceiver)) {
	    return;
	  } // shim sender stats.


	  if (!('getStats' in window.RTCRtpSender.prototype)) {
	    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;

	    if (origGetSenders) {
	      window.RTCPeerConnection.prototype.getSenders = function getSenders() {
	        const senders = origGetSenders.apply(this, []);

	        forEach$3(senders).call(senders, sender => sender._pc = this);

	        return senders;
	      };
	    }

	    const origAddTrack = window.RTCPeerConnection.prototype.addTrack;

	    if (origAddTrack) {
	      window.RTCPeerConnection.prototype.addTrack = function addTrack() {
	        const sender = origAddTrack.apply(this, arguments);
	        sender._pc = this;
	        return sender;
	      };
	    }

	    window.RTCRtpSender.prototype.getStats = function getStats() {
	      const sender = this;
	      return this._pc.getStats().then(result =>
	      /* Note: this will include stats of all senders that
	       *   send a track with the same id as sender.track as
	       *   it is not possible to identify the RTCRtpSender.
	       */
	      filterStats(result, sender.track, true));
	    };
	  } // shim receiver stats.


	  if (!('getStats' in window.RTCRtpReceiver.prototype)) {
	    const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;

	    if (origGetReceivers) {
	      window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
	        const receivers = origGetReceivers.apply(this, []);

	        forEach$3(receivers).call(receivers, receiver => receiver._pc = this);

	        return receivers;
	      };
	    }

	    wrapPeerConnectionEvent(window, 'track', e => {
	      e.receiver._pc = e.srcElement;
	      return e;
	    });

	    window.RTCRtpReceiver.prototype.getStats = function getStats() {
	      const receiver = this;
	      return this._pc.getStats().then(result => filterStats(result, receiver.track, false));
	    };
	  }

	  if (!('getStats' in window.RTCRtpSender.prototype && 'getStats' in window.RTCRtpReceiver.prototype)) {
	    return;
	  } // shim RTCPeerConnection.getStats(track).


	  const origGetStats = window.RTCPeerConnection.prototype.getStats;

	  window.RTCPeerConnection.prototype.getStats = function getStats() {
	    if (arguments.length > 0 && arguments[0] instanceof window.MediaStreamTrack) {
	      var _context14, _context15;

	      const track = arguments[0];
	      let sender;
	      let receiver;
	      let err;

	      forEach$3(_context14 = this.getSenders()).call(_context14, s => {
	        if (s.track === track) {
	          if (sender) {
	            err = true;
	          } else {
	            sender = s;
	          }
	        }
	      });

	      forEach$3(_context15 = this.getReceivers()).call(_context15, r => {
	        if (r.track === track) {
	          if (receiver) {
	            err = true;
	          } else {
	            receiver = r;
	          }
	        }

	        return r.track === track;
	      });

	      if (err || sender && receiver) {
	        return promise$3.reject(new DOMException('There are more than one sender or receiver for the track.', 'InvalidAccessError'));
	      } else if (sender) {
	        return sender.getStats();
	      } else if (receiver) {
	        return receiver.getStats();
	      }

	      return promise$3.reject(new DOMException('There is no sender or receiver for the track.', 'InvalidAccessError'));
	    }

	    return origGetStats.apply(this, arguments);
	  };
	}
	function shimAddTrackRemoveTrackWithNative(window) {
	  // shim addTrack/removeTrack with native variants in order to make
	  // the interactions with legacy getLocalStreams behave as in other browsers.
	  // Keeps a mapping stream.id => [stream, rtpsenders...]
	  window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
	    var _context16;

	    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
	    return map$5(_context16 = keys$3(this._shimmedLocalStreams)).call(_context16, streamId => this._shimmedLocalStreams[streamId][0]);
	  };

	  const origAddTrack = window.RTCPeerConnection.prototype.addTrack;

	  window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
	    var _context17;

	    if (!stream) {
	      return origAddTrack.apply(this, arguments);
	    }

	    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
	    const sender = origAddTrack.apply(this, arguments);

	    if (!this._shimmedLocalStreams[stream.id]) {
	      this._shimmedLocalStreams[stream.id] = [stream, sender];
	    } else if (indexOf$3(_context17 = this._shimmedLocalStreams[stream.id]).call(_context17, sender) === -1) {
	      this._shimmedLocalStreams[stream.id].push(sender);
	    }

	    return sender;
	  };

	  const origAddStream = window.RTCPeerConnection.prototype.addStream;

	  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
	    var _context18, _context20, _context21;

	    this._shimmedLocalStreams = this._shimmedLocalStreams || {};

	    forEach$3(_context18 = stream.getTracks()).call(_context18, track => {
	      var _context19;

	      const alreadyExists = find$2(_context19 = this.getSenders()).call(_context19, s => s.track === track);

	      if (alreadyExists) {
	        throw new DOMException('Track already exists.', 'InvalidAccessError');
	      }
	    });

	    const existingSenders = this.getSenders();
	    origAddStream.apply(this, arguments);

	    const newSenders = filter$2(_context20 = this.getSenders()).call(_context20, newSender => indexOf$3(existingSenders).call(existingSenders, newSender) === -1);

	    this._shimmedLocalStreams[stream.id] = concat$2(_context21 = [stream]).call(_context21, newSenders);
	  };

	  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;

	  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
	    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
	    delete this._shimmedLocalStreams[stream.id];
	    return origRemoveStream.apply(this, arguments);
	  };

	  const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;

	  window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
	    this._shimmedLocalStreams = this._shimmedLocalStreams || {};

	    if (sender) {
	      var _context22;

	      forEach$3(_context22 = keys$3(this._shimmedLocalStreams)).call(_context22, streamId => {
	        var _context23;

	        const idx = indexOf$3(_context23 = this._shimmedLocalStreams[streamId]).call(_context23, sender);

	        if (idx !== -1) {
	          var _context24;

	          splice$2(_context24 = this._shimmedLocalStreams[streamId]).call(_context24, idx, 1);
	        }

	        if (this._shimmedLocalStreams[streamId].length === 1) {
	          delete this._shimmedLocalStreams[streamId];
	        }
	      });
	    }

	    return origRemoveTrack.apply(this, arguments);
	  };
	}
	function shimAddTrackRemoveTrack(window) {
	  var _context32;

	  if (!window.RTCPeerConnection) {
	    return;
	  }

	  const browserDetails = detectBrowser(window); // shim addTrack and removeTrack.

	  if (window.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {
	    return shimAddTrackRemoveTrackWithNative(window);
	  } // also shim pc.getLocalStreams when addTrack is shimmed
	  // to return the original streams.


	  const origGetLocalStreams = window.RTCPeerConnection.prototype.getLocalStreams;

	  window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
	    const nativeStreams = origGetLocalStreams.apply(this);
	    this._reverseStreams = this._reverseStreams || {};
	    return map$5(nativeStreams).call(nativeStreams, stream => this._reverseStreams[stream.id]);
	  };

	  const origAddStream = window.RTCPeerConnection.prototype.addStream;

	  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
	    var _context25;

	    this._streams = this._streams || {};
	    this._reverseStreams = this._reverseStreams || {};

	    forEach$3(_context25 = stream.getTracks()).call(_context25, track => {
	      var _context26;

	      const alreadyExists = find$2(_context26 = this.getSenders()).call(_context26, s => s.track === track);

	      if (alreadyExists) {
	        throw new DOMException('Track already exists.', 'InvalidAccessError');
	      }
	    }); // Add identity mapping for consistency with addTrack.
	    // Unless this is being used with a stream from addTrack.


	    if (!this._reverseStreams[stream.id]) {
	      const newStream = new window.MediaStream(stream.getTracks());
	      this._streams[stream.id] = newStream;
	      this._reverseStreams[newStream.id] = stream;
	      stream = newStream;
	    }

	    origAddStream.apply(this, [stream]);
	  };

	  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;

	  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
	    this._streams = this._streams || {};
	    this._reverseStreams = this._reverseStreams || {};
	    origRemoveStream.apply(this, [this._streams[stream.id] || stream]);
	    delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];
	    delete this._streams[stream.id];
	  };

	  window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
	    var _context27, _context28, _context29;

	    if (this.signalingState === 'closed') {
	      throw new DOMException('The RTCPeerConnection\'s signalingState is \'closed\'.', 'InvalidStateError');
	    }

	    const streams = slice$2([]).call(arguments, 1);

	    if (streams.length !== 1 || !find$2(_context27 = streams[0].getTracks()).call(_context27, t => t === track)) {
	      // this is not fully correct but all we can manage without
	      // [[associated MediaStreams]] internal slot.
	      throw new DOMException('The adapter.js addTrack polyfill only supports a single ' + ' stream which is associated with the specified track.', 'NotSupportedError');
	    }

	    const alreadyExists = find$2(_context28 = this.getSenders()).call(_context28, s => s.track === track);

	    if (alreadyExists) {
	      throw new DOMException('Track already exists.', 'InvalidAccessError');
	    }

	    this._streams = this._streams || {};
	    this._reverseStreams = this._reverseStreams || {};
	    const oldStream = this._streams[stream.id];

	    if (oldStream) {
	      // this is using odd Chrome behaviour, use with caution:
	      // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815
	      // Note: we rely on the high-level addTrack/dtmf shim to
	      // create the sender with a dtmf sender.
	      oldStream.addTrack(track); // Trigger ONN async.

	      promise$3.resolve().then(() => {
	        this.dispatchEvent(new Event('negotiationneeded'));
	      });
	    } else {
	      const newStream = new window.MediaStream([track]);
	      this._streams[stream.id] = newStream;
	      this._reverseStreams[newStream.id] = stream;
	      this.addStream(newStream);
	    }

	    return find$2(_context29 = this.getSenders()).call(_context29, s => s.track === track);
	  }; // replace the internal stream id with the external one and
	  // vice versa.


	  function replaceInternalStreamId(pc, description) {
	    var _context30;

	    let sdp = description.sdp;

	    forEach$3(_context30 = keys$3(pc._reverseStreams || [])).call(_context30, internalId => {
	      const externalStream = pc._reverseStreams[internalId];
	      const internalStream = pc._streams[externalStream.id];
	      sdp = sdp.replace(new RegExp(internalStream.id, 'g'), externalStream.id);
	    });

	    return new RTCSessionDescription({
	      type: description.type,
	      sdp
	    });
	  }

	  function replaceExternalStreamId(pc, description) {
	    var _context31;

	    let sdp = description.sdp;

	    forEach$3(_context31 = keys$3(pc._reverseStreams || [])).call(_context31, internalId => {
	      const externalStream = pc._reverseStreams[internalId];
	      const internalStream = pc._streams[externalStream.id];
	      sdp = sdp.replace(new RegExp(externalStream.id, 'g'), internalStream.id);
	    });

	    return new RTCSessionDescription({
	      type: description.type,
	      sdp
	    });
	  }

	  forEach$3(_context32 = ['createOffer', 'createAnswer']).call(_context32, function (method) {
	    const nativeMethod = window.RTCPeerConnection.prototype[method];
	    const methodObj = {
	      [method]() {
	        const args = arguments;
	        const isLegacyCall = arguments.length && typeof arguments[0] === 'function';

	        if (isLegacyCall) {
	          return nativeMethod.apply(this, [description => {
	            const desc = replaceInternalStreamId(this, description);
	            args[0].apply(null, [desc]);
	          }, err => {
	            if (args[1]) {
	              args[1].apply(null, err);
	            }
	          }, arguments[2]]);
	        }

	        return nativeMethod.apply(this, arguments).then(description => replaceInternalStreamId(this, description));
	      }

	    };
	    window.RTCPeerConnection.prototype[method] = methodObj[method];
	  });

	  const origSetLocalDescription = window.RTCPeerConnection.prototype.setLocalDescription;

	  window.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {
	    if (!arguments.length || !arguments[0].type) {
	      return origSetLocalDescription.apply(this, arguments);
	    }

	    arguments[0] = replaceExternalStreamId(this, arguments[0]);
	    return origSetLocalDescription.apply(this, arguments);
	  }; // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier


	  const origLocalDescription = getOwnPropertyDescriptor$3(window.RTCPeerConnection.prototype, 'localDescription');

	  defineProperty$4(window.RTCPeerConnection.prototype, 'localDescription', {
	    get() {
	      const description = origLocalDescription.get.apply(this);

	      if (description.type === '') {
	        return description;
	      }

	      return replaceInternalStreamId(this, description);
	    }

	  });

	  window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
	    var _context33;

	    if (this.signalingState === 'closed') {
	      throw new DOMException('The RTCPeerConnection\'s signalingState is \'closed\'.', 'InvalidStateError');
	    } // We can not yet check for sender instanceof RTCRtpSender
	    // since we shim RTPSender. So we check if sender._pc is set.


	    if (!sender._pc) {
	      throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' + 'does not implement interface RTCRtpSender.', 'TypeError');
	    }

	    const isLocal = sender._pc === this;

	    if (!isLocal) {
	      throw new DOMException('Sender was not created by this connection.', 'InvalidAccessError');
	    } // Search for the native stream the senders track belongs to.


	    this._streams = this._streams || {};
	    let stream;

	    forEach$3(_context33 = keys$3(this._streams)).call(_context33, streamid => {
	      var _context34;

	      const hasTrack = find$2(_context34 = this._streams[streamid].getTracks()).call(_context34, track => sender.track === track);

	      if (hasTrack) {
	        stream = this._streams[streamid];
	      }
	    });

	    if (stream) {
	      if (stream.getTracks().length === 1) {
	        // if this is the last track of the stream, remove the stream. This
	        // takes care of any shimmed _senders.
	        this.removeStream(this._reverseStreams[stream.id]);
	      } else {
	        // relying on the same odd chrome behaviour as above.
	        stream.removeTrack(sender.track);
	      }

	      this.dispatchEvent(new Event('negotiationneeded'));
	    }
	  };
	}
	function shimPeerConnection(window) {
	  const browserDetails = detectBrowser(window);

	  if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {
	    // very basic support for old versions.
	    window.RTCPeerConnection = window.webkitRTCPeerConnection;
	  }

	  if (!window.RTCPeerConnection) {
	    return;
	  } // shim implicit creation of RTCSessionDescription/RTCIceCandidate


	  if (browserDetails.version < 53) {
	    var _context35;

	    forEach$3(_context35 = ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']).call(_context35, function (method) {
	      const nativeMethod = window.RTCPeerConnection.prototype[method];
	      const methodObj = {
	        [method]() {
	          arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);
	          return nativeMethod.apply(this, arguments);
	        }

	      };
	      window.RTCPeerConnection.prototype[method] = methodObj[method];
	    });
	  } // support for addIceCandidate(null or undefined)


	  const nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;

	  window.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {
	    if (!arguments[0]) {
	      if (arguments[1]) {
	        arguments[1].apply(null);
	      }

	      return promise$3.resolve();
	    } // Firefox 68+ emits and processes {candidate: "", ...}, ignore
	    // in older versions. Native support planned for Chrome M77.


	    if (browserDetails.version < 78 && arguments[0] && arguments[0].candidate === '') {
	      return promise$3.resolve();
	    }

	    return nativeAddIceCandidate.apply(this, arguments);
	  };
	}
	function fixNegotiationNeeded(window) {
	  wrapPeerConnectionEvent(window, 'negotiationneeded', e => {
	    const pc = e.target;

	    if (pc.signalingState !== 'stable') {
	      return;
	    }

	    return e;
	  });
	}

	var chromeShim = /*#__PURE__*/Object.freeze({
		__proto__: null,
		shimMediaStream: shimMediaStream,
		shimOnTrack: shimOnTrack,
		shimGetSendersWithDtmf: shimGetSendersWithDtmf,
		shimGetStats: shimGetStats,
		shimSenderReceiverGetStats: shimSenderReceiverGetStats,
		shimAddTrackRemoveTrackWithNative: shimAddTrackRemoveTrackWithNative,
		shimAddTrackRemoveTrack: shimAddTrackRemoveTrack,
		shimPeerConnection: shimPeerConnection,
		fixNegotiationNeeded: fixNegotiationNeeded,
		shimGetUserMedia: shimGetUserMedia,
		shimGetDisplayMedia: shimGetDisplayMedia
	});

	var nativeStartsWith = ''.startsWith;
	var min$4 = Math.min;

	var CORRECT_IS_REGEXP_LOGIC$1 = correctIsRegexpLogic('startsWith');

	// `String.prototype.startsWith` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.startswith
	_export({ target: 'String', proto: true, forced:  !CORRECT_IS_REGEXP_LOGIC$1 }, {
	  startsWith: function startsWith(searchString /* , position = 0 */) {
	    var that = String(requireObjectCoercible(this));
	    notARegexp(searchString);
	    var index = toLength(min$4(arguments.length > 1 ? arguments[1] : undefined, that.length));
	    var search = String(searchString);
	    return nativeStartsWith
	      ? nativeStartsWith.call(that, search, index)
	      : that.slice(index, index + search.length) === search;
	  }
	});

	var startsWith = entryVirtual('String').startsWith;

	var StringPrototype$2 = String.prototype;

	var startsWith_1 = function (it) {
	  var own = it.startsWith;
	  return typeof it === 'string' || it === StringPrototype$2
	    || (it instanceof String && own === StringPrototype$2.startsWith) ? startsWith : own;
	};

	var startsWith$1 = startsWith_1;

	var startsWith$2 = startsWith$1;

	/*
	 *  Copyright (c) 2018 The WebRTC project authors. All Rights Reserved.
	 *
	 *  Use of this source code is governed by a BSD-style license
	 *  that can be found in the LICENSE file in the root of the source
	 *  tree.
	 */
	// 1) stun: filtered after 14393 unless ?transport=udp is present
	// 2) turn: that does not have all of turn:host:port?transport=udp
	// 3) turn: with ipv6 addresses
	// 4) turn: occurring muliple times

	function filterIceServers(iceServers, edgeVersion) {
	  let hasTurn = false;
	  iceServers = JSON.parse(stringify$2(iceServers));
	  return filter$2(iceServers).call(iceServers, server => {
	    if (server && (server.urls || server.url)) {
	      var urls = server.urls || server.url;

	      if (server.url && !server.urls) {
	        deprecated('RTCIceServer.url', 'RTCIceServer.urls');
	      }

	      const isString = typeof urls === 'string';

	      if (isString) {
	        urls = [urls];
	      }

	      urls = filter$2(urls).call(urls, url => {
	        // filter STUN unconditionally.
	        if (indexOf$3(url).call(url, 'stun:') === 0) {
	          return false;
	        }

	        const validTurn = startsWith$2(url).call(url, 'turn') && !startsWith$2(url).call(url, 'turn:[') && includes$4(url).call(url, 'transport=udp');

	        if (validTurn && !hasTurn) {
	          hasTurn = true;
	          return true;
	        }

	        return validTurn && !hasTurn;
	      });
	      delete server.url;
	      server.urls = isString ? urls[0] : urls;
	      return !!urls.length;
	    }
	  });
	}

	var non = '\u200B\u0085\u180E';

	// check that a method works with the correct list
	// of whitespaces and has a correct name
	var forcedStringTrimMethod = function (METHOD_NAME) {
	  return fails(function () {
	    return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() != non || whitespaces[METHOD_NAME].name !== METHOD_NAME;
	  });
	};

	var $trim = stringTrim.trim;


	// `String.prototype.trim` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.trim
	_export({ target: 'String', proto: true, forced: forcedStringTrimMethod('trim') }, {
	  trim: function trim() {
	    return $trim(this);
	  }
	});

	var trim$1 = entryVirtual('String').trim;

	var StringPrototype$3 = String.prototype;

	var trim_1 = function (it) {
	  var own = it.trim;
	  return typeof it === 'string' || it === StringPrototype$3
	    || (it instanceof String && own === StringPrototype$3.trim) ? trim$1 : own;
	};

	var trim$2 = trim_1;

	var trim$3 = trim$2;

	var sdp = createCommonjsModule(function (module) {

	  var SDPUtils = {}; // Generate an alphanumeric identifier for cname or mids.
	  // TODO: use UUIDs instead? https://gist.github.com/jed/982883

	  SDPUtils.generateIdentifier = function () {
	    return Math.random().toString(36).substr(2, 10);
	  }; // The RTCP CNAME used by all peerconnections from the same JS.


	  SDPUtils.localCName = SDPUtils.generateIdentifier(); // Splits SDP into lines, dealing with both CRLF and LF.

	  SDPUtils.splitLines = function (blob) {
	    var _context;

	    return map$5(_context = trim$3(blob).call(blob).split('\n')).call(_context, function (line) {
	      return trim$3(line).call(line);
	    });
	  }; // Splits SDP into sessionpart and mediasections. Ensures CRLF.


	  SDPUtils.splitSections = function (blob) {
	    var parts = blob.split('\nm=');
	    return map$5(parts).call(parts, function (part, index) {
	      var _context2;

	      return trim$3(_context2 = index > 0 ? 'm=' + part : part).call(_context2) + '\r\n';
	    });
	  }; // returns the session description.


	  SDPUtils.getDescription = function (blob) {
	    var sections = SDPUtils.splitSections(blob);
	    return sections && sections[0];
	  }; // returns the individual media sections.


	  SDPUtils.getMediaSections = function (blob) {
	    var sections = SDPUtils.splitSections(blob);
	    sections.shift();
	    return sections;
	  }; // Returns lines that start with a certain prefix.


	  SDPUtils.matchPrefix = function (blob, prefix) {
	    var _context3;

	    return filter$2(_context3 = SDPUtils.splitLines(blob)).call(_context3, function (line) {
	      return indexOf$3(line).call(line, prefix) === 0;
	    });
	  }; // Parses an ICE candidate line. Sample input:
	  // candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8
	  // rport 55996"


	  SDPUtils.parseCandidate = function (line) {
	    var parts; // Parse both variants.

	    if (indexOf$3(line).call(line, 'a=candidate:') === 0) {
	      parts = line.substring(12).split(' ');
	    } else {
	      parts = line.substring(10).split(' ');
	    }

	    var candidate = {
	      foundation: parts[0],
	      component: _parseInt$3(parts[1], 10),
	      protocol: parts[2].toLowerCase(),
	      priority: _parseInt$3(parts[3], 10),
	      ip: parts[4],
	      address: parts[4],
	      // address is an alias for ip.
	      port: _parseInt$3(parts[5], 10),
	      // skip parts[6] == 'typ'
	      type: parts[7]
	    };

	    for (var i = 8; i < parts.length; i += 2) {
	      switch (parts[i]) {
	        case 'raddr':
	          candidate.relatedAddress = parts[i + 1];
	          break;

	        case 'rport':
	          candidate.relatedPort = _parseInt$3(parts[i + 1], 10);
	          break;

	        case 'tcptype':
	          candidate.tcpType = parts[i + 1];
	          break;

	        case 'ufrag':
	          candidate.ufrag = parts[i + 1]; // for backward compability.

	          candidate.usernameFragment = parts[i + 1];
	          break;

	        default:
	          // extension handling, in particular ufrag
	          candidate[parts[i]] = parts[i + 1];
	          break;
	      }
	    }

	    return candidate;
	  }; // Translates a candidate object into SDP candidate attribute.


	  SDPUtils.writeCandidate = function (candidate) {
	    var sdp = [];
	    sdp.push(candidate.foundation);
	    sdp.push(candidate.component);
	    sdp.push(candidate.protocol.toUpperCase());
	    sdp.push(candidate.priority);
	    sdp.push(candidate.address || candidate.ip);
	    sdp.push(candidate.port);
	    var type = candidate.type;
	    sdp.push('typ');
	    sdp.push(type);

	    if (type !== 'host' && candidate.relatedAddress && candidate.relatedPort) {
	      sdp.push('raddr');
	      sdp.push(candidate.relatedAddress);
	      sdp.push('rport');
	      sdp.push(candidate.relatedPort);
	    }

	    if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {
	      sdp.push('tcptype');
	      sdp.push(candidate.tcpType);
	    }

	    if (candidate.usernameFragment || candidate.ufrag) {
	      sdp.push('ufrag');
	      sdp.push(candidate.usernameFragment || candidate.ufrag);
	    }

	    return 'candidate:' + sdp.join(' ');
	  }; // Parses an ice-options line, returns an array of option tags.
	  // a=ice-options:foo bar


	  SDPUtils.parseIceOptions = function (line) {
	    return line.substr(14).split(' ');
	  }; // Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:
	  // a=rtpmap:111 opus/48000/2


	  SDPUtils.parseRtpMap = function (line) {
	    var parts = line.substr(9).split(' ');
	    var parsed = {
	      payloadType: _parseInt$3(parts.shift(), 10) // was: id

	    };
	    parts = parts[0].split('/');
	    parsed.name = parts[0];
	    parsed.clockRate = _parseInt$3(parts[1], 10); // was: clockrate

	    parsed.channels = parts.length === 3 ? _parseInt$3(parts[2], 10) : 1; // legacy alias, got renamed back to channels in ORTC.

	    parsed.numChannels = parsed.channels;
	    return parsed;
	  }; // Generate an a=rtpmap line from RTCRtpCodecCapability or
	  // RTCRtpCodecParameters.


	  SDPUtils.writeRtpMap = function (codec) {
	    var pt = codec.payloadType;

	    if (codec.preferredPayloadType !== undefined) {
	      pt = codec.preferredPayloadType;
	    }

	    var channels = codec.channels || codec.numChannels || 1;
	    return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate + (channels !== 1 ? '/' + channels : '') + '\r\n';
	  }; // Parses an a=extmap line (headerextension from RFC 5285). Sample input:
	  // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
	  // a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset


	  SDPUtils.parseExtmap = function (line) {
	    var _context4;

	    var parts = line.substr(9).split(' ');
	    return {
	      id: _parseInt$3(parts[0], 10),
	      direction: indexOf$3(_context4 = parts[0]).call(_context4, '/') > 0 ? parts[0].split('/')[1] : 'sendrecv',
	      uri: parts[1]
	    };
	  }; // Generates a=extmap line from RTCRtpHeaderExtensionParameters or
	  // RTCRtpHeaderExtension.


	  SDPUtils.writeExtmap = function (headerExtension) {
	    return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) + (headerExtension.direction && headerExtension.direction !== 'sendrecv' ? '/' + headerExtension.direction : '') + ' ' + headerExtension.uri + '\r\n';
	  }; // Parses an ftmp line, returns dictionary. Sample input:
	  // a=fmtp:96 vbr=on;cng=on
	  // Also deals with vbr=on; cng=on


	  SDPUtils.parseFmtp = function (line) {
	    var parsed = {};
	    var kv;
	    var parts = line.substr(indexOf$3(line).call(line, ' ') + 1).split(';');

	    for (var j = 0; j < parts.length; j++) {
	      var _context5, _context6;

	      kv = trim$3(_context5 = parts[j]).call(_context5).split('=');
	      parsed[trim$3(_context6 = kv[0]).call(_context6)] = kv[1];
	    }

	    return parsed;
	  }; // Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.


	  SDPUtils.writeFmtp = function (codec) {
	    var line = '';
	    var pt = codec.payloadType;

	    if (codec.preferredPayloadType !== undefined) {
	      pt = codec.preferredPayloadType;
	    }

	    if (codec.parameters && keys$3(codec.parameters).length) {
	      var _context7;

	      var params = [];

	      forEach$3(_context7 = keys$3(codec.parameters)).call(_context7, function (param) {
	        if (codec.parameters[param]) {
	          params.push(param + '=' + codec.parameters[param]);
	        } else {
	          params.push(param);
	        }
	      });

	      line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\r\n';
	    }

	    return line;
	  }; // Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
	  // a=rtcp-fb:98 nack rpsi


	  SDPUtils.parseRtcpFb = function (line) {
	    var parts = line.substr(indexOf$3(line).call(line, ' ') + 1).split(' ');
	    return {
	      type: parts.shift(),
	      parameter: parts.join(' ')
	    };
	  }; // Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.


	  SDPUtils.writeRtcpFb = function (codec) {
	    var lines = '';
	    var pt = codec.payloadType;

	    if (codec.preferredPayloadType !== undefined) {
	      pt = codec.preferredPayloadType;
	    }

	    if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
	      var _context8;

	      // FIXME: special handling for trr-int?
	      forEach$3(_context8 = codec.rtcpFeedback).call(_context8, function (fb) {
	        lines += 'a=rtcp-fb:' + pt + ' ' + fb.type + (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') + '\r\n';
	      });
	    }

	    return lines;
	  }; // Parses an RFC 5576 ssrc media attribute. Sample input:
	  // a=ssrc:3735928559 cname:something


	  SDPUtils.parseSsrcMedia = function (line) {
	    var sp = indexOf$3(line).call(line, ' ');

	    var parts = {
	      ssrc: _parseInt$3(line.substr(7, sp - 7), 10)
	    };

	    var colon = indexOf$3(line).call(line, ':', sp);

	    if (colon > -1) {
	      parts.attribute = line.substr(sp + 1, colon - sp - 1);
	      parts.value = line.substr(colon + 1);
	    } else {
	      parts.attribute = line.substr(sp + 1);
	    }

	    return parts;
	  };

	  SDPUtils.parseSsrcGroup = function (line) {
	    var parts = line.substr(13).split(' ');
	    return {
	      semantics: parts.shift(),
	      ssrcs: map$5(parts).call(parts, function (ssrc) {
	        return _parseInt$3(ssrc, 10);
	      })
	    };
	  }; // Extracts the MID (RFC 5888) from a media section.
	  // returns the MID or undefined if no mid line was found.


	  SDPUtils.getMid = function (mediaSection) {
	    var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];

	    if (mid) {
	      return mid.substr(6);
	    }
	  };

	  SDPUtils.parseFingerprint = function (line) {
	    var parts = line.substr(14).split(' ');
	    return {
	      algorithm: parts[0].toLowerCase(),
	      // algorithm is case-sensitive in Edge.
	      value: parts[1]
	    };
	  }; // Extracts DTLS parameters from SDP media section or sessionpart.
	  // FIXME: for consistency with other functions this should only
	  //   get the fingerprint line as input. See also getIceParameters.


	  SDPUtils.getDtlsParameters = function (mediaSection, sessionpart) {
	    var lines = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=fingerprint:'); // Note: a=setup line is ignored since we use the 'auto' role.
	    // Note2: 'algorithm' is not case sensitive except in Edge.

	    return {
	      role: 'auto',
	      fingerprints: map$5(lines).call(lines, SDPUtils.parseFingerprint)
	    };
	  }; // Serializes DTLS parameters to SDP.


	  SDPUtils.writeDtlsParameters = function (params, setupType) {
	    var _context9;

	    var sdp = 'a=setup:' + setupType + '\r\n';

	    forEach$3(_context9 = params.fingerprints).call(_context9, function (fp) {
	      sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\r\n';
	    });

	    return sdp;
	  }; // Parses ICE information from SDP media section or sessionpart.
	  // FIXME: for consistency with other functions this should only
	  //   get the ice-ufrag and ice-pwd lines as input.


	  SDPUtils.getIceParameters = function (mediaSection, sessionpart) {
	    var lines = SDPUtils.splitLines(mediaSection); // Search in session part, too.

	    lines = concat$2(lines).call(lines, SDPUtils.splitLines(sessionpart));
	    var iceParameters = {
	      usernameFragment: filter$2(lines).call(lines, function (line) {
	        return indexOf$3(line).call(line, 'a=ice-ufrag:') === 0;
	      })[0].substr(12),
	      password: filter$2(lines).call(lines, function (line) {
	        return indexOf$3(line).call(line, 'a=ice-pwd:') === 0;
	      })[0].substr(10)
	    };
	    return iceParameters;
	  }; // Serializes ICE parameters to SDP.


	  SDPUtils.writeIceParameters = function (params) {
	    return 'a=ice-ufrag:' + params.usernameFragment + '\r\n' + 'a=ice-pwd:' + params.password + '\r\n';
	  }; // Parses the SDP media section and returns RTCRtpParameters.


	  SDPUtils.parseRtpParameters = function (mediaSection) {
	    var _context11;

	    var description = {
	      codecs: [],
	      headerExtensions: [],
	      fecMechanisms: [],
	      rtcp: []
	    };
	    var lines = SDPUtils.splitLines(mediaSection);
	    var mline = lines[0].split(' ');

	    for (var i = 3; i < mline.length; i++) {
	      // find all codecs from mline[3..]
	      var pt = mline[i];
	      var rtpmapline = SDPUtils.matchPrefix(mediaSection, 'a=rtpmap:' + pt + ' ')[0];

	      if (rtpmapline) {
	        var _context10;

	        var codec = SDPUtils.parseRtpMap(rtpmapline);
	        var fmtps = SDPUtils.matchPrefix(mediaSection, 'a=fmtp:' + pt + ' '); // Only the first a=fmtp:<pt> is considered.

	        codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
	        codec.rtcpFeedback = map$5(_context10 = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-fb:' + pt + ' ')).call(_context10, SDPUtils.parseRtcpFb);
	        description.codecs.push(codec); // parse FEC mechanisms from rtpmap lines.

	        switch (codec.name.toUpperCase()) {
	          case 'RED':
	          case 'ULPFEC':
	            description.fecMechanisms.push(codec.name.toUpperCase());
	            break;
	        }
	      }
	    }

	    forEach$3(_context11 = SDPUtils.matchPrefix(mediaSection, 'a=extmap:')).call(_context11, function (line) {
	      description.headerExtensions.push(SDPUtils.parseExtmap(line));
	    }); // FIXME: parse rtcp.


	    return description;
	  }; // Generates parts of the SDP media section describing the capabilities /
	  // parameters.


	  SDPUtils.writeRtpDescription = function (kind, caps) {
	    var _context12, _context13, _context14;

	    var sdp = ''; // Build the mline.

	    sdp += 'm=' + kind + ' ';
	    sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.

	    sdp += ' UDP/TLS/RTP/SAVPF ';
	    sdp += map$5(_context12 = caps.codecs).call(_context12, function (codec) {
	      if (codec.preferredPayloadType !== undefined) {
	        return codec.preferredPayloadType;
	      }

	      return codec.payloadType;
	    }).join(' ') + '\r\n';
	    sdp += 'c=IN IP4 0.0.0.0\r\n';
	    sdp += 'a=rtcp:9 IN IP4 0.0.0.0\r\n'; // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.

	    forEach$3(_context13 = caps.codecs).call(_context13, function (codec) {
	      sdp += SDPUtils.writeRtpMap(codec);
	      sdp += SDPUtils.writeFmtp(codec);
	      sdp += SDPUtils.writeRtcpFb(codec);
	    });

	    var maxptime = 0;

	    forEach$3(_context14 = caps.codecs).call(_context14, function (codec) {
	      if (codec.maxptime > maxptime) {
	        maxptime = codec.maxptime;
	      }
	    });

	    if (maxptime > 0) {
	      sdp += 'a=maxptime:' + maxptime + '\r\n';
	    }

	    sdp += 'a=rtcp-mux\r\n';

	    if (caps.headerExtensions) {
	      var _context15;

	      forEach$3(_context15 = caps.headerExtensions).call(_context15, function (extension) {
	        sdp += SDPUtils.writeExtmap(extension);
	      });
	    } // FIXME: write fecMechanisms.


	    return sdp;
	  }; // Parses the SDP media section and returns an array of
	  // RTCRtpEncodingParameters.


	  SDPUtils.parseRtpEncodingParameters = function (mediaSection) {
	    var _context16, _context17, _context18, _context19, _context20, _context21;

	    var encodingParameters = [];
	    var description = SDPUtils.parseRtpParameters(mediaSection);
	    var hasRed = indexOf$3(_context16 = description.fecMechanisms).call(_context16, 'RED') !== -1;
	    var hasUlpfec = indexOf$3(_context17 = description.fecMechanisms).call(_context17, 'ULPFEC') !== -1; // filter a=ssrc:... cname:, ignore PlanB-msid

	    var ssrcs = filter$2(_context18 = map$5(_context19 = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')).call(_context19, function (line) {
	      return SDPUtils.parseSsrcMedia(line);
	    })).call(_context18, function (parts) {
	      return parts.attribute === 'cname';
	    });

	    var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
	    var secondarySsrc;

	    var flows = map$5(_context20 = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')).call(_context20, function (line) {
	      var parts = line.substr(17).split(' ');
	      return map$5(parts).call(parts, function (part) {
	        return _parseInt$3(part, 10);
	      });
	    });

	    if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
	      secondarySsrc = flows[0][1];
	    }

	    forEach$3(_context21 = description.codecs).call(_context21, function (codec) {
	      if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {
	        var encParam = {
	          ssrc: primarySsrc,
	          codecPayloadType: _parseInt$3(codec.parameters.apt, 10)
	        };

	        if (primarySsrc && secondarySsrc) {
	          encParam.rtx = {
	            ssrc: secondarySsrc
	          };
	        }

	        encodingParameters.push(encParam);

	        if (hasRed) {
	          encParam = JSON.parse(stringify$2(encParam));
	          encParam.fec = {
	            ssrc: primarySsrc,
	            mechanism: hasUlpfec ? 'red+ulpfec' : 'red'
	          };
	          encodingParameters.push(encParam);
	        }
	      }
	    });

	    if (encodingParameters.length === 0 && primarySsrc) {
	      encodingParameters.push({
	        ssrc: primarySsrc
	      });
	    } // we support both b=AS and b=TIAS but interpret AS as TIAS.


	    var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');

	    if (bandwidth.length) {
	      var _context22, _context23;

	      if (indexOf$3(_context22 = bandwidth[0]).call(_context22, 'b=TIAS:') === 0) {
	        bandwidth = _parseInt$3(bandwidth[0].substr(7), 10);
	      } else if (indexOf$3(_context23 = bandwidth[0]).call(_context23, 'b=AS:') === 0) {
	        // use formula from JSEP to convert b=AS to TIAS value.
	        bandwidth = _parseInt$3(bandwidth[0].substr(5), 10) * 1000 * 0.95 - 50 * 40 * 8;
	      } else {
	        bandwidth = undefined;
	      }

	      forEach$3(encodingParameters).call(encodingParameters, function (params) {
	        params.maxBitrate = bandwidth;
	      });
	    }

	    return encodingParameters;
	  }; // parses http://draft.ortc.org/#rtcrtcpparameters*


	  SDPUtils.parseRtcpParameters = function (mediaSection) {
	    var _context24, _context25;

	    var rtcpParameters = {}; // Gets the first SSRC. Note tha with RTX there might be multiple
	    // SSRCs.

	    var remoteSsrc = filter$2(_context24 = map$5(_context25 = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')).call(_context25, function (line) {
	      return SDPUtils.parseSsrcMedia(line);
	    })).call(_context24, function (obj) {
	      return obj.attribute === 'cname';
	    })[0];

	    if (remoteSsrc) {
	      rtcpParameters.cname = remoteSsrc.value;
	      rtcpParameters.ssrc = remoteSsrc.ssrc;
	    } // Edge uses the compound attribute instead of reducedSize
	    // compound is !reducedSize


	    var rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');
	    rtcpParameters.reducedSize = rsize.length > 0;
	    rtcpParameters.compound = rsize.length === 0; // parses the rtcp-mux attrіbute.
	    // Note that Edge does not support unmuxed RTCP.

	    var mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');
	    rtcpParameters.mux = mux.length > 0;
	    return rtcpParameters;
	  }; // parses either a=msid: or a=ssrc:... msid lines and returns
	  // the id of the MediaStream and MediaStreamTrack.


	  SDPUtils.parseMsid = function (mediaSection) {
	    var _context26, _context27;

	    var parts;
	    var spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');

	    if (spec.length === 1) {
	      parts = spec[0].substr(7).split(' ');
	      return {
	        stream: parts[0],
	        track: parts[1]
	      };
	    }

	    var planB = filter$2(_context26 = map$5(_context27 = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')).call(_context27, function (line) {
	      return SDPUtils.parseSsrcMedia(line);
	    })).call(_context26, function (msidParts) {
	      return msidParts.attribute === 'msid';
	    });

	    if (planB.length > 0) {
	      parts = planB[0].value.split(' ');
	      return {
	        stream: parts[0],
	        track: parts[1]
	      };
	    }
	  }; // Generate a session ID for SDP.
	  // https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1
	  // recommends using a cryptographically random +ve 64-bit value
	  // but right now this should be acceptable and within the right range


	  SDPUtils.generateSessionId = function () {
	    return Math.random().toString().substr(2, 21);
	  }; // Write boilder plate for start of SDP
	  // sessId argument is optional - if not supplied it will
	  // be generated randomly
	  // sessVersion is optional and defaults to 2
	  // sessUser is optional and defaults to 'thisisadapterortc'


	  SDPUtils.writeSessionBoilerplate = function (sessId, sessVer, sessUser) {
	    var sessionId;
	    var version = sessVer !== undefined ? sessVer : 2;

	    if (sessId) {
	      sessionId = sessId;
	    } else {
	      sessionId = SDPUtils.generateSessionId();
	    }

	    var user = sessUser || 'thisisadapterortc'; // FIXME: sess-id should be an NTP timestamp.

	    return 'v=0\r\n' + 'o=' + user + ' ' + sessionId + ' ' + version + ' IN IP4 127.0.0.1\r\n' + 's=-\r\n' + 't=0 0\r\n';
	  };

	  SDPUtils.writeMediaSection = function (transceiver, caps, type, stream) {
	    var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps); // Map ICE parameters (ufrag, pwd) to SDP.

	    sdp += SDPUtils.writeIceParameters(transceiver.iceGatherer.getLocalParameters()); // Map DTLS parameters to SDP.

	    sdp += SDPUtils.writeDtlsParameters(transceiver.dtlsTransport.getLocalParameters(), type === 'offer' ? 'actpass' : 'active');
	    sdp += 'a=mid:' + transceiver.mid + '\r\n';

	    if (transceiver.direction) {
	      sdp += 'a=' + transceiver.direction + '\r\n';
	    } else if (transceiver.rtpSender && transceiver.rtpReceiver) {
	      sdp += 'a=sendrecv\r\n';
	    } else if (transceiver.rtpSender) {
	      sdp += 'a=sendonly\r\n';
	    } else if (transceiver.rtpReceiver) {
	      sdp += 'a=recvonly\r\n';
	    } else {
	      sdp += 'a=inactive\r\n';
	    }

	    if (transceiver.rtpSender) {
	      // spec.
	      var msid = 'msid:' + stream.id + ' ' + transceiver.rtpSender.track.id + '\r\n';
	      sdp += 'a=' + msid; // for Chrome.

	      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc + ' ' + msid;

	      if (transceiver.sendEncodingParameters[0].rtx) {
	        sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc + ' ' + msid;
	        sdp += 'a=ssrc-group:FID ' + transceiver.sendEncodingParameters[0].ssrc + ' ' + transceiver.sendEncodingParameters[0].rtx.ssrc + '\r\n';
	      }
	    } // FIXME: this should be written by writeRtpDescription.


	    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc + ' cname:' + SDPUtils.localCName + '\r\n';

	    if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
	      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc + ' cname:' + SDPUtils.localCName + '\r\n';
	    }

	    return sdp;
	  }; // Gets the direction from the mediaSection or the sessionpart.


	  SDPUtils.getDirection = function (mediaSection, sessionpart) {
	    // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
	    var lines = SDPUtils.splitLines(mediaSection);

	    for (var i = 0; i < lines.length; i++) {
	      switch (lines[i]) {
	        case 'a=sendrecv':
	        case 'a=sendonly':
	        case 'a=recvonly':
	        case 'a=inactive':
	          return lines[i].substr(2);

	      }
	    }

	    if (sessionpart) {
	      return SDPUtils.getDirection(sessionpart);
	    }

	    return 'sendrecv';
	  };

	  SDPUtils.getKind = function (mediaSection) {
	    var lines = SDPUtils.splitLines(mediaSection);
	    var mline = lines[0].split(' ');
	    return mline[0].substr(2);
	  };

	  SDPUtils.isRejected = function (mediaSection) {
	    return mediaSection.split(' ', 2)[1] === '0';
	  };

	  SDPUtils.parseMLine = function (mediaSection) {
	    var lines = SDPUtils.splitLines(mediaSection);
	    var parts = lines[0].substr(2).split(' ');
	    return {
	      kind: parts[0],
	      port: _parseInt$3(parts[1], 10),
	      protocol: parts[2],
	      fmt: slice$2(parts).call(parts, 3).join(' ')
	    };
	  };

	  SDPUtils.parseOLine = function (mediaSection) {
	    var line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];
	    var parts = line.substr(2).split(' ');
	    return {
	      username: parts[0],
	      sessionId: parts[1],
	      sessionVersion: _parseInt$3(parts[2], 10),
	      netType: parts[3],
	      addressType: parts[4],
	      address: parts[5]
	    };
	  }; // a very naive interpretation of a valid SDP.


	  SDPUtils.isValidSDP = function (blob) {
	    if (typeof blob !== 'string' || blob.length === 0) {
	      return false;
	    }

	    var lines = SDPUtils.splitLines(blob);

	    for (var i = 0; i < lines.length; i++) {
	      if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {
	        return false;
	      } // TODO: check the modifier a bit more.

	    }

	    return true;
	  }; // Expose public methods.


	  {
	    module.exports = SDPUtils;
	  }
	});

	function fixStatsType(stat) {
	  return {
	    inboundrtp: 'inbound-rtp',
	    outboundrtp: 'outbound-rtp',
	    candidatepair: 'candidate-pair',
	    localcandidate: 'local-candidate',
	    remotecandidate: 'remote-candidate'
	  }[stat.type] || stat.type;
	}

	function writeMediaSection(transceiver, caps, type, stream, dtlsRole) {
	  var sdp$1 = sdp.writeRtpDescription(transceiver.kind, caps);

	  // Map ICE parameters (ufrag, pwd) to SDP.
	  sdp$1 += sdp.writeIceParameters(
	      transceiver.iceGatherer.getLocalParameters());

	  // Map DTLS parameters to SDP.
	  sdp$1 += sdp.writeDtlsParameters(
	      transceiver.dtlsTransport.getLocalParameters(),
	      type === 'offer' ? 'actpass' : dtlsRole || 'active');

	  sdp$1 += 'a=mid:' + transceiver.mid + '\r\n';

	  if (transceiver.rtpSender && transceiver.rtpReceiver) {
	    sdp$1 += 'a=sendrecv\r\n';
	  } else if (transceiver.rtpSender) {
	    sdp$1 += 'a=sendonly\r\n';
	  } else if (transceiver.rtpReceiver) {
	    sdp$1 += 'a=recvonly\r\n';
	  } else {
	    sdp$1 += 'a=inactive\r\n';
	  }

	  if (transceiver.rtpSender) {
	    var trackId = transceiver.rtpSender._initialTrackId ||
	        transceiver.rtpSender.track.id;
	    transceiver.rtpSender._initialTrackId = trackId;
	    // spec.
	    var msid = 'msid:' + (stream ? stream.id : '-') + ' ' +
	        trackId + '\r\n';
	    sdp$1 += 'a=' + msid;
	    // for Chrome. Legacy should no longer be required.
	    sdp$1 += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
	        ' ' + msid;

	    // RTX
	    if (transceiver.sendEncodingParameters[0].rtx) {
	      sdp$1 += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
	          ' ' + msid;
	      sdp$1 += 'a=ssrc-group:FID ' +
	          transceiver.sendEncodingParameters[0].ssrc + ' ' +
	          transceiver.sendEncodingParameters[0].rtx.ssrc +
	          '\r\n';
	    }
	  }
	  // FIXME: this should be written by writeRtpDescription.
	  sdp$1 += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
	      ' cname:' + sdp.localCName + '\r\n';
	  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
	    sdp$1 += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
	        ' cname:' + sdp.localCName + '\r\n';
	  }
	  return sdp$1;
	}

	// Edge does not like
	// 1) stun: filtered after 14393 unless ?transport=udp is present
	// 2) turn: that does not have all of turn:host:port?transport=udp
	// 3) turn: with ipv6 addresses
	// 4) turn: occurring muliple times
	function filterIceServers$1(iceServers, edgeVersion) {
	  var hasTurn = false;
	  iceServers = JSON.parse(JSON.stringify(iceServers));
	  return iceServers.filter(function(server) {
	    if (server && (server.urls || server.url)) {
	      var urls = server.urls || server.url;
	      if (server.url && !server.urls) {
	        console.warn('RTCIceServer.url is deprecated! Use urls instead.');
	      }
	      var isString = typeof urls === 'string';
	      if (isString) {
	        urls = [urls];
	      }
	      urls = urls.filter(function(url) {
	        var validTurn = url.indexOf('turn:') === 0 &&
	            url.indexOf('transport=udp') !== -1 &&
	            url.indexOf('turn:[') === -1 &&
	            !hasTurn;

	        if (validTurn) {
	          hasTurn = true;
	          return true;
	        }
	        return url.indexOf('stun:') === 0 && edgeVersion >= 14393 &&
	            url.indexOf('?transport=udp') === -1;
	      });

	      delete server.url;
	      server.urls = isString ? urls[0] : urls;
	      return !!urls.length;
	    }
	  });
	}

	// Determines the intersection of local and remote capabilities.
	function getCommonCapabilities(localCapabilities, remoteCapabilities) {
	  var commonCapabilities = {
	    codecs: [],
	    headerExtensions: [],
	    fecMechanisms: []
	  };

	  var findCodecByPayloadType = function(pt, codecs) {
	    pt = parseInt(pt, 10);
	    for (var i = 0; i < codecs.length; i++) {
	      if (codecs[i].payloadType === pt ||
	          codecs[i].preferredPayloadType === pt) {
	        return codecs[i];
	      }
	    }
	  };

	  var rtxCapabilityMatches = function(lRtx, rRtx, lCodecs, rCodecs) {
	    var lCodec = findCodecByPayloadType(lRtx.parameters.apt, lCodecs);
	    var rCodec = findCodecByPayloadType(rRtx.parameters.apt, rCodecs);
	    return lCodec && rCodec &&
	        lCodec.name.toLowerCase() === rCodec.name.toLowerCase();
	  };

	  localCapabilities.codecs.forEach(function(lCodec) {
	    for (var i = 0; i < remoteCapabilities.codecs.length; i++) {
	      var rCodec = remoteCapabilities.codecs[i];
	      if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() &&
	          lCodec.clockRate === rCodec.clockRate) {
	        if (lCodec.name.toLowerCase() === 'rtx' &&
	            lCodec.parameters && rCodec.parameters.apt) {
	          // for RTX we need to find the local rtx that has a apt
	          // which points to the same local codec as the remote one.
	          if (!rtxCapabilityMatches(lCodec, rCodec,
	              localCapabilities.codecs, remoteCapabilities.codecs)) {
	            continue;
	          }
	        }
	        rCodec = JSON.parse(JSON.stringify(rCodec)); // deepcopy
	        // number of channels is the highest common number of channels
	        rCodec.numChannels = Math.min(lCodec.numChannels,
	            rCodec.numChannels);
	        // push rCodec so we reply with offerer payload type
	        commonCapabilities.codecs.push(rCodec);

	        // determine common feedback mechanisms
	        rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function(fb) {
	          for (var j = 0; j < lCodec.rtcpFeedback.length; j++) {
	            if (lCodec.rtcpFeedback[j].type === fb.type &&
	                lCodec.rtcpFeedback[j].parameter === fb.parameter) {
	              return true;
	            }
	          }
	          return false;
	        });
	        // FIXME: also need to determine .parameters
	        //  see https://github.com/openpeer/ortc/issues/569
	        break;
	      }
	    }
	  });

	  localCapabilities.headerExtensions.forEach(function(lHeaderExtension) {
	    for (var i = 0; i < remoteCapabilities.headerExtensions.length;
	         i++) {
	      var rHeaderExtension = remoteCapabilities.headerExtensions[i];
	      if (lHeaderExtension.uri === rHeaderExtension.uri) {
	        commonCapabilities.headerExtensions.push(rHeaderExtension);
	        break;
	      }
	    }
	  });

	  // FIXME: fecMechanisms
	  return commonCapabilities;
	}

	// is action=setLocalDescription with type allowed in signalingState
	function isActionAllowedInSignalingState(action, type, signalingState) {
	  return {
	    offer: {
	      setLocalDescription: ['stable', 'have-local-offer'],
	      setRemoteDescription: ['stable', 'have-remote-offer']
	    },
	    answer: {
	      setLocalDescription: ['have-remote-offer', 'have-local-pranswer'],
	      setRemoteDescription: ['have-local-offer', 'have-remote-pranswer']
	    }
	  }[type][action].indexOf(signalingState) !== -1;
	}

	function maybeAddCandidate(iceTransport, candidate) {
	  // Edge's internal representation adds some fields therefore
	  // not all fieldѕ are taken into account.
	  var alreadyAdded = iceTransport.getRemoteCandidates()
	      .find(function(remoteCandidate) {
	        return candidate.foundation === remoteCandidate.foundation &&
	            candidate.ip === remoteCandidate.ip &&
	            candidate.port === remoteCandidate.port &&
	            candidate.priority === remoteCandidate.priority &&
	            candidate.protocol === remoteCandidate.protocol &&
	            candidate.type === remoteCandidate.type;
	      });
	  if (!alreadyAdded) {
	    iceTransport.addRemoteCandidate(candidate);
	  }
	  return !alreadyAdded;
	}


	function makeError(name, description) {
	  var e = new Error(description);
	  e.name = name;
	  // legacy error codes from https://heycam.github.io/webidl/#idl-DOMException-error-names
	  e.code = {
	    NotSupportedError: 9,
	    InvalidStateError: 11,
	    InvalidAccessError: 15,
	    TypeError: undefined,
	    OperationError: undefined
	  }[name];
	  return e;
	}

	var rtcpeerconnection = function(window, edgeVersion) {
	  // https://w3c.github.io/mediacapture-main/#mediastream
	  // Helper function to add the track to the stream and
	  // dispatch the event ourselves.
	  function addTrackToStreamAndFireEvent(track, stream) {
	    stream.addTrack(track);
	    stream.dispatchEvent(new window.MediaStreamTrackEvent('addtrack',
	        {track: track}));
	  }

	  function removeTrackFromStreamAndFireEvent(track, stream) {
	    stream.removeTrack(track);
	    stream.dispatchEvent(new window.MediaStreamTrackEvent('removetrack',
	        {track: track}));
	  }

	  function fireAddTrack(pc, track, receiver, streams) {
	    var trackEvent = new Event('track');
	    trackEvent.track = track;
	    trackEvent.receiver = receiver;
	    trackEvent.transceiver = {receiver: receiver};
	    trackEvent.streams = streams;
	    window.setTimeout(function() {
	      pc._dispatchEvent('track', trackEvent);
	    });
	  }

	  var RTCPeerConnection = function(config) {
	    var pc = this;

	    var _eventTarget = document.createDocumentFragment();
	    ['addEventListener', 'removeEventListener', 'dispatchEvent']
	        .forEach(function(method) {
	          pc[method] = _eventTarget[method].bind(_eventTarget);
	        });

	    this.canTrickleIceCandidates = null;

	    this.needNegotiation = false;

	    this.localStreams = [];
	    this.remoteStreams = [];

	    this._localDescription = null;
	    this._remoteDescription = null;

	    this.signalingState = 'stable';
	    this.iceConnectionState = 'new';
	    this.connectionState = 'new';
	    this.iceGatheringState = 'new';

	    config = JSON.parse(JSON.stringify(config || {}));

	    this.usingBundle = config.bundlePolicy === 'max-bundle';
	    if (config.rtcpMuxPolicy === 'negotiate') {
	      throw(makeError('NotSupportedError',
	          'rtcpMuxPolicy \'negotiate\' is not supported'));
	    } else if (!config.rtcpMuxPolicy) {
	      config.rtcpMuxPolicy = 'require';
	    }

	    switch (config.iceTransportPolicy) {
	      case 'all':
	      case 'relay':
	        break;
	      default:
	        config.iceTransportPolicy = 'all';
	        break;
	    }

	    switch (config.bundlePolicy) {
	      case 'balanced':
	      case 'max-compat':
	      case 'max-bundle':
	        break;
	      default:
	        config.bundlePolicy = 'balanced';
	        break;
	    }

	    config.iceServers = filterIceServers$1(config.iceServers || [], edgeVersion);

	    this._iceGatherers = [];
	    if (config.iceCandidatePoolSize) {
	      for (var i = config.iceCandidatePoolSize; i > 0; i--) {
	        this._iceGatherers.push(new window.RTCIceGatherer({
	          iceServers: config.iceServers,
	          gatherPolicy: config.iceTransportPolicy
	        }));
	      }
	    } else {
	      config.iceCandidatePoolSize = 0;
	    }

	    this._config = config;

	    // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...
	    // everything that is needed to describe a SDP m-line.
	    this.transceivers = [];

	    this._sdpSessionId = sdp.generateSessionId();
	    this._sdpSessionVersion = 0;

	    this._dtlsRole = undefined; // role for a=setup to use in answers.

	    this._isClosed = false;
	  };

	  Object.defineProperty(RTCPeerConnection.prototype, 'localDescription', {
	    configurable: true,
	    get: function() {
	      return this._localDescription;
	    }
	  });
	  Object.defineProperty(RTCPeerConnection.prototype, 'remoteDescription', {
	    configurable: true,
	    get: function() {
	      return this._remoteDescription;
	    }
	  });

	  // set up event handlers on prototype
	  RTCPeerConnection.prototype.onicecandidate = null;
	  RTCPeerConnection.prototype.onaddstream = null;
	  RTCPeerConnection.prototype.ontrack = null;
	  RTCPeerConnection.prototype.onremovestream = null;
	  RTCPeerConnection.prototype.onsignalingstatechange = null;
	  RTCPeerConnection.prototype.oniceconnectionstatechange = null;
	  RTCPeerConnection.prototype.onconnectionstatechange = null;
	  RTCPeerConnection.prototype.onicegatheringstatechange = null;
	  RTCPeerConnection.prototype.onnegotiationneeded = null;
	  RTCPeerConnection.prototype.ondatachannel = null;

	  RTCPeerConnection.prototype._dispatchEvent = function(name, event) {
	    if (this._isClosed) {
	      return;
	    }
	    this.dispatchEvent(event);
	    if (typeof this['on' + name] === 'function') {
	      this['on' + name](event);
	    }
	  };

	  RTCPeerConnection.prototype._emitGatheringStateChange = function() {
	    var event = new Event('icegatheringstatechange');
	    this._dispatchEvent('icegatheringstatechange', event);
	  };

	  RTCPeerConnection.prototype.getConfiguration = function() {
	    return this._config;
	  };

	  RTCPeerConnection.prototype.getLocalStreams = function() {
	    return this.localStreams;
	  };

	  RTCPeerConnection.prototype.getRemoteStreams = function() {
	    return this.remoteStreams;
	  };

	  // internal helper to create a transceiver object.
	  // (which is not yet the same as the WebRTC 1.0 transceiver)
	  RTCPeerConnection.prototype._createTransceiver = function(kind, doNotAdd) {
	    var hasBundleTransport = this.transceivers.length > 0;
	    var transceiver = {
	      track: null,
	      iceGatherer: null,
	      iceTransport: null,
	      dtlsTransport: null,
	      localCapabilities: null,
	      remoteCapabilities: null,
	      rtpSender: null,
	      rtpReceiver: null,
	      kind: kind,
	      mid: null,
	      sendEncodingParameters: null,
	      recvEncodingParameters: null,
	      stream: null,
	      associatedRemoteMediaStreams: [],
	      wantReceive: true
	    };
	    if (this.usingBundle && hasBundleTransport) {
	      transceiver.iceTransport = this.transceivers[0].iceTransport;
	      transceiver.dtlsTransport = this.transceivers[0].dtlsTransport;
	    } else {
	      var transports = this._createIceAndDtlsTransports();
	      transceiver.iceTransport = transports.iceTransport;
	      transceiver.dtlsTransport = transports.dtlsTransport;
	    }
	    if (!doNotAdd) {
	      this.transceivers.push(transceiver);
	    }
	    return transceiver;
	  };

	  RTCPeerConnection.prototype.addTrack = function(track, stream) {
	    if (this._isClosed) {
	      throw makeError('InvalidStateError',
	          'Attempted to call addTrack on a closed peerconnection.');
	    }

	    var alreadyExists = this.transceivers.find(function(s) {
	      return s.track === track;
	    });

	    if (alreadyExists) {
	      throw makeError('InvalidAccessError', 'Track already exists.');
	    }

	    var transceiver;
	    for (var i = 0; i < this.transceivers.length; i++) {
	      if (!this.transceivers[i].track &&
	          this.transceivers[i].kind === track.kind) {
	        transceiver = this.transceivers[i];
	      }
	    }
	    if (!transceiver) {
	      transceiver = this._createTransceiver(track.kind);
	    }

	    this._maybeFireNegotiationNeeded();

	    if (this.localStreams.indexOf(stream) === -1) {
	      this.localStreams.push(stream);
	    }

	    transceiver.track = track;
	    transceiver.stream = stream;
	    transceiver.rtpSender = new window.RTCRtpSender(track,
	        transceiver.dtlsTransport);
	    return transceiver.rtpSender;
	  };

	  RTCPeerConnection.prototype.addStream = function(stream) {
	    var pc = this;
	    if (edgeVersion >= 15025) {
	      stream.getTracks().forEach(function(track) {
	        pc.addTrack(track, stream);
	      });
	    } else {
	      // Clone is necessary for local demos mostly, attaching directly
	      // to two different senders does not work (build 10547).
	      // Fixed in 15025 (or earlier)
	      var clonedStream = stream.clone();
	      stream.getTracks().forEach(function(track, idx) {
	        var clonedTrack = clonedStream.getTracks()[idx];
	        track.addEventListener('enabled', function(event) {
	          clonedTrack.enabled = event.enabled;
	        });
	      });
	      clonedStream.getTracks().forEach(function(track) {
	        pc.addTrack(track, clonedStream);
	      });
	    }
	  };

	  RTCPeerConnection.prototype.removeTrack = function(sender) {
	    if (this._isClosed) {
	      throw makeError('InvalidStateError',
	          'Attempted to call removeTrack on a closed peerconnection.');
	    }

	    if (!(sender instanceof window.RTCRtpSender)) {
	      throw new TypeError('Argument 1 of RTCPeerConnection.removeTrack ' +
	          'does not implement interface RTCRtpSender.');
	    }

	    var transceiver = this.transceivers.find(function(t) {
	      return t.rtpSender === sender;
	    });

	    if (!transceiver) {
	      throw makeError('InvalidAccessError',
	          'Sender was not created by this connection.');
	    }
	    var stream = transceiver.stream;

	    transceiver.rtpSender.stop();
	    transceiver.rtpSender = null;
	    transceiver.track = null;
	    transceiver.stream = null;

	    // remove the stream from the set of local streams
	    var localStreams = this.transceivers.map(function(t) {
	      return t.stream;
	    });
	    if (localStreams.indexOf(stream) === -1 &&
	        this.localStreams.indexOf(stream) > -1) {
	      this.localStreams.splice(this.localStreams.indexOf(stream), 1);
	    }

	    this._maybeFireNegotiationNeeded();
	  };

	  RTCPeerConnection.prototype.removeStream = function(stream) {
	    var pc = this;
	    stream.getTracks().forEach(function(track) {
	      var sender = pc.getSenders().find(function(s) {
	        return s.track === track;
	      });
	      if (sender) {
	        pc.removeTrack(sender);
	      }
	    });
	  };

	  RTCPeerConnection.prototype.getSenders = function() {
	    return this.transceivers.filter(function(transceiver) {
	      return !!transceiver.rtpSender;
	    })
	    .map(function(transceiver) {
	      return transceiver.rtpSender;
	    });
	  };

	  RTCPeerConnection.prototype.getReceivers = function() {
	    return this.transceivers.filter(function(transceiver) {
	      return !!transceiver.rtpReceiver;
	    })
	    .map(function(transceiver) {
	      return transceiver.rtpReceiver;
	    });
	  };


	  RTCPeerConnection.prototype._createIceGatherer = function(sdpMLineIndex,
	      usingBundle) {
	    var pc = this;
	    if (usingBundle && sdpMLineIndex > 0) {
	      return this.transceivers[0].iceGatherer;
	    } else if (this._iceGatherers.length) {
	      return this._iceGatherers.shift();
	    }
	    var iceGatherer = new window.RTCIceGatherer({
	      iceServers: this._config.iceServers,
	      gatherPolicy: this._config.iceTransportPolicy
	    });
	    Object.defineProperty(iceGatherer, 'state',
	        {value: 'new', writable: true}
	    );

	    this.transceivers[sdpMLineIndex].bufferedCandidateEvents = [];
	    this.transceivers[sdpMLineIndex].bufferCandidates = function(event) {
	      var end = !event.candidate || Object.keys(event.candidate).length === 0;
	      // polyfill since RTCIceGatherer.state is not implemented in
	      // Edge 10547 yet.
	      iceGatherer.state = end ? 'completed' : 'gathering';
	      if (pc.transceivers[sdpMLineIndex].bufferedCandidateEvents !== null) {
	        pc.transceivers[sdpMLineIndex].bufferedCandidateEvents.push(event);
	      }
	    };
	    iceGatherer.addEventListener('localcandidate',
	      this.transceivers[sdpMLineIndex].bufferCandidates);
	    return iceGatherer;
	  };

	  // start gathering from an RTCIceGatherer.
	  RTCPeerConnection.prototype._gather = function(mid, sdpMLineIndex) {
	    var pc = this;
	    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;
	    if (iceGatherer.onlocalcandidate) {
	      return;
	    }
	    var bufferedCandidateEvents =
	      this.transceivers[sdpMLineIndex].bufferedCandidateEvents;
	    this.transceivers[sdpMLineIndex].bufferedCandidateEvents = null;
	    iceGatherer.removeEventListener('localcandidate',
	      this.transceivers[sdpMLineIndex].bufferCandidates);
	    iceGatherer.onlocalcandidate = function(evt) {
	      if (pc.usingBundle && sdpMLineIndex > 0) {
	        // if we know that we use bundle we can drop candidates with
	        // ѕdpMLineIndex > 0. If we don't do this then our state gets
	        // confused since we dispose the extra ice gatherer.
	        return;
	      }
	      var event = new Event('icecandidate');
	      event.candidate = {sdpMid: mid, sdpMLineIndex: sdpMLineIndex};

	      var cand = evt.candidate;
	      // Edge emits an empty object for RTCIceCandidateComplete‥
	      var end = !cand || Object.keys(cand).length === 0;
	      if (end) {
	        // polyfill since RTCIceGatherer.state is not implemented in
	        // Edge 10547 yet.
	        if (iceGatherer.state === 'new' || iceGatherer.state === 'gathering') {
	          iceGatherer.state = 'completed';
	        }
	      } else {
	        if (iceGatherer.state === 'new') {
	          iceGatherer.state = 'gathering';
	        }
	        // RTCIceCandidate doesn't have a component, needs to be added
	        cand.component = 1;
	        // also the usernameFragment. TODO: update SDP to take both variants.
	        cand.ufrag = iceGatherer.getLocalParameters().usernameFragment;

	        var serializedCandidate = sdp.writeCandidate(cand);
	        event.candidate = Object.assign(event.candidate,
	            sdp.parseCandidate(serializedCandidate));

	        event.candidate.candidate = serializedCandidate;
	        event.candidate.toJSON = function() {
	          return {
	            candidate: event.candidate.candidate,
	            sdpMid: event.candidate.sdpMid,
	            sdpMLineIndex: event.candidate.sdpMLineIndex,
	            usernameFragment: event.candidate.usernameFragment
	          };
	        };
	      }

	      // update local description.
	      var sections = sdp.getMediaSections(pc._localDescription.sdp);
	      if (!end) {
	        sections[event.candidate.sdpMLineIndex] +=
	            'a=' + event.candidate.candidate + '\r\n';
	      } else {
	        sections[event.candidate.sdpMLineIndex] +=
	            'a=end-of-candidates\r\n';
	      }
	      pc._localDescription.sdp =
	          sdp.getDescription(pc._localDescription.sdp) +
	          sections.join('');
	      var complete = pc.transceivers.every(function(transceiver) {
	        return transceiver.iceGatherer &&
	            transceiver.iceGatherer.state === 'completed';
	      });

	      if (pc.iceGatheringState !== 'gathering') {
	        pc.iceGatheringState = 'gathering';
	        pc._emitGatheringStateChange();
	      }

	      // Emit candidate. Also emit null candidate when all gatherers are
	      // complete.
	      if (!end) {
	        pc._dispatchEvent('icecandidate', event);
	      }
	      if (complete) {
	        pc._dispatchEvent('icecandidate', new Event('icecandidate'));
	        pc.iceGatheringState = 'complete';
	        pc._emitGatheringStateChange();
	      }
	    };

	    // emit already gathered candidates.
	    window.setTimeout(function() {
	      bufferedCandidateEvents.forEach(function(e) {
	        iceGatherer.onlocalcandidate(e);
	      });
	    }, 0);
	  };

	  // Create ICE transport and DTLS transport.
	  RTCPeerConnection.prototype._createIceAndDtlsTransports = function() {
	    var pc = this;
	    var iceTransport = new window.RTCIceTransport(null);
	    iceTransport.onicestatechange = function() {
	      pc._updateIceConnectionState();
	      pc._updateConnectionState();
	    };

	    var dtlsTransport = new window.RTCDtlsTransport(iceTransport);
	    dtlsTransport.ondtlsstatechange = function() {
	      pc._updateConnectionState();
	    };
	    dtlsTransport.onerror = function() {
	      // onerror does not set state to failed by itself.
	      Object.defineProperty(dtlsTransport, 'state',
	          {value: 'failed', writable: true});
	      pc._updateConnectionState();
	    };

	    return {
	      iceTransport: iceTransport,
	      dtlsTransport: dtlsTransport
	    };
	  };

	  // Destroy ICE gatherer, ICE transport and DTLS transport.
	  // Without triggering the callbacks.
	  RTCPeerConnection.prototype._disposeIceAndDtlsTransports = function(
	      sdpMLineIndex) {
	    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;
	    if (iceGatherer) {
	      delete iceGatherer.onlocalcandidate;
	      delete this.transceivers[sdpMLineIndex].iceGatherer;
	    }
	    var iceTransport = this.transceivers[sdpMLineIndex].iceTransport;
	    if (iceTransport) {
	      delete iceTransport.onicestatechange;
	      delete this.transceivers[sdpMLineIndex].iceTransport;
	    }
	    var dtlsTransport = this.transceivers[sdpMLineIndex].dtlsTransport;
	    if (dtlsTransport) {
	      delete dtlsTransport.ondtlsstatechange;
	      delete dtlsTransport.onerror;
	      delete this.transceivers[sdpMLineIndex].dtlsTransport;
	    }
	  };

	  // Start the RTP Sender and Receiver for a transceiver.
	  RTCPeerConnection.prototype._transceive = function(transceiver,
	      send, recv) {
	    var params = getCommonCapabilities(transceiver.localCapabilities,
	        transceiver.remoteCapabilities);
	    if (send && transceiver.rtpSender) {
	      params.encodings = transceiver.sendEncodingParameters;
	      params.rtcp = {
	        cname: sdp.localCName,
	        compound: transceiver.rtcpParameters.compound
	      };
	      if (transceiver.recvEncodingParameters.length) {
	        params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;
	      }
	      transceiver.rtpSender.send(params);
	    }
	    if (recv && transceiver.rtpReceiver && params.codecs.length > 0) {
	      // remove RTX field in Edge 14942
	      if (transceiver.kind === 'video'
	          && transceiver.recvEncodingParameters
	          && edgeVersion < 15019) {
	        transceiver.recvEncodingParameters.forEach(function(p) {
	          delete p.rtx;
	        });
	      }
	      if (transceiver.recvEncodingParameters.length) {
	        params.encodings = transceiver.recvEncodingParameters;
	      } else {
	        params.encodings = [{}];
	      }
	      params.rtcp = {
	        compound: transceiver.rtcpParameters.compound
	      };
	      if (transceiver.rtcpParameters.cname) {
	        params.rtcp.cname = transceiver.rtcpParameters.cname;
	      }
	      if (transceiver.sendEncodingParameters.length) {
	        params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;
	      }
	      transceiver.rtpReceiver.receive(params);
	    }
	  };

	  RTCPeerConnection.prototype.setLocalDescription = function(description) {
	    var pc = this;

	    // Note: pranswer is not supported.
	    if (['offer', 'answer'].indexOf(description.type) === -1) {
	      return Promise.reject(makeError('TypeError',
	          'Unsupported type "' + description.type + '"'));
	    }

	    if (!isActionAllowedInSignalingState('setLocalDescription',
	        description.type, pc.signalingState) || pc._isClosed) {
	      return Promise.reject(makeError('InvalidStateError',
	          'Can not set local ' + description.type +
	          ' in state ' + pc.signalingState));
	    }

	    var sections;
	    var sessionpart;
	    if (description.type === 'offer') {
	      // VERY limited support for SDP munging. Limited to:
	      // * changing the order of codecs
	      sections = sdp.splitSections(description.sdp);
	      sessionpart = sections.shift();
	      sections.forEach(function(mediaSection, sdpMLineIndex) {
	        var caps = sdp.parseRtpParameters(mediaSection);
	        pc.transceivers[sdpMLineIndex].localCapabilities = caps;
	      });

	      pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
	        pc._gather(transceiver.mid, sdpMLineIndex);
	      });
	    } else if (description.type === 'answer') {
	      sections = sdp.splitSections(pc._remoteDescription.sdp);
	      sessionpart = sections.shift();
	      var isIceLite = sdp.matchPrefix(sessionpart,
	          'a=ice-lite').length > 0;
	      sections.forEach(function(mediaSection, sdpMLineIndex) {
	        var transceiver = pc.transceivers[sdpMLineIndex];
	        var iceGatherer = transceiver.iceGatherer;
	        var iceTransport = transceiver.iceTransport;
	        var dtlsTransport = transceiver.dtlsTransport;
	        var localCapabilities = transceiver.localCapabilities;
	        var remoteCapabilities = transceiver.remoteCapabilities;

	        // treat bundle-only as not-rejected.
	        var rejected = sdp.isRejected(mediaSection) &&
	            sdp.matchPrefix(mediaSection, 'a=bundle-only').length === 0;

	        if (!rejected && !transceiver.rejected) {
	          var remoteIceParameters = sdp.getIceParameters(
	              mediaSection, sessionpart);
	          var remoteDtlsParameters = sdp.getDtlsParameters(
	              mediaSection, sessionpart);
	          if (isIceLite) {
	            remoteDtlsParameters.role = 'server';
	          }

	          if (!pc.usingBundle || sdpMLineIndex === 0) {
	            pc._gather(transceiver.mid, sdpMLineIndex);
	            if (iceTransport.state === 'new') {
	              iceTransport.start(iceGatherer, remoteIceParameters,
	                  isIceLite ? 'controlling' : 'controlled');
	            }
	            if (dtlsTransport.state === 'new') {
	              dtlsTransport.start(remoteDtlsParameters);
	            }
	          }

	          // Calculate intersection of capabilities.
	          var params = getCommonCapabilities(localCapabilities,
	              remoteCapabilities);

	          // Start the RTCRtpSender. The RTCRtpReceiver for this
	          // transceiver has already been started in setRemoteDescription.
	          pc._transceive(transceiver,
	              params.codecs.length > 0,
	              false);
	        }
	      });
	    }

	    pc._localDescription = {
	      type: description.type,
	      sdp: description.sdp
	    };
	    if (description.type === 'offer') {
	      pc._updateSignalingState('have-local-offer');
	    } else {
	      pc._updateSignalingState('stable');
	    }

	    return Promise.resolve();
	  };

	  RTCPeerConnection.prototype.setRemoteDescription = function(description) {
	    var pc = this;

	    // Note: pranswer is not supported.
	    if (['offer', 'answer'].indexOf(description.type) === -1) {
	      return Promise.reject(makeError('TypeError',
	          'Unsupported type "' + description.type + '"'));
	    }

	    if (!isActionAllowedInSignalingState('setRemoteDescription',
	        description.type, pc.signalingState) || pc._isClosed) {
	      return Promise.reject(makeError('InvalidStateError',
	          'Can not set remote ' + description.type +
	          ' in state ' + pc.signalingState));
	    }

	    var streams = {};
	    pc.remoteStreams.forEach(function(stream) {
	      streams[stream.id] = stream;
	    });
	    var receiverList = [];
	    var sections = sdp.splitSections(description.sdp);
	    var sessionpart = sections.shift();
	    var isIceLite = sdp.matchPrefix(sessionpart,
	        'a=ice-lite').length > 0;
	    var usingBundle = sdp.matchPrefix(sessionpart,
	        'a=group:BUNDLE ').length > 0;
	    pc.usingBundle = usingBundle;
	    var iceOptions = sdp.matchPrefix(sessionpart,
	        'a=ice-options:')[0];
	    if (iceOptions) {
	      pc.canTrickleIceCandidates = iceOptions.substr(14).split(' ')
	          .indexOf('trickle') >= 0;
	    } else {
	      pc.canTrickleIceCandidates = false;
	    }

	    sections.forEach(function(mediaSection, sdpMLineIndex) {
	      var lines = sdp.splitLines(mediaSection);
	      var kind = sdp.getKind(mediaSection);
	      // treat bundle-only as not-rejected.
	      var rejected = sdp.isRejected(mediaSection) &&
	          sdp.matchPrefix(mediaSection, 'a=bundle-only').length === 0;
	      var protocol = lines[0].substr(2).split(' ')[2];

	      var direction = sdp.getDirection(mediaSection, sessionpart);
	      var remoteMsid = sdp.parseMsid(mediaSection);

	      var mid = sdp.getMid(mediaSection) || sdp.generateIdentifier();

	      // Reject datachannels which are not implemented yet.
	      if (rejected || (kind === 'application' && (protocol === 'DTLS/SCTP' ||
	          protocol === 'UDP/DTLS/SCTP'))) {
	        // TODO: this is dangerous in the case where a non-rejected m-line
	        //     becomes rejected.
	        pc.transceivers[sdpMLineIndex] = {
	          mid: mid,
	          kind: kind,
	          protocol: protocol,
	          rejected: true
	        };
	        return;
	      }

	      if (!rejected && pc.transceivers[sdpMLineIndex] &&
	          pc.transceivers[sdpMLineIndex].rejected) {
	        // recycle a rejected transceiver.
	        pc.transceivers[sdpMLineIndex] = pc._createTransceiver(kind, true);
	      }

	      var transceiver;
	      var iceGatherer;
	      var iceTransport;
	      var dtlsTransport;
	      var rtpReceiver;
	      var sendEncodingParameters;
	      var recvEncodingParameters;
	      var localCapabilities;

	      var track;
	      // FIXME: ensure the mediaSection has rtcp-mux set.
	      var remoteCapabilities = sdp.parseRtpParameters(mediaSection);
	      var remoteIceParameters;
	      var remoteDtlsParameters;
	      if (!rejected) {
	        remoteIceParameters = sdp.getIceParameters(mediaSection,
	            sessionpart);
	        remoteDtlsParameters = sdp.getDtlsParameters(mediaSection,
	            sessionpart);
	        remoteDtlsParameters.role = 'client';
	      }
	      recvEncodingParameters =
	          sdp.parseRtpEncodingParameters(mediaSection);

	      var rtcpParameters = sdp.parseRtcpParameters(mediaSection);

	      var isComplete = sdp.matchPrefix(mediaSection,
	          'a=end-of-candidates', sessionpart).length > 0;
	      var cands = sdp.matchPrefix(mediaSection, 'a=candidate:')
	          .map(function(cand) {
	            return sdp.parseCandidate(cand);
	          })
	          .filter(function(cand) {
	            return cand.component === 1;
	          });

	      // Check if we can use BUNDLE and dispose transports.
	      if ((description.type === 'offer' || description.type === 'answer') &&
	          !rejected && usingBundle && sdpMLineIndex > 0 &&
	          pc.transceivers[sdpMLineIndex]) {
	        pc._disposeIceAndDtlsTransports(sdpMLineIndex);
	        pc.transceivers[sdpMLineIndex].iceGatherer =
	            pc.transceivers[0].iceGatherer;
	        pc.transceivers[sdpMLineIndex].iceTransport =
	            pc.transceivers[0].iceTransport;
	        pc.transceivers[sdpMLineIndex].dtlsTransport =
	            pc.transceivers[0].dtlsTransport;
	        if (pc.transceivers[sdpMLineIndex].rtpSender) {
	          pc.transceivers[sdpMLineIndex].rtpSender.setTransport(
	              pc.transceivers[0].dtlsTransport);
	        }
	        if (pc.transceivers[sdpMLineIndex].rtpReceiver) {
	          pc.transceivers[sdpMLineIndex].rtpReceiver.setTransport(
	              pc.transceivers[0].dtlsTransport);
	        }
	      }
	      if (description.type === 'offer' && !rejected) {
	        transceiver = pc.transceivers[sdpMLineIndex] ||
	            pc._createTransceiver(kind);
	        transceiver.mid = mid;

	        if (!transceiver.iceGatherer) {
	          transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,
	              usingBundle);
	        }

	        if (cands.length && transceiver.iceTransport.state === 'new') {
	          if (isComplete && (!usingBundle || sdpMLineIndex === 0)) {
	            transceiver.iceTransport.setRemoteCandidates(cands);
	          } else {
	            cands.forEach(function(candidate) {
	              maybeAddCandidate(transceiver.iceTransport, candidate);
	            });
	          }
	        }

	        localCapabilities = window.RTCRtpReceiver.getCapabilities(kind);

	        // filter RTX until additional stuff needed for RTX is implemented
	        // in adapter.js
	        if (edgeVersion < 15019) {
	          localCapabilities.codecs = localCapabilities.codecs.filter(
	              function(codec) {
	                return codec.name !== 'rtx';
	              });
	        }

	        sendEncodingParameters = transceiver.sendEncodingParameters || [{
	          ssrc: (2 * sdpMLineIndex + 2) * 1001
	        }];

	        // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams
	        var isNewTrack = false;
	        if (direction === 'sendrecv' || direction === 'sendonly') {
	          isNewTrack = !transceiver.rtpReceiver;
	          rtpReceiver = transceiver.rtpReceiver ||
	              new window.RTCRtpReceiver(transceiver.dtlsTransport, kind);

	          if (isNewTrack) {
	            var stream;
	            track = rtpReceiver.track;
	            // FIXME: does not work with Plan B.
	            if (remoteMsid && remoteMsid.stream === '-') ; else if (remoteMsid) {
	              if (!streams[remoteMsid.stream]) {
	                streams[remoteMsid.stream] = new window.MediaStream();
	                Object.defineProperty(streams[remoteMsid.stream], 'id', {
	                  get: function() {
	                    return remoteMsid.stream;
	                  }
	                });
	              }
	              Object.defineProperty(track, 'id', {
	                get: function() {
	                  return remoteMsid.track;
	                }
	              });
	              stream = streams[remoteMsid.stream];
	            } else {
	              if (!streams.default) {
	                streams.default = new window.MediaStream();
	              }
	              stream = streams.default;
	            }
	            if (stream) {
	              addTrackToStreamAndFireEvent(track, stream);
	              transceiver.associatedRemoteMediaStreams.push(stream);
	            }
	            receiverList.push([track, rtpReceiver, stream]);
	          }
	        } else if (transceiver.rtpReceiver && transceiver.rtpReceiver.track) {
	          transceiver.associatedRemoteMediaStreams.forEach(function(s) {
	            var nativeTrack = s.getTracks().find(function(t) {
	              return t.id === transceiver.rtpReceiver.track.id;
	            });
	            if (nativeTrack) {
	              removeTrackFromStreamAndFireEvent(nativeTrack, s);
	            }
	          });
	          transceiver.associatedRemoteMediaStreams = [];
	        }

	        transceiver.localCapabilities = localCapabilities;
	        transceiver.remoteCapabilities = remoteCapabilities;
	        transceiver.rtpReceiver = rtpReceiver;
	        transceiver.rtcpParameters = rtcpParameters;
	        transceiver.sendEncodingParameters = sendEncodingParameters;
	        transceiver.recvEncodingParameters = recvEncodingParameters;

	        // Start the RTCRtpReceiver now. The RTPSender is started in
	        // setLocalDescription.
	        pc._transceive(pc.transceivers[sdpMLineIndex],
	            false,
	            isNewTrack);
	      } else if (description.type === 'answer' && !rejected) {
	        transceiver = pc.transceivers[sdpMLineIndex];
	        iceGatherer = transceiver.iceGatherer;
	        iceTransport = transceiver.iceTransport;
	        dtlsTransport = transceiver.dtlsTransport;
	        rtpReceiver = transceiver.rtpReceiver;
	        sendEncodingParameters = transceiver.sendEncodingParameters;
	        localCapabilities = transceiver.localCapabilities;

	        pc.transceivers[sdpMLineIndex].recvEncodingParameters =
	            recvEncodingParameters;
	        pc.transceivers[sdpMLineIndex].remoteCapabilities =
	            remoteCapabilities;
	        pc.transceivers[sdpMLineIndex].rtcpParameters = rtcpParameters;

	        if (cands.length && iceTransport.state === 'new') {
	          if ((isIceLite || isComplete) &&
	              (!usingBundle || sdpMLineIndex === 0)) {
	            iceTransport.setRemoteCandidates(cands);
	          } else {
	            cands.forEach(function(candidate) {
	              maybeAddCandidate(transceiver.iceTransport, candidate);
	            });
	          }
	        }

	        if (!usingBundle || sdpMLineIndex === 0) {
	          if (iceTransport.state === 'new') {
	            iceTransport.start(iceGatherer, remoteIceParameters,
	                'controlling');
	          }
	          if (dtlsTransport.state === 'new') {
	            dtlsTransport.start(remoteDtlsParameters);
	          }
	        }

	        // If the offer contained RTX but the answer did not,
	        // remove RTX from sendEncodingParameters.
	        var commonCapabilities = getCommonCapabilities(
	          transceiver.localCapabilities,
	          transceiver.remoteCapabilities);

	        var hasRtx = commonCapabilities.codecs.filter(function(c) {
	          return c.name.toLowerCase() === 'rtx';
	        }).length;
	        if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {
	          delete transceiver.sendEncodingParameters[0].rtx;
	        }

	        pc._transceive(transceiver,
	            direction === 'sendrecv' || direction === 'recvonly',
	            direction === 'sendrecv' || direction === 'sendonly');

	        // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams
	        if (rtpReceiver &&
	            (direction === 'sendrecv' || direction === 'sendonly')) {
	          track = rtpReceiver.track;
	          if (remoteMsid) {
	            if (!streams[remoteMsid.stream]) {
	              streams[remoteMsid.stream] = new window.MediaStream();
	            }
	            addTrackToStreamAndFireEvent(track, streams[remoteMsid.stream]);
	            receiverList.push([track, rtpReceiver, streams[remoteMsid.stream]]);
	          } else {
	            if (!streams.default) {
	              streams.default = new window.MediaStream();
	            }
	            addTrackToStreamAndFireEvent(track, streams.default);
	            receiverList.push([track, rtpReceiver, streams.default]);
	          }
	        } else {
	          // FIXME: actually the receiver should be created later.
	          delete transceiver.rtpReceiver;
	        }
	      }
	    });

	    if (pc._dtlsRole === undefined) {
	      pc._dtlsRole = description.type === 'offer' ? 'active' : 'passive';
	    }

	    pc._remoteDescription = {
	      type: description.type,
	      sdp: description.sdp
	    };
	    if (description.type === 'offer') {
	      pc._updateSignalingState('have-remote-offer');
	    } else {
	      pc._updateSignalingState('stable');
	    }
	    Object.keys(streams).forEach(function(sid) {
	      var stream = streams[sid];
	      if (stream.getTracks().length) {
	        if (pc.remoteStreams.indexOf(stream) === -1) {
	          pc.remoteStreams.push(stream);
	          var event = new Event('addstream');
	          event.stream = stream;
	          window.setTimeout(function() {
	            pc._dispatchEvent('addstream', event);
	          });
	        }

	        receiverList.forEach(function(item) {
	          var track = item[0];
	          var receiver = item[1];
	          if (stream.id !== item[2].id) {
	            return;
	          }
	          fireAddTrack(pc, track, receiver, [stream]);
	        });
	      }
	    });
	    receiverList.forEach(function(item) {
	      if (item[2]) {
	        return;
	      }
	      fireAddTrack(pc, item[0], item[1], []);
	    });

	    // check whether addIceCandidate({}) was called within four seconds after
	    // setRemoteDescription.
	    window.setTimeout(function() {
	      if (!(pc && pc.transceivers)) {
	        return;
	      }
	      pc.transceivers.forEach(function(transceiver) {
	        if (transceiver.iceTransport &&
	            transceiver.iceTransport.state === 'new' &&
	            transceiver.iceTransport.getRemoteCandidates().length > 0) {
	          console.warn('Timeout for addRemoteCandidate. Consider sending ' +
	              'an end-of-candidates notification');
	          transceiver.iceTransport.addRemoteCandidate({});
	        }
	      });
	    }, 4000);

	    return Promise.resolve();
	  };

	  RTCPeerConnection.prototype.close = function() {
	    this.transceivers.forEach(function(transceiver) {
	      /* not yet
	      if (transceiver.iceGatherer) {
	        transceiver.iceGatherer.close();
	      }
	      */
	      if (transceiver.iceTransport) {
	        transceiver.iceTransport.stop();
	      }
	      if (transceiver.dtlsTransport) {
	        transceiver.dtlsTransport.stop();
	      }
	      if (transceiver.rtpSender) {
	        transceiver.rtpSender.stop();
	      }
	      if (transceiver.rtpReceiver) {
	        transceiver.rtpReceiver.stop();
	      }
	    });
	    // FIXME: clean up tracks, local streams, remote streams, etc
	    this._isClosed = true;
	    this._updateSignalingState('closed');
	  };

	  // Update the signaling state.
	  RTCPeerConnection.prototype._updateSignalingState = function(newState) {
	    this.signalingState = newState;
	    var event = new Event('signalingstatechange');
	    this._dispatchEvent('signalingstatechange', event);
	  };

	  // Determine whether to fire the negotiationneeded event.
	  RTCPeerConnection.prototype._maybeFireNegotiationNeeded = function() {
	    var pc = this;
	    if (this.signalingState !== 'stable' || this.needNegotiation === true) {
	      return;
	    }
	    this.needNegotiation = true;
	    window.setTimeout(function() {
	      if (pc.needNegotiation) {
	        pc.needNegotiation = false;
	        var event = new Event('negotiationneeded');
	        pc._dispatchEvent('negotiationneeded', event);
	      }
	    }, 0);
	  };

	  // Update the ice connection state.
	  RTCPeerConnection.prototype._updateIceConnectionState = function() {
	    var newState;
	    var states = {
	      'new': 0,
	      closed: 0,
	      checking: 0,
	      connected: 0,
	      completed: 0,
	      disconnected: 0,
	      failed: 0
	    };
	    this.transceivers.forEach(function(transceiver) {
	      if (transceiver.iceTransport && !transceiver.rejected) {
	        states[transceiver.iceTransport.state]++;
	      }
	    });

	    newState = 'new';
	    if (states.failed > 0) {
	      newState = 'failed';
	    } else if (states.checking > 0) {
	      newState = 'checking';
	    } else if (states.disconnected > 0) {
	      newState = 'disconnected';
	    } else if (states.new > 0) {
	      newState = 'new';
	    } else if (states.connected > 0) {
	      newState = 'connected';
	    } else if (states.completed > 0) {
	      newState = 'completed';
	    }

	    if (newState !== this.iceConnectionState) {
	      this.iceConnectionState = newState;
	      var event = new Event('iceconnectionstatechange');
	      this._dispatchEvent('iceconnectionstatechange', event);
	    }
	  };

	  // Update the connection state.
	  RTCPeerConnection.prototype._updateConnectionState = function() {
	    var newState;
	    var states = {
	      'new': 0,
	      closed: 0,
	      connecting: 0,
	      connected: 0,
	      completed: 0,
	      disconnected: 0,
	      failed: 0
	    };
	    this.transceivers.forEach(function(transceiver) {
	      if (transceiver.iceTransport && transceiver.dtlsTransport &&
	          !transceiver.rejected) {
	        states[transceiver.iceTransport.state]++;
	        states[transceiver.dtlsTransport.state]++;
	      }
	    });
	    // ICETransport.completed and connected are the same for this purpose.
	    states.connected += states.completed;

	    newState = 'new';
	    if (states.failed > 0) {
	      newState = 'failed';
	    } else if (states.connecting > 0) {
	      newState = 'connecting';
	    } else if (states.disconnected > 0) {
	      newState = 'disconnected';
	    } else if (states.new > 0) {
	      newState = 'new';
	    } else if (states.connected > 0) {
	      newState = 'connected';
	    }

	    if (newState !== this.connectionState) {
	      this.connectionState = newState;
	      var event = new Event('connectionstatechange');
	      this._dispatchEvent('connectionstatechange', event);
	    }
	  };

	  RTCPeerConnection.prototype.createOffer = function() {
	    var pc = this;

	    if (pc._isClosed) {
	      return Promise.reject(makeError('InvalidStateError',
	          'Can not call createOffer after close'));
	    }

	    var numAudioTracks = pc.transceivers.filter(function(t) {
	      return t.kind === 'audio';
	    }).length;
	    var numVideoTracks = pc.transceivers.filter(function(t) {
	      return t.kind === 'video';
	    }).length;

	    // Determine number of audio and video tracks we need to send/recv.
	    var offerOptions = arguments[0];
	    if (offerOptions) {
	      // Reject Chrome legacy constraints.
	      if (offerOptions.mandatory || offerOptions.optional) {
	        throw new TypeError(
	            'Legacy mandatory/optional constraints not supported.');
	      }
	      if (offerOptions.offerToReceiveAudio !== undefined) {
	        if (offerOptions.offerToReceiveAudio === true) {
	          numAudioTracks = 1;
	        } else if (offerOptions.offerToReceiveAudio === false) {
	          numAudioTracks = 0;
	        } else {
	          numAudioTracks = offerOptions.offerToReceiveAudio;
	        }
	      }
	      if (offerOptions.offerToReceiveVideo !== undefined) {
	        if (offerOptions.offerToReceiveVideo === true) {
	          numVideoTracks = 1;
	        } else if (offerOptions.offerToReceiveVideo === false) {
	          numVideoTracks = 0;
	        } else {
	          numVideoTracks = offerOptions.offerToReceiveVideo;
	        }
	      }
	    }

	    pc.transceivers.forEach(function(transceiver) {
	      if (transceiver.kind === 'audio') {
	        numAudioTracks--;
	        if (numAudioTracks < 0) {
	          transceiver.wantReceive = false;
	        }
	      } else if (transceiver.kind === 'video') {
	        numVideoTracks--;
	        if (numVideoTracks < 0) {
	          transceiver.wantReceive = false;
	        }
	      }
	    });

	    // Create M-lines for recvonly streams.
	    while (numAudioTracks > 0 || numVideoTracks > 0) {
	      if (numAudioTracks > 0) {
	        pc._createTransceiver('audio');
	        numAudioTracks--;
	      }
	      if (numVideoTracks > 0) {
	        pc._createTransceiver('video');
	        numVideoTracks--;
	      }
	    }

	    var sdp$1 = sdp.writeSessionBoilerplate(pc._sdpSessionId,
	        pc._sdpSessionVersion++);
	    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
	      // For each track, create an ice gatherer, ice transport,
	      // dtls transport, potentially rtpsender and rtpreceiver.
	      var track = transceiver.track;
	      var kind = transceiver.kind;
	      var mid = transceiver.mid || sdp.generateIdentifier();
	      transceiver.mid = mid;

	      if (!transceiver.iceGatherer) {
	        transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,
	            pc.usingBundle);
	      }

	      var localCapabilities = window.RTCRtpSender.getCapabilities(kind);
	      // filter RTX until additional stuff needed for RTX is implemented
	      // in adapter.js
	      if (edgeVersion < 15019) {
	        localCapabilities.codecs = localCapabilities.codecs.filter(
	            function(codec) {
	              return codec.name !== 'rtx';
	            });
	      }
	      localCapabilities.codecs.forEach(function(codec) {
	        // work around https://bugs.chromium.org/p/webrtc/issues/detail?id=6552
	        // by adding level-asymmetry-allowed=1
	        if (codec.name === 'H264' &&
	            codec.parameters['level-asymmetry-allowed'] === undefined) {
	          codec.parameters['level-asymmetry-allowed'] = '1';
	        }

	        // for subsequent offers, we might have to re-use the payload
	        // type of the last offer.
	        if (transceiver.remoteCapabilities &&
	            transceiver.remoteCapabilities.codecs) {
	          transceiver.remoteCapabilities.codecs.forEach(function(remoteCodec) {
	            if (codec.name.toLowerCase() === remoteCodec.name.toLowerCase() &&
	                codec.clockRate === remoteCodec.clockRate) {
	              codec.preferredPayloadType = remoteCodec.payloadType;
	            }
	          });
	        }
	      });
	      localCapabilities.headerExtensions.forEach(function(hdrExt) {
	        var remoteExtensions = transceiver.remoteCapabilities &&
	            transceiver.remoteCapabilities.headerExtensions || [];
	        remoteExtensions.forEach(function(rHdrExt) {
	          if (hdrExt.uri === rHdrExt.uri) {
	            hdrExt.id = rHdrExt.id;
	          }
	        });
	      });

	      // generate an ssrc now, to be used later in rtpSender.send
	      var sendEncodingParameters = transceiver.sendEncodingParameters || [{
	        ssrc: (2 * sdpMLineIndex + 1) * 1001
	      }];
	      if (track) {
	        // add RTX
	        if (edgeVersion >= 15019 && kind === 'video' &&
	            !sendEncodingParameters[0].rtx) {
	          sendEncodingParameters[0].rtx = {
	            ssrc: sendEncodingParameters[0].ssrc + 1
	          };
	        }
	      }

	      if (transceiver.wantReceive) {
	        transceiver.rtpReceiver = new window.RTCRtpReceiver(
	            transceiver.dtlsTransport, kind);
	      }

	      transceiver.localCapabilities = localCapabilities;
	      transceiver.sendEncodingParameters = sendEncodingParameters;
	    });

	    // always offer BUNDLE and dispose on return if not supported.
	    if (pc._config.bundlePolicy !== 'max-compat') {
	      sdp$1 += 'a=group:BUNDLE ' + pc.transceivers.map(function(t) {
	        return t.mid;
	      }).join(' ') + '\r\n';
	    }
	    sdp$1 += 'a=ice-options:trickle\r\n';

	    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
	      sdp$1 += writeMediaSection(transceiver, transceiver.localCapabilities,
	          'offer', transceiver.stream, pc._dtlsRole);
	      sdp$1 += 'a=rtcp-rsize\r\n';

	      if (transceiver.iceGatherer && pc.iceGatheringState !== 'new' &&
	          (sdpMLineIndex === 0 || !pc.usingBundle)) {
	        transceiver.iceGatherer.getLocalCandidates().forEach(function(cand) {
	          cand.component = 1;
	          sdp$1 += 'a=' + sdp.writeCandidate(cand) + '\r\n';
	        });

	        if (transceiver.iceGatherer.state === 'completed') {
	          sdp$1 += 'a=end-of-candidates\r\n';
	        }
	      }
	    });

	    var desc = new window.RTCSessionDescription({
	      type: 'offer',
	      sdp: sdp$1
	    });
	    return Promise.resolve(desc);
	  };

	  RTCPeerConnection.prototype.createAnswer = function() {
	    var pc = this;

	    if (pc._isClosed) {
	      return Promise.reject(makeError('InvalidStateError',
	          'Can not call createAnswer after close'));
	    }

	    if (!(pc.signalingState === 'have-remote-offer' ||
	        pc.signalingState === 'have-local-pranswer')) {
	      return Promise.reject(makeError('InvalidStateError',
	          'Can not call createAnswer in signalingState ' + pc.signalingState));
	    }

	    var sdp$1 = sdp.writeSessionBoilerplate(pc._sdpSessionId,
	        pc._sdpSessionVersion++);
	    if (pc.usingBundle) {
	      sdp$1 += 'a=group:BUNDLE ' + pc.transceivers.map(function(t) {
	        return t.mid;
	      }).join(' ') + '\r\n';
	    }
	    sdp$1 += 'a=ice-options:trickle\r\n';

	    var mediaSectionsInOffer = sdp.getMediaSections(
	        pc._remoteDescription.sdp).length;
	    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
	      if (sdpMLineIndex + 1 > mediaSectionsInOffer) {
	        return;
	      }
	      if (transceiver.rejected) {
	        if (transceiver.kind === 'application') {
	          if (transceiver.protocol === 'DTLS/SCTP') { // legacy fmt
	            sdp$1 += 'm=application 0 DTLS/SCTP 5000\r\n';
	          } else {
	            sdp$1 += 'm=application 0 ' + transceiver.protocol +
	                ' webrtc-datachannel\r\n';
	          }
	        } else if (transceiver.kind === 'audio') {
	          sdp$1 += 'm=audio 0 UDP/TLS/RTP/SAVPF 0\r\n' +
	              'a=rtpmap:0 PCMU/8000\r\n';
	        } else if (transceiver.kind === 'video') {
	          sdp$1 += 'm=video 0 UDP/TLS/RTP/SAVPF 120\r\n' +
	              'a=rtpmap:120 VP8/90000\r\n';
	        }
	        sdp$1 += 'c=IN IP4 0.0.0.0\r\n' +
	            'a=inactive\r\n' +
	            'a=mid:' + transceiver.mid + '\r\n';
	        return;
	      }

	      // FIXME: look at direction.
	      if (transceiver.stream) {
	        var localTrack;
	        if (transceiver.kind === 'audio') {
	          localTrack = transceiver.stream.getAudioTracks()[0];
	        } else if (transceiver.kind === 'video') {
	          localTrack = transceiver.stream.getVideoTracks()[0];
	        }
	        if (localTrack) {
	          // add RTX
	          if (edgeVersion >= 15019 && transceiver.kind === 'video' &&
	              !transceiver.sendEncodingParameters[0].rtx) {
	            transceiver.sendEncodingParameters[0].rtx = {
	              ssrc: transceiver.sendEncodingParameters[0].ssrc + 1
	            };
	          }
	        }
	      }

	      // Calculate intersection of capabilities.
	      var commonCapabilities = getCommonCapabilities(
	          transceiver.localCapabilities,
	          transceiver.remoteCapabilities);

	      var hasRtx = commonCapabilities.codecs.filter(function(c) {
	        return c.name.toLowerCase() === 'rtx';
	      }).length;
	      if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {
	        delete transceiver.sendEncodingParameters[0].rtx;
	      }

	      sdp$1 += writeMediaSection(transceiver, commonCapabilities,
	          'answer', transceiver.stream, pc._dtlsRole);
	      if (transceiver.rtcpParameters &&
	          transceiver.rtcpParameters.reducedSize) {
	        sdp$1 += 'a=rtcp-rsize\r\n';
	      }
	    });

	    var desc = new window.RTCSessionDescription({
	      type: 'answer',
	      sdp: sdp$1
	    });
	    return Promise.resolve(desc);
	  };

	  RTCPeerConnection.prototype.addIceCandidate = function(candidate) {
	    var pc = this;
	    var sections;
	    if (candidate && !(candidate.sdpMLineIndex !== undefined ||
	        candidate.sdpMid)) {
	      return Promise.reject(new TypeError('sdpMLineIndex or sdpMid required'));
	    }

	    // TODO: needs to go into ops queue.
	    return new Promise(function(resolve, reject) {
	      if (!pc._remoteDescription) {
	        return reject(makeError('InvalidStateError',
	            'Can not add ICE candidate without a remote description'));
	      } else if (!candidate || candidate.candidate === '') {
	        for (var j = 0; j < pc.transceivers.length; j++) {
	          if (pc.transceivers[j].rejected) {
	            continue;
	          }
	          pc.transceivers[j].iceTransport.addRemoteCandidate({});
	          sections = sdp.getMediaSections(pc._remoteDescription.sdp);
	          sections[j] += 'a=end-of-candidates\r\n';
	          pc._remoteDescription.sdp =
	              sdp.getDescription(pc._remoteDescription.sdp) +
	              sections.join('');
	          if (pc.usingBundle) {
	            break;
	          }
	        }
	      } else {
	        var sdpMLineIndex = candidate.sdpMLineIndex;
	        if (candidate.sdpMid) {
	          for (var i = 0; i < pc.transceivers.length; i++) {
	            if (pc.transceivers[i].mid === candidate.sdpMid) {
	              sdpMLineIndex = i;
	              break;
	            }
	          }
	        }
	        var transceiver = pc.transceivers[sdpMLineIndex];
	        if (transceiver) {
	          if (transceiver.rejected) {
	            return resolve();
	          }
	          var cand = Object.keys(candidate.candidate).length > 0 ?
	              sdp.parseCandidate(candidate.candidate) : {};
	          // Ignore Chrome's invalid candidates since Edge does not like them.
	          if (cand.protocol === 'tcp' && (cand.port === 0 || cand.port === 9)) {
	            return resolve();
	          }
	          // Ignore RTCP candidates, we assume RTCP-MUX.
	          if (cand.component && cand.component !== 1) {
	            return resolve();
	          }
	          // when using bundle, avoid adding candidates to the wrong
	          // ice transport. And avoid adding candidates added in the SDP.
	          if (sdpMLineIndex === 0 || (sdpMLineIndex > 0 &&
	              transceiver.iceTransport !== pc.transceivers[0].iceTransport)) {
	            if (!maybeAddCandidate(transceiver.iceTransport, cand)) {
	              return reject(makeError('OperationError',
	                  'Can not add ICE candidate'));
	            }
	          }

	          // update the remoteDescription.
	          var candidateString = candidate.candidate.trim();
	          if (candidateString.indexOf('a=') === 0) {
	            candidateString = candidateString.substr(2);
	          }
	          sections = sdp.getMediaSections(pc._remoteDescription.sdp);
	          sections[sdpMLineIndex] += 'a=' +
	              (cand.type ? candidateString : 'end-of-candidates')
	              + '\r\n';
	          pc._remoteDescription.sdp =
	              sdp.getDescription(pc._remoteDescription.sdp) +
	              sections.join('');
	        } else {
	          return reject(makeError('OperationError',
	              'Can not add ICE candidate'));
	        }
	      }
	      resolve();
	    });
	  };

	  RTCPeerConnection.prototype.getStats = function(selector) {
	    if (selector && selector instanceof window.MediaStreamTrack) {
	      var senderOrReceiver = null;
	      this.transceivers.forEach(function(transceiver) {
	        if (transceiver.rtpSender &&
	            transceiver.rtpSender.track === selector) {
	          senderOrReceiver = transceiver.rtpSender;
	        } else if (transceiver.rtpReceiver &&
	            transceiver.rtpReceiver.track === selector) {
	          senderOrReceiver = transceiver.rtpReceiver;
	        }
	      });
	      if (!senderOrReceiver) {
	        throw makeError('InvalidAccessError', 'Invalid selector.');
	      }
	      return senderOrReceiver.getStats();
	    }

	    var promises = [];
	    this.transceivers.forEach(function(transceiver) {
	      ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport',
	          'dtlsTransport'].forEach(function(method) {
	            if (transceiver[method]) {
	              promises.push(transceiver[method].getStats());
	            }
	          });
	    });
	    return Promise.all(promises).then(function(allStats) {
	      var results = new Map();
	      allStats.forEach(function(stats) {
	        stats.forEach(function(stat) {
	          results.set(stat.id, stat);
	        });
	      });
	      return results;
	    });
	  };

	  // fix low-level stat names and return Map instead of object.
	  var ortcObjects = ['RTCRtpSender', 'RTCRtpReceiver', 'RTCIceGatherer',
	    'RTCIceTransport', 'RTCDtlsTransport'];
	  ortcObjects.forEach(function(ortcObjectName) {
	    var obj = window[ortcObjectName];
	    if (obj && obj.prototype && obj.prototype.getStats) {
	      var nativeGetstats = obj.prototype.getStats;
	      obj.prototype.getStats = function() {
	        return nativeGetstats.apply(this)
	        .then(function(nativeStats) {
	          var mapStats = new Map();
	          Object.keys(nativeStats).forEach(function(id) {
	            nativeStats[id].type = fixStatsType(nativeStats[id]);
	            mapStats.set(id, nativeStats[id]);
	          });
	          return mapStats;
	        });
	      };
	    }
	  });

	  // legacy callback shims. Should be moved to adapter.js some days.
	  var methods = ['createOffer', 'createAnswer'];
	  methods.forEach(function(method) {
	    var nativeMethod = RTCPeerConnection.prototype[method];
	    RTCPeerConnection.prototype[method] = function() {
	      var args = arguments;
	      if (typeof args[0] === 'function' ||
	          typeof args[1] === 'function') { // legacy
	        return nativeMethod.apply(this, [arguments[2]])
	        .then(function(description) {
	          if (typeof args[0] === 'function') {
	            args[0].apply(null, [description]);
	          }
	        }, function(error) {
	          if (typeof args[1] === 'function') {
	            args[1].apply(null, [error]);
	          }
	        });
	      }
	      return nativeMethod.apply(this, arguments);
	    };
	  });

	  methods = ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'];
	  methods.forEach(function(method) {
	    var nativeMethod = RTCPeerConnection.prototype[method];
	    RTCPeerConnection.prototype[method] = function() {
	      var args = arguments;
	      if (typeof args[1] === 'function' ||
	          typeof args[2] === 'function') { // legacy
	        return nativeMethod.apply(this, arguments)
	        .then(function() {
	          if (typeof args[1] === 'function') {
	            args[1].apply(null);
	          }
	        }, function(error) {
	          if (typeof args[2] === 'function') {
	            args[2].apply(null, [error]);
	          }
	        });
	      }
	      return nativeMethod.apply(this, arguments);
	    };
	  });

	  // getStats is special. It doesn't have a spec legacy method yet we support
	  // getStats(something, cb) without error callbacks.
	  ['getStats'].forEach(function(method) {
	    var nativeMethod = RTCPeerConnection.prototype[method];
	    RTCPeerConnection.prototype[method] = function() {
	      var args = arguments;
	      if (typeof args[1] === 'function') {
	        return nativeMethod.apply(this, arguments)
	        .then(function() {
	          if (typeof args[1] === 'function') {
	            args[1].apply(null);
	          }
	        });
	      }
	      return nativeMethod.apply(this, arguments);
	    };
	  });

	  return RTCPeerConnection;
	};

	/*
	 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
	 *
	 *  Use of this source code is governed by a BSD-style license
	 *  that can be found in the LICENSE file in the root of the source
	 *  tree.
	 */
	function shimGetUserMedia$1(window) {
	  var _context;

	  const navigator = window && window.navigator;

	  const shimError_ = function (e) {
	    return {
	      name: {
	        PermissionDeniedError: 'NotAllowedError'
	      }[e.name] || e.name,
	      message: e.message,
	      constraint: e.constraint,

	      toString() {
	        return this.name;
	      }

	    };
	  }; // getUserMedia error shim.


	  const origGetUserMedia = bind$3(_context = navigator.mediaDevices.getUserMedia).call(_context, navigator.mediaDevices);

	  navigator.mediaDevices.getUserMedia = function (c) {
	    return origGetUserMedia(c).catch(e => promise$3.reject(shimError_(e)));
	  };
	}

	/*
	 *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
	 *
	 *  Use of this source code is governed by a BSD-style license
	 *  that can be found in the LICENSE file in the root of the source
	 *  tree.
	 */
	function shimGetDisplayMedia$1(window) {
	  var _context;

	  if (!('getDisplayMedia' in window.navigator)) {
	    return;
	  }

	  if (!window.navigator.mediaDevices) {
	    return;
	  }

	  if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {
	    return;
	  }

	  window.navigator.mediaDevices.getDisplayMedia = bind$3(_context = window.navigator.getDisplayMedia).call(_context, window.navigator);
	}

	/*
	 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
	 *
	 *  Use of this source code is governed by a BSD-style license
	 *  that can be found in the LICENSE file in the root of the source
	 *  tree.
	 */
	function shimPeerConnection$1(window) {
	  const browserDetails = detectBrowser(window);

	  if (window.RTCIceGatherer) {
	    if (!window.RTCIceCandidate) {
	      window.RTCIceCandidate = function RTCIceCandidate(args) {
	        return args;
	      };
	    }

	    if (!window.RTCSessionDescription) {
	      window.RTCSessionDescription = function RTCSessionDescription(args) {
	        return args;
	      };
	    } // this adds an additional event listener to MediaStrackTrack that signals
	    // when a tracks enabled property was changed. Workaround for a bug in
	    // addStream, see below. No longer required in 15025+


	    if (browserDetails.version < 15025) {
	      const origMSTEnabled = getOwnPropertyDescriptor$3(window.MediaStreamTrack.prototype, 'enabled');

	      defineProperty$4(window.MediaStreamTrack.prototype, 'enabled', {
	        set(value) {
	          origMSTEnabled.set.call(this, value);
	          const ev = new Event('enabled');
	          ev.enabled = value;
	          this.dispatchEvent(ev);
	        }

	      });
	    }
	  } // ORTC defines the DTMF sender a bit different.
	  // https://github.com/w3c/ortc/issues/714


	  if (window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {
	    defineProperty$4(window.RTCRtpSender.prototype, 'dtmf', {
	      get() {
	        if (this._dtmf === undefined) {
	          if (this.track.kind === 'audio') {
	            this._dtmf = new window.RTCDtmfSender(this);
	          } else if (this.track.kind === 'video') {
	            this._dtmf = null;
	          }
	        }

	        return this._dtmf;
	      }

	    });
	  } // Edge currently only implements the RTCDtmfSender, not the
	  // RTCDTMFSender alias. See http://draft.ortc.org/#rtcdtmfsender2*


	  if (window.RTCDtmfSender && !window.RTCDTMFSender) {
	    window.RTCDTMFSender = window.RTCDtmfSender;
	  }

	  const RTCPeerConnectionShim = rtcpeerconnection(window, browserDetails.version);

	  window.RTCPeerConnection = function RTCPeerConnection(config) {
	    if (config && config.iceServers) {
	      config.iceServers = filterIceServers(config.iceServers, browserDetails.version);
	      log('ICE servers after filtering:', config.iceServers);
	    }

	    return new RTCPeerConnectionShim(config);
	  };

	  window.RTCPeerConnection.prototype = RTCPeerConnectionShim.prototype;
	}
	function shimReplaceTrack(window) {
	  // ORTC has replaceTrack -- https://github.com/w3c/ortc/issues/614
	  if (window.RTCRtpSender && !('replaceTrack' in window.RTCRtpSender.prototype)) {
	    window.RTCRtpSender.prototype.replaceTrack = window.RTCRtpSender.prototype.setTrack;
	  }
	}

	var edgeShim = /*#__PURE__*/Object.freeze({
		__proto__: null,
		shimPeerConnection: shimPeerConnection$1,
		shimReplaceTrack: shimReplaceTrack,
		shimGetUserMedia: shimGetUserMedia$1,
		shimGetDisplayMedia: shimGetDisplayMedia$1
	});

	/*
	 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
	 *
	 *  Use of this source code is governed by a BSD-style license
	 *  that can be found in the LICENSE file in the root of the source
	 *  tree.
	 */
	function shimGetUserMedia$2(window) {
	  const browserDetails = detectBrowser(window);
	  const navigator = window && window.navigator;
	  const MediaStreamTrack = window && window.MediaStreamTrack;

	  navigator.getUserMedia = function (constraints, onSuccess, onError) {
	    // Replace Firefox 44+'s deprecation warning with unprefixed version.
	    deprecated('navigator.getUserMedia', 'navigator.mediaDevices.getUserMedia');
	    navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
	  };

	  if (!(browserDetails.version > 55 && 'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {
	    var _context;

	    const remap = function (obj, a, b) {
	      if (a in obj && !(b in obj)) {
	        obj[b] = obj[a];
	        delete obj[a];
	      }
	    };

	    const nativeGetUserMedia = bind$3(_context = navigator.mediaDevices.getUserMedia).call(_context, navigator.mediaDevices);

	    navigator.mediaDevices.getUserMedia = function (c) {
	      if (typeof c === 'object' && typeof c.audio === 'object') {
	        c = JSON.parse(stringify$2(c));
	        remap(c.audio, 'autoGainControl', 'mozAutoGainControl');
	        remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');
	      }

	      return nativeGetUserMedia(c);
	    };

	    if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {
	      const nativeGetSettings = MediaStreamTrack.prototype.getSettings;

	      MediaStreamTrack.prototype.getSettings = function () {
	        const obj = nativeGetSettings.apply(this, arguments);
	        remap(obj, 'mozAutoGainControl', 'autoGainControl');
	        remap(obj, 'mozNoiseSuppression', 'noiseSuppression');
	        return obj;
	      };
	    }

	    if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {
	      const nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;

	      MediaStreamTrack.prototype.applyConstraints = function (c) {
	        if (this.kind === 'audio' && typeof c === 'object') {
	          c = JSON.parse(stringify$2(c));
	          remap(c, 'autoGainControl', 'mozAutoGainControl');
	          remap(c, 'noiseSuppression', 'mozNoiseSuppression');
	        }

	        return nativeApplyConstraints.apply(this, [c]);
	      };
	    }
	  }
	}

	/*
	 *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
	 *
	 *  Use of this source code is governed by a BSD-style license
	 *  that can be found in the LICENSE file in the root of the source
	 *  tree.
	 */
	function shimGetDisplayMedia$2(window, preferredMediaSource) {
	  if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {
	    return;
	  }

	  if (!window.navigator.mediaDevices) {
	    return;
	  }

	  window.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {
	    if (!(constraints && constraints.video)) {
	      const err = new DOMException('getDisplayMedia without video ' + 'constraints is undefined');
	      err.name = 'NotFoundError'; // from https://heycam.github.io/webidl/#idl-DOMException-error-names

	      err.code = 8;
	      return promise$3.reject(err);
	    }

	    if (constraints.video === true) {
	      constraints.video = {
	        mediaSource: preferredMediaSource
	      };
	    } else {
	      constraints.video.mediaSource = preferredMediaSource;
	    }

	    return window.navigator.mediaDevices.getUserMedia(constraints);
	  };
	}

	/*
	 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
	 *
	 *  Use of this source code is governed by a BSD-style license
	 *  that can be found in the LICENSE file in the root of the source
	 *  tree.
	 */
	function shimOnTrack$1(window) {
	  if (typeof window === 'object' && window.RTCTrackEvent && 'receiver' in window.RTCTrackEvent.prototype && !('transceiver' in window.RTCTrackEvent.prototype)) {
	    defineProperty$4(window.RTCTrackEvent.prototype, 'transceiver', {
	      get() {
	        return {
	          receiver: this.receiver
	        };
	      }

	    });
	  }
	}
	function shimPeerConnection$2(window) {
	  const browserDetails = detectBrowser(window);

	  if (typeof window !== 'object' || !(window.RTCPeerConnection || window.mozRTCPeerConnection)) {
	    return; // probably media.peerconnection.enabled=false in about:config
	  }

	  if (!window.RTCPeerConnection && window.mozRTCPeerConnection) {
	    // very basic support for old versions.
	    window.RTCPeerConnection = window.mozRTCPeerConnection;
	  }

	  if (browserDetails.version < 53) {
	    var _context;

	    // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.
	    forEach$3(_context = ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']).call(_context, function (method) {
	      const nativeMethod = window.RTCPeerConnection.prototype[method];
	      const methodObj = {
	        [method]() {
	          arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);
	          return nativeMethod.apply(this, arguments);
	        }

	      };
	      window.RTCPeerConnection.prototype[method] = methodObj[method];
	    });
	  } // support for addIceCandidate(null or undefined)


	  const nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;

	  window.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {
	    if (!arguments[0]) {
	      if (arguments[1]) {
	        arguments[1].apply(null);
	      }

	      return promise$3.resolve();
	    } // Firefox 68+ emits and processes {candidate: "", ...}, ignore
	    // in older versions.


	    if (browserDetails.version < 68 && arguments[0] && arguments[0].candidate === '') {
	      return promise$3.resolve();
	    }

	    return nativeAddIceCandidate.apply(this, arguments);
	  };

	  const modernStatsTypes = {
	    inboundrtp: 'inbound-rtp',
	    outboundrtp: 'outbound-rtp',
	    candidatepair: 'candidate-pair',
	    localcandidate: 'local-candidate',
	    remotecandidate: 'remote-candidate'
	  };
	  const nativeGetStats = window.RTCPeerConnection.prototype.getStats;

	  window.RTCPeerConnection.prototype.getStats = function getStats() {
	    const [selector, onSucc, onErr] = arguments;
	    return nativeGetStats.apply(this, [selector || null]).then(stats => {
	      if (browserDetails.version < 53 && !onSucc) {
	        // Shim only promise getStats with spec-hyphens in type names
	        // Leave callback version alone; misc old uses of forEach before Map
	        try {
	          forEach$3(stats).call(stats, stat => {
	            stat.type = modernStatsTypes[stat.type] || stat.type;
	          });
	        } catch (e) {
	          if (e.name !== 'TypeError') {
	            throw e;
	          } // Avoid TypeError: "type" is read-only, in old versions. 34-43ish


	          forEach$3(stats).call(stats, (stat, i) => {
	            stats.set(i, assign$2({}, stat, {
	              type: modernStatsTypes[stat.type] || stat.type
	            }));
	          });
	        }
	      }

	      return stats;
	    }).then(onSucc, onErr);
	  };
	}
	function shimSenderGetStats(window) {
	  if (!(typeof window === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {
	    return;
	  }

	  if (window.RTCRtpSender && 'getStats' in window.RTCRtpSender.prototype) {
	    return;
	  }

	  const origGetSenders = window.RTCPeerConnection.prototype.getSenders;

	  if (origGetSenders) {
	    window.RTCPeerConnection.prototype.getSenders = function getSenders() {
	      const senders = origGetSenders.apply(this, []);

	      forEach$3(senders).call(senders, sender => sender._pc = this);

	      return senders;
	    };
	  }

	  const origAddTrack = window.RTCPeerConnection.prototype.addTrack;

	  if (origAddTrack) {
	    window.RTCPeerConnection.prototype.addTrack = function addTrack() {
	      const sender = origAddTrack.apply(this, arguments);
	      sender._pc = this;
	      return sender;
	    };
	  }

	  window.RTCRtpSender.prototype.getStats = function getStats() {
	    return this.track ? this._pc.getStats(this.track) : promise$3.resolve(new map$2());
	  };
	}
	function shimReceiverGetStats(window) {
	  if (!(typeof window === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {
	    return;
	  }

	  if (window.RTCRtpSender && 'getStats' in window.RTCRtpReceiver.prototype) {
	    return;
	  }

	  const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;

	  if (origGetReceivers) {
	    window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
	      const receivers = origGetReceivers.apply(this, []);

	      forEach$3(receivers).call(receivers, receiver => receiver._pc = this);

	      return receivers;
	    };
	  }

	  wrapPeerConnectionEvent(window, 'track', e => {
	    e.receiver._pc = e.srcElement;
	    return e;
	  });

	  window.RTCRtpReceiver.prototype.getStats = function getStats() {
	    return this._pc.getStats(this.track);
	  };
	}
	function shimRemoveStream(window) {
	  if (!window.RTCPeerConnection || 'removeStream' in window.RTCPeerConnection.prototype) {
	    return;
	  }

	  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
	    var _context2;

	    deprecated('removeStream', 'removeTrack');

	    forEach$3(_context2 = this.getSenders()).call(_context2, sender => {
	      var _context3;

	      if (sender.track && includes$4(_context3 = stream.getTracks()).call(_context3, sender.track)) {
	        this.removeTrack(sender);
	      }
	    });
	  };
	}
	function shimRTCDataChannel(window) {
	  // rename DataChannel to RTCDataChannel (native fix in FF60):
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851
	  if (window.DataChannel && !window.RTCDataChannel) {
	    window.RTCDataChannel = window.DataChannel;
	  }
	}

	var firefoxShim = /*#__PURE__*/Object.freeze({
		__proto__: null,
		shimOnTrack: shimOnTrack$1,
		shimPeerConnection: shimPeerConnection$2,
		shimSenderGetStats: shimSenderGetStats,
		shimReceiverGetStats: shimReceiverGetStats,
		shimRemoveStream: shimRemoveStream,
		shimRTCDataChannel: shimRTCDataChannel,
		shimGetUserMedia: shimGetUserMedia$2,
		shimGetDisplayMedia: shimGetDisplayMedia$2
	});

	/*
	 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
	 *
	 *  Use of this source code is governed by a BSD-style license
	 *  that can be found in the LICENSE file in the root of the source
	 *  tree.
	 */
	function shimLocalStreamsAPI(window) {
	  if (typeof window !== 'object' || !window.RTCPeerConnection) {
	    return;
	  }

	  if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {
	    window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
	      if (!this._localStreams) {
	        this._localStreams = [];
	      }

	      return this._localStreams;
	    };
	  }

	  if (!('addStream' in window.RTCPeerConnection.prototype)) {
	    const _addTrack = window.RTCPeerConnection.prototype.addTrack;

	    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
	      var _context, _context2, _context3;

	      if (!this._localStreams) {
	        this._localStreams = [];
	      }

	      if (!includes$4(_context = this._localStreams).call(_context, stream)) {
	        this._localStreams.push(stream);
	      } // Try to emulate Chrome's behaviour of adding in audio-video order.
	      // Safari orders by track id.


	      forEach$3(_context2 = stream.getAudioTracks()).call(_context2, track => _addTrack.call(this, track, stream));

	      forEach$3(_context3 = stream.getVideoTracks()).call(_context3, track => _addTrack.call(this, track, stream));
	    };

	    window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
	      if (stream) {
	        var _context4;

	        if (!this._localStreams) {
	          this._localStreams = [stream];
	        } else if (!includes$4(_context4 = this._localStreams).call(_context4, stream)) {
	          this._localStreams.push(stream);
	        }
	      }

	      return _addTrack.call(this, track, stream);
	    };
	  }

	  if (!('removeStream' in window.RTCPeerConnection.prototype)) {
	    window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
	      var _context5, _context6, _context7;

	      if (!this._localStreams) {
	        this._localStreams = [];
	      }

	      const index = indexOf$3(_context5 = this._localStreams).call(_context5, stream);

	      if (index === -1) {
	        return;
	      }

	      splice$2(_context6 = this._localStreams).call(_context6, index, 1);

	      const tracks = stream.getTracks();

	      forEach$3(_context7 = this.getSenders()).call(_context7, sender => {
	        if (includes$4(tracks).call(tracks, sender.track)) {
	          this.removeTrack(sender);
	        }
	      });
	    };
	  }
	}
	function shimRemoteStreamsAPI(window) {
	  if (typeof window !== 'object' || !window.RTCPeerConnection) {
	    return;
	  }

	  if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {
	    window.RTCPeerConnection.prototype.getRemoteStreams = function getRemoteStreams() {
	      return this._remoteStreams ? this._remoteStreams : [];
	    };
	  }

	  if (!('onaddstream' in window.RTCPeerConnection.prototype)) {
	    defineProperty$4(window.RTCPeerConnection.prototype, 'onaddstream', {
	      get() {
	        return this._onaddstream;
	      },

	      set(f) {
	        if (this._onaddstream) {
	          this.removeEventListener('addstream', this._onaddstream);
	          this.removeEventListener('track', this._onaddstreampoly);
	        }

	        this.addEventListener('addstream', this._onaddstream = f);
	        this.addEventListener('track', this._onaddstreampoly = e => {
	          var _context8;

	          forEach$3(_context8 = e.streams).call(_context8, stream => {
	            var _context9;

	            if (!this._remoteStreams) {
	              this._remoteStreams = [];
	            }

	            if (includes$4(_context9 = this._remoteStreams).call(_context9, stream)) {
	              return;
	            }

	            this._remoteStreams.push(stream);

	            const event = new Event('addstream');
	            event.stream = stream;
	            this.dispatchEvent(event);
	          });
	        });
	      }

	    });

	    const origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;

	    window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
	      const pc = this;

	      if (!this._onaddstreampoly) {
	        this.addEventListener('track', this._onaddstreampoly = function (e) {
	          var _context10;

	          forEach$3(_context10 = e.streams).call(_context10, stream => {
	            var _context11;

	            if (!pc._remoteStreams) {
	              pc._remoteStreams = [];
	            }

	            if (indexOf$3(_context11 = pc._remoteStreams).call(_context11, stream) >= 0) {
	              return;
	            }

	            pc._remoteStreams.push(stream);

	            const event = new Event('addstream');
	            event.stream = stream;
	            pc.dispatchEvent(event);
	          });
	        });
	      }

	      return origSetRemoteDescription.apply(pc, arguments);
	    };
	  }
	}
	function shimCallbacksAPI(window) {
	  if (typeof window !== 'object' || !window.RTCPeerConnection) {
	    return;
	  }

	  const prototype = window.RTCPeerConnection.prototype;
	  const origCreateOffer = prototype.createOffer;
	  const origCreateAnswer = prototype.createAnswer;
	  const setLocalDescription = prototype.setLocalDescription;
	  const setRemoteDescription = prototype.setRemoteDescription;
	  const addIceCandidate = prototype.addIceCandidate;

	  prototype.createOffer = function createOffer(successCallback, failureCallback) {
	    const options = arguments.length >= 2 ? arguments[2] : arguments[0];
	    const promise = origCreateOffer.apply(this, [options]);

	    if (!failureCallback) {
	      return promise;
	    }

	    promise.then(successCallback, failureCallback);
	    return promise$3.resolve();
	  };

	  prototype.createAnswer = function createAnswer(successCallback, failureCallback) {
	    const options = arguments.length >= 2 ? arguments[2] : arguments[0];
	    const promise = origCreateAnswer.apply(this, [options]);

	    if (!failureCallback) {
	      return promise;
	    }

	    promise.then(successCallback, failureCallback);
	    return promise$3.resolve();
	  };

	  let withCallback = function (description, successCallback, failureCallback) {
	    const promise = setLocalDescription.apply(this, [description]);

	    if (!failureCallback) {
	      return promise;
	    }

	    promise.then(successCallback, failureCallback);
	    return promise$3.resolve();
	  };

	  prototype.setLocalDescription = withCallback;

	  withCallback = function (description, successCallback, failureCallback) {
	    const promise = setRemoteDescription.apply(this, [description]);

	    if (!failureCallback) {
	      return promise;
	    }

	    promise.then(successCallback, failureCallback);
	    return promise$3.resolve();
	  };

	  prototype.setRemoteDescription = withCallback;

	  withCallback = function (candidate, successCallback, failureCallback) {
	    const promise = addIceCandidate.apply(this, [candidate]);

	    if (!failureCallback) {
	      return promise;
	    }

	    promise.then(successCallback, failureCallback);
	    return promise$3.resolve();
	  };

	  prototype.addIceCandidate = withCallback;
	}
	function shimGetUserMedia$3(window) {
	  const navigator = window && window.navigator;

	  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
	    var _context12;

	    // shim not needed in Safari 12.1
	    const mediaDevices = navigator.mediaDevices;

	    const _getUserMedia = bind$3(_context12 = mediaDevices.getUserMedia).call(_context12, mediaDevices);

	    navigator.mediaDevices.getUserMedia = constraints => {
	      return _getUserMedia(shimConstraints(constraints));
	    };
	  }

	  if (!navigator.getUserMedia && navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
	    var _context13;

	    navigator.getUserMedia = bind$3(_context13 = function getUserMedia(constraints, cb, errcb) {
	      navigator.mediaDevices.getUserMedia(constraints).then(cb, errcb);
	    }).call(_context13, navigator);
	  }
	}
	function shimConstraints(constraints) {
	  if (constraints && constraints.video !== undefined) {
	    return assign$2({}, constraints, {
	      video: compactObject(constraints.video)
	    });
	  }

	  return constraints;
	}
	function shimRTCIceServerUrls(window) {
	  // migrate from non-spec RTCIceServer.url to RTCIceServer.urls
	  const OrigPeerConnection = window.RTCPeerConnection;

	  window.RTCPeerConnection = function RTCPeerConnection(pcConfig, pcConstraints) {
	    if (pcConfig && pcConfig.iceServers) {
	      const newIceServers = [];

	      for (let i = 0; i < pcConfig.iceServers.length; i++) {
	        let server = pcConfig.iceServers[i];

	        if (!server.hasOwnProperty('urls') && server.hasOwnProperty('url')) {
	          deprecated('RTCIceServer.url', 'RTCIceServer.urls');
	          server = JSON.parse(stringify$2(server));
	          server.urls = server.url;
	          delete server.url;
	          newIceServers.push(server);
	        } else {
	          newIceServers.push(pcConfig.iceServers[i]);
	        }
	      }

	      pcConfig.iceServers = newIceServers;
	    }

	    return new OrigPeerConnection(pcConfig, pcConstraints);
	  };

	  window.RTCPeerConnection.prototype = OrigPeerConnection.prototype; // wrap static methods. Currently just generateCertificate.

	  if ('generateCertificate' in window.RTCPeerConnection) {
	    defineProperty$4(window.RTCPeerConnection, 'generateCertificate', {
	      get() {
	        return OrigPeerConnection.generateCertificate;
	      }

	    });
	  }
	}
	function shimTrackEventTransceiver(window) {
	  // Add event.transceiver member over deprecated event.receiver
	  if (typeof window === 'object' && window.RTCPeerConnection && 'receiver' in window.RTCTrackEvent.prototype && // can't check 'transceiver' in window.RTCTrackEvent.prototype, as it is
	  // defined for some reason even when window.RTCTransceiver is not.
	  !window.RTCTransceiver) {
	    defineProperty$4(window.RTCTrackEvent.prototype, 'transceiver', {
	      get() {
	        return {
	          receiver: this.receiver
	        };
	      }

	    });
	  }
	}
	function shimCreateOfferLegacy(window) {
	  const origCreateOffer = window.RTCPeerConnection.prototype.createOffer;

	  window.RTCPeerConnection.prototype.createOffer = function createOffer(offerOptions) {
	    if (offerOptions) {
	      var _context14, _context15;

	      if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {
	        // support bit values
	        offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;
	      }

	      const audioTransceiver = find$2(_context14 = this.getTransceivers()).call(_context14, transceiver => transceiver.receiver.track.kind === 'audio');

	      if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {
	        if (audioTransceiver.direction === 'sendrecv') {
	          if (audioTransceiver.setDirection) {
	            audioTransceiver.setDirection('sendonly');
	          } else {
	            audioTransceiver.direction = 'sendonly';
	          }
	        } else if (audioTransceiver.direction === 'recvonly') {
	          if (audioTransceiver.setDirection) {
	            audioTransceiver.setDirection('inactive');
	          } else {
	            audioTransceiver.direction = 'inactive';
	          }
	        }
	      } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {
	        this.addTransceiver('audio');
	      }

	      if (typeof offerOptions.offerToReceiveVideo !== 'undefined') {
	        // support bit values
	        offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;
	      }

	      const videoTransceiver = find$2(_context15 = this.getTransceivers()).call(_context15, transceiver => transceiver.receiver.track.kind === 'video');

	      if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {
	        if (videoTransceiver.direction === 'sendrecv') {
	          if (videoTransceiver.setDirection) {
	            videoTransceiver.setDirection('sendonly');
	          } else {
	            videoTransceiver.direction = 'sendonly';
	          }
	        } else if (videoTransceiver.direction === 'recvonly') {
	          if (videoTransceiver.setDirection) {
	            videoTransceiver.setDirection('inactive');
	          } else {
	            videoTransceiver.direction = 'inactive';
	          }
	        }
	      } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {
	        this.addTransceiver('video');
	      }
	    }

	    return origCreateOffer.apply(this, arguments);
	  };
	}

	var safariShim = /*#__PURE__*/Object.freeze({
		__proto__: null,
		shimLocalStreamsAPI: shimLocalStreamsAPI,
		shimRemoteStreamsAPI: shimRemoteStreamsAPI,
		shimCallbacksAPI: shimCallbacksAPI,
		shimGetUserMedia: shimGetUserMedia$3,
		shimConstraints: shimConstraints,
		shimRTCIceServerUrls: shimRTCIceServerUrls,
		shimTrackEventTransceiver: shimTrackEventTransceiver,
		shimCreateOfferLegacy: shimCreateOfferLegacy
	});

	/*
	 *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
	 *
	 *  Use of this source code is governed by a BSD-style license
	 *  that can be found in the LICENSE file in the root of the source
	 *  tree.
	 */
	function shimRTCIceCandidate(window) {
	  // foundation is arbitrarily chosen as an indicator for full support for
	  // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface
	  if (!window.RTCIceCandidate || window.RTCIceCandidate && 'foundation' in window.RTCIceCandidate.prototype) {
	    return;
	  }

	  const NativeRTCIceCandidate = window.RTCIceCandidate;

	  window.RTCIceCandidate = function RTCIceCandidate(args) {
	    var _context;

	    // Remove the a= which shouldn't be part of the candidate string.
	    if (typeof args === 'object' && args.candidate && indexOf$3(_context = args.candidate).call(_context, 'a=') === 0) {
	      args = JSON.parse(stringify$2(args));
	      args.candidate = args.candidate.substr(2);
	    }

	    if (args.candidate && args.candidate.length) {
	      // Augment the native candidate with the parsed fields.
	      const nativeCandidate = new NativeRTCIceCandidate(args);
	      const parsedCandidate = sdp.parseCandidate(args.candidate);

	      const augmentedCandidate = assign$2(nativeCandidate, parsedCandidate); // Add a serializer that does not serialize the extra attributes.


	      augmentedCandidate.toJSON = function toJSON() {
	        return {
	          candidate: augmentedCandidate.candidate,
	          sdpMid: augmentedCandidate.sdpMid,
	          sdpMLineIndex: augmentedCandidate.sdpMLineIndex,
	          usernameFragment: augmentedCandidate.usernameFragment
	        };
	      };

	      return augmentedCandidate;
	    }

	    return new NativeRTCIceCandidate(args);
	  };

	  window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype; // Hook up the augmented candidate in onicecandidate and
	  // addEventListener('icecandidate', ...)

	  wrapPeerConnectionEvent(window, 'icecandidate', e => {
	    if (e.candidate) {
	      defineProperty$4(e, 'candidate', {
	        value: new window.RTCIceCandidate(e.candidate),
	        writable: 'false'
	      });
	    }

	    return e;
	  });
	}
	function shimMaxMessageSize(window) {
	  if (!window.RTCPeerConnection) {
	    return;
	  }

	  const browserDetails = detectBrowser(window);

	  if (!('sctp' in window.RTCPeerConnection.prototype)) {
	    defineProperty$4(window.RTCPeerConnection.prototype, 'sctp', {
	      get() {
	        return typeof this._sctp === 'undefined' ? null : this._sctp;
	      }

	    });
	  }

	  const sctpInDescription = function (description) {
	    if (!description || !description.sdp) {
	      return false;
	    }

	    const sections = sdp.splitSections(description.sdp);
	    sections.shift();
	    return some$2(sections).call(sections, mediaSection => {
	      var _context2;

	      const mLine = sdp.parseMLine(mediaSection);
	      return mLine && mLine.kind === 'application' && indexOf$3(_context2 = mLine.protocol).call(_context2, 'SCTP') !== -1;
	    });
	  };

	  const getRemoteFirefoxVersion = function (description) {
	    // TODO: Is there a better solution for detecting Firefox?
	    const match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);

	    if (match === null || match.length < 2) {
	      return -1;
	    }

	    const version = _parseInt$3(match[1], 10); // Test for NaN (yes, this is ugly)


	    return version !== version ? -1 : version;
	  };

	  const getCanSendMaxMessageSize = function (remoteIsFirefox) {
	    // Every implementation we know can send at least 64 KiB.
	    // Note: Although Chrome is technically able to send up to 256 KiB, the
	    //       data does not reach the other peer reliably.
	    //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419
	    let canSendMaxMessageSize = 65536;

	    if (browserDetails.browser === 'firefox') {
	      if (browserDetails.version < 57) {
	        if (remoteIsFirefox === -1) {
	          // FF < 57 will send in 16 KiB chunks using the deprecated PPID
	          // fragmentation.
	          canSendMaxMessageSize = 16384;
	        } else {
	          // However, other FF (and RAWRTC) can reassemble PPID-fragmented
	          // messages. Thus, supporting ~2 GiB when sending.
	          canSendMaxMessageSize = 2147483637;
	        }
	      } else if (browserDetails.version < 60) {
	        // Currently, all FF >= 57 will reset the remote maximum message size
	        // to the default value when a data channel is created at a later
	        // stage. :(
	        // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831
	        canSendMaxMessageSize = browserDetails.version === 57 ? 65535 : 65536;
	      } else {
	        // FF >= 60 supports sending ~2 GiB
	        canSendMaxMessageSize = 2147483637;
	      }
	    }

	    return canSendMaxMessageSize;
	  };

	  const getMaxMessageSize = function (description, remoteIsFirefox) {
	    // Note: 65536 bytes is the default value from the SDP spec. Also,
	    //       every implementation we know supports receiving 65536 bytes.
	    let maxMessageSize = 65536; // FF 57 has a slightly incorrect default remote max message size, so
	    // we need to adjust it here to avoid a failure when sending.
	    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697

	    if (browserDetails.browser === 'firefox' && browserDetails.version === 57) {
	      maxMessageSize = 65535;
	    }

	    const match = sdp.matchPrefix(description.sdp, 'a=max-message-size:');

	    if (match.length > 0) {
	      maxMessageSize = _parseInt$3(match[0].substr(19), 10);
	    } else if (browserDetails.browser === 'firefox' && remoteIsFirefox !== -1) {
	      // If the maximum message size is not present in the remote SDP and
	      // both local and remote are Firefox, the remote peer can receive
	      // ~2 GiB.
	      maxMessageSize = 2147483637;
	    }

	    return maxMessageSize;
	  };

	  const origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;

	  window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
	    this._sctp = null; // Chrome decided to not expose .sctp in plan-b mode.
	    // As usual, adapter.js has to do an 'ugly worakaround'
	    // to cover up the mess.

	    if (browserDetails.browser === 'chrome' && browserDetails.version >= 76) {
	      const {
	        sdpSemantics
	      } = this.getConfiguration();

	      if (sdpSemantics === 'plan-b') {
	        defineProperty$4(this, 'sctp', {
	          get() {
	            return typeof this._sctp === 'undefined' ? null : this._sctp;
	          },

	          enumerable: true,
	          configurable: true
	        });
	      }
	    }

	    if (sctpInDescription(arguments[0])) {
	      // Check if the remote is FF.
	      const isFirefox = getRemoteFirefoxVersion(arguments[0]); // Get the maximum message size the local peer is capable of sending

	      const canSendMMS = getCanSendMaxMessageSize(isFirefox); // Get the maximum message size of the remote peer.

	      const remoteMMS = getMaxMessageSize(arguments[0], isFirefox); // Determine final maximum message size

	      let maxMessageSize;

	      if (canSendMMS === 0 && remoteMMS === 0) {
	        maxMessageSize = Number.POSITIVE_INFINITY;
	      } else if (canSendMMS === 0 || remoteMMS === 0) {
	        maxMessageSize = Math.max(canSendMMS, remoteMMS);
	      } else {
	        maxMessageSize = Math.min(canSendMMS, remoteMMS);
	      } // Create a dummy RTCSctpTransport object and the 'maxMessageSize'
	      // attribute.


	      const sctp = {};

	      defineProperty$4(sctp, 'maxMessageSize', {
	        get() {
	          return maxMessageSize;
	        }

	      });

	      this._sctp = sctp;
	    }

	    return origSetRemoteDescription.apply(this, arguments);
	  };
	}
	function shimSendThrowTypeError(window) {
	  if (!(window.RTCPeerConnection && 'createDataChannel' in window.RTCPeerConnection.prototype)) {
	    return;
	  } // Note: Although Firefox >= 57 has a native implementation, the maximum
	  //       message size can be reset for all data channels at a later stage.
	  //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831


	  function wrapDcSend(dc, pc) {
	    const origDataChannelSend = dc.send;

	    dc.send = function send() {
	      const data = arguments[0];
	      const length = data.length || data.size || data.byteLength;

	      if (dc.readyState === 'open' && pc.sctp && length > pc.sctp.maxMessageSize) {
	        throw new TypeError('Message too large (can send a maximum of ' + pc.sctp.maxMessageSize + ' bytes)');
	      }

	      return origDataChannelSend.apply(dc, arguments);
	    };
	  }

	  const origCreateDataChannel = window.RTCPeerConnection.prototype.createDataChannel;

	  window.RTCPeerConnection.prototype.createDataChannel = function createDataChannel() {
	    const dataChannel = origCreateDataChannel.apply(this, arguments);
	    wrapDcSend(dataChannel, this);
	    return dataChannel;
	  };

	  wrapPeerConnectionEvent(window, 'datachannel', e => {
	    wrapDcSend(e.channel, e.target);
	    return e;
	  });
	}
	/* shims RTCConnectionState by pretending it is the same as iceConnectionState.
	 * See https://bugs.chromium.org/p/webrtc/issues/detail?id=6145#c12
	 * for why this is a valid hack in Chrome. In Firefox it is slightly incorrect
	 * since DTLS failures would be hidden. See
	 * https://bugzilla.mozilla.org/show_bug.cgi?id=1265827
	 * for the Firefox tracking bug.
	 */

	function shimConnectionState(window) {
	  var _context3;

	  if (!window.RTCPeerConnection || 'connectionState' in window.RTCPeerConnection.prototype) {
	    return;
	  }

	  const proto = window.RTCPeerConnection.prototype;

	  defineProperty$4(proto, 'connectionState', {
	    get() {
	      return {
	        completed: 'connected',
	        checking: 'connecting'
	      }[this.iceConnectionState] || this.iceConnectionState;
	    },

	    enumerable: true,
	    configurable: true
	  });

	  defineProperty$4(proto, 'onconnectionstatechange', {
	    get() {
	      return this._onconnectionstatechange || null;
	    },

	    set(cb) {
	      if (this._onconnectionstatechange) {
	        this.removeEventListener('connectionstatechange', this._onconnectionstatechange);
	        delete this._onconnectionstatechange;
	      }

	      if (cb) {
	        this.addEventListener('connectionstatechange', this._onconnectionstatechange = cb);
	      }
	    },

	    enumerable: true,
	    configurable: true
	  });

	  forEach$3(_context3 = ['setLocalDescription', 'setRemoteDescription']).call(_context3, method => {
	    const origMethod = proto[method];

	    proto[method] = function () {
	      if (!this._connectionstatechangepoly) {
	        this._connectionstatechangepoly = e => {
	          const pc = e.target;

	          if (pc._lastConnectionState !== pc.connectionState) {
	            pc._lastConnectionState = pc.connectionState;
	            const newEvent = new Event('connectionstatechange', e);
	            pc.dispatchEvent(newEvent);
	          }

	          return e;
	        };

	        this.addEventListener('iceconnectionstatechange', this._connectionstatechangepoly);
	      }

	      return origMethod.apply(this, arguments);
	    };
	  });
	}
	function removeAllowExtmapMixed(window) {
	  /* remove a=extmap-allow-mixed for Chrome < M71 */
	  if (!window.RTCPeerConnection) {
	    return;
	  }

	  const browserDetails = detectBrowser(window);

	  if (browserDetails.browser === 'chrome' && browserDetails.version >= 71) {
	    return;
	  }

	  const nativeSRD = window.RTCPeerConnection.prototype.setRemoteDescription;

	  window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(desc) {
	    var _context4;

	    if (desc && desc.sdp && indexOf$3(_context4 = desc.sdp).call(_context4, '\na=extmap-allow-mixed') !== -1) {
	      var _context5;

	      desc.sdp = filter$2(_context5 = desc.sdp.split('\n')).call(_context5, line => {
	        return trim$3(line).call(line) !== 'a=extmap-allow-mixed';
	      }).join('\n');
	    }

	    return nativeSRD.apply(this, arguments);
	  };
	}

	var commonShim = /*#__PURE__*/Object.freeze({
		__proto__: null,
		shimRTCIceCandidate: shimRTCIceCandidate,
		shimMaxMessageSize: shimMaxMessageSize,
		shimSendThrowTypeError: shimSendThrowTypeError,
		shimConnectionState: shimConnectionState,
		removeAllowExtmapMixed: removeAllowExtmapMixed
	});

	/*
	 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
	 *
	 *  Use of this source code is governed by a BSD-style license
	 *  that can be found in the LICENSE file in the root of the source
	 *  tree.
	 */

	function adapterFactory({
	  window
	} = {}, options = {
	  shimChrome: true,
	  shimFirefox: true,
	  shimEdge: true,
	  shimSafari: true
	}) {
	  // Utils.
	  const logging = log;
	  const browserDetails = detectBrowser(window);
	  const adapter = {
	    browserDetails,
	    commonShim,
	    extractVersion: extractVersion,
	    disableLog: disableLog,
	    disableWarnings: disableWarnings
	  }; // Shim browser if found.

	  switch (browserDetails.browser) {
	    case 'chrome':
	      if (!chromeShim || !shimPeerConnection || !options.shimChrome) {
	        logging('Chrome shim is not included in this adapter release.');
	        return adapter;
	      }

	      logging('adapter.js shimming chrome.'); // Export to the adapter global object visible in the browser.

	      adapter.browserShim = chromeShim;
	      shimGetUserMedia(window);
	      shimMediaStream(window);
	      shimPeerConnection(window);
	      shimOnTrack(window);
	      shimAddTrackRemoveTrack(window);
	      shimGetSendersWithDtmf(window);
	      shimGetStats(window);
	      shimSenderReceiverGetStats(window);
	      fixNegotiationNeeded(window);
	      shimRTCIceCandidate(window);
	      shimConnectionState(window);
	      shimMaxMessageSize(window);
	      shimSendThrowTypeError(window);
	      removeAllowExtmapMixed(window);
	      break;

	    case 'firefox':
	      if (!firefoxShim || !shimPeerConnection$2 || !options.shimFirefox) {
	        logging('Firefox shim is not included in this adapter release.');
	        return adapter;
	      }

	      logging('adapter.js shimming firefox.'); // Export to the adapter global object visible in the browser.

	      adapter.browserShim = firefoxShim;
	      shimGetUserMedia$2(window);
	      shimPeerConnection$2(window);
	      shimOnTrack$1(window);
	      shimRemoveStream(window);
	      shimSenderGetStats(window);
	      shimReceiverGetStats(window);
	      shimRTCDataChannel(window);
	      shimRTCIceCandidate(window);
	      shimConnectionState(window);
	      shimMaxMessageSize(window);
	      shimSendThrowTypeError(window);
	      break;

	    case 'edge':
	      if (!edgeShim || !shimPeerConnection$1 || !options.shimEdge) {
	        logging('MS edge shim is not included in this adapter release.');
	        return adapter;
	      }

	      logging('adapter.js shimming edge.'); // Export to the adapter global object visible in the browser.

	      adapter.browserShim = edgeShim;
	      shimGetUserMedia$1(window);
	      shimGetDisplayMedia$1(window);
	      shimPeerConnection$1(window);
	      shimReplaceTrack(window); // the edge shim implements the full RTCIceCandidate object.

	      shimMaxMessageSize(window);
	      shimSendThrowTypeError(window);
	      break;

	    case 'safari':
	      if (!safariShim || !options.shimSafari) {
	        logging('Safari shim is not included in this adapter release.');
	        return adapter;
	      }

	      logging('adapter.js shimming safari.'); // Export to the adapter global object visible in the browser.

	      adapter.browserShim = safariShim;
	      shimRTCIceServerUrls(window);
	      shimCreateOfferLegacy(window);
	      shimCallbacksAPI(window);
	      shimLocalStreamsAPI(window);
	      shimRemoteStreamsAPI(window);
	      shimTrackEventTransceiver(window);
	      shimGetUserMedia$3(window);
	      shimRTCIceCandidate(window);
	      shimMaxMessageSize(window);
	      shimSendThrowTypeError(window);
	      removeAllowExtmapMixed(window);
	      break;

	    default:
	      logging('Unsupported browser!');
	      break;
	  }

	  return adapter;
	}

	/*
	 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
	 *
	 *  Use of this source code is governed by a BSD-style license
	 *  that can be found in the LICENSE file in the root of the source
	 *  tree.
	 */
	const adapter = adapterFactory({
	  window
	});

	var BrowserOS;

	(function (BrowserOS) {
	  BrowserOS["WIN_10"] = "Windows 10";
	  BrowserOS["WIN_81"] = "Windows 8.1";
	  BrowserOS["WIN_8"] = "Windows 8";
	  BrowserOS["WIN_7"] = "Windows 7";
	  BrowserOS["WIN_VISTA"] = "Windows Vista";
	  BrowserOS["WIN_SERVER_2003"] = "Windows Server 2003";
	  BrowserOS["WIN_XP"] = "Windows XP";
	  BrowserOS["WIN_2000"] = "Windows 2000";
	  BrowserOS["ANDROID"] = "Android";
	  BrowserOS["OPEN_BSD"] = "Open BSD";
	  BrowserOS["SUN_OS"] = "Sun OS";
	  BrowserOS["LINUX"] = "Linux";
	  BrowserOS["IOS"] = "iOS";
	  BrowserOS["MAC_OS_X"] = "Mac OS X";
	  BrowserOS["MAC_OS"] = "Mac OS";
	  BrowserOS["QNX"] = "QNX";
	  BrowserOS["UNIX"] = "UNIX";
	  BrowserOS["BEOS"] = "BeOS";
	  BrowserOS["OS_2"] = "OS/2";
	  BrowserOS["SEARCH_BOT"] = "Search Bot";
	})(BrowserOS || (BrowserOS = {}));

	var BrowserName;

	(function (BrowserName) {
	  BrowserName["CHROME"] = "Chrome";
	  BrowserName["SAFARI"] = "Safari";
	  BrowserName["EDGE"] = "Edge";
	  BrowserName["FIREFOX"] = "Firefox";
	  BrowserName["OPERA"] = "OPR";
	  BrowserName["QQ"] = "QQBrowser";
	  BrowserName["WECHAT"] = "MicroMessenger";
	})(BrowserName || (BrowserName = {}));

	/** @en
	 * The build information of the Agora Web SDK.
	 * @public
	 */

	/**
	 * Agora Web SDK 的编译信息。
	 * @public
	 */
	var BUILD = "v4.1.1-58-gfdaff12-dirty(11/26/2020, 2:57:21 PM)";
	var VERSION = transferVersion("4.1.1");
	var IS_GLOBAL_VERSION = isGlobalVersion();
	var DEFAULT_TURN_CONFIG = {
	  username: "test",
	  password: "111111",
	  turnServerURL: "",
	  tcpport: 3433,
	  udpport: 3478,
	  forceturn: false
	};

	function isGlobalVersion() {
	  try {
	    return JSON.parse("true") === true;
	  } catch (e) {
	    return true;
	  }
	}
	/**
	 * 将 3.0.0-alpha.19 这种版本号转为合法的 4 位版本号
	 *
	 * 版本号规范：
	 * - alpha 表示 prerelease 版本，占第 4 位版本号的 [0 - 100), 所以 3.0.0-alpha.19 -> 3.0.0.19
	 * - special 表示特殊版，占第 4 位版本号的 [100 ~ 200), 所以 3.0.0-special.0 -> 3.0.0.100
	 * - 如果没有版本前缀，代表正式版本，直接返回 3 位版本号
	 */


	function transferVersion(version) {
	  var releaseVersionMatch = version.match(/[0-9]+\.[0-9]+\.[0-9]+$/);
	  if (releaseVersionMatch) return version;
	  var alphaVersionMatch = version.match(/([0-9]+\.[0-9]+\.[0-9]+)\-alpha\.([0-9]+)/);

	  if (alphaVersionMatch && alphaVersionMatch[1] && alphaVersionMatch[2]) {
	    var mainVersion = alphaVersionMatch[1];
	    var alphaVersion = alphaVersionMatch[2];
	    return mainVersion + "." + alphaVersion;
	  }

	  var specialVersionMatch = version.match(/([0-9]+\.[0-9]+\.[0-9]+)\-special\.([0-9]+)/);

	  if (specialVersionMatch && specialVersionMatch[1] && specialVersionMatch[2]) {
	    var mainVersion = specialVersionMatch[1];
	    var specialVersion = specialVersionMatch[2];
	    return mainVersion + "." + (Number(specialVersion) + 1) * 100;
	  } // 非法版本号，通常出现在测试中


	  return "4.0.0.999";
	}
	/**
	 * @ignore
	 * AgoraSDK 支持的 Video Profile 列表
	 */

	/** @en
	 * @ignore
	 */


	var SUPPORT_VIDEO_ENCODER_CONFIG_LIST = {
	  "90p": createVideoEncoderConfiguration(160, 90),
	  "90p_1": createVideoEncoderConfiguration(160, 90),
	  "120p": createVideoEncoderConfiguration(160, 120, 15, 30, 65),
	  "120p_1": createVideoEncoderConfiguration(160, 120, 15, 30, 65),
	  "120p_3": createVideoEncoderConfiguration(120, 120, 15, 30, 50),
	  "120p_4": createVideoEncoderConfiguration(212, 120),
	  "180p": createVideoEncoderConfiguration(320, 180, 15, 30, 140),
	  "180p_1": createVideoEncoderConfiguration(320, 180, 15, 30, 140),
	  "180p_3": createVideoEncoderConfiguration(180, 180, 15, 30, 100),
	  "180p_4": createVideoEncoderConfiguration(240, 180, 15, 30, 120),
	  "240p": createVideoEncoderConfiguration(320, 240, 15, 40, 200),
	  "240p_1": createVideoEncoderConfiguration(320, 240, 15, 40, 200),
	  "240p_3": createVideoEncoderConfiguration(240, 240, 15, 40, 140),
	  "240p_4": createVideoEncoderConfiguration(424, 240, 15, 40, 220),
	  "360p": createVideoEncoderConfiguration(640, 360, 15, 80, 400),
	  "360p_1": createVideoEncoderConfiguration(640, 360, 15, 80, 400),
	  "360p_3": createVideoEncoderConfiguration(360, 360, 15, 80, 260),
	  "360p_4": createVideoEncoderConfiguration(640, 360, 30, 80, 600),
	  "360p_6": createVideoEncoderConfiguration(360, 360, 30, 80, 400),
	  "360p_7": createVideoEncoderConfiguration(480, 360, 15, 80, 320),
	  "360p_8": createVideoEncoderConfiguration(480, 360, 30, 80, 490),
	  "360p_9": createVideoEncoderConfiguration(640, 360, 15, 80, 800),
	  "360p_10": createVideoEncoderConfiguration(640, 360, 24, 80, 800),
	  "360p_11": createVideoEncoderConfiguration(640, 360, 24, 80, 1000),
	  "480p": createVideoEncoderConfiguration(640, 480, 15, 100, 500),
	  "480p_1": createVideoEncoderConfiguration(640, 480, 15, 100, 500),
	  "480p_2": createVideoEncoderConfiguration(640, 480, 30, 100, 1000),
	  "480p_3": createVideoEncoderConfiguration(480, 480, 15, 100, 400),
	  "480p_4": createVideoEncoderConfiguration(640, 480, 30, 100, 750),
	  "480p_6": createVideoEncoderConfiguration(480, 480, 30, 100, 600),
	  "480p_8": createVideoEncoderConfiguration(848, 480, 15, 100, 610),
	  "480p_9": createVideoEncoderConfiguration(848, 480, 30, 100, 930),
	  "480p_10": createVideoEncoderConfiguration(640, 480, 10, 100, 400),
	  "720p": createVideoEncoderConfiguration(1280, 720, 15, 120, 1130),
	  "720p_1": createVideoEncoderConfiguration(1280, 720, 15, 120, 1130),
	  "720p_2": createVideoEncoderConfiguration(1280, 720, 30, 120, 2000),
	  "720p_3": createVideoEncoderConfiguration(1280, 720, 30, 120, 1710),
	  "720p_5": createVideoEncoderConfiguration(960, 720, 15, 120, 910),
	  "720p_6": createVideoEncoderConfiguration(960, 720, 30, 120, 1380),
	  "1080p": createVideoEncoderConfiguration(1920, 1080, 15, 120, 2080),
	  "1080p_1": createVideoEncoderConfiguration(1920, 1080, 15, 120, 2080),
	  "1080p_2": createVideoEncoderConfiguration(1920, 1080, 30, 120, 3000),
	  "1080p_3": createVideoEncoderConfiguration(1920, 1080, 30, 120, 3150),
	  "1080p_5": createVideoEncoderConfiguration(1920, 1080, 60, 120, 4780),
	  "1440p": createVideoEncoderConfiguration(2560, 1440, 30, 120, 4850),
	  "1440p_1": createVideoEncoderConfiguration(2560, 1440, 30, 120, 4850),
	  "1440p_2": createVideoEncoderConfiguration(2560, 1440, 60, 120, 7350),
	  "4k": createVideoEncoderConfiguration(3840, 2160, 30, 120, 8910),
	  "4k_1": createVideoEncoderConfiguration(3840, 2160, 30, 120, 8910),
	  "4k_3": createVideoEncoderConfiguration(3840, 2160, 60, 120, 13500)
	};
	/**
	 * @ignore
	 */

	/** @en
	 * @ignore
	 */

	var SUPPORT_SCREEN_ENCODER_CONFIG_LIST = {
	  "480p": createScreenEncoderConfiguration(640, 480, 5),
	  "480p_1": createScreenEncoderConfiguration(640, 480, 5),
	  "480p_2": createScreenEncoderConfiguration(640, 480, 30),
	  "720p": createScreenEncoderConfiguration(1280, 720, 5),
	  "720p_1": createScreenEncoderConfiguration(1280, 720, 5),
	  "720p_2": createScreenEncoderConfiguration(1280, 720, 30),
	  "1080p": createScreenEncoderConfiguration(1920, 1080, 5),
	  "1080p_1": createScreenEncoderConfiguration(1920, 1080, 5),
	  "1080p_2": createScreenEncoderConfiguration(1920, 1080, 30)
	};
	function getVideoEncoderConfiguration(profile) {
	  if (typeof profile === "string") {
	    return assign$2({}, SUPPORT_VIDEO_ENCODER_CONFIG_LIST[profile]);
	  }

	  return profile;
	}
	function getScreenEncoderConfiguration(profile) {
	  if (typeof profile === "string") {
	    return assign$2({}, SUPPORT_SCREEN_ENCODER_CONFIG_LIST[profile]);
	  }

	  return profile;
	}
	/**
	 * @ignore
	 * AgoraSDK 支持的音频 Profile 列表
	 */

	/** @en
	 * @ignore
	 */

	var AUDIO_ENCODER_CONFIG_SETTINGS = {
	  speech_low_quality: createAudioEncoderConfiguration(16000, false),
	  speech_standard: createAudioEncoderConfiguration(32000, false, 18),
	  music_standard: createAudioEncoderConfiguration(48000, false),
	  standard_stereo: createAudioEncoderConfiguration(48000, true, 56),
	  high_quality: createAudioEncoderConfiguration(48000, false, 128),
	  high_quality_stereo: createAudioEncoderConfiguration(48000, true, 192)
	};
	function getAudioEncoderConfiguration(profile) {
	  if (typeof profile === "string") {
	    return assign$2({}, AUDIO_ENCODER_CONFIG_SETTINGS[profile]);
	  }

	  return profile;
	}
	/**
	 * 设置可变的全局变量
	 * @param key - 全局变量的 key
	 * @param value - 全局变量的值，可以为任意对象
	 *
	 * @internal
	 */

	function setParameter(key, value) {
	  var _context;

	  if (!includes$4(_context = keys$3(MUTABLE_PARAMS)).call(_context, key)) return;
	  MUTABLE_PARAMS[key] = value;
	}
	/**
	 * 获取可变的全局变量
	 * @param key - 全局变量的 key
	 *
	 */

	function getParameter(key) {
	  return MUTABLE_PARAMS[key];
	}
	/**
	 * @internal
	 */

	var MUTABLE_PARAMS = {
	  // 全局唯一的随机 ID
	  PROCESS_ID: "",
	  ENCRYPT_AES: true,
	  AREAS: [],
	  WEBCS_DOMAIN: ["webrtc2-ap-web-1.agora.io", "webrtc2-ap-web-2.agoraio.cn"],
	  WEBCS_DOMAIN_BACKUP_LIST: ["webrtc2-ap-web-3.agora.io", "webrtc2-ap-web-4.agoraio.cn"],
	  PROXY_CS: ["ap-proxy-1.agora.io", "ap-proxy-2.agora.io"],
	  CDS_AP: ["cds-ap-web-1.agora.io", "cds-ap-web-2.agoraio.cn", "cds-ap-web-3.agora.io", "cds-ap-web-4.agoraio.cn"],
	  ACCOUNT_REGISTER: ["sua-ap-web-1.agora.io", "sua-ap-web-2.agoraio.cn", "sua-ap-web-3.agora.io", "sua-ap-web-4.agoraio.cn"],
	  UAP_AP: ["uap-ap-web-1.agora.io", "uap-ap-web-2.agoraio.cn", "uap-ap-web-3.agora.io", "uap-ap-web-4.agoraio.cn"],
	  LOG_UPLOAD_SERVER: "logservice.agora.io",
	  EVENT_REPORT_DOMAIN: "statscollector-1.agora.io",
	  EVENT_REPORT_BACKUP_DOMAIN: "statscollector-2.agoraio.cn",
	  GATEWAY_ADDRESS: [],
	  GATEWAY_WSS_ADDRESS: "",

	  /*
	  GATEWAY_ADDRESS: [
	    { ip: "113.207.108.198", port: 14700 },
	    { ip: "113.207.108.198", port: 14701 },
	  ],
	  */
	  // 推流 workerManager wss 地址
	  LIVE_STREAMING_ADDRESS: "",
	  ACCOUNT_REGISTER_RETRY_TIMEOUT: 1,
	  ACCOUNT_REGISTER_RETRY_RATIO: 2,
	  ACCOUNT_REGISTER_RETRY_TIMEOUT_MAX: 60000,
	  ACCOUNT_REGISTER_RETRY_COUNT_MAX: 100000,
	  AUDIO_CONTEXT: null,
	  WEBCS_BACKUP_CONNECT_TIMEOUT: 6000,
	  HTTP_CONNECT_TIMEOUT: 5000,
	  PLAYER_STATE_DEFER: 2000,
	  SIGNAL_REQUEST_TIMEOUT: 10000,
	  SIGNAL_REQUEST_WATCH_INTERVAL: 1000,
	  REPORT_STATS: true,
	  UPLOAD_LOG: false,
	  NOT_REPORT_EVENT: [],
	  FILEPATH_LENMAX: 255,
	  SUBSCRIBE_TCC: false,
	  PING_PONG_TIME_OUT: 10,
	  DUALSTREAM_OPERATION_CHECK: true,
	  WEBSOCKET_TIMEOUT_MIN: 10000,
	  EVENT_REPORT_SEND_INTERVAL: 3000,
	  MEDIA_ELEMENT_EXISTS_DEPTH: 3,
	  CANDIDATE_TIMEOUT: 5000,
	  SHIM_CANDIDATE: false,
	  LEAVE_MSG_TIMEOUT: 2000,
	  SHOW_REPORT_INVOKER_LOG: false,
	  STATS_FILTER: {
	    transportId: true,
	    googTrackId: true
	  },
	  JOIN_EXTEND: "",
	  PUB_EXTEND: "",
	  SUB_EXTEND: "",
	  FORCE_TURN: false,
	  TURN_ENABLE_TCP: true,
	  TURN_ENABLE_UDP: true,
	  MAX_UPLOAD_CACHE: 50,
	  UPLOAD_CACHE_INTERVAL: 2000,

	  /** 强制 Chrome 使用 plan b */
	  CHROME_FORCE_PLAN_B: false,

	  /** 计算 WebAudio 音量的间隔(ms) */
	  AUDIO_SOURCE_VOLUME_UPDATE_INTERVAL: 400,

	  /** 计算平均音量的最大音频 duration (ms) */
	  AUDIO_SOURCE_AVG_VOLUME_DURATION: 3000,

	  /** volume-indicator 回调间隔(ms) */
	  AUDIO_VOLUME_INDICATION_INTERVAL: 2000,

	  /** 非关键事件的最大缓存数 */
	  NORMAL_EVENT_QUEUE_CAPACITY: 100,

	  /** 是否开启自定义事件上报 */
	  CUSTOM_REPORT: true,

	  /** 自定义上报数量限制 （5s） */
	  CUSTOM_REPORT_LIMIT: 20,
	  PROXY_SERVER_TYPE2: "webnginx-proxy.agora.io"
	};

	function setOverseaPamareters() {
	  if (!IS_GLOBAL_VERSION) {
	    MUTABLE_PARAMS["WEBCS_DOMAIN"] = ["ap-web-1-oversea.agora.io", "ap-web-1-north-america.agora.io"];
	    MUTABLE_PARAMS["WEBCS_DOMAIN_BACKUP_LIST"] = ["ap-web-2-oversea.agora.io", "ap-web-2-north-america.agora.io"];
	    MUTABLE_PARAMS["PROXY_CS"] = ["proxy-ap-web-oversea.agora.io", "proxy-ap-web-america.agora.io"];
	    MUTABLE_PARAMS["CDS_AP"] = ["cds-ap-web-oversea.agora.io", "cds-ap-web-america.agora.io", "cds-ap-web-america2.agora.io"];
	    MUTABLE_PARAMS["ACCOUNT_REGISTER"] = ["sua-ap-web-oversea.agora.io", "sua-ap-web-america.agora.io", "sua-ap-web-america2.agora.io"];
	    MUTABLE_PARAMS["UAP_AP"] = ["uap-ap-web-oversea.agora.io", "uap-ap-web-america.agora.io", "uap-ap-web-america2.agora.io"];
	    MUTABLE_PARAMS["LOG_UPLOAD_SERVER"] = "logservice-oversea.agora.io";
	    MUTABLE_PARAMS["EVENT_REPORT_DOMAIN"] = "statscollector-1-oversea.agora.io";
	    MUTABLE_PARAMS["EVENT_REPORT_BACKUP_DOMAIN"] = "statscollector-2-oversea.agora.io";
	  }
	}

	setOverseaPamareters();

	function createAudioEncoderConfiguration(sampleRate, stereo, bitrate) {
	  return {
	    sampleRate: sampleRate,
	    stereo: stereo,
	    bitrate: bitrate
	  };
	}

	function createVideoEncoderConfiguration(w, h, ideal, bmin, bmax) {
	  return {
	    width: w,
	    height: h,
	    frameRate: ideal,
	    bitrateMin: bmin,
	    bitrateMax: bmax
	  };
	}

	function createScreenEncoderConfiguration(w, h, ideal, bmin, bmax) {
	  return {
	    width: {
	      max: w
	    },
	    height: {
	      max: h
	    },
	    frameRate: ideal,
	    bitrateMin: bmin,
	    bitrateMax: bmax
	  };
	}

	var BANDWIDTH_FACTOR_TABLE = [[0, 1, 2, 3, 4, 5, 5], [0, 2, 2, 3, 4, 5, 5], [0, 3, 3, 3, 4, 5, 5], [0, 4, 4, 4, 4, 5, 5], [0, 5, 5, 5, 5, 5, 5]];
	var CLIENT_LIST = [];

	var test$1 = [];
	var nativeSort = test$1.sort;

	// IE8-
	var FAILS_ON_UNDEFINED = fails(function () {
	  test$1.sort(undefined);
	});
	// V8 bug
	var FAILS_ON_NULL = fails(function () {
	  test$1.sort(null);
	});
	// Old WebKit
	var SLOPPY_METHOD$1 = sloppyArrayMethod('sort');

	var FORCED$5 = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || SLOPPY_METHOD$1;

	// `Array.prototype.sort` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.sort
	_export({ target: 'Array', proto: true, forced: FORCED$5 }, {
	  sort: function sort(comparefn) {
	    return comparefn === undefined
	      ? nativeSort.call(toObject(this))
	      : nativeSort.call(toObject(this), aFunction(comparefn));
	  }
	});

	var sort = entryVirtual('Array').sort;

	var ArrayPrototype$c = Array.prototype;

	var sort_1 = function (it) {
	  var own = it.sort;
	  return it === ArrayPrototype$c || (it instanceof Array && own === ArrayPrototype$c.sort) ? sort : own;
	};

	var sort$1 = sort_1;

	var sort$2 = sort$1;

	// `Array.isArray` method
	// https://tc39.github.io/ecma262/#sec-array.isarray
	_export({ target: 'Array', stat: true }, {
	  isArray: isArray
	});

	var isArray$1 = path.Array.isArray;

	var isArray$2 = isArray$1;

	var isArray$3 = isArray$2;

	/**
	 * AgoraSDK 抛出的错误的 Code
	 * @ignore
	 */

	/** @en
	 * @ignore
	 */
	var AgoraRTCErrorCode;

	(function (AgoraRTCErrorCode) {
	  /**
	   * 所有用户无法处理的、非预期的错误都使用这个错误码
	   */
	  AgoraRTCErrorCode["UNEXPECTED_ERROR"] = "UNEXPECTED_ERROR";
	  /** 服务端返回了非预期的响应  */

	  AgoraRTCErrorCode["UNEXPECTED_RESPONSE"] = "UNEXPECTED_RESPONSE";
	  AgoraRTCErrorCode["TIMEOUT"] = "TIMEOUT";
	  /** 非法参数 */

	  AgoraRTCErrorCode["INVALID_PARAMS"] = "INVALID_PARAMS";
	  /** 浏览器不支持 */

	  AgoraRTCErrorCode["NOT_SUPPORTED"] = "NOT_SUPPORTED";
	  /** 非法操作，比如在加入房间之前发布 */

	  AgoraRTCErrorCode["INVALID_OPERATION"] = "INVALID_OPERATION";
	  /** 操作中止，比如在加入房间的中途离开房间 */

	  AgoraRTCErrorCode["OPERATION_ABORTED"] = "OPERATION_ABORTED";
	  /** 安全策略限制 */

	  AgoraRTCErrorCode["WEB_SECURITY_RESTRICT"] = "WEB_SECURITY_RESTRICT";
	  /**
	   * http post 请求相关
	   */

	  AgoraRTCErrorCode["NETWORK_ERROR"] = "NETWORK_ERROR";
	  AgoraRTCErrorCode["NETWORK_TIMEOUT"] = "NETWORK_TIMEOUT";
	  AgoraRTCErrorCode["NETWORK_RESPONSE_ERROR"] = "NETWORK_RESPONSE_ERROR";
	  /**
	   * report 相关
	   */

	  AgoraRTCErrorCode["API_INVOKE_TIMEOUT"] = "API_INVOKE_TIMEOUT";
	  /**
	   * Device 模块相关
	   */

	  /** 枚举本地设备失败 */

	  AgoraRTCErrorCode["ENUMERATE_DEVICES_FAILED"] = "ENUMERATE_DEVICES_FAILED";
	  /** 找不到指定设备 */

	  AgoraRTCErrorCode["DEVICE_NOT_FOUND"] = "DEVICE_NOT_FOUND";
	  /**
	   * Electron 相关
	   */

	  /** 无法获取 Electron 对象 */

	  AgoraRTCErrorCode["ELECTRON_IS_NULL"] = "ELECTRON_IS_NULL";
	  /** 无法通过 Electron 获取屏幕共享源 */

	  AgoraRTCErrorCode["ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR"] = "ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR";
	  /**
	   * Stream 相关
	   */
	  // STREAM_ALREADY_INITIALIZED = "STREAM_ALREADY_INITIALIZED",
	  // STREAM_IS_CLOSED = "STREAM_IS_CLOSED",

	  /** init 因为其他的 init 操作而中止 */
	  // ABORT_OTHER_INIT = "ABORT_OTHER_INIT",

	  /** chrome 屏幕共享插件没有响应 */

	  AgoraRTCErrorCode["CHROME_PLUGIN_NO_RESPONSE"] = "CHROME_PLUGIN_NO_RESPONSE";
	  /** chrome 屏幕共享插件没有安装 */

	  AgoraRTCErrorCode["CHROME_PLUGIN_NOT_INSTALL"] = "CHROME_PLUGIN_NOT_INSTALL";
	  /** 媒体采集的参数不支持 */

	  AgoraRTCErrorCode["MEDIA_OPTION_INVALID"] = "MEDIA_OPTION_INVALID";
	  /** 获取媒体设备权限被拒绝 */

	  AgoraRTCErrorCode["PERMISSION_DENIED"] = "PERMISSION_DENIED";
	  /** 浏览器不支持该 constraint */

	  AgoraRTCErrorCode["CONSTRAINT_NOT_SATISFIED"] = "CONSTRAINT_NOT_SATISFIED";
	  /** 播放时被浏览器自动播放策略阻止 */
	  // CAN_NOT_AUTOPLAY = "CAN_NOT_AUTOPLAY",

	  /** 创建小流时检测到大流没有视频轨 */
	  // HIGH_STREAM_NO_VIDEO_TRACK = "HIGH_STREAM_NO_VIDEO_TRACK",

	  /** 屏幕共享不允许使用大小流 */
	  // SCREEN_SHARE_CAN_NOT_CREATE_LOW_STREAM = "SCREEN_SHARE_CAN_NOT_CREATE_LOW_STREAM",

	  /** 轨道被禁用 */

	  AgoraRTCErrorCode["TRACK_IS_DISABLED"] = "TRACK_IS_DISABLED";
	  /** 屏幕共享音频时用户没有点击 **分享音频** */

	  AgoraRTCErrorCode["SHARE_AUDIO_NOT_ALLOWED"] = "SHARE_AUDIO_NOT_ALLOWED";
	  /**
	   * Client join 相关
	   */

	  /** 用户提供的 Token 生成函数运行时出现错误 */
	  // TOKEN_GENERATOR_FUNCTION_ERROR = "TOKEN_GENERATOR_FUNCTION_ERROR",

	  /** 通过 string uid allocate 服务返回了非法的 int uid */

	  AgoraRTCErrorCode["INVALID_UINT_UID_FROM_STRING_UID"] = "INVALID_UINT_UID_FROM_STRING_UID";
	  /** 尝试了数次均无法获取云代理服务 */

	  AgoraRTCErrorCode["CAN_NOT_GET_PROXY_SERVER"] = "CAN_NOT_GET_PROXY_SERVER";
	  /** 尝试了数次均无法获取 gateway 地址 */

	  AgoraRTCErrorCode["CAN_NOT_GET_GATEWAY_SERVER"] = "CAN_NOT_GET_GATEWAY_SERVER";
	  /** UID 冲突，重复的 UID */

	  AgoraRTCErrorCode["UID_CONFLICT"] = "UID_CONFLICT";
	  /**
	   * Client publish/unpublish 相关
	   */

	  /** 传入了非法的 local track */

	  AgoraRTCErrorCode["INVALID_LOCAL_TRACK"] = "INVALID_LOCAL_TRACK";
	  /** 传入了非法的 track */

	  AgoraRTCErrorCode["INVALID_TRACK"] = "INVALID_TRACK";
	  /** replaceTrack 等操作时找不到指定的 sender */

	  AgoraRTCErrorCode["SENDER_NOT_FOUND"] = "SENDER_NOT_FOUND";
	  /** p2p 建立相关 */

	  AgoraRTCErrorCode["CREATE_OFFER_FAILED"] = "CREATE_OFFER_FAILED";
	  AgoraRTCErrorCode["SET_ANSWER_FAILED"] = "SET_ANSWER_FAILED";
	  AgoraRTCErrorCode["ICE_FAILED"] = "ICE_FAILED";
	  AgoraRTCErrorCode["PC_CLOSED"] = "PC_CLOSED";
	  AgoraRTCErrorCode["SENDER_REPLACE_FAILED"] = "SENDER_REPLACE_FAILED";
	  /** 网关抛出的 P2P 断开 */

	  AgoraRTCErrorCode["GATEWAY_P2P_LOST"] = "GATEWAY_P2P_LOST";
	  AgoraRTCErrorCode["NO_ICE_CANDIDATE"] = "NO_ICE_CANDIDATE";
	  /** 不允许发布多个视频轨道 */

	  AgoraRTCErrorCode["CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS"] = "CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS";
	  AgoraRTCErrorCode["EXIST_DISABLED_VIDEO_TRACK"] = "EXIST_DISABLED_VIDEO_TRACK";
	  /**
	   * Client subscribe/unsubscribe 相关
	   */

	  /** 找不到指定的订阅用户 */

	  AgoraRTCErrorCode["INVALID_REMOTE_USER"] = "INVALID_REMOTE_USER";
	  /** 远端用户没有发布 */

	  AgoraRTCErrorCode["REMOTE_USER_IS_NOT_PUBLISHED"] = "REMOTE_USER_IS_NOT_PUBLISHED";
	  /** 相同流的上一个订阅还没有完成 */
	  // SUBSCRIPTION_IS_IN_PROGRESS = "SUBSCRIPTION_IS_IN_PROGRESS",

	  /**
	   * Client 其他
	   */

	  /** 自定义事件上报失败，通常是因为网络原因 */

	  AgoraRTCErrorCode["CUSTOM_REPORT_SEND_FAILED"] = "CUSTOM_REPORT_SEND_FAILED";
	  /** 自定义上报太频繁 */

	  AgoraRTCErrorCode["CUSTOM_REPORT_FREQUENCY_TOO_HIGH"] = "CUSTOM_REPORT_FREQUENCY_TOO_HIGH";
	  /**
	  * Stream 混音相关
	  */

	  /** 下载在线音频文件失败 */

	  AgoraRTCErrorCode["FETCH_AUDIO_FILE_FAILED"] = "FETCH_AUDIO_FILE_FAILED";
	  /** 读取本地 音频文件失败*/

	  AgoraRTCErrorCode["READ_LOCAL_AUDIO_FILE_ERROR"] = "READ_LOCAL_AUDIO_FILE_ERROR";
	  /** 解码音频文件失败 */

	  AgoraRTCErrorCode["DECODE_AUDIO_FILE_FAILED"] = "DECODE_AUDIO_FILE_FAILED";
	  /** 音效的 `soundID` 发生冲突 */
	  // EFFECT_ID_CONFLICTED = "EFFECT_ID_CONFLICTED",

	  /** 找不到指定的音效 ID */
	  // EFFECT_SOUND_ID_NOT_FOUND = "EFFECT_SOUND_ID_NOT_FOUND",

	  /**
	   * Gateway 操作相关
	   */

	  /** 请求网关时 WS 断开 */

	  AgoraRTCErrorCode["WS_ABORT"] = "WS_ABORT";
	  /** 请求网关前网关就已经断开 */

	  AgoraRTCErrorCode["WS_DISCONNECT"] = "WS_DISCONNECT";
	  AgoraRTCErrorCode["WS_ERR"] = "WS_ERR";
	  /**
	   * Live Streaming 相关
	   */

	  /** 无法和推流后台建立连接 */
	  // CAN_NOT_CONNECT_TO_LIVE_STREAMING_WORKER = "CAN_NOT_CONNECT_TO_LIVE_STREAMING_WORKER",

	  /** 推流任务已经存在 */

	  AgoraRTCErrorCode["LIVE_STREAMING_TASK_CONFLICT"] = "LIVE_STREAMING_TASK_CONFLICT";
	  /** 推流/拉流参数错误 */

	  AgoraRTCErrorCode["LIVE_STREAMING_INVALID_ARGUMENT"] = "LIVE_STREAMING_INVALID_ARGUMENT";
	  /** 推流/拉流服务内部错误 */

	  AgoraRTCErrorCode["LIVE_STREAMING_INTERNAL_SERVER_ERROR"] = "LIVE_STREAMING_INTERNAL_SERVER_ERROR";
	  /** 推流 URL 被占用 */

	  AgoraRTCErrorCode["LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED"] = "LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED";
	  /** 在非转码推流中调用了转码参数 */

	  AgoraRTCErrorCode["LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED"] = "LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED";
	  /** 推流的目标 CDN 出现错误导致推流失败 */

	  AgoraRTCErrorCode["LIVE_STREAMING_CDN_ERROR"] = "LIVE_STREAMING_CDN_ERROR";
	  /** 推流超时，请确认目标流是否存在 */

	  AgoraRTCErrorCode["LIVE_STREAMING_INVALID_RAW_STREAM"] = "LIVE_STREAMING_INVALID_RAW_STREAM";
	  /** 推流超过 10 路流 */

	  AgoraRTCErrorCode["LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT"] = "LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT";
	  /** 推流中的背景图片或者水印地址无法拉取(不影响推流流程) */

	  AgoraRTCErrorCode["LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE"] = "LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE";
	  /** 推流请求太频繁（不影响推流流程） */

	  AgoraRTCErrorCode["LIVE_STREAMING_WARN_FREQUENT_REQUEST"] = "LIVE_STREAMING_WARN_FREQUENT_REQUEST";
	  /**
	   * WebGL/美颜相关
	   */

	  /** WebGL 内部错误 */

	  AgoraRTCErrorCode["WEBGL_INTERNAL_ERROR"] = "WEBGL_INTERNAL_ERROR";
	  /** 美颜内部错误 */

	  AgoraRTCErrorCode["BEAUTY_PROCESSOR_INTERNAL_ERROR"] = "BEAUTY_PROCESSOR_INTERNAL_ERROR";
	  /**
	   * Cross Channel 相关
	   */

	  /** 等待 status 回调出错 */

	  AgoraRTCErrorCode["CROSS_CHANNEL_WAIT_STATUS_ERROR"] = "CROSS_CHANNEL_WAIT_STATUS_ERROR";
	  /** 服务器加入源频道失败 */

	  AgoraRTCErrorCode["CROSS_CHANNEL_FAILED_JOIN_SRC"] = "CROSS_CHANNEL_FAILED_JOIN_SEC";
	  /** 服务器加入目标频道失败 */

	  AgoraRTCErrorCode["CROSS_CHANNEL_FAILED_JOIN_DEST"] = "CROSS_CHANNEL_FAILED_JOIN_DEST";
	  /** 源频道发送数据失败 */

	  AgoraRTCErrorCode["CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST"] = "CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST";
	  /** 服务器回应出错 */

	  AgoraRTCErrorCode["CROSS_CHANNEL_SERVER_ERROR_RESPONSE"] = "CROSS_CHANNEL_SERVER_ERROR_RESPONSE";
	  /**
	   * AVC SEI 相关
	   */

	  /** 需要编码的 SEI 数据超过了最大大小 */

	  AgoraRTCErrorCode["METADATA_OUT_OF_RANGE"] = "METADATA_OUT_OF_RANGE";
	})(AgoraRTCErrorCode || (AgoraRTCErrorCode = {}));

	var f$5 = wellKnownSymbol;

	var wrappedWellKnownSymbol = {
		f: f$5
	};

	var defineProperty$5 = objectDefineProperty.f;

	var defineWellKnownSymbol = function (NAME) {
	  var Symbol = path.Symbol || (path.Symbol = {});
	  if (!has(Symbol, NAME)) defineProperty$5(Symbol, NAME, {
	    value: wrappedWellKnownSymbol.f(NAME)
	  });
	};

	// `Symbol.iterator` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.iterator
	defineWellKnownSymbol('iterator');

	var iterator = wrappedWellKnownSymbol.f('iterator');

	var iterator$1 = iterator;

	var iterator$2 = iterator$1;

	var hiddenKeys$1 = enumBugKeys.concat('length', 'prototype');

	// `Object.getOwnPropertyNames` method
	// https://tc39.github.io/ecma262/#sec-object.getownpropertynames
	var f$6 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
	  return objectKeysInternal(O, hiddenKeys$1);
	};

	var objectGetOwnPropertyNames = {
		f: f$6
	};

	var nativeGetOwnPropertyNames = objectGetOwnPropertyNames.f;

	var toString$1 = {}.toString;

	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];

	var getWindowNames = function (it) {
	  try {
	    return nativeGetOwnPropertyNames(it);
	  } catch (error) {
	    return windowNames.slice();
	  }
	};

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var f$7 = function getOwnPropertyNames(it) {
	  return windowNames && toString$1.call(it) == '[object Window]'
	    ? getWindowNames(it)
	    : nativeGetOwnPropertyNames(toIndexedObject(it));
	};

	var objectGetOwnPropertyNamesExternal = {
		f: f$7
	};

	var $forEach$1 = arrayIteration.forEach;

	var HIDDEN = sharedKey('hidden');
	var SYMBOL = 'Symbol';
	var PROTOTYPE$1 = 'prototype';
	var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
	var setInternalState$5 = internalState.set;
	var getInternalState$3 = internalState.getterFor(SYMBOL);
	var ObjectPrototype$1 = Object[PROTOTYPE$1];
	var $Symbol = global_1.Symbol;
	var $stringify$1 = getBuiltIn('JSON', 'stringify');
	var nativeGetOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;
	var nativeDefineProperty$1 = objectDefineProperty.f;
	var nativeGetOwnPropertyNames$1 = objectGetOwnPropertyNamesExternal.f;
	var nativePropertyIsEnumerable$1 = objectPropertyIsEnumerable.f;
	var AllSymbols = shared('symbols');
	var ObjectPrototypeSymbols = shared('op-symbols');
	var StringToSymbolRegistry = shared('string-to-symbol-registry');
	var SymbolToStringRegistry = shared('symbol-to-string-registry');
	var WellKnownSymbolsStore$1 = shared('wks');
	var QObject = global_1.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var USE_SETTER = !QObject || !QObject[PROTOTYPE$1] || !QObject[PROTOTYPE$1].findChild;

	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDescriptor = descriptors && fails(function () {
	  return objectCreate(nativeDefineProperty$1({}, 'a', {
	    get: function () { return nativeDefineProperty$1(this, 'a', { value: 7 }).a; }
	  })).a != 7;
	}) ? function (O, P, Attributes) {
	  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor$2(ObjectPrototype$1, P);
	  if (ObjectPrototypeDescriptor) delete ObjectPrototype$1[P];
	  nativeDefineProperty$1(O, P, Attributes);
	  if (ObjectPrototypeDescriptor && O !== ObjectPrototype$1) {
	    nativeDefineProperty$1(ObjectPrototype$1, P, ObjectPrototypeDescriptor);
	  }
	} : nativeDefineProperty$1;

	var wrap = function (tag, description) {
	  var symbol = AllSymbols[tag] = objectCreate($Symbol[PROTOTYPE$1]);
	  setInternalState$5(symbol, {
	    type: SYMBOL,
	    tag: tag,
	    description: description
	  });
	  if (!descriptors) symbol.description = description;
	  return symbol;
	};

	var isSymbol = nativeSymbol && typeof $Symbol.iterator == 'symbol' ? function (it) {
	  return typeof it == 'symbol';
	} : function (it) {
	  return Object(it) instanceof $Symbol;
	};

	var $defineProperty = function defineProperty(O, P, Attributes) {
	  if (O === ObjectPrototype$1) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
	  anObject(O);
	  var key = toPrimitive(P, true);
	  anObject(Attributes);
	  if (has(AllSymbols, key)) {
	    if (!Attributes.enumerable) {
	      if (!has(O, HIDDEN)) nativeDefineProperty$1(O, HIDDEN, createPropertyDescriptor(1, {}));
	      O[HIDDEN][key] = true;
	    } else {
	      if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
	      Attributes = objectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
	    } return setSymbolDescriptor(O, key, Attributes);
	  } return nativeDefineProperty$1(O, key, Attributes);
	};

	var $defineProperties = function defineProperties(O, Properties) {
	  anObject(O);
	  var properties = toIndexedObject(Properties);
	  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
	  $forEach$1(keys, function (key) {
	    if (!descriptors || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);
	  });
	  return O;
	};

	var $create = function create(O, Properties) {
	  return Properties === undefined ? objectCreate(O) : $defineProperties(objectCreate(O), Properties);
	};

	var $propertyIsEnumerable = function propertyIsEnumerable(V) {
	  var P = toPrimitive(V, true);
	  var enumerable = nativePropertyIsEnumerable$1.call(this, P);
	  if (this === ObjectPrototype$1 && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false;
	  return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
	};

	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
	  var it = toIndexedObject(O);
	  var key = toPrimitive(P, true);
	  if (it === ObjectPrototype$1 && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;
	  var descriptor = nativeGetOwnPropertyDescriptor$2(it, key);
	  if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {
	    descriptor.enumerable = true;
	  }
	  return descriptor;
	};

	var $getOwnPropertyNames = function getOwnPropertyNames(O) {
	  var names = nativeGetOwnPropertyNames$1(toIndexedObject(O));
	  var result = [];
	  $forEach$1(names, function (key) {
	    if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);
	  });
	  return result;
	};

	var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
	  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype$1;
	  var names = nativeGetOwnPropertyNames$1(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
	  var result = [];
	  $forEach$1(names, function (key) {
	    if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype$1, key))) {
	      result.push(AllSymbols[key]);
	    }
	  });
	  return result;
	};

	// `Symbol` constructor
	// https://tc39.github.io/ecma262/#sec-symbol-constructor
	if (!nativeSymbol) {
	  $Symbol = function Symbol() {
	    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor');
	    var description = !arguments.length || arguments[0] === undefined ? undefined : String(arguments[0]);
	    var tag = uid(description);
	    var setter = function (value) {
	      if (this === ObjectPrototype$1) setter.call(ObjectPrototypeSymbols, value);
	      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
	      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
	    };
	    if (descriptors && USE_SETTER) setSymbolDescriptor(ObjectPrototype$1, tag, { configurable: true, set: setter });
	    return wrap(tag, description);
	  };

	  redefine($Symbol[PROTOTYPE$1], 'toString', function toString() {
	    return getInternalState$3(this).tag;
	  });

	  objectPropertyIsEnumerable.f = $propertyIsEnumerable;
	  objectDefineProperty.f = $defineProperty;
	  objectGetOwnPropertyDescriptor.f = $getOwnPropertyDescriptor;
	  objectGetOwnPropertyNames.f = objectGetOwnPropertyNamesExternal.f = $getOwnPropertyNames;
	  objectGetOwnPropertySymbols.f = $getOwnPropertySymbols;

	  if (descriptors) {
	    // https://github.com/tc39/proposal-Symbol-description
	    nativeDefineProperty$1($Symbol[PROTOTYPE$1], 'description', {
	      configurable: true,
	      get: function description() {
	        return getInternalState$3(this).description;
	      }
	    });
	  }
	}

	if (!useSymbolAsUid) {
	  wrappedWellKnownSymbol.f = function (name) {
	    return wrap(wellKnownSymbol(name), name);
	  };
	}

	_export({ global: true, wrap: true, forced: !nativeSymbol, sham: !nativeSymbol }, {
	  Symbol: $Symbol
	});

	$forEach$1(objectKeys(WellKnownSymbolsStore$1), function (name) {
	  defineWellKnownSymbol(name);
	});

	_export({ target: SYMBOL, stat: true, forced: !nativeSymbol }, {
	  // `Symbol.for` method
	  // https://tc39.github.io/ecma262/#sec-symbol.for
	  'for': function (key) {
	    var string = String(key);
	    if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
	    var symbol = $Symbol(string);
	    StringToSymbolRegistry[string] = symbol;
	    SymbolToStringRegistry[symbol] = string;
	    return symbol;
	  },
	  // `Symbol.keyFor` method
	  // https://tc39.github.io/ecma262/#sec-symbol.keyfor
	  keyFor: function keyFor(sym) {
	    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol');
	    if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
	  },
	  useSetter: function () { USE_SETTER = true; },
	  useSimple: function () { USE_SETTER = false; }
	});

	_export({ target: 'Object', stat: true, forced: !nativeSymbol, sham: !descriptors }, {
	  // `Object.create` method
	  // https://tc39.github.io/ecma262/#sec-object.create
	  create: $create,
	  // `Object.defineProperty` method
	  // https://tc39.github.io/ecma262/#sec-object.defineproperty
	  defineProperty: $defineProperty,
	  // `Object.defineProperties` method
	  // https://tc39.github.io/ecma262/#sec-object.defineproperties
	  defineProperties: $defineProperties,
	  // `Object.getOwnPropertyDescriptor` method
	  // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
	});

	_export({ target: 'Object', stat: true, forced: !nativeSymbol }, {
	  // `Object.getOwnPropertyNames` method
	  // https://tc39.github.io/ecma262/#sec-object.getownpropertynames
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // `Object.getOwnPropertySymbols` method
	  // https://tc39.github.io/ecma262/#sec-object.getownpropertysymbols
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});

	// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
	// https://bugs.chromium.org/p/v8/issues/detail?id=3443
	_export({ target: 'Object', stat: true, forced: fails(function () { objectGetOwnPropertySymbols.f(1); }) }, {
	  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
	    return objectGetOwnPropertySymbols.f(toObject(it));
	  }
	});

	// `JSON.stringify` method behavior with symbols
	// https://tc39.github.io/ecma262/#sec-json.stringify
	if ($stringify$1) {
	  var FORCED_JSON_STRINGIFY = !nativeSymbol || fails(function () {
	    var symbol = $Symbol();
	    // MS Edge converts symbol values to JSON as {}
	    return $stringify$1([symbol]) != '[null]'
	      // WebKit converts symbol values to JSON as null
	      || $stringify$1({ a: symbol }) != '{}'
	      // V8 throws on boxed symbols
	      || $stringify$1(Object(symbol)) != '{}';
	  });

	  _export({ target: 'JSON', stat: true, forced: FORCED_JSON_STRINGIFY }, {
	    // eslint-disable-next-line no-unused-vars
	    stringify: function stringify(it, replacer, space) {
	      var args = [it];
	      var index = 1;
	      var $replacer;
	      while (arguments.length > index) args.push(arguments[index++]);
	      $replacer = replacer;
	      if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
	      if (!isArray(replacer)) replacer = function (key, value) {
	        if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
	        if (!isSymbol(value)) return value;
	      };
	      args[1] = replacer;
	      return $stringify$1.apply(null, args);
	    }
	  });
	}

	// `Symbol.prototype[@@toPrimitive]` method
	// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@toprimitive
	if (!$Symbol[PROTOTYPE$1][TO_PRIMITIVE]) {
	  createNonEnumerableProperty($Symbol[PROTOTYPE$1], TO_PRIMITIVE, $Symbol[PROTOTYPE$1].valueOf);
	}
	// `Symbol.prototype[@@toStringTag]` property
	// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@tostringtag
	setToStringTag($Symbol, SYMBOL);

	hiddenKeys[HIDDEN] = true;

	// `Symbol.asyncIterator` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.asynciterator
	defineWellKnownSymbol('asyncIterator');

	// `Symbol.hasInstance` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.hasinstance
	defineWellKnownSymbol('hasInstance');

	// `Symbol.isConcatSpreadable` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.isconcatspreadable
	defineWellKnownSymbol('isConcatSpreadable');

	// `Symbol.match` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.match
	defineWellKnownSymbol('match');

	// `Symbol.matchAll` well-known symbol
	defineWellKnownSymbol('matchAll');

	// `Symbol.replace` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.replace
	defineWellKnownSymbol('replace');

	// `Symbol.search` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.search
	defineWellKnownSymbol('search');

	// `Symbol.species` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.species
	defineWellKnownSymbol('species');

	// `Symbol.split` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.split
	defineWellKnownSymbol('split');

	// `Symbol.toPrimitive` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.toprimitive
	defineWellKnownSymbol('toPrimitive');

	// `Symbol.toStringTag` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.tostringtag
	defineWellKnownSymbol('toStringTag');

	// `Symbol.unscopables` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.unscopables
	defineWellKnownSymbol('unscopables');

	// Math[@@toStringTag] property
	// https://tc39.github.io/ecma262/#sec-math-@@tostringtag
	setToStringTag(Math, 'Math', true);

	// JSON[@@toStringTag] property
	// https://tc39.github.io/ecma262/#sec-json-@@tostringtag
	setToStringTag(global_1.JSON, 'JSON', true);

	var symbol = path.Symbol;

	var symbol$1 = symbol;

	var symbol$2 = symbol$1;

	var bind$4 = function bind(fn, thisArg) {
	  return function wrap() {
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }
	    return fn.apply(thisArg, args);
	  };
	};

	/*!
	 * Determine if an object is a Buffer
	 *
	 * @author   Feross Aboukhadijeh <https://feross.org>
	 * @license  MIT
	 */

	var isBuffer = function isBuffer (obj) {
	  return obj != null && obj.constructor != null &&
	    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
	};

	/*global toString:true*/

	// utils is a library of generic helper functions non-specific to axios

	var toString$2 = Object.prototype.toString;

	/**
	 * Determine if a value is an Array
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an Array, otherwise false
	 */
	function isArray$4(val) {
	  return toString$2.call(val) === '[object Array]';
	}

	/**
	 * Determine if a value is an ArrayBuffer
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
	 */
	function isArrayBuffer(val) {
	  return toString$2.call(val) === '[object ArrayBuffer]';
	}

	/**
	 * Determine if a value is a FormData
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an FormData, otherwise false
	 */
	function isFormData(val) {
	  return (typeof FormData !== 'undefined') && (val instanceof FormData);
	}

	/**
	 * Determine if a value is a view on an ArrayBuffer
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
	 */
	function isArrayBufferView(val) {
	  var result;
	  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
	    result = ArrayBuffer.isView(val);
	  } else {
	    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
	  }
	  return result;
	}

	/**
	 * Determine if a value is a String
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a String, otherwise false
	 */
	function isString(val) {
	  return typeof val === 'string';
	}

	/**
	 * Determine if a value is a Number
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Number, otherwise false
	 */
	function isNumber(val) {
	  return typeof val === 'number';
	}

	/**
	 * Determine if a value is undefined
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if the value is undefined, otherwise false
	 */
	function isUndefined(val) {
	  return typeof val === 'undefined';
	}

	/**
	 * Determine if a value is an Object
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an Object, otherwise false
	 */
	function isObject$2(val) {
	  return val !== null && typeof val === 'object';
	}

	/**
	 * Determine if a value is a Date
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Date, otherwise false
	 */
	function isDate(val) {
	  return toString$2.call(val) === '[object Date]';
	}

	/**
	 * Determine if a value is a File
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a File, otherwise false
	 */
	function isFile(val) {
	  return toString$2.call(val) === '[object File]';
	}

	/**
	 * Determine if a value is a Blob
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Blob, otherwise false
	 */
	function isBlob(val) {
	  return toString$2.call(val) === '[object Blob]';
	}

	/**
	 * Determine if a value is a Function
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Function, otherwise false
	 */
	function isFunction(val) {
	  return toString$2.call(val) === '[object Function]';
	}

	/**
	 * Determine if a value is a Stream
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Stream, otherwise false
	 */
	function isStream(val) {
	  return isObject$2(val) && isFunction(val.pipe);
	}

	/**
	 * Determine if a value is a URLSearchParams object
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
	 */
	function isURLSearchParams(val) {
	  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
	}

	/**
	 * Trim excess whitespace off the beginning and end of a string
	 *
	 * @param {String} str The String to trim
	 * @returns {String} The String freed of excess whitespace
	 */
	function trim$4(str) {
	  return str.replace(/^\s*/, '').replace(/\s*$/, '');
	}

	/**
	 * Determine if we're running in a standard browser environment
	 *
	 * This allows axios to run in a web worker, and react-native.
	 * Both environments support XMLHttpRequest, but not fully standard globals.
	 *
	 * web workers:
	 *  typeof window -> undefined
	 *  typeof document -> undefined
	 *
	 * react-native:
	 *  navigator.product -> 'ReactNative'
	 * nativescript
	 *  navigator.product -> 'NativeScript' or 'NS'
	 */
	function isStandardBrowserEnv() {
	  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
	                                           navigator.product === 'NativeScript' ||
	                                           navigator.product === 'NS')) {
	    return false;
	  }
	  return (
	    typeof window !== 'undefined' &&
	    typeof document !== 'undefined'
	  );
	}

	/**
	 * Iterate over an Array or an Object invoking a function for each item.
	 *
	 * If `obj` is an Array callback will be called passing
	 * the value, index, and complete array for each item.
	 *
	 * If 'obj' is an Object callback will be called passing
	 * the value, key, and complete object for each property.
	 *
	 * @param {Object|Array} obj The object to iterate
	 * @param {Function} fn The callback to invoke for each item
	 */
	function forEach$4(obj, fn) {
	  // Don't bother if no value provided
	  if (obj === null || typeof obj === 'undefined') {
	    return;
	  }

	  // Force an array if not already something iterable
	  if (typeof obj !== 'object') {
	    /*eslint no-param-reassign:0*/
	    obj = [obj];
	  }

	  if (isArray$4(obj)) {
	    // Iterate over array values
	    for (var i = 0, l = obj.length; i < l; i++) {
	      fn.call(null, obj[i], i, obj);
	    }
	  } else {
	    // Iterate over object keys
	    for (var key in obj) {
	      if (Object.prototype.hasOwnProperty.call(obj, key)) {
	        fn.call(null, obj[key], key, obj);
	      }
	    }
	  }
	}

	/**
	 * Accepts varargs expecting each argument to be an object, then
	 * immutably merges the properties of each object and returns result.
	 *
	 * When multiple objects contain the same key the later object in
	 * the arguments list will take precedence.
	 *
	 * Example:
	 *
	 * ```js
	 * var result = merge({foo: 123}, {foo: 456});
	 * console.log(result.foo); // outputs 456
	 * ```
	 *
	 * @param {Object} obj1 Object to merge
	 * @returns {Object} Result of all merge properties
	 */
	function merge(/* obj1, obj2, obj3, ... */) {
	  var result = {};
	  function assignValue(val, key) {
	    if (typeof result[key] === 'object' && typeof val === 'object') {
	      result[key] = merge(result[key], val);
	    } else {
	      result[key] = val;
	    }
	  }

	  for (var i = 0, l = arguments.length; i < l; i++) {
	    forEach$4(arguments[i], assignValue);
	  }
	  return result;
	}

	/**
	 * Function equal to merge with the difference being that no reference
	 * to original objects is kept.
	 *
	 * @see merge
	 * @param {Object} obj1 Object to merge
	 * @returns {Object} Result of all merge properties
	 */
	function deepMerge(/* obj1, obj2, obj3, ... */) {
	  var result = {};
	  function assignValue(val, key) {
	    if (typeof result[key] === 'object' && typeof val === 'object') {
	      result[key] = deepMerge(result[key], val);
	    } else if (typeof val === 'object') {
	      result[key] = deepMerge({}, val);
	    } else {
	      result[key] = val;
	    }
	  }

	  for (var i = 0, l = arguments.length; i < l; i++) {
	    forEach$4(arguments[i], assignValue);
	  }
	  return result;
	}

	/**
	 * Extends object a by mutably adding to it the properties of object b.
	 *
	 * @param {Object} a The object to be extended
	 * @param {Object} b The object to copy properties from
	 * @param {Object} thisArg The object to bind function to
	 * @return {Object} The resulting value of object a
	 */
	function extend(a, b, thisArg) {
	  forEach$4(b, function assignValue(val, key) {
	    if (thisArg && typeof val === 'function') {
	      a[key] = bind$4(val, thisArg);
	    } else {
	      a[key] = val;
	    }
	  });
	  return a;
	}

	var utils = {
	  isArray: isArray$4,
	  isArrayBuffer: isArrayBuffer,
	  isBuffer: isBuffer,
	  isFormData: isFormData,
	  isArrayBufferView: isArrayBufferView,
	  isString: isString,
	  isNumber: isNumber,
	  isObject: isObject$2,
	  isUndefined: isUndefined,
	  isDate: isDate,
	  isFile: isFile,
	  isBlob: isBlob,
	  isFunction: isFunction,
	  isStream: isStream,
	  isURLSearchParams: isURLSearchParams,
	  isStandardBrowserEnv: isStandardBrowserEnv,
	  forEach: forEach$4,
	  merge: merge,
	  deepMerge: deepMerge,
	  extend: extend,
	  trim: trim$4
	};

	function encode(val) {
	  return encodeURIComponent(val).
	    replace(/%40/gi, '@').
	    replace(/%3A/gi, ':').
	    replace(/%24/g, '$').
	    replace(/%2C/gi, ',').
	    replace(/%20/g, '+').
	    replace(/%5B/gi, '[').
	    replace(/%5D/gi, ']');
	}

	/**
	 * Build a URL by appending params to the end
	 *
	 * @param {string} url The base of the url (e.g., http://www.google.com)
	 * @param {object} [params] The params to be appended
	 * @returns {string} The formatted url
	 */
	var buildURL = function buildURL(url, params, paramsSerializer) {
	  /*eslint no-param-reassign:0*/
	  if (!params) {
	    return url;
	  }

	  var serializedParams;
	  if (paramsSerializer) {
	    serializedParams = paramsSerializer(params);
	  } else if (utils.isURLSearchParams(params)) {
	    serializedParams = params.toString();
	  } else {
	    var parts = [];

	    utils.forEach(params, function serialize(val, key) {
	      if (val === null || typeof val === 'undefined') {
	        return;
	      }

	      if (utils.isArray(val)) {
	        key = key + '[]';
	      } else {
	        val = [val];
	      }

	      utils.forEach(val, function parseValue(v) {
	        if (utils.isDate(v)) {
	          v = v.toISOString();
	        } else if (utils.isObject(v)) {
	          v = JSON.stringify(v);
	        }
	        parts.push(encode(key) + '=' + encode(v));
	      });
	    });

	    serializedParams = parts.join('&');
	  }

	  if (serializedParams) {
	    var hashmarkIndex = url.indexOf('#');
	    if (hashmarkIndex !== -1) {
	      url = url.slice(0, hashmarkIndex);
	    }

	    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
	  }

	  return url;
	};

	function InterceptorManager() {
	  this.handlers = [];
	}

	/**
	 * Add a new interceptor to the stack
	 *
	 * @param {Function} fulfilled The function to handle `then` for a `Promise`
	 * @param {Function} rejected The function to handle `reject` for a `Promise`
	 *
	 * @return {Number} An ID used to remove interceptor later
	 */
	InterceptorManager.prototype.use = function use(fulfilled, rejected) {
	  this.handlers.push({
	    fulfilled: fulfilled,
	    rejected: rejected
	  });
	  return this.handlers.length - 1;
	};

	/**
	 * Remove an interceptor from the stack
	 *
	 * @param {Number} id The ID that was returned by `use`
	 */
	InterceptorManager.prototype.eject = function eject(id) {
	  if (this.handlers[id]) {
	    this.handlers[id] = null;
	  }
	};

	/**
	 * Iterate over all the registered interceptors
	 *
	 * This method is particularly useful for skipping over any
	 * interceptors that may have become `null` calling `eject`.
	 *
	 * @param {Function} fn The function to call for each interceptor
	 */
	InterceptorManager.prototype.forEach = function forEach(fn) {
	  utils.forEach(this.handlers, function forEachHandler(h) {
	    if (h !== null) {
	      fn(h);
	    }
	  });
	};

	var InterceptorManager_1 = InterceptorManager;

	/**
	 * Transform the data for a request or a response
	 *
	 * @param {Object|String} data The data to be transformed
	 * @param {Array} headers The headers for the request or response
	 * @param {Array|Function} fns A single function or Array of functions
	 * @returns {*} The resulting transformed data
	 */
	var transformData = function transformData(data, headers, fns) {
	  /*eslint no-param-reassign:0*/
	  utils.forEach(fns, function transform(fn) {
	    data = fn(data, headers);
	  });

	  return data;
	};

	var isCancel = function isCancel(value) {
	  return !!(value && value.__CANCEL__);
	};

	var normalizeHeaderName = function normalizeHeaderName(headers, normalizedName) {
	  utils.forEach(headers, function processHeader(value, name) {
	    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
	      headers[normalizedName] = value;
	      delete headers[name];
	    }
	  });
	};

	/**
	 * Update an Error with the specified config, error code, and response.
	 *
	 * @param {Error} error The error to update.
	 * @param {Object} config The config.
	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
	 * @param {Object} [request] The request.
	 * @param {Object} [response] The response.
	 * @returns {Error} The error.
	 */
	var enhanceError = function enhanceError(error, config, code, request, response) {
	  error.config = config;
	  if (code) {
	    error.code = code;
	  }

	  error.request = request;
	  error.response = response;
	  error.isAxiosError = true;

	  error.toJSON = function() {
	    return {
	      // Standard
	      message: this.message,
	      name: this.name,
	      // Microsoft
	      description: this.description,
	      number: this.number,
	      // Mozilla
	      fileName: this.fileName,
	      lineNumber: this.lineNumber,
	      columnNumber: this.columnNumber,
	      stack: this.stack,
	      // Axios
	      config: this.config,
	      code: this.code
	    };
	  };
	  return error;
	};

	/**
	 * Create an Error with the specified message, config, error code, request and response.
	 *
	 * @param {string} message The error message.
	 * @param {Object} config The config.
	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
	 * @param {Object} [request] The request.
	 * @param {Object} [response] The response.
	 * @returns {Error} The created error.
	 */
	var createError = function createError(message, config, code, request, response) {
	  var error = new Error(message);
	  return enhanceError(error, config, code, request, response);
	};

	/**
	 * Resolve or reject a Promise based on response status.
	 *
	 * @param {Function} resolve A function that resolves the promise.
	 * @param {Function} reject A function that rejects the promise.
	 * @param {object} response The response.
	 */
	var settle = function settle(resolve, reject, response) {
	  var validateStatus = response.config.validateStatus;
	  if (!validateStatus || validateStatus(response.status)) {
	    resolve(response);
	  } else {
	    reject(createError(
	      'Request failed with status code ' + response.status,
	      response.config,
	      null,
	      response.request,
	      response
	    ));
	  }
	};

	// Headers whose duplicates are ignored by node
	// c.f. https://nodejs.org/api/http.html#http_message_headers
	var ignoreDuplicateOf = [
	  'age', 'authorization', 'content-length', 'content-type', 'etag',
	  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
	  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
	  'referer', 'retry-after', 'user-agent'
	];

	/**
	 * Parse headers into an object
	 *
	 * ```
	 * Date: Wed, 27 Aug 2014 08:58:49 GMT
	 * Content-Type: application/json
	 * Connection: keep-alive
	 * Transfer-Encoding: chunked
	 * ```
	 *
	 * @param {String} headers Headers needing to be parsed
	 * @returns {Object} Headers parsed into an object
	 */
	var parseHeaders = function parseHeaders(headers) {
	  var parsed = {};
	  var key;
	  var val;
	  var i;

	  if (!headers) { return parsed; }

	  utils.forEach(headers.split('\n'), function parser(line) {
	    i = line.indexOf(':');
	    key = utils.trim(line.substr(0, i)).toLowerCase();
	    val = utils.trim(line.substr(i + 1));

	    if (key) {
	      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
	        return;
	      }
	      if (key === 'set-cookie') {
	        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
	      } else {
	        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
	      }
	    }
	  });

	  return parsed;
	};

	var isURLSameOrigin = (
	  utils.isStandardBrowserEnv() ?

	  // Standard browser envs have full support of the APIs needed to test
	  // whether the request URL is of the same origin as current location.
	    (function standardBrowserEnv() {
	      var msie = /(msie|trident)/i.test(navigator.userAgent);
	      var urlParsingNode = document.createElement('a');
	      var originURL;

	      /**
	    * Parse a URL to discover it's components
	    *
	    * @param {String} url The URL to be parsed
	    * @returns {Object}
	    */
	      function resolveURL(url) {
	        var href = url;

	        if (msie) {
	        // IE needs attribute set twice to normalize properties
	          urlParsingNode.setAttribute('href', href);
	          href = urlParsingNode.href;
	        }

	        urlParsingNode.setAttribute('href', href);

	        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
	        return {
	          href: urlParsingNode.href,
	          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
	          host: urlParsingNode.host,
	          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
	          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
	          hostname: urlParsingNode.hostname,
	          port: urlParsingNode.port,
	          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
	            urlParsingNode.pathname :
	            '/' + urlParsingNode.pathname
	        };
	      }

	      originURL = resolveURL(window.location.href);

	      /**
	    * Determine if a URL shares the same origin as the current location
	    *
	    * @param {String} requestURL The URL to test
	    * @returns {boolean} True if URL shares the same origin, otherwise false
	    */
	      return function isURLSameOrigin(requestURL) {
	        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
	        return (parsed.protocol === originURL.protocol &&
	            parsed.host === originURL.host);
	      };
	    })() :

	  // Non standard browser envs (web workers, react-native) lack needed support.
	    (function nonStandardBrowserEnv() {
	      return function isURLSameOrigin() {
	        return true;
	      };
	    })()
	);

	var cookies = (
	  utils.isStandardBrowserEnv() ?

	  // Standard browser envs support document.cookie
	    (function standardBrowserEnv() {
	      return {
	        write: function write(name, value, expires, path, domain, secure) {
	          var cookie = [];
	          cookie.push(name + '=' + encodeURIComponent(value));

	          if (utils.isNumber(expires)) {
	            cookie.push('expires=' + new Date(expires).toGMTString());
	          }

	          if (utils.isString(path)) {
	            cookie.push('path=' + path);
	          }

	          if (utils.isString(domain)) {
	            cookie.push('domain=' + domain);
	          }

	          if (secure === true) {
	            cookie.push('secure');
	          }

	          document.cookie = cookie.join('; ');
	        },

	        read: function read(name) {
	          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
	          return (match ? decodeURIComponent(match[3]) : null);
	        },

	        remove: function remove(name) {
	          this.write(name, '', Date.now() - 86400000);
	        }
	      };
	    })() :

	  // Non standard browser env (web workers, react-native) lack needed support.
	    (function nonStandardBrowserEnv() {
	      return {
	        write: function write() {},
	        read: function read() { return null; },
	        remove: function remove() {}
	      };
	    })()
	);

	var xhr = function xhrAdapter(config) {
	  return new Promise(function dispatchXhrRequest(resolve, reject) {
	    var requestData = config.data;
	    var requestHeaders = config.headers;

	    if (utils.isFormData(requestData)) {
	      delete requestHeaders['Content-Type']; // Let the browser set it
	    }

	    var request = new XMLHttpRequest();

	    // HTTP basic authentication
	    if (config.auth) {
	      var username = config.auth.username || '';
	      var password = config.auth.password || '';
	      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
	    }

	    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);

	    // Set the request timeout in MS
	    request.timeout = config.timeout;

	    // Listen for ready state
	    request.onreadystatechange = function handleLoad() {
	      if (!request || request.readyState !== 4) {
	        return;
	      }

	      // The request errored out and we didn't get a response, this will be
	      // handled by onerror instead
	      // With one exception: request that using file: protocol, most browsers
	      // will return status as 0 even though it's a successful request
	      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
	        return;
	      }

	      // Prepare the response
	      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
	      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
	      var response = {
	        data: responseData,
	        status: request.status,
	        statusText: request.statusText,
	        headers: responseHeaders,
	        config: config,
	        request: request
	      };

	      settle(resolve, reject, response);

	      // Clean up request
	      request = null;
	    };

	    // Handle browser request cancellation (as opposed to a manual cancellation)
	    request.onabort = function handleAbort() {
	      if (!request) {
	        return;
	      }

	      reject(createError('Request aborted', config, 'ECONNABORTED', request));

	      // Clean up request
	      request = null;
	    };

	    // Handle low level network errors
	    request.onerror = function handleError() {
	      // Real errors are hidden from us by the browser
	      // onerror should only fire if it's a network error
	      reject(createError('Network Error', config, null, request));

	      // Clean up request
	      request = null;
	    };

	    // Handle timeout
	    request.ontimeout = function handleTimeout() {
	      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED',
	        request));

	      // Clean up request
	      request = null;
	    };

	    // Add xsrf header
	    // This is only done if running in a standard browser environment.
	    // Specifically not if we're in a web worker, or react-native.
	    if (utils.isStandardBrowserEnv()) {
	      var cookies$1 = cookies;

	      // Add xsrf header
	      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?
	        cookies$1.read(config.xsrfCookieName) :
	        undefined;

	      if (xsrfValue) {
	        requestHeaders[config.xsrfHeaderName] = xsrfValue;
	      }
	    }

	    // Add headers to the request
	    if ('setRequestHeader' in request) {
	      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
	        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
	          // Remove Content-Type if data is undefined
	          delete requestHeaders[key];
	        } else {
	          // Otherwise add header to the request
	          request.setRequestHeader(key, val);
	        }
	      });
	    }

	    // Add withCredentials to request if needed
	    if (config.withCredentials) {
	      request.withCredentials = true;
	    }

	    // Add responseType to request if needed
	    if (config.responseType) {
	      try {
	        request.responseType = config.responseType;
	      } catch (e) {
	        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
	        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
	        if (config.responseType !== 'json') {
	          throw e;
	        }
	      }
	    }

	    // Handle progress if needed
	    if (typeof config.onDownloadProgress === 'function') {
	      request.addEventListener('progress', config.onDownloadProgress);
	    }

	    // Not all browsers support upload events
	    if (typeof config.onUploadProgress === 'function' && request.upload) {
	      request.upload.addEventListener('progress', config.onUploadProgress);
	    }

	    if (config.cancelToken) {
	      // Handle cancellation
	      config.cancelToken.promise.then(function onCanceled(cancel) {
	        if (!request) {
	          return;
	        }

	        request.abort();
	        reject(cancel);
	        // Clean up request
	        request = null;
	      });
	    }

	    if (requestData === undefined) {
	      requestData = null;
	    }

	    // Send the request
	    request.send(requestData);
	  });
	};

	var DEFAULT_CONTENT_TYPE = {
	  'Content-Type': 'application/x-www-form-urlencoded'
	};

	function setContentTypeIfUnset(headers, value) {
	  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
	    headers['Content-Type'] = value;
	  }
	}

	function getDefaultAdapter() {
	  var adapter;
	  // Only Node.JS has a process variable that is of [[Class]] process
	  if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
	    // For node use HTTP adapter
	    adapter = xhr;
	  } else if (typeof XMLHttpRequest !== 'undefined') {
	    // For browsers use XHR adapter
	    adapter = xhr;
	  }
	  return adapter;
	}

	var defaults = {
	  adapter: getDefaultAdapter(),

	  transformRequest: [function transformRequest(data, headers) {
	    normalizeHeaderName(headers, 'Accept');
	    normalizeHeaderName(headers, 'Content-Type');
	    if (utils.isFormData(data) ||
	      utils.isArrayBuffer(data) ||
	      utils.isBuffer(data) ||
	      utils.isStream(data) ||
	      utils.isFile(data) ||
	      utils.isBlob(data)
	    ) {
	      return data;
	    }
	    if (utils.isArrayBufferView(data)) {
	      return data.buffer;
	    }
	    if (utils.isURLSearchParams(data)) {
	      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
	      return data.toString();
	    }
	    if (utils.isObject(data)) {
	      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
	      return JSON.stringify(data);
	    }
	    return data;
	  }],

	  transformResponse: [function transformResponse(data) {
	    /*eslint no-param-reassign:0*/
	    if (typeof data === 'string') {
	      try {
	        data = JSON.parse(data);
	      } catch (e) { /* Ignore */ }
	    }
	    return data;
	  }],

	  /**
	   * A timeout in milliseconds to abort a request. If set to 0 (default) a
	   * timeout is not created.
	   */
	  timeout: 0,

	  xsrfCookieName: 'XSRF-TOKEN',
	  xsrfHeaderName: 'X-XSRF-TOKEN',

	  maxContentLength: -1,

	  validateStatus: function validateStatus(status) {
	    return status >= 200 && status < 300;
	  }
	};

	defaults.headers = {
	  common: {
	    'Accept': 'application/json, text/plain, */*'
	  }
	};

	utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
	  defaults.headers[method] = {};
	});

	utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
	  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
	});

	var defaults_1 = defaults;

	/**
	 * Determines whether the specified URL is absolute
	 *
	 * @param {string} url The URL to test
	 * @returns {boolean} True if the specified URL is absolute, otherwise false
	 */
	var isAbsoluteURL = function isAbsoluteURL(url) {
	  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
	  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
	  // by any combination of letters, digits, plus, period, or hyphen.
	  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
	};

	/**
	 * Creates a new URL by combining the specified URLs
	 *
	 * @param {string} baseURL The base URL
	 * @param {string} relativeURL The relative URL
	 * @returns {string} The combined URL
	 */
	var combineURLs = function combineURLs(baseURL, relativeURL) {
	  return relativeURL
	    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
	    : baseURL;
	};

	/**
	 * Throws a `Cancel` if cancellation has been requested.
	 */
	function throwIfCancellationRequested(config) {
	  if (config.cancelToken) {
	    config.cancelToken.throwIfRequested();
	  }
	}

	/**
	 * Dispatch a request to the server using the configured adapter.
	 *
	 * @param {object} config The config that is to be used for the request
	 * @returns {Promise} The Promise to be fulfilled
	 */
	var dispatchRequest = function dispatchRequest(config) {
	  throwIfCancellationRequested(config);

	  // Support baseURL config
	  if (config.baseURL && !isAbsoluteURL(config.url)) {
	    config.url = combineURLs(config.baseURL, config.url);
	  }

	  // Ensure headers exist
	  config.headers = config.headers || {};

	  // Transform request data
	  config.data = transformData(
	    config.data,
	    config.headers,
	    config.transformRequest
	  );

	  // Flatten headers
	  config.headers = utils.merge(
	    config.headers.common || {},
	    config.headers[config.method] || {},
	    config.headers || {}
	  );

	  utils.forEach(
	    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
	    function cleanHeaderConfig(method) {
	      delete config.headers[method];
	    }
	  );

	  var adapter = config.adapter || defaults_1.adapter;

	  return adapter(config).then(function onAdapterResolution(response) {
	    throwIfCancellationRequested(config);

	    // Transform response data
	    response.data = transformData(
	      response.data,
	      response.headers,
	      config.transformResponse
	    );

	    return response;
	  }, function onAdapterRejection(reason) {
	    if (!isCancel(reason)) {
	      throwIfCancellationRequested(config);

	      // Transform response data
	      if (reason && reason.response) {
	        reason.response.data = transformData(
	          reason.response.data,
	          reason.response.headers,
	          config.transformResponse
	        );
	      }
	    }

	    return Promise.reject(reason);
	  });
	};

	/**
	 * Config-specific merge-function which creates a new config-object
	 * by merging two configuration objects together.
	 *
	 * @param {Object} config1
	 * @param {Object} config2
	 * @returns {Object} New object resulting from merging config2 to config1
	 */
	var mergeConfig = function mergeConfig(config1, config2) {
	  // eslint-disable-next-line no-param-reassign
	  config2 = config2 || {};
	  var config = {};

	  utils.forEach(['url', 'method', 'params', 'data'], function valueFromConfig2(prop) {
	    if (typeof config2[prop] !== 'undefined') {
	      config[prop] = config2[prop];
	    }
	  });

	  utils.forEach(['headers', 'auth', 'proxy'], function mergeDeepProperties(prop) {
	    if (utils.isObject(config2[prop])) {
	      config[prop] = utils.deepMerge(config1[prop], config2[prop]);
	    } else if (typeof config2[prop] !== 'undefined') {
	      config[prop] = config2[prop];
	    } else if (utils.isObject(config1[prop])) {
	      config[prop] = utils.deepMerge(config1[prop]);
	    } else if (typeof config1[prop] !== 'undefined') {
	      config[prop] = config1[prop];
	    }
	  });

	  utils.forEach([
	    'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',
	    'timeout', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
	    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'maxContentLength',
	    'validateStatus', 'maxRedirects', 'httpAgent', 'httpsAgent', 'cancelToken',
	    'socketPath'
	  ], function defaultToConfig2(prop) {
	    if (typeof config2[prop] !== 'undefined') {
	      config[prop] = config2[prop];
	    } else if (typeof config1[prop] !== 'undefined') {
	      config[prop] = config1[prop];
	    }
	  });

	  return config;
	};

	/**
	 * Create a new instance of Axios
	 *
	 * @param {Object} instanceConfig The default config for the instance
	 */
	function Axios(instanceConfig) {
	  this.defaults = instanceConfig;
	  this.interceptors = {
	    request: new InterceptorManager_1(),
	    response: new InterceptorManager_1()
	  };
	}

	/**
	 * Dispatch a request
	 *
	 * @param {Object} config The config specific for this request (merged with this.defaults)
	 */
	Axios.prototype.request = function request(config) {
	  /*eslint no-param-reassign:0*/
	  // Allow for axios('example/url'[, config]) a la fetch API
	  if (typeof config === 'string') {
	    config = arguments[1] || {};
	    config.url = arguments[0];
	  } else {
	    config = config || {};
	  }

	  config = mergeConfig(this.defaults, config);
	  config.method = config.method ? config.method.toLowerCase() : 'get';

	  // Hook up interceptors middleware
	  var chain = [dispatchRequest, undefined];
	  var promise = Promise.resolve(config);

	  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
	    chain.unshift(interceptor.fulfilled, interceptor.rejected);
	  });

	  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
	    chain.push(interceptor.fulfilled, interceptor.rejected);
	  });

	  while (chain.length) {
	    promise = promise.then(chain.shift(), chain.shift());
	  }

	  return promise;
	};

	Axios.prototype.getUri = function getUri(config) {
	  config = mergeConfig(this.defaults, config);
	  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
	};

	// Provide aliases for supported request methods
	utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
	  /*eslint func-names:0*/
	  Axios.prototype[method] = function(url, config) {
	    return this.request(utils.merge(config || {}, {
	      method: method,
	      url: url
	    }));
	  };
	});

	utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
	  /*eslint func-names:0*/
	  Axios.prototype[method] = function(url, data, config) {
	    return this.request(utils.merge(config || {}, {
	      method: method,
	      url: url,
	      data: data
	    }));
	  };
	});

	var Axios_1 = Axios;

	/**
	 * A `Cancel` is an object that is thrown when an operation is canceled.
	 *
	 * @class
	 * @param {string=} message The message.
	 */
	function Cancel(message) {
	  this.message = message;
	}

	Cancel.prototype.toString = function toString() {
	  return 'Cancel' + (this.message ? ': ' + this.message : '');
	};

	Cancel.prototype.__CANCEL__ = true;

	var Cancel_1 = Cancel;

	/**
	 * A `CancelToken` is an object that can be used to request cancellation of an operation.
	 *
	 * @class
	 * @param {Function} executor The executor function.
	 */
	function CancelToken(executor) {
	  if (typeof executor !== 'function') {
	    throw new TypeError('executor must be a function.');
	  }

	  var resolvePromise;
	  this.promise = new Promise(function promiseExecutor(resolve) {
	    resolvePromise = resolve;
	  });

	  var token = this;
	  executor(function cancel(message) {
	    if (token.reason) {
	      // Cancellation has already been requested
	      return;
	    }

	    token.reason = new Cancel_1(message);
	    resolvePromise(token.reason);
	  });
	}

	/**
	 * Throws a `Cancel` if cancellation has been requested.
	 */
	CancelToken.prototype.throwIfRequested = function throwIfRequested() {
	  if (this.reason) {
	    throw this.reason;
	  }
	};

	/**
	 * Returns an object that contains a new `CancelToken` and a function that, when called,
	 * cancels the `CancelToken`.
	 */
	CancelToken.source = function source() {
	  var cancel;
	  var token = new CancelToken(function executor(c) {
	    cancel = c;
	  });
	  return {
	    token: token,
	    cancel: cancel
	  };
	};

	var CancelToken_1 = CancelToken;

	/**
	 * Syntactic sugar for invoking a function and expanding an array for arguments.
	 *
	 * Common use case would be to use `Function.prototype.apply`.
	 *
	 *  ```js
	 *  function f(x, y, z) {}
	 *  var args = [1, 2, 3];
	 *  f.apply(null, args);
	 *  ```
	 *
	 * With `spread` this example can be re-written.
	 *
	 *  ```js
	 *  spread(function(x, y, z) {})([1, 2, 3]);
	 *  ```
	 *
	 * @param {Function} callback
	 * @returns {Function}
	 */
	var spread = function spread(callback) {
	  return function wrap(arr) {
	    return callback.apply(null, arr);
	  };
	};

	/**
	 * Create an instance of Axios
	 *
	 * @param {Object} defaultConfig The default config for the instance
	 * @return {Axios} A new instance of Axios
	 */
	function createInstance(defaultConfig) {
	  var context = new Axios_1(defaultConfig);
	  var instance = bind$4(Axios_1.prototype.request, context);

	  // Copy axios.prototype to instance
	  utils.extend(instance, Axios_1.prototype, context);

	  // Copy context to instance
	  utils.extend(instance, context);

	  return instance;
	}

	// Create the default instance to be exported
	var axios = createInstance(defaults_1);

	// Expose Axios class to allow class inheritance
	axios.Axios = Axios_1;

	// Factory for creating new instances
	axios.create = function create(instanceConfig) {
	  return createInstance(mergeConfig(axios.defaults, instanceConfig));
	};

	// Expose Cancel & CancelToken
	axios.Cancel = Cancel_1;
	axios.CancelToken = CancelToken_1;
	axios.isCancel = isCancel;

	// Expose all/spread
	axios.all = function all(promises) {
	  return Promise.all(promises);
	};
	axios.spread = spread;

	var axios_1 = axios;

	// Allow use of default import syntax in TypeScript
	var _default = axios;
	axios_1.default = _default;

	var axios$1 = axios_1;

	var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = promise$3))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var __generator = undefined && undefined.__generator || function (thisArg, body) {
	  var _ = {
	    label: 0,
	    sent: function () {
	      if (t[0] & 1) throw t[1];
	      return t[1];
	    },
	    trys: [],
	    ops: []
	  },
	      f,
	      y,
	      t,
	      g;
	  return g = {
	    next: verb(0),
	    "throw": verb(1),
	    "return": verb(2)
	  }, typeof symbol$2 === "function" && (g[iterator$2] = function () {
	    return this;
	  }), g;

	  function verb(n) {
	    return function (v) {
	      return step([n, v]);
	    };
	  }

	  function step(op) {
	    if (f) throw new TypeError("Generator is already executing.");

	    while (_) try {
	      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	      if (y = 0, t) op = [op[0] & 2, t.value];

	      switch (op[0]) {
	        case 0:
	        case 1:
	          t = op;
	          break;

	        case 4:
	          _.label++;
	          return {
	            value: op[1],
	            done: false
	          };

	        case 5:
	          _.label++;
	          y = op[1];
	          op = [0];
	          continue;

	        case 7:
	          op = _.ops.pop();

	          _.trys.pop();

	          continue;

	        default:
	          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
	            _ = 0;
	            continue;
	          }

	          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
	            _.label = op[1];
	            break;
	          }

	          if (op[0] === 6 && _.label < t[1]) {
	            _.label = t[1];
	            t = op;
	            break;
	          }

	          if (t && _.label < t[2]) {
	            _.label = t[2];

	            _.ops.push(op);

	            break;
	          }

	          if (t[2]) _.ops.pop();

	          _.trys.pop();

	          continue;
	      }

	      op = body.call(thisArg, _);
	    } catch (e) {
	      op = [6, e];
	      y = 0;
	    } finally {
	      f = t = 0;
	    }

	    if (op[0] & 5) throw op[1];
	    return {
	      value: op[0] ? op[1] : void 0,
	      done: true
	    };
	  }
	};

	function getTimestamp() {
	  var date = new Date();
	  return date.toTimeString().split(" ")[0] + ":" + date.getMilliseconds();
	}

	var logLevelMap = {
	  DEBUG: 0,
	  INFO: 1,
	  WARNING: 2,
	  ERROR: 3,
	  NONE: 4
	};

	var getLevelName = function (level) {
	  for (var key in logLevelMap) {
	    if (logLevelMap[key] === level) {
	      return key;
	    }
	  }

	  return "DEFAULT";
	};
	/**
	 * 控制 SDK 日志输出的对象，可以通过全局的 `Logger` 对象获取
	 */


	var AgoraLogger =
	/** @class */
	function () {
	  /** @internal */
	  function AgoraLogger() {
	    this.logLevel = logLevelMap.DEBUG;
	    /** 等待上传的 log 数据 */

	    this.uploadLogWaitingList = [];
	    /** 正在上传的 log 数据，为空表示没有正在上传的 log 数据 */

	    this.uploadLogUploadingList = [];
	    /** 连续上传失败的次数 */

	    this.uploadErrorCount = 0;
	    /**
	     * 累加的 log id，用于 log 上报
	     */

	    this.currentLogID = 0;
	  }
	  /** @internal */


	  AgoraLogger.prototype.debug = function () {
	    var _context;

	    var args = [];

	    for (var _i = 0; _i < arguments.length; _i++) {
	      args[_i] = arguments[_i];
	    }

	    var argsWithLevel = concat$2(_context = [logLevelMap.DEBUG]).call(_context, args);

	    this.log.apply(this, argsWithLevel);
	  };
	  /** @internal */


	  AgoraLogger.prototype.info = function () {
	    var _context2;

	    var args = [];

	    for (var _i = 0; _i < arguments.length; _i++) {
	      args[_i] = arguments[_i];
	    }

	    var argsWithLevel = concat$2(_context2 = [logLevelMap.INFO]).call(_context2, args);

	    this.log.apply(this, argsWithLevel);
	  };
	  /** @internal */


	  AgoraLogger.prototype.warning = function () {
	    var _context3;

	    var args = [];

	    for (var _i = 0; _i < arguments.length; _i++) {
	      args[_i] = arguments[_i];
	    }

	    var argsWithLevel = concat$2(_context3 = [logLevelMap.WARNING]).call(_context3, args);

	    this.log.apply(this, argsWithLevel);
	  };
	  /** @internal */


	  AgoraLogger.prototype.error = function () {
	    var _context4;

	    var args = [];

	    for (var _i = 0; _i < arguments.length; _i++) {
	      args[_i] = arguments[_i];
	    }

	    var argsWithLevel = concat$2(_context4 = [logLevelMap.ERROR]).call(_context4, args);

	    this.log.apply(this, argsWithLevel);
	  };
	  /**
	   * 设置 SDK 的日志输出级别
	   * @param level - SDK 日志级别依次为 NONE(4)，ERROR(3)，WARNING(2)，INFO(1)，DEBUG(0)。选择一个级别，
	   * 你就可以看到在该级别及该级别以上所有级别的日志信息。
	   *
	   * 例如，如果你输入代码 AgoraRTC.Logger.setLogLevel(1);，就可以看到 INFO，ERROR 和 WARNING 级别的日志信息。
	   */


	  AgoraLogger.prototype.setLogLevel = function (level) {
	    level = Math.min(Math.max(0, level), 4);
	    this.logLevel = level;
	  };
	  /**
	   * 调用本方法开启日志上传。开启后 SDK 的日志会上传到 Agora 的服务器。
	   *
	   * 日志上传功能默认为关闭状态，如果你需要开启此功能，请确保在所有方法之前调用本方法。
	   *
	   * **Note:** 如果没有成功加入频道，则服务器上无法查看日志信息。
	   */


	  AgoraLogger.prototype.enableLogUpload = function () {
	    setParameter("UPLOAD_LOG", true);
	  };
	  /**
	   * 该方法用于关闭日志上传。
	   *
	   * 日志上传默认是关闭状态，如果你调用了开启日志上传（[enableLogUpload]{@link IAgoraLogger.enableLogUpload})，可以通过本方法停止上传日志。
	   */


	  AgoraLogger.prototype.disableLogUpload = function () {
	    setParameter("UPLOAD_LOG", false); // 清空日志上传的缓存列表

	    this.uploadLogUploadingList = [];
	    this.uploadLogWaitingList = [];
	  };
	  /** @internal */


	  AgoraLogger.prototype.setProxyServer = function (proxyServerURL) {
	    this.proxyServerURL = proxyServerURL;
	  };

	  AgoraLogger.prototype.log = function () {
	    var _context5, _context6, _context7, _context8;

	    var args = [];

	    for (var _i = 0; _i < arguments.length; _i++) {
	      args[_i] = arguments[_i];
	    }

	    var level = Math.max(0, Math.min(4, args[0]));
	    args[0] = getTimestamp() + (" Agora-SDK [" + getLevelName(level) + "]:");
	    this.appendLogToWaitingList(level, args);
	    if (level < this.logLevel) return;
	    var prefix = getTimestamp() + (" %cAgora-SDK [" + getLevelName(level) + "]:");
	    var argsWithStyle = [];

	    switch (level) {
	      case logLevelMap.DEBUG:
	        argsWithStyle = concat$2(_context5 = [prefix, "color: #64B5F6;"]).call(_context5, slice$2(args).call(args, 1));
	        console.log.apply(console, argsWithStyle);
	        break;

	      case logLevelMap.INFO:
	        argsWithStyle = concat$2(_context6 = [prefix, "color: #1E88E5; font-weight: bold;"]).call(_context6, slice$2(args).call(args, 1));
	        console.log.apply(console, argsWithStyle);
	        break;

	      case logLevelMap.WARNING:
	        argsWithStyle = concat$2(_context7 = [prefix, "color: #FB8C00; font-weight: bold;"]).call(_context7, slice$2(args).call(args, 1));
	        console.warn.apply(console, argsWithStyle);
	        break;

	      case logLevelMap.ERROR:
	        argsWithStyle = concat$2(_context8 = [prefix, "color: #B00020; font-weight: bold;"]).call(_context8, slice$2(args).call(args, 1));
	        console.error.apply(console, argsWithStyle);
	        break;
	    }
	  };

	  AgoraLogger.prototype.appendLogToWaitingList = function (level) {
	    var args = [];

	    for (var _i = 1; _i < arguments.length; _i++) {
	      args[_i - 1] = arguments[_i];
	    }

	    if (!getParameter("UPLOAD_LOG")) return;
	    var payload = "";

	    forEach$3(args).call(args, function (arg) {
	      if (typeof arg === "object") {
	        arg = stringify$2(arg);
	      }

	      payload += arg + " ";
	    });

	    this.uploadLogWaitingList.push({
	      payload_str: payload,
	      log_level: level,
	      log_item_id: this.currentLogID++
	    });

	    if (this.uploadLogUploadingList.length === 0) {
	      this.uploadLogInterval();
	    }
	  };

	  AgoraLogger.prototype.uploadLogs = function () {
	    return __awaiter(this, void 0, void 0, function () {
	      var logs, uploadData, res, err;
	      return __generator(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            logs = this.uploadLogUploadingList;
	            uploadData = {
	              sdk_version: VERSION,
	              process_id: getParameter("PROCESS_ID"),
	              payload: stringify$2(logs)
	            };
	            return [4
	            /*yield*/
	            , axios$1.post(this.proxyServerURL ? "https://" + this.proxyServerURL + "/ls/?h=" + getParameter("LOG_UPLOAD_SERVER") + "&p=443&d=upload/v1" : "https://" + getParameter("LOG_UPLOAD_SERVER") + "/upload/v1", uploadData, {
	              responseType: "text"
	            })];

	          case 1:
	            res = _a.sent();

	            if (res.data !== "OK") {
	              err = new Error("unexpected upload log response: " + res.data);
	              throw err;
	            } else {
	              // 上传成功，清理上传队列
	              this.uploadLogUploadingList = [];
	            }

	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  AgoraLogger.prototype.uploadLogInterval = function () {
	    var _this = this; // 如果即没有正在上传的数据，也没有等待上传的数据，直接返回


	    if (this.uploadLogUploadingList.length === 0 && this.uploadLogWaitingList.length === 0) {
	      return;
	    } // 如果没有正在上传的数据，取出等等上传的数据


	    if (this.uploadLogUploadingList.length === 0) {
	      var _context9;

	      this.uploadLogUploadingList = splice$2(_context9 = this.uploadLogWaitingList).call(_context9, 0, 10);
	    }

	    this.uploadLogs().then(function () {
	      _this.uploadErrorCount = 0; // 如果上传成功且还有数据在等待上传，下一次上传在 3 秒后

	      if (_this.uploadLogWaitingList.length > 0) {
	        window.setTimeout(function () {
	          return _this.uploadLogInterval();
	        }, 3000);
	      }
	    }).catch(function (err) {
	      // 如果上传失败
	      _this.uploadErrorCount += 1; // 如果上传失败小于 2 次，下一次上传在 0.2 秒后，否则 10 秒后再尝试

	      if (_this.uploadErrorCount < 2) {
	        window.setTimeout(function () {
	          return _this.uploadLogInterval();
	        }, 200);
	      } else {
	        window.setTimeout(function () {
	          return _this.uploadLogInterval();
	        }, 1000);
	      }
	    });
	  };

	  return AgoraLogger;
	}();
	var logger = new AgoraLogger();

	/**
	 * @ignore
	 */

	/** @en
	 * @ignore
	 */

	var AgoraRTCError =
	/** @class */
	function () {
	  function AgoraRTCError(code, message, data) {
	    if (message === void 0) {
	      message = "";
	    }

	    this.name = "AgoraRTCException";
	    this.code = code;
	    this.message = "AgoraRTCError " + this.code + ": " + message;
	    this.data = data;
	  }

	  AgoraRTCError.prototype.toString = function () {
	    if (!this.data) {
	      return this.message;
	    }

	    return this.message + " data: " + stringify$2(this.data);
	  };

	  AgoraRTCError.prototype.throw = function () {
	    logger.error(this.toString());
	    throw this;
	  };

	  return AgoraRTCError;
	}();

	/**
	 * 所有的 check function，如果 check 失败，直接 throw error
	 */

	function checkValidBoolean(value, name) {
	  if (typeof value === "boolean") return;
	  throw new AgoraRTCError(AgoraRTCErrorCode.INVALID_PARAMS, "Invalid " + name + ": The value is of the boolean type.");
	}
	function checkValidEnum(value, name, list) {
	  if (includes$4(list).call(list, value)) return;
	  var err = new AgoraRTCError(AgoraRTCErrorCode.INVALID_PARAMS, name + " can only be set as " + stringify$2(list));
	  throw err;
	}
	function checkValidNumber(num, name, min, max, forceInteger) {
	  if (min === void 0) {
	    min = 1;
	  }

	  if (max === void 0) {
	    max = 10000;
	  }

	  if (forceInteger === void 0) {
	    forceInteger = true;
	  }

	  if (num < min || num > max || forceInteger && !isInteger(num)) {
	    var err = new AgoraRTCError(AgoraRTCErrorCode.INVALID_PARAMS, "invalid " + name + ": the value range is [" + min + ", " + max + "]. integer only");
	    throw err;
	  }
	}
	function checkValidString(string, name, lenMin, lenMax, ascii) {
	  if (lenMin === void 0) {
	    lenMin = 1;
	  }

	  if (lenMax === void 0) {
	    lenMax = 255;
	  }

	  if (ascii === void 0) {
	    ascii = true;
	  }

	  if (string === undefined || string === null) {
	    throw new AgoraRTCError(AgoraRTCErrorCode.INVALID_PARAMS, (name || "param") + " cannot be empty");
	  }

	  if (!isValidString(string, lenMin, lenMax, ascii)) {
	    throw new AgoraRTCError(AgoraRTCErrorCode.INVALID_PARAMS, "Invalid " + (name || "string param") + ": Length of the string: [" + lenMin + "," + lenMax + "]." + (ascii ? " ASCII characters only." : ""));
	  }
	}
	function checkValidArray(array, name) {
	  if (!isArray$3(array)) {
	    throw new AgoraRTCError(AgoraRTCErrorCode.INVALID_PARAMS, name + " should be an array");
	  }
	}
	function checkValidChannelName(channel) {
	  if (typeof channel === "string" && /^[a-zA-Z0-9 \!\#\$\%\&\(\)\+\-\:\;\<\=\.\>\?\@\[\]\^\_\{\}\|\~\,]{1,64}$/.test(channel)) {
	    return;
	  }

	  logger.error("Invalid Channel Name " + channel);
	  throw new AgoraRTCError(AgoraRTCErrorCode.INVALID_PARAMS, "The length must be within 64 bytes. The supported characters: a-z,A-Z,0-9,space,!, #, $, %, &, (, ), +, -, :, ;, <, =, ., >, ?, @, [, ], ^, _,  {, }, |, ~, ,");
	}
	function checkValidUID(uid) {
	  if (!is32Uint(uid) && !isValidString(uid, 1, 255)) {
	    logger.error("Invalid UID " + uid + " " + typeof uid);
	    throw new AgoraRTCError(AgoraRTCErrorCode.INVALID_PARAMS, "[String uid] Length of the string: [1,255]. ASCII characters only. [Number uid] The value range is [0,10000]");
	  }
	}
	/**
	 * 比较 2 个 Object 是否相等
	 * **Note:** 不会递归比较，只会比较一层
	 */

	function checkIsEqual(a, b) {
	  var _context, _context2;

	  var aKeys = sort$2(_context = keys$3(a)).call(_context);

	  var bKeys = sort$2(_context2 = keys$3(b)).call(_context2);

	  for (var i = 0; i < aKeys.length; i += 1) {
	    if (aKeys[i] !== bKeys[i]) return false;
	    if (a[aKeys[i]] !== b[aKeys[i]]) return false;
	  }

	  return true;
	}
	function isEmpty(n) {
	  return n === null || n === undefined;
	}

	function isValidString(string, lenMin, lenMax, ascii) {
	  if (lenMin === void 0) {
	    lenMin = 1;
	  }

	  if (lenMax === void 0) {
	    lenMax = 255;
	  }

	  if (ascii === void 0) {
	    ascii = true;
	  }

	  return typeof string === "string" && string.length <= lenMax && string.length >= lenMin && (ascii ? isASCII(string) : true);
	}

	function isInteger(num) {
	  return typeof num === "number" && num % 1 === 0;
	}

	function isASCII(string) {
	  if (typeof string !== "string") return false;

	  for (var i = 0; i < string.length; i += 1) {
	    var char = string.charCodeAt(i);

	    if (char < 0 || char > 255) {
	      return false;
	    }
	  }

	  return true;
	}

	function is32Uint(n) {
	  return typeof n === "number" && 0 <= n && n <= 4294967296 - 1;
	}

	var LOG_UPLOAD_STATE;

	(function (LOG_UPLOAD_STATE) {
	  LOG_UPLOAD_STATE["FREE"] = "free";
	  LOG_UPLOAD_STATE["UPLOADING"] = "uploading";
	})(LOG_UPLOAD_STATE || (LOG_UPLOAD_STATE = {}));

	var VideoElementStatus;

	(function (VideoElementStatus) {
	  VideoElementStatus["NONE"] = "none";
	  VideoElementStatus["INIT"] = "init";
	  VideoElementStatus["CANPLAY"] = "canplay";
	  VideoElementStatus["PLAYING"] = "playing";
	  VideoElementStatus["PAUSED"] = "paused";
	  VideoElementStatus["SUSPEND"] = "suspend";
	  VideoElementStatus["STALLED"] = "stalled";
	  VideoElementStatus["WAITING"] = "waiting";
	  VideoElementStatus["ERROR"] = "error";
	  VideoElementStatus["DESTROYED"] = "destroyed";
	  VideoElementStatus["ABORT"] = "abort";
	  VideoElementStatus["ENDED"] = "ended";
	  VideoElementStatus["EMPTIED"] = "emptied";
	})(VideoElementStatus || (VideoElementStatus = {}));

	// `Number.MAX_SAFE_INTEGER` constant
	// https://tc39.github.io/ecma262/#sec-number.max_safe_integer
	_export({ target: 'Number', stat: true }, {
	  MAX_SAFE_INTEGER: 0x1FFFFFFFFFFFFF
	});

	var maxSafeInteger = 0x1FFFFFFFFFFFFF;

	var maxSafeInteger$1 = maxSafeInteger;

	var maxSafeInteger$2 = maxSafeInteger$1;

	// `Number.MIN_SAFE_INTEGER` constant
	// https://tc39.github.io/ecma262/#sec-number.min_safe_integer
	_export({ target: 'Number', stat: true }, {
	  MIN_SAFE_INTEGER: -0x1FFFFFFFFFFFFF
	});

	var minSafeInteger = -0x1FFFFFFFFFFFFF;

	var minSafeInteger$1 = minSafeInteger;

	var minSafeInteger$2 = minSafeInteger$1;

	var aspromise = asPromise;

	/**
	 * Callback as used by {@link util.asPromise}.
	 * @typedef asPromiseCallback
	 * @type {function}
	 * @param {Error|null} error Error, if any
	 * @param {...*} params Additional arguments
	 * @returns {undefined}
	 */

	/**
	 * Returns a promise from a node-style callback function.
	 * @memberof util
	 * @param {asPromiseCallback} fn Function to call
	 * @param {*} ctx Function context
	 * @param {...*} params Function arguments
	 * @returns {Promise<*>} Promisified function
	 */
	function asPromise(fn, ctx/*, varargs */) {
	    var params  = new Array(arguments.length - 1),
	        offset  = 0,
	        index   = 2,
	        pending = true;
	    while (index < arguments.length)
	        params[offset++] = arguments[index++];
	    return new Promise(function executor(resolve, reject) {
	        params[offset] = function callback(err/*, varargs */) {
	            if (pending) {
	                pending = false;
	                if (err)
	                    reject(err);
	                else {
	                    var params = new Array(arguments.length - 1),
	                        offset = 0;
	                    while (offset < params.length)
	                        params[offset++] = arguments[offset];
	                    resolve.apply(null, params);
	                }
	            }
	        };
	        try {
	            fn.apply(ctx || null, params);
	        } catch (err) {
	            if (pending) {
	                pending = false;
	                reject(err);
	            }
	        }
	    });
	}

	var base64_1 = createCommonjsModule(function (module, exports) {

	/**
	 * A minimal base64 implementation for number arrays.
	 * @memberof util
	 * @namespace
	 */
	var base64 = exports;

	/**
	 * Calculates the byte length of a base64 encoded string.
	 * @param {string} string Base64 encoded string
	 * @returns {number} Byte length
	 */
	base64.length = function length(string) {
	    var p = string.length;
	    if (!p)
	        return 0;
	    var n = 0;
	    while (--p % 4 > 1 && string.charAt(p) === "=")
	        ++n;
	    return Math.ceil(string.length * 3) / 4 - n;
	};

	// Base64 encoding table
	var b64 = new Array(64);

	// Base64 decoding table
	var s64 = new Array(123);

	// 65..90, 97..122, 48..57, 43, 47
	for (var i = 0; i < 64;)
	    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

	/**
	 * Encodes a buffer to a base64 encoded string.
	 * @param {Uint8Array} buffer Source buffer
	 * @param {number} start Source start
	 * @param {number} end Source end
	 * @returns {string} Base64 encoded string
	 */
	base64.encode = function encode(buffer, start, end) {
	    var parts = null,
	        chunk = [];
	    var i = 0, // output index
	        j = 0, // goto index
	        t;     // temporary
	    while (start < end) {
	        var b = buffer[start++];
	        switch (j) {
	            case 0:
	                chunk[i++] = b64[b >> 2];
	                t = (b & 3) << 4;
	                j = 1;
	                break;
	            case 1:
	                chunk[i++] = b64[t | b >> 4];
	                t = (b & 15) << 2;
	                j = 2;
	                break;
	            case 2:
	                chunk[i++] = b64[t | b >> 6];
	                chunk[i++] = b64[b & 63];
	                j = 0;
	                break;
	        }
	        if (i > 8191) {
	            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
	            i = 0;
	        }
	    }
	    if (j) {
	        chunk[i++] = b64[t];
	        chunk[i++] = 61;
	        if (j === 1)
	            chunk[i++] = 61;
	    }
	    if (parts) {
	        if (i)
	            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
	        return parts.join("");
	    }
	    return String.fromCharCode.apply(String, chunk.slice(0, i));
	};

	var invalidEncoding = "invalid encoding";

	/**
	 * Decodes a base64 encoded string to a buffer.
	 * @param {string} string Source string
	 * @param {Uint8Array} buffer Destination buffer
	 * @param {number} offset Destination offset
	 * @returns {number} Number of bytes written
	 * @throws {Error} If encoding is invalid
	 */
	base64.decode = function decode(string, buffer, offset) {
	    var start = offset;
	    var j = 0, // goto index
	        t;     // temporary
	    for (var i = 0; i < string.length;) {
	        var c = string.charCodeAt(i++);
	        if (c === 61 && j > 1)
	            break;
	        if ((c = s64[c]) === undefined)
	            throw Error(invalidEncoding);
	        switch (j) {
	            case 0:
	                t = c;
	                j = 1;
	                break;
	            case 1:
	                buffer[offset++] = t << 2 | (c & 48) >> 4;
	                t = c;
	                j = 2;
	                break;
	            case 2:
	                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
	                t = c;
	                j = 3;
	                break;
	            case 3:
	                buffer[offset++] = (t & 3) << 6 | c;
	                j = 0;
	                break;
	        }
	    }
	    if (j === 1)
	        throw Error(invalidEncoding);
	    return offset - start;
	};

	/**
	 * Tests if the specified string appears to be base64 encoded.
	 * @param {string} string String to test
	 * @returns {boolean} `true` if probably base64 encoded, otherwise false
	 */
	base64.test = function test(string) {
	    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
	};
	});

	var eventemitter = EventEmitter;

	/**
	 * Constructs a new event emitter instance.
	 * @classdesc A minimal event emitter.
	 * @memberof util
	 * @constructor
	 */
	function EventEmitter() {

	    /**
	     * Registered listeners.
	     * @type {Object.<string,*>}
	     * @private
	     */
	    this._listeners = {};
	}

	/**
	 * Registers an event listener.
	 * @param {string} evt Event name
	 * @param {function} fn Listener
	 * @param {*} [ctx] Listener context
	 * @returns {util.EventEmitter} `this`
	 */
	EventEmitter.prototype.on = function on(evt, fn, ctx) {
	    (this._listeners[evt] || (this._listeners[evt] = [])).push({
	        fn  : fn,
	        ctx : ctx || this
	    });
	    return this;
	};

	/**
	 * Removes an event listener or any matching listeners if arguments are omitted.
	 * @param {string} [evt] Event name. Removes all listeners if omitted.
	 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
	 * @returns {util.EventEmitter} `this`
	 */
	EventEmitter.prototype.off = function off(evt, fn) {
	    if (evt === undefined)
	        this._listeners = {};
	    else {
	        if (fn === undefined)
	            this._listeners[evt] = [];
	        else {
	            var listeners = this._listeners[evt];
	            for (var i = 0; i < listeners.length;)
	                if (listeners[i].fn === fn)
	                    listeners.splice(i, 1);
	                else
	                    ++i;
	        }
	    }
	    return this;
	};

	/**
	 * Emits an event by calling its listeners with the specified arguments.
	 * @param {string} evt Event name
	 * @param {...*} args Arguments
	 * @returns {util.EventEmitter} `this`
	 */
	EventEmitter.prototype.emit = function emit(evt) {
	    var listeners = this._listeners[evt];
	    if (listeners) {
	        var args = [],
	            i = 1;
	        for (; i < arguments.length;)
	            args.push(arguments[i++]);
	        for (i = 0; i < listeners.length;)
	            listeners[i].fn.apply(listeners[i++].ctx, args);
	    }
	    return this;
	};

	var float_1 = factory(factory);

	/**
	 * Reads / writes floats / doubles from / to buffers.
	 * @name util.float
	 * @namespace
	 */

	/**
	 * Writes a 32 bit float to a buffer using little endian byte order.
	 * @name util.float.writeFloatLE
	 * @function
	 * @param {number} val Value to write
	 * @param {Uint8Array} buf Target buffer
	 * @param {number} pos Target buffer offset
	 * @returns {undefined}
	 */

	/**
	 * Writes a 32 bit float to a buffer using big endian byte order.
	 * @name util.float.writeFloatBE
	 * @function
	 * @param {number} val Value to write
	 * @param {Uint8Array} buf Target buffer
	 * @param {number} pos Target buffer offset
	 * @returns {undefined}
	 */

	/**
	 * Reads a 32 bit float from a buffer using little endian byte order.
	 * @name util.float.readFloatLE
	 * @function
	 * @param {Uint8Array} buf Source buffer
	 * @param {number} pos Source buffer offset
	 * @returns {number} Value read
	 */

	/**
	 * Reads a 32 bit float from a buffer using big endian byte order.
	 * @name util.float.readFloatBE
	 * @function
	 * @param {Uint8Array} buf Source buffer
	 * @param {number} pos Source buffer offset
	 * @returns {number} Value read
	 */

	/**
	 * Writes a 64 bit double to a buffer using little endian byte order.
	 * @name util.float.writeDoubleLE
	 * @function
	 * @param {number} val Value to write
	 * @param {Uint8Array} buf Target buffer
	 * @param {number} pos Target buffer offset
	 * @returns {undefined}
	 */

	/**
	 * Writes a 64 bit double to a buffer using big endian byte order.
	 * @name util.float.writeDoubleBE
	 * @function
	 * @param {number} val Value to write
	 * @param {Uint8Array} buf Target buffer
	 * @param {number} pos Target buffer offset
	 * @returns {undefined}
	 */

	/**
	 * Reads a 64 bit double from a buffer using little endian byte order.
	 * @name util.float.readDoubleLE
	 * @function
	 * @param {Uint8Array} buf Source buffer
	 * @param {number} pos Source buffer offset
	 * @returns {number} Value read
	 */

	/**
	 * Reads a 64 bit double from a buffer using big endian byte order.
	 * @name util.float.readDoubleBE
	 * @function
	 * @param {Uint8Array} buf Source buffer
	 * @param {number} pos Source buffer offset
	 * @returns {number} Value read
	 */

	// Factory function for the purpose of node-based testing in modified global environments
	function factory(exports) {

	    // float: typed array
	    if (typeof Float32Array !== "undefined") (function() {

	        var f32 = new Float32Array([ -0 ]),
	            f8b = new Uint8Array(f32.buffer),
	            le  = f8b[3] === 128;

	        function writeFloat_f32_cpy(val, buf, pos) {
	            f32[0] = val;
	            buf[pos    ] = f8b[0];
	            buf[pos + 1] = f8b[1];
	            buf[pos + 2] = f8b[2];
	            buf[pos + 3] = f8b[3];
	        }

	        function writeFloat_f32_rev(val, buf, pos) {
	            f32[0] = val;
	            buf[pos    ] = f8b[3];
	            buf[pos + 1] = f8b[2];
	            buf[pos + 2] = f8b[1];
	            buf[pos + 3] = f8b[0];
	        }

	        /* istanbul ignore next */
	        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
	        /* istanbul ignore next */
	        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

	        function readFloat_f32_cpy(buf, pos) {
	            f8b[0] = buf[pos    ];
	            f8b[1] = buf[pos + 1];
	            f8b[2] = buf[pos + 2];
	            f8b[3] = buf[pos + 3];
	            return f32[0];
	        }

	        function readFloat_f32_rev(buf, pos) {
	            f8b[3] = buf[pos    ];
	            f8b[2] = buf[pos + 1];
	            f8b[1] = buf[pos + 2];
	            f8b[0] = buf[pos + 3];
	            return f32[0];
	        }

	        /* istanbul ignore next */
	        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
	        /* istanbul ignore next */
	        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

	    // float: ieee754
	    })(); else (function() {

	        function writeFloat_ieee754(writeUint, val, buf, pos) {
	            var sign = val < 0 ? 1 : 0;
	            if (sign)
	                val = -val;
	            if (val === 0)
	                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
	            else if (isNaN(val))
	                writeUint(2143289344, buf, pos);
	            else if (val > 3.4028234663852886e+38) // +-Infinity
	                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
	            else if (val < 1.1754943508222875e-38) // denormal
	                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
	            else {
	                var exponent = Math.floor(Math.log(val) / Math.LN2),
	                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
	                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
	            }
	        }

	        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
	        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

	        function readFloat_ieee754(readUint, buf, pos) {
	            var uint = readUint(buf, pos),
	                sign = (uint >> 31) * 2 + 1,
	                exponent = uint >>> 23 & 255,
	                mantissa = uint & 8388607;
	            return exponent === 255
	                ? mantissa
	                ? NaN
	                : sign * Infinity
	                : exponent === 0 // denormal
	                ? sign * 1.401298464324817e-45 * mantissa
	                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
	        }

	        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
	        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

	    })();

	    // double: typed array
	    if (typeof Float64Array !== "undefined") (function() {

	        var f64 = new Float64Array([-0]),
	            f8b = new Uint8Array(f64.buffer),
	            le  = f8b[7] === 128;

	        function writeDouble_f64_cpy(val, buf, pos) {
	            f64[0] = val;
	            buf[pos    ] = f8b[0];
	            buf[pos + 1] = f8b[1];
	            buf[pos + 2] = f8b[2];
	            buf[pos + 3] = f8b[3];
	            buf[pos + 4] = f8b[4];
	            buf[pos + 5] = f8b[5];
	            buf[pos + 6] = f8b[6];
	            buf[pos + 7] = f8b[7];
	        }

	        function writeDouble_f64_rev(val, buf, pos) {
	            f64[0] = val;
	            buf[pos    ] = f8b[7];
	            buf[pos + 1] = f8b[6];
	            buf[pos + 2] = f8b[5];
	            buf[pos + 3] = f8b[4];
	            buf[pos + 4] = f8b[3];
	            buf[pos + 5] = f8b[2];
	            buf[pos + 6] = f8b[1];
	            buf[pos + 7] = f8b[0];
	        }

	        /* istanbul ignore next */
	        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
	        /* istanbul ignore next */
	        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

	        function readDouble_f64_cpy(buf, pos) {
	            f8b[0] = buf[pos    ];
	            f8b[1] = buf[pos + 1];
	            f8b[2] = buf[pos + 2];
	            f8b[3] = buf[pos + 3];
	            f8b[4] = buf[pos + 4];
	            f8b[5] = buf[pos + 5];
	            f8b[6] = buf[pos + 6];
	            f8b[7] = buf[pos + 7];
	            return f64[0];
	        }

	        function readDouble_f64_rev(buf, pos) {
	            f8b[7] = buf[pos    ];
	            f8b[6] = buf[pos + 1];
	            f8b[5] = buf[pos + 2];
	            f8b[4] = buf[pos + 3];
	            f8b[3] = buf[pos + 4];
	            f8b[2] = buf[pos + 5];
	            f8b[1] = buf[pos + 6];
	            f8b[0] = buf[pos + 7];
	            return f64[0];
	        }

	        /* istanbul ignore next */
	        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
	        /* istanbul ignore next */
	        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

	    // double: ieee754
	    })(); else (function() {

	        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
	            var sign = val < 0 ? 1 : 0;
	            if (sign)
	                val = -val;
	            if (val === 0) {
	                writeUint(0, buf, pos + off0);
	                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
	            } else if (isNaN(val)) {
	                writeUint(0, buf, pos + off0);
	                writeUint(2146959360, buf, pos + off1);
	            } else if (val > 1.7976931348623157e+308) { // +-Infinity
	                writeUint(0, buf, pos + off0);
	                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
	            } else {
	                var mantissa;
	                if (val < 2.2250738585072014e-308) { // denormal
	                    mantissa = val / 5e-324;
	                    writeUint(mantissa >>> 0, buf, pos + off0);
	                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
	                } else {
	                    var exponent = Math.floor(Math.log(val) / Math.LN2);
	                    if (exponent === 1024)
	                        exponent = 1023;
	                    mantissa = val * Math.pow(2, -exponent);
	                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
	                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
	                }
	            }
	        }

	        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
	        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

	        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
	            var lo = readUint(buf, pos + off0),
	                hi = readUint(buf, pos + off1);
	            var sign = (hi >> 31) * 2 + 1,
	                exponent = hi >>> 20 & 2047,
	                mantissa = 4294967296 * (hi & 1048575) + lo;
	            return exponent === 2047
	                ? mantissa
	                ? NaN
	                : sign * Infinity
	                : exponent === 0 // denormal
	                ? sign * 5e-324 * mantissa
	                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
	        }

	        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
	        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

	    })();

	    return exports;
	}

	// uint helpers

	function writeUintLE(val, buf, pos) {
	    buf[pos    ] =  val        & 255;
	    buf[pos + 1] =  val >>> 8  & 255;
	    buf[pos + 2] =  val >>> 16 & 255;
	    buf[pos + 3] =  val >>> 24;
	}

	function writeUintBE(val, buf, pos) {
	    buf[pos    ] =  val >>> 24;
	    buf[pos + 1] =  val >>> 16 & 255;
	    buf[pos + 2] =  val >>> 8  & 255;
	    buf[pos + 3] =  val        & 255;
	}

	function readUintLE(buf, pos) {
	    return (buf[pos    ]
	          | buf[pos + 1] << 8
	          | buf[pos + 2] << 16
	          | buf[pos + 3] << 24) >>> 0;
	}

	function readUintBE(buf, pos) {
	    return (buf[pos    ] << 24
	          | buf[pos + 1] << 16
	          | buf[pos + 2] << 8
	          | buf[pos + 3]) >>> 0;
	}

	var inquire_1 = inquire;

	/**
	 * Requires a module only if available.
	 * @memberof util
	 * @param {string} moduleName Module to require
	 * @returns {?Object} Required module if available and not empty, otherwise `null`
	 */
	function inquire(moduleName) {
	    try {
	        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
	        if (mod && (mod.length || Object.keys(mod).length))
	            return mod;
	    } catch (e) {} // eslint-disable-line no-empty
	    return null;
	}

	var utf8_1 = createCommonjsModule(function (module, exports) {

	/**
	 * A minimal UTF8 implementation for number arrays.
	 * @memberof util
	 * @namespace
	 */
	var utf8 = exports;

	/**
	 * Calculates the UTF8 byte length of a string.
	 * @param {string} string String
	 * @returns {number} Byte length
	 */
	utf8.length = function utf8_length(string) {
	    var len = 0,
	        c = 0;
	    for (var i = 0; i < string.length; ++i) {
	        c = string.charCodeAt(i);
	        if (c < 128)
	            len += 1;
	        else if (c < 2048)
	            len += 2;
	        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
	            ++i;
	            len += 4;
	        } else
	            len += 3;
	    }
	    return len;
	};

	/**
	 * Reads UTF8 bytes as a string.
	 * @param {Uint8Array} buffer Source buffer
	 * @param {number} start Source start
	 * @param {number} end Source end
	 * @returns {string} String read
	 */
	utf8.read = function utf8_read(buffer, start, end) {
	    var len = end - start;
	    if (len < 1)
	        return "";
	    var parts = null,
	        chunk = [],
	        i = 0, // char offset
	        t;     // temporary
	    while (start < end) {
	        t = buffer[start++];
	        if (t < 128)
	            chunk[i++] = t;
	        else if (t > 191 && t < 224)
	            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
	        else if (t > 239 && t < 365) {
	            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
	            chunk[i++] = 0xD800 + (t >> 10);
	            chunk[i++] = 0xDC00 + (t & 1023);
	        } else
	            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
	        if (i > 8191) {
	            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
	            i = 0;
	        }
	    }
	    if (parts) {
	        if (i)
	            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
	        return parts.join("");
	    }
	    return String.fromCharCode.apply(String, chunk.slice(0, i));
	};

	/**
	 * Writes a string as UTF8 bytes.
	 * @param {string} string Source string
	 * @param {Uint8Array} buffer Destination buffer
	 * @param {number} offset Destination offset
	 * @returns {number} Bytes written
	 */
	utf8.write = function utf8_write(string, buffer, offset) {
	    var start = offset,
	        c1, // character 1
	        c2; // character 2
	    for (var i = 0; i < string.length; ++i) {
	        c1 = string.charCodeAt(i);
	        if (c1 < 128) {
	            buffer[offset++] = c1;
	        } else if (c1 < 2048) {
	            buffer[offset++] = c1 >> 6       | 192;
	            buffer[offset++] = c1       & 63 | 128;
	        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
	            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
	            ++i;
	            buffer[offset++] = c1 >> 18      | 240;
	            buffer[offset++] = c1 >> 12 & 63 | 128;
	            buffer[offset++] = c1 >> 6  & 63 | 128;
	            buffer[offset++] = c1       & 63 | 128;
	        } else {
	            buffer[offset++] = c1 >> 12      | 224;
	            buffer[offset++] = c1 >> 6  & 63 | 128;
	            buffer[offset++] = c1       & 63 | 128;
	        }
	    }
	    return offset - start;
	};
	});

	var pool_1 = pool;

	/**
	 * An allocator as used by {@link util.pool}.
	 * @typedef PoolAllocator
	 * @type {function}
	 * @param {number} size Buffer size
	 * @returns {Uint8Array} Buffer
	 */

	/**
	 * A slicer as used by {@link util.pool}.
	 * @typedef PoolSlicer
	 * @type {function}
	 * @param {number} start Start offset
	 * @param {number} end End offset
	 * @returns {Uint8Array} Buffer slice
	 * @this {Uint8Array}
	 */

	/**
	 * A general purpose buffer pool.
	 * @memberof util
	 * @function
	 * @param {PoolAllocator} alloc Allocator
	 * @param {PoolSlicer} slice Slicer
	 * @param {number} [size=8192] Slab size
	 * @returns {PoolAllocator} Pooled allocator
	 */
	function pool(alloc, slice, size) {
	    var SIZE   = size || 8192;
	    var MAX    = SIZE >>> 1;
	    var slab   = null;
	    var offset = SIZE;
	    return function pool_alloc(size) {
	        if (size < 1 || size > MAX)
	            return alloc(size);
	        if (offset + size > SIZE) {
	            slab = alloc(SIZE);
	            offset = 0;
	        }
	        var buf = slice.call(slab, offset, offset += size);
	        if (offset & 7) // align to 32 bit
	            offset = (offset | 7) + 1;
	        return buf;
	    };
	}

	var longbits = LongBits;



	/**
	 * Constructs new long bits.
	 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
	 * @memberof util
	 * @constructor
	 * @param {number} lo Low 32 bits, unsigned
	 * @param {number} hi High 32 bits, unsigned
	 */
	function LongBits(lo, hi) {

	    // note that the casts below are theoretically unnecessary as of today, but older statically
	    // generated converter code might still call the ctor with signed 32bits. kept for compat.

	    /**
	     * Low bits.
	     * @type {number}
	     */
	    this.lo = lo >>> 0;

	    /**
	     * High bits.
	     * @type {number}
	     */
	    this.hi = hi >>> 0;
	}

	/**
	 * Zero bits.
	 * @memberof util.LongBits
	 * @type {util.LongBits}
	 */
	var zero = LongBits.zero = new LongBits(0, 0);

	zero.toNumber = function() { return 0; };
	zero.zzEncode = zero.zzDecode = function() { return this; };
	zero.length = function() { return 1; };

	/**
	 * Zero hash.
	 * @memberof util.LongBits
	 * @type {string}
	 */
	var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

	/**
	 * Constructs new long bits from the specified number.
	 * @param {number} value Value
	 * @returns {util.LongBits} Instance
	 */
	LongBits.fromNumber = function fromNumber(value) {
	    if (value === 0)
	        return zero;
	    var sign = value < 0;
	    if (sign)
	        value = -value;
	    var lo = value >>> 0,
	        hi = (value - lo) / 4294967296 >>> 0;
	    if (sign) {
	        hi = ~hi >>> 0;
	        lo = ~lo >>> 0;
	        if (++lo > 4294967295) {
	            lo = 0;
	            if (++hi > 4294967295)
	                hi = 0;
	        }
	    }
	    return new LongBits(lo, hi);
	};

	/**
	 * Constructs new long bits from a number, long or string.
	 * @param {Long|number|string} value Value
	 * @returns {util.LongBits} Instance
	 */
	LongBits.from = function from(value) {
	    if (typeof value === "number")
	        return LongBits.fromNumber(value);
	    if (minimal.isString(value)) {
	        /* istanbul ignore else */
	        if (minimal.Long)
	            value = minimal.Long.fromString(value);
	        else
	            return LongBits.fromNumber(parseInt(value, 10));
	    }
	    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
	};

	/**
	 * Converts this long bits to a possibly unsafe JavaScript number.
	 * @param {boolean} [unsigned=false] Whether unsigned or not
	 * @returns {number} Possibly unsafe number
	 */
	LongBits.prototype.toNumber = function toNumber(unsigned) {
	    if (!unsigned && this.hi >>> 31) {
	        var lo = ~this.lo + 1 >>> 0,
	            hi = ~this.hi     >>> 0;
	        if (!lo)
	            hi = hi + 1 >>> 0;
	        return -(lo + hi * 4294967296);
	    }
	    return this.lo + this.hi * 4294967296;
	};

	/**
	 * Converts this long bits to a long.
	 * @param {boolean} [unsigned=false] Whether unsigned or not
	 * @returns {Long} Long
	 */
	LongBits.prototype.toLong = function toLong(unsigned) {
	    return minimal.Long
	        ? new minimal.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
	        /* istanbul ignore next */
	        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
	};

	var charCodeAt = String.prototype.charCodeAt;

	/**
	 * Constructs new long bits from the specified 8 characters long hash.
	 * @param {string} hash Hash
	 * @returns {util.LongBits} Bits
	 */
	LongBits.fromHash = function fromHash(hash) {
	    if (hash === zeroHash)
	        return zero;
	    return new LongBits(
	        ( charCodeAt.call(hash, 0)
	        | charCodeAt.call(hash, 1) << 8
	        | charCodeAt.call(hash, 2) << 16
	        | charCodeAt.call(hash, 3) << 24) >>> 0
	    ,
	        ( charCodeAt.call(hash, 4)
	        | charCodeAt.call(hash, 5) << 8
	        | charCodeAt.call(hash, 6) << 16
	        | charCodeAt.call(hash, 7) << 24) >>> 0
	    );
	};

	/**
	 * Converts this long bits to a 8 characters long hash.
	 * @returns {string} Hash
	 */
	LongBits.prototype.toHash = function toHash() {
	    return String.fromCharCode(
	        this.lo        & 255,
	        this.lo >>> 8  & 255,
	        this.lo >>> 16 & 255,
	        this.lo >>> 24      ,
	        this.hi        & 255,
	        this.hi >>> 8  & 255,
	        this.hi >>> 16 & 255,
	        this.hi >>> 24
	    );
	};

	/**
	 * Zig-zag encodes this long bits.
	 * @returns {util.LongBits} `this`
	 */
	LongBits.prototype.zzEncode = function zzEncode() {
	    var mask =   this.hi >> 31;
	    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
	    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
	    return this;
	};

	/**
	 * Zig-zag decodes this long bits.
	 * @returns {util.LongBits} `this`
	 */
	LongBits.prototype.zzDecode = function zzDecode() {
	    var mask = -(this.lo & 1);
	    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
	    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
	    return this;
	};

	/**
	 * Calculates the length of this longbits when encoded as a varint.
	 * @returns {number} Length
	 */
	LongBits.prototype.length = function length() {
	    var part0 =  this.lo,
	        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
	        part2 =  this.hi >>> 24;
	    return part2 === 0
	         ? part1 === 0
	           ? part0 < 16384
	             ? part0 < 128 ? 1 : 2
	             : part0 < 2097152 ? 3 : 4
	           : part1 < 16384
	             ? part1 < 128 ? 5 : 6
	             : part1 < 2097152 ? 7 : 8
	         : part2 < 128 ? 9 : 10;
	};

	var minimal = createCommonjsModule(function (module, exports) {
	var util = exports;

	// used to return a Promise where callback is omitted
	util.asPromise = aspromise;

	// converts to / from base64 encoded strings
	util.base64 = base64_1;

	// base class of rpc.Service
	util.EventEmitter = eventemitter;

	// float handling accross browsers
	util.float = float_1;

	// requires modules optionally and hides the call from bundlers
	util.inquire = inquire_1;

	// converts to / from utf8 encoded strings
	util.utf8 = utf8_1;

	// provides a node-like buffer pool in the browser
	util.pool = pool_1;

	// utility to work with the low and high bits of a 64 bit value
	util.LongBits = longbits;

	/**
	 * Whether running within node or not.
	 * @memberof util
	 * @type {boolean}
	 */
	util.isNode = Boolean(typeof commonjsGlobal !== "undefined"
	                   && commonjsGlobal
	                   && commonjsGlobal.process
	                   && commonjsGlobal.process.versions
	                   && commonjsGlobal.process.versions.node);

	/**
	 * Global object reference.
	 * @memberof util
	 * @type {Object}
	 */
	util.global = util.isNode && commonjsGlobal
	           || typeof window !== "undefined" && window
	           || typeof self   !== "undefined" && self
	           || commonjsGlobal; // eslint-disable-line no-invalid-this

	/**
	 * An immuable empty array.
	 * @memberof util
	 * @type {Array.<*>}
	 * @const
	 */
	util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

	/**
	 * An immutable empty object.
	 * @type {Object}
	 * @const
	 */
	util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

	/**
	 * Tests if the specified value is an integer.
	 * @function
	 * @param {*} value Value to test
	 * @returns {boolean} `true` if the value is an integer
	 */
	util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
	    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
	};

	/**
	 * Tests if the specified value is a string.
	 * @param {*} value Value to test
	 * @returns {boolean} `true` if the value is a string
	 */
	util.isString = function isString(value) {
	    return typeof value === "string" || value instanceof String;
	};

	/**
	 * Tests if the specified value is a non-null object.
	 * @param {*} value Value to test
	 * @returns {boolean} `true` if the value is a non-null object
	 */
	util.isObject = function isObject(value) {
	    return value && typeof value === "object";
	};

	/**
	 * Checks if a property on a message is considered to be present.
	 * This is an alias of {@link util.isSet}.
	 * @function
	 * @param {Object} obj Plain object or message instance
	 * @param {string} prop Property name
	 * @returns {boolean} `true` if considered to be present, otherwise `false`
	 */
	util.isset =

	/**
	 * Checks if a property on a message is considered to be present.
	 * @param {Object} obj Plain object or message instance
	 * @param {string} prop Property name
	 * @returns {boolean} `true` if considered to be present, otherwise `false`
	 */
	util.isSet = function isSet(obj, prop) {
	    var value = obj[prop];
	    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
	        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
	    return false;
	};

	/**
	 * Any compatible Buffer instance.
	 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
	 * @interface Buffer
	 * @extends Uint8Array
	 */

	/**
	 * Node's Buffer class if available.
	 * @type {Constructor<Buffer>}
	 */
	util.Buffer = (function() {
	    try {
	        var Buffer = util.inquire("buffer").Buffer;
	        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
	        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
	    } catch (e) {
	        /* istanbul ignore next */
	        return null;
	    }
	})();

	// Internal alias of or polyfull for Buffer.from.
	util._Buffer_from = null;

	// Internal alias of or polyfill for Buffer.allocUnsafe.
	util._Buffer_allocUnsafe = null;

	/**
	 * Creates a new buffer of whatever type supported by the environment.
	 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
	 * @returns {Uint8Array|Buffer} Buffer
	 */
	util.newBuffer = function newBuffer(sizeOrArray) {
	    /* istanbul ignore next */
	    return typeof sizeOrArray === "number"
	        ? util.Buffer
	            ? util._Buffer_allocUnsafe(sizeOrArray)
	            : new util.Array(sizeOrArray)
	        : util.Buffer
	            ? util._Buffer_from(sizeOrArray)
	            : typeof Uint8Array === "undefined"
	                ? sizeOrArray
	                : new Uint8Array(sizeOrArray);
	};

	/**
	 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
	 * @type {Constructor<Uint8Array>}
	 */
	util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

	/**
	 * Any compatible Long instance.
	 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
	 * @interface Long
	 * @property {number} low Low bits
	 * @property {number} high High bits
	 * @property {boolean} unsigned Whether unsigned or not
	 */

	/**
	 * Long.js's Long class if available.
	 * @type {Constructor<Long>}
	 */
	util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
	         || /* istanbul ignore next */ util.global.Long
	         || util.inquire("long");

	/**
	 * Regular expression used to verify 2 bit (`bool`) map keys.
	 * @type {RegExp}
	 * @const
	 */
	util.key2Re = /^true|false|0|1$/;

	/**
	 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
	 * @type {RegExp}
	 * @const
	 */
	util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

	/**
	 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
	 * @type {RegExp}
	 * @const
	 */
	util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

	/**
	 * Converts a number or long to an 8 characters long hash string.
	 * @param {Long|number} value Value to convert
	 * @returns {string} Hash
	 */
	util.longToHash = function longToHash(value) {
	    return value
	        ? util.LongBits.from(value).toHash()
	        : util.LongBits.zeroHash;
	};

	/**
	 * Converts an 8 characters long hash string to a long or number.
	 * @param {string} hash Hash
	 * @param {boolean} [unsigned=false] Whether unsigned or not
	 * @returns {Long|number} Original value
	 */
	util.longFromHash = function longFromHash(hash, unsigned) {
	    var bits = util.LongBits.fromHash(hash);
	    if (util.Long)
	        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
	    return bits.toNumber(Boolean(unsigned));
	};

	/**
	 * Merges the properties of the source object into the destination object.
	 * @memberof util
	 * @param {Object.<string,*>} dst Destination object
	 * @param {Object.<string,*>} src Source object
	 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
	 * @returns {Object.<string,*>} Destination object
	 */
	function merge(dst, src, ifNotSet) { // used by converters
	    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
	        if (dst[keys[i]] === undefined || !ifNotSet)
	            dst[keys[i]] = src[keys[i]];
	    return dst;
	}

	util.merge = merge;

	/**
	 * Converts the first character of a string to lower case.
	 * @param {string} str String to convert
	 * @returns {string} Converted string
	 */
	util.lcFirst = function lcFirst(str) {
	    return str.charAt(0).toLowerCase() + str.substring(1);
	};

	/**
	 * Creates a custom error constructor.
	 * @memberof util
	 * @param {string} name Error name
	 * @returns {Constructor<Error>} Custom error constructor
	 */
	function newError(name) {

	    function CustomError(message, properties) {

	        if (!(this instanceof CustomError))
	            return new CustomError(message, properties);

	        // Error.call(this, message);
	        // ^ just returns a new error instance because the ctor can be called as a function

	        Object.defineProperty(this, "message", { get: function() { return message; } });

	        /* istanbul ignore next */
	        if (Error.captureStackTrace) // node
	            Error.captureStackTrace(this, CustomError);
	        else
	            Object.defineProperty(this, "stack", { value: new Error().stack || "" });

	        if (properties)
	            merge(this, properties);
	    }

	    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

	    Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; } });

	    CustomError.prototype.toString = function toString() {
	        return this.name + ": " + this.message;
	    };

	    return CustomError;
	}

	util.newError = newError;

	/**
	 * Constructs a new protocol error.
	 * @classdesc Error subclass indicating a protocol specifc error.
	 * @memberof util
	 * @extends Error
	 * @template T extends Message<T>
	 * @constructor
	 * @param {string} message Error message
	 * @param {Object.<string,*>} [properties] Additional properties
	 * @example
	 * try {
	 *     MyMessage.decode(someBuffer); // throws if required fields are missing
	 * } catch (e) {
	 *     if (e instanceof ProtocolError && e.instance)
	 *         console.log("decoded so far: " + JSON.stringify(e.instance));
	 * }
	 */
	util.ProtocolError = newError("ProtocolError");

	/**
	 * So far decoded message instance.
	 * @name util.ProtocolError#instance
	 * @type {Message<T>}
	 */

	/**
	 * A OneOf getter as returned by {@link util.oneOfGetter}.
	 * @typedef OneOfGetter
	 * @type {function}
	 * @returns {string|undefined} Set field name, if any
	 */

	/**
	 * Builds a getter for a oneof's present field name.
	 * @param {string[]} fieldNames Field names
	 * @returns {OneOfGetter} Unbound getter
	 */
	util.oneOfGetter = function getOneOf(fieldNames) {
	    var fieldMap = {};
	    for (var i = 0; i < fieldNames.length; ++i)
	        fieldMap[fieldNames[i]] = 1;

	    /**
	     * @returns {string|undefined} Set field name, if any
	     * @this Object
	     * @ignore
	     */
	    return function() { // eslint-disable-line consistent-return
	        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
	            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
	                return keys[i];
	    };
	};

	/**
	 * A OneOf setter as returned by {@link util.oneOfSetter}.
	 * @typedef OneOfSetter
	 * @type {function}
	 * @param {string|undefined} value Field name
	 * @returns {undefined}
	 */

	/**
	 * Builds a setter for a oneof's present field name.
	 * @param {string[]} fieldNames Field names
	 * @returns {OneOfSetter} Unbound setter
	 */
	util.oneOfSetter = function setOneOf(fieldNames) {

	    /**
	     * @param {string} name Field name
	     * @returns {undefined}
	     * @this Object
	     * @ignore
	     */
	    return function(name) {
	        for (var i = 0; i < fieldNames.length; ++i)
	            if (fieldNames[i] !== name)
	                delete this[fieldNames[i]];
	    };
	};

	/**
	 * Default conversion options used for {@link Message#toJSON} implementations.
	 *
	 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
	 *
	 * - Longs become strings
	 * - Enums become string keys
	 * - Bytes become base64 encoded strings
	 * - (Sub-)Messages become plain objects
	 * - Maps become plain objects with all string keys
	 * - Repeated fields become arrays
	 * - NaN and Infinity for float and double fields become strings
	 *
	 * @type {IConversionOptions}
	 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
	 */
	util.toJSONOptions = {
	    longs: String,
	    enums: String,
	    bytes: String,
	    json: true
	};

	// Sets up buffer utility according to the environment (called in index-minimal)
	util._configure = function() {
	    var Buffer = util.Buffer;
	    /* istanbul ignore if */
	    if (!Buffer) {
	        util._Buffer_from = util._Buffer_allocUnsafe = null;
	        return;
	    }
	    // because node 4.x buffers are incompatible & immutable
	    // see: https://github.com/dcodeIO/protobuf.js/pull/665
	    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
	        /* istanbul ignore next */
	        function Buffer_from(value, encoding) {
	            return new Buffer(value, encoding);
	        };
	    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
	        /* istanbul ignore next */
	        function Buffer_allocUnsafe(size) {
	            return new Buffer(size);
	        };
	};
	});

	var writer = Writer;



	var BufferWriter; // cyclic

	var LongBits$1  = minimal.LongBits,
	    base64    = minimal.base64,
	    utf8      = minimal.utf8;

	/**
	 * Constructs a new writer operation instance.
	 * @classdesc Scheduled writer operation.
	 * @constructor
	 * @param {function(*, Uint8Array, number)} fn Function to call
	 * @param {number} len Value byte length
	 * @param {*} val Value to write
	 * @ignore
	 */
	function Op(fn, len, val) {

	    /**
	     * Function to call.
	     * @type {function(Uint8Array, number, *)}
	     */
	    this.fn = fn;

	    /**
	     * Value byte length.
	     * @type {number}
	     */
	    this.len = len;

	    /**
	     * Next operation.
	     * @type {Writer.Op|undefined}
	     */
	    this.next = undefined;

	    /**
	     * Value to write.
	     * @type {*}
	     */
	    this.val = val; // type varies
	}

	/* istanbul ignore next */
	function noop() {} // eslint-disable-line no-empty-function

	/**
	 * Constructs a new writer state instance.
	 * @classdesc Copied writer state.
	 * @memberof Writer
	 * @constructor
	 * @param {Writer} writer Writer to copy state from
	 * @ignore
	 */
	function State(writer) {

	    /**
	     * Current head.
	     * @type {Writer.Op}
	     */
	    this.head = writer.head;

	    /**
	     * Current tail.
	     * @type {Writer.Op}
	     */
	    this.tail = writer.tail;

	    /**
	     * Current buffer length.
	     * @type {number}
	     */
	    this.len = writer.len;

	    /**
	     * Next state.
	     * @type {State|null}
	     */
	    this.next = writer.states;
	}

	/**
	 * Constructs a new writer instance.
	 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
	 * @constructor
	 */
	function Writer() {

	    /**
	     * Current length.
	     * @type {number}
	     */
	    this.len = 0;

	    /**
	     * Operations head.
	     * @type {Object}
	     */
	    this.head = new Op(noop, 0, 0);

	    /**
	     * Operations tail
	     * @type {Object}
	     */
	    this.tail = this.head;

	    /**
	     * Linked forked states.
	     * @type {Object|null}
	     */
	    this.states = null;

	    // When a value is written, the writer calculates its byte length and puts it into a linked
	    // list of operations to perform when finish() is called. This both allows us to allocate
	    // buffers of the exact required size and reduces the amount of work we have to do compared
	    // to first calculating over objects and then encoding over objects. In our case, the encoding
	    // part is just a linked list walk calling operations with already prepared values.
	}

	var create = function create() {
	    return minimal.Buffer
	        ? function create_buffer_setup() {
	            return (Writer.create = function create_buffer() {
	                return new BufferWriter();
	            })();
	        }
	        /* istanbul ignore next */
	        : function create_array() {
	            return new Writer();
	        };
	};

	/**
	 * Creates a new writer.
	 * @function
	 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
	 */
	Writer.create = create();

	/**
	 * Allocates a buffer of the specified size.
	 * @param {number} size Buffer size
	 * @returns {Uint8Array} Buffer
	 */
	Writer.alloc = function alloc(size) {
	    return new minimal.Array(size);
	};

	// Use Uint8Array buffer pool in the browser, just like node does with buffers
	/* istanbul ignore else */
	if (minimal.Array !== Array)
	    Writer.alloc = minimal.pool(Writer.alloc, minimal.Array.prototype.subarray);

	/**
	 * Pushes a new operation to the queue.
	 * @param {function(Uint8Array, number, *)} fn Function to call
	 * @param {number} len Value byte length
	 * @param {number} val Value to write
	 * @returns {Writer} `this`
	 * @private
	 */
	Writer.prototype._push = function push(fn, len, val) {
	    this.tail = this.tail.next = new Op(fn, len, val);
	    this.len += len;
	    return this;
	};

	function writeByte(val, buf, pos) {
	    buf[pos] = val & 255;
	}

	function writeVarint32(val, buf, pos) {
	    while (val > 127) {
	        buf[pos++] = val & 127 | 128;
	        val >>>= 7;
	    }
	    buf[pos] = val;
	}

	/**
	 * Constructs a new varint writer operation instance.
	 * @classdesc Scheduled varint writer operation.
	 * @extends Op
	 * @constructor
	 * @param {number} len Value byte length
	 * @param {number} val Value to write
	 * @ignore
	 */
	function VarintOp(len, val) {
	    this.len = len;
	    this.next = undefined;
	    this.val = val;
	}

	VarintOp.prototype = Object.create(Op.prototype);
	VarintOp.prototype.fn = writeVarint32;

	/**
	 * Writes an unsigned 32 bit value as a varint.
	 * @param {number} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.uint32 = function write_uint32(value) {
	    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
	    // uint32 is by far the most frequently used operation and benefits significantly from this.
	    this.len += (this.tail = this.tail.next = new VarintOp(
	        (value = value >>> 0)
	                < 128       ? 1
	        : value < 16384     ? 2
	        : value < 2097152   ? 3
	        : value < 268435456 ? 4
	        :                     5,
	    value)).len;
	    return this;
	};

	/**
	 * Writes a signed 32 bit value as a varint.
	 * @function
	 * @param {number} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.int32 = function write_int32(value) {
	    return value < 0
	        ? this._push(writeVarint64, 10, LongBits$1.fromNumber(value)) // 10 bytes per spec
	        : this.uint32(value);
	};

	/**
	 * Writes a 32 bit value as a varint, zig-zag encoded.
	 * @param {number} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.sint32 = function write_sint32(value) {
	    return this.uint32((value << 1 ^ value >> 31) >>> 0);
	};

	function writeVarint64(val, buf, pos) {
	    while (val.hi) {
	        buf[pos++] = val.lo & 127 | 128;
	        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
	        val.hi >>>= 7;
	    }
	    while (val.lo > 127) {
	        buf[pos++] = val.lo & 127 | 128;
	        val.lo = val.lo >>> 7;
	    }
	    buf[pos++] = val.lo;
	}

	/**
	 * Writes an unsigned 64 bit value as a varint.
	 * @param {Long|number|string} value Value to write
	 * @returns {Writer} `this`
	 * @throws {TypeError} If `value` is a string and no long library is present.
	 */
	Writer.prototype.uint64 = function write_uint64(value) {
	    var bits = LongBits$1.from(value);
	    return this._push(writeVarint64, bits.length(), bits);
	};

	/**
	 * Writes a signed 64 bit value as a varint.
	 * @function
	 * @param {Long|number|string} value Value to write
	 * @returns {Writer} `this`
	 * @throws {TypeError} If `value` is a string and no long library is present.
	 */
	Writer.prototype.int64 = Writer.prototype.uint64;

	/**
	 * Writes a signed 64 bit value as a varint, zig-zag encoded.
	 * @param {Long|number|string} value Value to write
	 * @returns {Writer} `this`
	 * @throws {TypeError} If `value` is a string and no long library is present.
	 */
	Writer.prototype.sint64 = function write_sint64(value) {
	    var bits = LongBits$1.from(value).zzEncode();
	    return this._push(writeVarint64, bits.length(), bits);
	};

	/**
	 * Writes a boolish value as a varint.
	 * @param {boolean} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.bool = function write_bool(value) {
	    return this._push(writeByte, 1, value ? 1 : 0);
	};

	function writeFixed32(val, buf, pos) {
	    buf[pos    ] =  val         & 255;
	    buf[pos + 1] =  val >>> 8   & 255;
	    buf[pos + 2] =  val >>> 16  & 255;
	    buf[pos + 3] =  val >>> 24;
	}

	/**
	 * Writes an unsigned 32 bit value as fixed 32 bits.
	 * @param {number} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.fixed32 = function write_fixed32(value) {
	    return this._push(writeFixed32, 4, value >>> 0);
	};

	/**
	 * Writes a signed 32 bit value as fixed 32 bits.
	 * @function
	 * @param {number} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.sfixed32 = Writer.prototype.fixed32;

	/**
	 * Writes an unsigned 64 bit value as fixed 64 bits.
	 * @param {Long|number|string} value Value to write
	 * @returns {Writer} `this`
	 * @throws {TypeError} If `value` is a string and no long library is present.
	 */
	Writer.prototype.fixed64 = function write_fixed64(value) {
	    var bits = LongBits$1.from(value);
	    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
	};

	/**
	 * Writes a signed 64 bit value as fixed 64 bits.
	 * @function
	 * @param {Long|number|string} value Value to write
	 * @returns {Writer} `this`
	 * @throws {TypeError} If `value` is a string and no long library is present.
	 */
	Writer.prototype.sfixed64 = Writer.prototype.fixed64;

	/**
	 * Writes a float (32 bit).
	 * @function
	 * @param {number} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.float = function write_float(value) {
	    return this._push(minimal.float.writeFloatLE, 4, value);
	};

	/**
	 * Writes a double (64 bit float).
	 * @function
	 * @param {number} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.double = function write_double(value) {
	    return this._push(minimal.float.writeDoubleLE, 8, value);
	};

	var writeBytes = minimal.Array.prototype.set
	    ? function writeBytes_set(val, buf, pos) {
	        buf.set(val, pos); // also works for plain array values
	    }
	    /* istanbul ignore next */
	    : function writeBytes_for(val, buf, pos) {
	        for (var i = 0; i < val.length; ++i)
	            buf[pos + i] = val[i];
	    };

	/**
	 * Writes a sequence of bytes.
	 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.bytes = function write_bytes(value) {
	    var len = value.length >>> 0;
	    if (!len)
	        return this._push(writeByte, 1, 0);
	    if (minimal.isString(value)) {
	        var buf = Writer.alloc(len = base64.length(value));
	        base64.decode(value, buf, 0);
	        value = buf;
	    }
	    return this.uint32(len)._push(writeBytes, len, value);
	};

	/**
	 * Writes a string.
	 * @param {string} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.string = function write_string(value) {
	    var len = utf8.length(value);
	    return len
	        ? this.uint32(len)._push(utf8.write, len, value)
	        : this._push(writeByte, 1, 0);
	};

	/**
	 * Forks this writer's state by pushing it to a stack.
	 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
	 * @returns {Writer} `this`
	 */
	Writer.prototype.fork = function fork() {
	    this.states = new State(this);
	    this.head = this.tail = new Op(noop, 0, 0);
	    this.len = 0;
	    return this;
	};

	/**
	 * Resets this instance to the last state.
	 * @returns {Writer} `this`
	 */
	Writer.prototype.reset = function reset() {
	    if (this.states) {
	        this.head   = this.states.head;
	        this.tail   = this.states.tail;
	        this.len    = this.states.len;
	        this.states = this.states.next;
	    } else {
	        this.head = this.tail = new Op(noop, 0, 0);
	        this.len  = 0;
	    }
	    return this;
	};

	/**
	 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
	 * @returns {Writer} `this`
	 */
	Writer.prototype.ldelim = function ldelim() {
	    var head = this.head,
	        tail = this.tail,
	        len  = this.len;
	    this.reset().uint32(len);
	    if (len) {
	        this.tail.next = head.next; // skip noop
	        this.tail = tail;
	        this.len += len;
	    }
	    return this;
	};

	/**
	 * Finishes the write operation.
	 * @returns {Uint8Array} Finished buffer
	 */
	Writer.prototype.finish = function finish() {
	    var head = this.head.next, // skip noop
	        buf  = this.constructor.alloc(this.len),
	        pos  = 0;
	    while (head) {
	        head.fn(head.val, buf, pos);
	        pos += head.len;
	        head = head.next;
	    }
	    // this.head = this.tail = null;
	    return buf;
	};

	Writer._configure = function(BufferWriter_) {
	    BufferWriter = BufferWriter_;
	    Writer.create = create();
	    BufferWriter._configure();
	};

	var writer_buffer = BufferWriter$1;

	// extends Writer

	(BufferWriter$1.prototype = Object.create(writer.prototype)).constructor = BufferWriter$1;



	/**
	 * Constructs a new buffer writer instance.
	 * @classdesc Wire format writer using node buffers.
	 * @extends Writer
	 * @constructor
	 */
	function BufferWriter$1() {
	    writer.call(this);
	}

	BufferWriter$1._configure = function () {
	    /**
	     * Allocates a buffer of the specified size.
	     * @function
	     * @param {number} size Buffer size
	     * @returns {Buffer} Buffer
	     */
	    BufferWriter$1.alloc = minimal._Buffer_allocUnsafe;

	    BufferWriter$1.writeBytesBuffer = minimal.Buffer && minimal.Buffer.prototype instanceof Uint8Array && minimal.Buffer.prototype.set.name === "set"
	        ? function writeBytesBuffer_set(val, buf, pos) {
	          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
	          // also works for plain array values
	        }
	        /* istanbul ignore next */
	        : function writeBytesBuffer_copy(val, buf, pos) {
	          if (val.copy) // Buffer values
	            val.copy(buf, pos, 0, val.length);
	          else for (var i = 0; i < val.length;) // plain array values
	            buf[pos++] = val[i++];
	        };
	};


	/**
	 * @override
	 */
	BufferWriter$1.prototype.bytes = function write_bytes_buffer(value) {
	    if (minimal.isString(value))
	        value = minimal._Buffer_from(value, "base64");
	    var len = value.length >>> 0;
	    this.uint32(len);
	    if (len)
	        this._push(BufferWriter$1.writeBytesBuffer, len, value);
	    return this;
	};

	function writeStringBuffer(val, buf, pos) {
	    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
	        minimal.utf8.write(val, buf, pos);
	    else if (buf.utf8Write)
	        buf.utf8Write(val, pos);
	    else
	        buf.write(val, pos);
	}

	/**
	 * @override
	 */
	BufferWriter$1.prototype.string = function write_string_buffer(value) {
	    var len = minimal.Buffer.byteLength(value);
	    this.uint32(len);
	    if (len)
	        this._push(writeStringBuffer, len, value);
	    return this;
	};


	/**
	 * Finishes the write operation.
	 * @name BufferWriter#finish
	 * @function
	 * @returns {Buffer} Finished buffer
	 */

	BufferWriter$1._configure();

	var reader = Reader;



	var BufferReader; // cyclic

	var LongBits$2  = minimal.LongBits,
	    utf8$1      = minimal.utf8;

	/* istanbul ignore next */
	function indexOutOfRange(reader, writeLength) {
	    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
	}

	/**
	 * Constructs a new reader instance using the specified buffer.
	 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
	 * @constructor
	 * @param {Uint8Array} buffer Buffer to read from
	 */
	function Reader(buffer) {

	    /**
	     * Read buffer.
	     * @type {Uint8Array}
	     */
	    this.buf = buffer;

	    /**
	     * Read buffer position.
	     * @type {number}
	     */
	    this.pos = 0;

	    /**
	     * Read buffer length.
	     * @type {number}
	     */
	    this.len = buffer.length;
	}

	var create_array = typeof Uint8Array !== "undefined"
	    ? function create_typed_array(buffer) {
	        if (buffer instanceof Uint8Array || Array.isArray(buffer))
	            return new Reader(buffer);
	        throw Error("illegal buffer");
	    }
	    /* istanbul ignore next */
	    : function create_array(buffer) {
	        if (Array.isArray(buffer))
	            return new Reader(buffer);
	        throw Error("illegal buffer");
	    };

	var create$1 = function create() {
	    return minimal.Buffer
	        ? function create_buffer_setup(buffer) {
	            return (Reader.create = function create_buffer(buffer) {
	                return minimal.Buffer.isBuffer(buffer)
	                    ? new BufferReader(buffer)
	                    /* istanbul ignore next */
	                    : create_array(buffer);
	            })(buffer);
	        }
	        /* istanbul ignore next */
	        : create_array;
	};

	/**
	 * Creates a new reader using the specified buffer.
	 * @function
	 * @param {Uint8Array|Buffer} buffer Buffer to read from
	 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
	 * @throws {Error} If `buffer` is not a valid buffer
	 */
	Reader.create = create$1();

	Reader.prototype._slice = minimal.Array.prototype.subarray || /* istanbul ignore next */ minimal.Array.prototype.slice;

	/**
	 * Reads a varint as an unsigned 32 bit value.
	 * @function
	 * @returns {number} Value read
	 */
	Reader.prototype.uint32 = (function read_uint32_setup() {
	    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
	    return function read_uint32() {
	        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
	        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
	        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
	        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
	        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

	        /* istanbul ignore if */
	        if ((this.pos += 5) > this.len) {
	            this.pos = this.len;
	            throw indexOutOfRange(this, 10);
	        }
	        return value;
	    };
	})();

	/**
	 * Reads a varint as a signed 32 bit value.
	 * @returns {number} Value read
	 */
	Reader.prototype.int32 = function read_int32() {
	    return this.uint32() | 0;
	};

	/**
	 * Reads a zig-zag encoded varint as a signed 32 bit value.
	 * @returns {number} Value read
	 */
	Reader.prototype.sint32 = function read_sint32() {
	    var value = this.uint32();
	    return value >>> 1 ^ -(value & 1) | 0;
	};

	/* eslint-disable no-invalid-this */

	function readLongVarint() {
	    // tends to deopt with local vars for octet etc.
	    var bits = new LongBits$2(0, 0);
	    var i = 0;
	    if (this.len - this.pos > 4) { // fast route (lo)
	        for (; i < 4; ++i) {
	            // 1st..4th
	            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
	            if (this.buf[this.pos++] < 128)
	                return bits;
	        }
	        // 5th
	        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
	        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
	        if (this.buf[this.pos++] < 128)
	            return bits;
	        i = 0;
	    } else {
	        for (; i < 3; ++i) {
	            /* istanbul ignore if */
	            if (this.pos >= this.len)
	                throw indexOutOfRange(this);
	            // 1st..3th
	            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
	            if (this.buf[this.pos++] < 128)
	                return bits;
	        }
	        // 4th
	        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
	        return bits;
	    }
	    if (this.len - this.pos > 4) { // fast route (hi)
	        for (; i < 5; ++i) {
	            // 6th..10th
	            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
	            if (this.buf[this.pos++] < 128)
	                return bits;
	        }
	    } else {
	        for (; i < 5; ++i) {
	            /* istanbul ignore if */
	            if (this.pos >= this.len)
	                throw indexOutOfRange(this);
	            // 6th..10th
	            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
	            if (this.buf[this.pos++] < 128)
	                return bits;
	        }
	    }
	    /* istanbul ignore next */
	    throw Error("invalid varint encoding");
	}

	/* eslint-enable no-invalid-this */

	/**
	 * Reads a varint as a signed 64 bit value.
	 * @name Reader#int64
	 * @function
	 * @returns {Long} Value read
	 */

	/**
	 * Reads a varint as an unsigned 64 bit value.
	 * @name Reader#uint64
	 * @function
	 * @returns {Long} Value read
	 */

	/**
	 * Reads a zig-zag encoded varint as a signed 64 bit value.
	 * @name Reader#sint64
	 * @function
	 * @returns {Long} Value read
	 */

	/**
	 * Reads a varint as a boolean.
	 * @returns {boolean} Value read
	 */
	Reader.prototype.bool = function read_bool() {
	    return this.uint32() !== 0;
	};

	function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
	    return (buf[end - 4]
	          | buf[end - 3] << 8
	          | buf[end - 2] << 16
	          | buf[end - 1] << 24) >>> 0;
	}

	/**
	 * Reads fixed 32 bits as an unsigned 32 bit integer.
	 * @returns {number} Value read
	 */
	Reader.prototype.fixed32 = function read_fixed32() {

	    /* istanbul ignore if */
	    if (this.pos + 4 > this.len)
	        throw indexOutOfRange(this, 4);

	    return readFixed32_end(this.buf, this.pos += 4);
	};

	/**
	 * Reads fixed 32 bits as a signed 32 bit integer.
	 * @returns {number} Value read
	 */
	Reader.prototype.sfixed32 = function read_sfixed32() {

	    /* istanbul ignore if */
	    if (this.pos + 4 > this.len)
	        throw indexOutOfRange(this, 4);

	    return readFixed32_end(this.buf, this.pos += 4) | 0;
	};

	/* eslint-disable no-invalid-this */

	function readFixed64(/* this: Reader */) {

	    /* istanbul ignore if */
	    if (this.pos + 8 > this.len)
	        throw indexOutOfRange(this, 8);

	    return new LongBits$2(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
	}

	/* eslint-enable no-invalid-this */

	/**
	 * Reads fixed 64 bits.
	 * @name Reader#fixed64
	 * @function
	 * @returns {Long} Value read
	 */

	/**
	 * Reads zig-zag encoded fixed 64 bits.
	 * @name Reader#sfixed64
	 * @function
	 * @returns {Long} Value read
	 */

	/**
	 * Reads a float (32 bit) as a number.
	 * @function
	 * @returns {number} Value read
	 */
	Reader.prototype.float = function read_float() {

	    /* istanbul ignore if */
	    if (this.pos + 4 > this.len)
	        throw indexOutOfRange(this, 4);

	    var value = minimal.float.readFloatLE(this.buf, this.pos);
	    this.pos += 4;
	    return value;
	};

	/**
	 * Reads a double (64 bit float) as a number.
	 * @function
	 * @returns {number} Value read
	 */
	Reader.prototype.double = function read_double() {

	    /* istanbul ignore if */
	    if (this.pos + 8 > this.len)
	        throw indexOutOfRange(this, 4);

	    var value = minimal.float.readDoubleLE(this.buf, this.pos);
	    this.pos += 8;
	    return value;
	};

	/**
	 * Reads a sequence of bytes preceeded by its length as a varint.
	 * @returns {Uint8Array} Value read
	 */
	Reader.prototype.bytes = function read_bytes() {
	    var length = this.uint32(),
	        start  = this.pos,
	        end    = this.pos + length;

	    /* istanbul ignore if */
	    if (end > this.len)
	        throw indexOutOfRange(this, length);

	    this.pos += length;
	    if (Array.isArray(this.buf)) // plain array
	        return this.buf.slice(start, end);
	    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
	        ? new this.buf.constructor(0)
	        : this._slice.call(this.buf, start, end);
	};

	/**
	 * Reads a string preceeded by its byte length as a varint.
	 * @returns {string} Value read
	 */
	Reader.prototype.string = function read_string() {
	    var bytes = this.bytes();
	    return utf8$1.read(bytes, 0, bytes.length);
	};

	/**
	 * Skips the specified number of bytes if specified, otherwise skips a varint.
	 * @param {number} [length] Length if known, otherwise a varint is assumed
	 * @returns {Reader} `this`
	 */
	Reader.prototype.skip = function skip(length) {
	    if (typeof length === "number") {
	        /* istanbul ignore if */
	        if (this.pos + length > this.len)
	            throw indexOutOfRange(this, length);
	        this.pos += length;
	    } else {
	        do {
	            /* istanbul ignore if */
	            if (this.pos >= this.len)
	                throw indexOutOfRange(this);
	        } while (this.buf[this.pos++] & 128);
	    }
	    return this;
	};

	/**
	 * Skips the next element of the specified wire type.
	 * @param {number} wireType Wire type received
	 * @returns {Reader} `this`
	 */
	Reader.prototype.skipType = function(wireType) {
	    switch (wireType) {
	        case 0:
	            this.skip();
	            break;
	        case 1:
	            this.skip(8);
	            break;
	        case 2:
	            this.skip(this.uint32());
	            break;
	        case 3:
	            while ((wireType = this.uint32() & 7) !== 4) {
	                this.skipType(wireType);
	            }
	            break;
	        case 5:
	            this.skip(4);
	            break;

	        /* istanbul ignore next */
	        default:
	            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
	    }
	    return this;
	};

	Reader._configure = function(BufferReader_) {
	    BufferReader = BufferReader_;
	    Reader.create = create$1();
	    BufferReader._configure();

	    var fn = minimal.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
	    minimal.merge(Reader.prototype, {

	        int64: function read_int64() {
	            return readLongVarint.call(this)[fn](false);
	        },

	        uint64: function read_uint64() {
	            return readLongVarint.call(this)[fn](true);
	        },

	        sint64: function read_sint64() {
	            return readLongVarint.call(this).zzDecode()[fn](false);
	        },

	        fixed64: function read_fixed64() {
	            return readFixed64.call(this)[fn](true);
	        },

	        sfixed64: function read_sfixed64() {
	            return readFixed64.call(this)[fn](false);
	        }

	    });
	};

	var reader_buffer = BufferReader$1;

	// extends Reader

	(BufferReader$1.prototype = Object.create(reader.prototype)).constructor = BufferReader$1;



	/**
	 * Constructs a new buffer reader instance.
	 * @classdesc Wire format reader using node buffers.
	 * @extends Reader
	 * @constructor
	 * @param {Buffer} buffer Buffer to read from
	 */
	function BufferReader$1(buffer) {
	    reader.call(this, buffer);

	    /**
	     * Read buffer.
	     * @name BufferReader#buf
	     * @type {Buffer}
	     */
	}

	BufferReader$1._configure = function () {
	    /* istanbul ignore else */
	    if (minimal.Buffer)
	        BufferReader$1.prototype._slice = minimal.Buffer.prototype.slice;
	};


	/**
	 * @override
	 */
	BufferReader$1.prototype.string = function read_string_buffer() {
	    var len = this.uint32(); // modifies pos
	    return this.buf.utf8Slice
	        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))
	        : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
	};

	/**
	 * Reads a sequence of bytes preceeded by its length as a varint.
	 * @name BufferReader#bytes
	 * @function
	 * @returns {Buffer} Value read
	 */

	BufferReader$1._configure();

	var service = Service;



	// Extends EventEmitter
	(Service.prototype = Object.create(minimal.EventEmitter.prototype)).constructor = Service;

	/**
	 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
	 *
	 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
	 * @typedef rpc.ServiceMethodCallback
	 * @template TRes extends Message<TRes>
	 * @type {function}
	 * @param {Error|null} error Error, if any
	 * @param {TRes} [response] Response message
	 * @returns {undefined}
	 */

	/**
	 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
	 * @typedef rpc.ServiceMethod
	 * @template TReq extends Message<TReq>
	 * @template TRes extends Message<TRes>
	 * @type {function}
	 * @param {TReq|Properties<TReq>} request Request message or plain object
	 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
	 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
	 */

	/**
	 * Constructs a new RPC service instance.
	 * @classdesc An RPC service as returned by {@link Service#create}.
	 * @exports rpc.Service
	 * @extends util.EventEmitter
	 * @constructor
	 * @param {RPCImpl} rpcImpl RPC implementation
	 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
	 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
	 */
	function Service(rpcImpl, requestDelimited, responseDelimited) {

	    if (typeof rpcImpl !== "function")
	        throw TypeError("rpcImpl must be a function");

	    minimal.EventEmitter.call(this);

	    /**
	     * RPC implementation. Becomes `null` once the service is ended.
	     * @type {RPCImpl|null}
	     */
	    this.rpcImpl = rpcImpl;

	    /**
	     * Whether requests are length-delimited.
	     * @type {boolean}
	     */
	    this.requestDelimited = Boolean(requestDelimited);

	    /**
	     * Whether responses are length-delimited.
	     * @type {boolean}
	     */
	    this.responseDelimited = Boolean(responseDelimited);
	}

	/**
	 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
	 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
	 * @param {Constructor<TReq>} requestCtor Request constructor
	 * @param {Constructor<TRes>} responseCtor Response constructor
	 * @param {TReq|Properties<TReq>} request Request message or plain object
	 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
	 * @returns {undefined}
	 * @template TReq extends Message<TReq>
	 * @template TRes extends Message<TRes>
	 */
	Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

	    if (!request)
	        throw TypeError("request must be specified");

	    var self = this;
	    if (!callback)
	        return minimal.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

	    if (!self.rpcImpl) {
	        setTimeout(function() { callback(Error("already ended")); }, 0);
	        return undefined;
	    }

	    try {
	        return self.rpcImpl(
	            method,
	            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
	            function rpcCallback(err, response) {

	                if (err) {
	                    self.emit("error", err, method);
	                    return callback(err);
	                }

	                if (response === null) {
	                    self.end(/* endedByRPC */ true);
	                    return undefined;
	                }

	                if (!(response instanceof responseCtor)) {
	                    try {
	                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
	                    } catch (err) {
	                        self.emit("error", err, method);
	                        return callback(err);
	                    }
	                }

	                self.emit("data", response, method);
	                return callback(null, response);
	            }
	        );
	    } catch (err) {
	        self.emit("error", err, method);
	        setTimeout(function() { callback(err); }, 0);
	        return undefined;
	    }
	};

	/**
	 * Ends this service and emits the `end` event.
	 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
	 * @returns {rpc.Service} `this`
	 */
	Service.prototype.end = function end(endedByRPC) {
	    if (this.rpcImpl) {
	        if (!endedByRPC) // signal end to rpcImpl
	            this.rpcImpl(null, null, null);
	        this.rpcImpl = null;
	        this.emit("end").off();
	    }
	    return this;
	};

	var rpc_1 = createCommonjsModule(function (module, exports) {

	/**
	 * Streaming RPC helpers.
	 * @namespace
	 */
	var rpc = exports;

	/**
	 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
	 * @typedef RPCImpl
	 * @type {function}
	 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
	 * @param {Uint8Array} requestData Request data
	 * @param {RPCImplCallback} callback Callback function
	 * @returns {undefined}
	 * @example
	 * function rpcImpl(method, requestData, callback) {
	 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
	 *         throw Error("no such method");
	 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
	 *         callback(err, responseData);
	 *     });
	 * }
	 */

	/**
	 * Node-style callback as used by {@link RPCImpl}.
	 * @typedef RPCImplCallback
	 * @type {function}
	 * @param {Error|null} error Error, if any, otherwise `null`
	 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
	 * @returns {undefined}
	 */

	rpc.Service = service;
	});

	var roots = {};

	var indexMinimal = createCommonjsModule(function (module, exports) {
	var protobuf = exports;

	/**
	 * Build type, one of `"full"`, `"light"` or `"minimal"`.
	 * @name build
	 * @type {string}
	 * @const
	 */
	protobuf.build = "minimal";

	// Serialization
	protobuf.Writer       = writer;
	protobuf.BufferWriter = writer_buffer;
	protobuf.Reader       = reader;
	protobuf.BufferReader = reader_buffer;

	// Utility
	protobuf.util         = minimal;
	protobuf.rpc          = rpc_1;
	protobuf.roots        = roots;
	protobuf.configure    = configure;

	/* istanbul ignore next */
	/**
	 * Reconfigures the library according to the environment.
	 * @returns {undefined}
	 */
	function configure() {
	    protobuf.util._configure();
	    protobuf.Writer._configure(protobuf.BufferWriter);
	    protobuf.Reader._configure(protobuf.BufferReader);
	}

	// Set up buffer utility according to the environment
	configure();
	});

	var minimal$1 = indexMinimal;

	var $Reader = minimal$1.Reader,
	    $Writer = minimal$1.Writer,
	    $util = minimal$1.util; // Exported root namespace

	var $root = minimal$1.roots["default"] || (minimal$1.roots["default"] = {});

	$root.Events = function () {
	  /**
	   * Namespace Events.
	   * @exports Events
	   * @namespace
	   */
	  var Events = {};

	  Events.Message = function () {
	    /**
	     * Properties of a Message.
	     * @memberof Events
	     * @interface IMessage
	     * @property {number|Long|null} [id] Message id
	     * @property {Uint8Array|null} [msg] Message msg
	     */

	    /**
	     * Constructs a new Message.
	     * @memberof Events
	     * @classdesc Represents a Message.
	     * @implements IMessage
	     * @constructor
	     * @param {Events.IMessage=} [properties] Properties to set
	     */
	    function Message(properties) {
	      if (properties) for (var keys = keys$3(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	    }
	    /**
	     * Message id.
	     * @member {number|Long} id
	     * @memberof Events.Message
	     * @instance
	     */


	    Message.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
	    /**
	     * Message msg.
	     * @member {Uint8Array} msg
	     * @memberof Events.Message
	     * @instance
	     */

	    Message.prototype.msg = $util.newBuffer([]);
	    /**
	     * Creates a new Message instance using the specified properties.
	     * @function create
	     * @memberof Events.Message
	     * @static
	     * @param {Events.IMessage=} [properties] Properties to set
	     * @returns {Events.Message} Message instance
	     */

	    Message.create = function create(properties) {
	      return new Message(properties);
	    };
	    /**
	     * Encodes the specified Message message. Does not implicitly {@link Events.Message.verify|verify} messages.
	     * @function encode
	     * @memberof Events.Message
	     * @static
	     * @param {Events.IMessage} message Message message or plain object to encode
	     * @param {$protobuf.Writer} [writer] Writer to encode to
	     * @returns {$protobuf.Writer} Writer
	     */


	    Message.encode = function encode(message, writer) {
	      if (!writer) writer = $Writer.create();
	      if (message.id != null && Object.hasOwnProperty.call(message, "id")) writer.uint32(
	      /* id 1, wireType 0 =*/
	      8).int64(message.id);
	      if (message.msg != null && Object.hasOwnProperty.call(message, "msg")) writer.uint32(
	      /* id 2, wireType 2 =*/
	      18).bytes(message.msg);
	      return writer;
	    };
	    /**
	     * Encodes the specified Message message, length delimited. Does not implicitly {@link Events.Message.verify|verify} messages.
	     * @function encodeDelimited
	     * @memberof Events.Message
	     * @static
	     * @param {Events.IMessage} message Message message or plain object to encode
	     * @param {$protobuf.Writer} [writer] Writer to encode to
	     * @returns {$protobuf.Writer} Writer
	     */


	    Message.encodeDelimited = function encodeDelimited(message, writer) {
	      return this.encode(message, writer).ldelim();
	    };
	    /**
	     * Decodes a Message message from the specified reader or buffer.
	     * @function decode
	     * @memberof Events.Message
	     * @static
	     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	     * @param {number} [length] Message length if known beforehand
	     * @returns {Events.Message} Message
	     * @throws {Error} If the payload is not a reader or valid buffer
	     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	     */


	    Message.decode = function decode(reader, length) {
	      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
	      var end = length === undefined ? reader.len : reader.pos + length,
	          message = new $root.Events.Message();

	      while (reader.pos < end) {
	        var tag = reader.uint32();

	        switch (tag >>> 3) {
	          case 1:
	            message.id = reader.int64();
	            break;

	          case 2:
	            message.msg = reader.bytes();
	            break;

	          default:
	            reader.skipType(tag & 7);
	            break;
	        }
	      }

	      return message;
	    };
	    /**
	     * Decodes a Message message from the specified reader or buffer, length delimited.
	     * @function decodeDelimited
	     * @memberof Events.Message
	     * @static
	     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	     * @returns {Events.Message} Message
	     * @throws {Error} If the payload is not a reader or valid buffer
	     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	     */


	    Message.decodeDelimited = function decodeDelimited(reader) {
	      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
	      return this.decode(reader, reader.uint32());
	    };
	    /**
	     * Verifies a Message message.
	     * @function verify
	     * @memberof Events.Message
	     * @static
	     * @param {Object.<string,*>} message Plain object to verify
	     * @returns {string|null} `null` if valid, otherwise the reason why it is not
	     */


	    Message.verify = function verify(message) {
	      if (typeof message !== "object" || message === null) return "object expected";
	      if (message.id != null && message.hasOwnProperty("id")) if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high))) return "id: integer|Long expected";
	      if (message.msg != null && message.hasOwnProperty("msg")) if (!(message.msg && typeof message.msg.length === "number" || $util.isString(message.msg))) return "msg: buffer expected";
	      return null;
	    };
	    /**
	     * Creates a Message message from a plain object. Also converts values to their respective internal types.
	     * @function fromObject
	     * @memberof Events.Message
	     * @static
	     * @param {Object.<string,*>} object Plain object
	     * @returns {Events.Message} Message
	     */


	    Message.fromObject = function fromObject(object) {
	      if (object instanceof $root.Events.Message) return object;
	      var message = new $root.Events.Message();
	      if (object.id != null) if ($util.Long) (message.id = $util.Long.fromValue(object.id)).unsigned = false;else if (typeof object.id === "string") message.id = _parseInt$3(object.id, 10);else if (typeof object.id === "number") message.id = object.id;else if (typeof object.id === "object") message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
	      if (object.msg != null) if (typeof object.msg === "string") $util.base64.decode(object.msg, message.msg = $util.newBuffer($util.base64.length(object.msg)), 0);else if (object.msg.length) message.msg = object.msg;
	      return message;
	    };
	    /**
	     * Creates a plain object from a Message message. Also converts values to other types if specified.
	     * @function toObject
	     * @memberof Events.Message
	     * @static
	     * @param {Events.Message} message Message
	     * @param {$protobuf.IConversionOptions} [options] Conversion options
	     * @returns {Object.<string,*>} Plain object
	     */


	    Message.toObject = function toObject(message, options) {
	      if (!options) options = {};
	      var object = {};

	      if (options.defaults) {
	        if ($util.Long) {
	          var long = new $util.Long(0, 0, false);
	          object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	        } else object.id = options.longs === String ? "0" : 0;

	        if (options.bytes === String) object.msg = "";else {
	          object.msg = [];
	          if (options.bytes !== Array) object.msg = $util.newBuffer(object.msg);
	        }
	      }

	      if (message.id != null && message.hasOwnProperty("id")) if (typeof message.id === "number") object.id = options.longs === String ? String(message.id) : message.id;else object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
	      if (message.msg != null && message.hasOwnProperty("msg")) object.msg = options.bytes === String ? $util.base64.encode(message.msg, 0, message.msg.length) : options.bytes === Array ? slice$2(Array.prototype).call(message.msg) : message.msg;
	      return object;
	    };
	    /**
	     * Converts this Message to JSON.
	     * @function toJSON
	     * @memberof Events.Message
	     * @instance
	     * @returns {Object.<string,*>} JSON object
	     */


	    Message.prototype.toJSON = function toJSON() {
	      return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
	    };

	    return Message;
	  }();

	  Events.ProtoRaws = function () {
	    /**
	     * Properties of a ProtoRaws.
	     * @memberof Events
	     * @interface IProtoRaws
	     * @property {number|Long|null} [sendTs] ProtoRaws sendTs
	     * @property {Array.<Events.IMessage>|null} [payloads] ProtoRaws payloads
	     */

	    /**
	     * Constructs a new ProtoRaws.
	     * @memberof Events
	     * @classdesc Represents a ProtoRaws.
	     * @implements IProtoRaws
	     * @constructor
	     * @param {Events.IProtoRaws=} [properties] Properties to set
	     */
	    function ProtoRaws(properties) {
	      this.payloads = [];
	      if (properties) for (var keys = keys$3(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	    }
	    /**
	     * ProtoRaws sendTs.
	     * @member {number|Long} sendTs
	     * @memberof Events.ProtoRaws
	     * @instance
	     */


	    ProtoRaws.prototype.sendTs = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
	    /**
	     * ProtoRaws payloads.
	     * @member {Array.<Events.IMessage>} payloads
	     * @memberof Events.ProtoRaws
	     * @instance
	     */

	    ProtoRaws.prototype.payloads = $util.emptyArray;
	    /**
	     * Creates a new ProtoRaws instance using the specified properties.
	     * @function create
	     * @memberof Events.ProtoRaws
	     * @static
	     * @param {Events.IProtoRaws=} [properties] Properties to set
	     * @returns {Events.ProtoRaws} ProtoRaws instance
	     */

	    ProtoRaws.create = function create(properties) {
	      return new ProtoRaws(properties);
	    };
	    /**
	     * Encodes the specified ProtoRaws message. Does not implicitly {@link Events.ProtoRaws.verify|verify} messages.
	     * @function encode
	     * @memberof Events.ProtoRaws
	     * @static
	     * @param {Events.IProtoRaws} message ProtoRaws message or plain object to encode
	     * @param {$protobuf.Writer} [writer] Writer to encode to
	     * @returns {$protobuf.Writer} Writer
	     */


	    ProtoRaws.encode = function encode(message, writer) {
	      if (!writer) writer = $Writer.create();
	      if (message.sendTs != null && Object.hasOwnProperty.call(message, "sendTs")) writer.uint32(
	      /* id 1, wireType 0 =*/
	      8).int64(message.sendTs);
	      if (message.payloads != null && message.payloads.length) for (var i = 0; i < message.payloads.length; ++i) $root.Events.Message.encode(message.payloads[i], writer.uint32(
	      /* id 2, wireType 2 =*/
	      18).fork()).ldelim();
	      return writer;
	    };
	    /**
	     * Encodes the specified ProtoRaws message, length delimited. Does not implicitly {@link Events.ProtoRaws.verify|verify} messages.
	     * @function encodeDelimited
	     * @memberof Events.ProtoRaws
	     * @static
	     * @param {Events.IProtoRaws} message ProtoRaws message or plain object to encode
	     * @param {$protobuf.Writer} [writer] Writer to encode to
	     * @returns {$protobuf.Writer} Writer
	     */


	    ProtoRaws.encodeDelimited = function encodeDelimited(message, writer) {
	      return this.encode(message, writer).ldelim();
	    };
	    /**
	     * Decodes a ProtoRaws message from the specified reader or buffer.
	     * @function decode
	     * @memberof Events.ProtoRaws
	     * @static
	     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	     * @param {number} [length] Message length if known beforehand
	     * @returns {Events.ProtoRaws} ProtoRaws
	     * @throws {Error} If the payload is not a reader or valid buffer
	     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	     */


	    ProtoRaws.decode = function decode(reader, length) {
	      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
	      var end = length === undefined ? reader.len : reader.pos + length,
	          message = new $root.Events.ProtoRaws();

	      while (reader.pos < end) {
	        var tag = reader.uint32();

	        switch (tag >>> 3) {
	          case 1:
	            message.sendTs = reader.int64();
	            break;

	          case 2:
	            if (!(message.payloads && message.payloads.length)) message.payloads = [];
	            message.payloads.push($root.Events.Message.decode(reader, reader.uint32()));
	            break;

	          default:
	            reader.skipType(tag & 7);
	            break;
	        }
	      }

	      return message;
	    };
	    /**
	     * Decodes a ProtoRaws message from the specified reader or buffer, length delimited.
	     * @function decodeDelimited
	     * @memberof Events.ProtoRaws
	     * @static
	     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	     * @returns {Events.ProtoRaws} ProtoRaws
	     * @throws {Error} If the payload is not a reader or valid buffer
	     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	     */


	    ProtoRaws.decodeDelimited = function decodeDelimited(reader) {
	      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
	      return this.decode(reader, reader.uint32());
	    };
	    /**
	     * Verifies a ProtoRaws message.
	     * @function verify
	     * @memberof Events.ProtoRaws
	     * @static
	     * @param {Object.<string,*>} message Plain object to verify
	     * @returns {string|null} `null` if valid, otherwise the reason why it is not
	     */


	    ProtoRaws.verify = function verify(message) {
	      if (typeof message !== "object" || message === null) return "object expected";
	      if (message.sendTs != null && message.hasOwnProperty("sendTs")) if (!$util.isInteger(message.sendTs) && !(message.sendTs && $util.isInteger(message.sendTs.low) && $util.isInteger(message.sendTs.high))) return "sendTs: integer|Long expected";

	      if (message.payloads != null && message.hasOwnProperty("payloads")) {
	        if (!isArray$3(message.payloads)) return "payloads: array expected";

	        for (var i = 0; i < message.payloads.length; ++i) {
	          var error = $root.Events.Message.verify(message.payloads[i]);
	          if (error) return "payloads." + error;
	        }
	      }

	      return null;
	    };
	    /**
	     * Creates a ProtoRaws message from a plain object. Also converts values to their respective internal types.
	     * @function fromObject
	     * @memberof Events.ProtoRaws
	     * @static
	     * @param {Object.<string,*>} object Plain object
	     * @returns {Events.ProtoRaws} ProtoRaws
	     */


	    ProtoRaws.fromObject = function fromObject(object) {
	      if (object instanceof $root.Events.ProtoRaws) return object;
	      var message = new $root.Events.ProtoRaws();
	      if (object.sendTs != null) if ($util.Long) (message.sendTs = $util.Long.fromValue(object.sendTs)).unsigned = false;else if (typeof object.sendTs === "string") message.sendTs = _parseInt$3(object.sendTs, 10);else if (typeof object.sendTs === "number") message.sendTs = object.sendTs;else if (typeof object.sendTs === "object") message.sendTs = new $util.LongBits(object.sendTs.low >>> 0, object.sendTs.high >>> 0).toNumber();

	      if (object.payloads) {
	        if (!isArray$3(object.payloads)) throw TypeError(".Events.ProtoRaws.payloads: array expected");
	        message.payloads = [];

	        for (var i = 0; i < object.payloads.length; ++i) {
	          if (typeof object.payloads[i] !== "object") throw TypeError(".Events.ProtoRaws.payloads: object expected");
	          message.payloads[i] = $root.Events.Message.fromObject(object.payloads[i]);
	        }
	      }

	      return message;
	    };
	    /**
	     * Creates a plain object from a ProtoRaws message. Also converts values to other types if specified.
	     * @function toObject
	     * @memberof Events.ProtoRaws
	     * @static
	     * @param {Events.ProtoRaws} message ProtoRaws
	     * @param {$protobuf.IConversionOptions} [options] Conversion options
	     * @returns {Object.<string,*>} Plain object
	     */


	    ProtoRaws.toObject = function toObject(message, options) {
	      if (!options) options = {};
	      var object = {};
	      if (options.arrays || options.defaults) object.payloads = [];
	      if (options.defaults) if ($util.Long) {
	        var long = new $util.Long(0, 0, false);
	        object.sendTs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	      } else object.sendTs = options.longs === String ? "0" : 0;
	      if (message.sendTs != null && message.hasOwnProperty("sendTs")) if (typeof message.sendTs === "number") object.sendTs = options.longs === String ? String(message.sendTs) : message.sendTs;else object.sendTs = options.longs === String ? $util.Long.prototype.toString.call(message.sendTs) : options.longs === Number ? new $util.LongBits(message.sendTs.low >>> 0, message.sendTs.high >>> 0).toNumber() : message.sendTs;

	      if (message.payloads && message.payloads.length) {
	        object.payloads = [];

	        for (var j = 0; j < message.payloads.length; ++j) object.payloads[j] = $root.Events.Message.toObject(message.payloads[j], options);
	      }

	      return object;
	    };
	    /**
	     * Converts this ProtoRaws to JSON.
	     * @function toJSON
	     * @memberof Events.ProtoRaws
	     * @instance
	     * @returns {Object.<string,*>} JSON object
	     */


	    ProtoRaws.prototype.toJSON = function toJSON() {
	      return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
	    };

	    return ProtoRaws;
	  }();

	  Events.APWorkerEvent = function () {
	    /**
	     * Properties of a APWorkerEvent.
	     * @memberof Events
	     * @interface IAPWorkerEvent
	     * @property {string|null} [sid] APWorkerEvent sid
	     * @property {string|null} [cname] APWorkerEvent cname
	     * @property {number|Long|null} [cid] APWorkerEvent cid
	     * @property {number|Long|null} [lts] APWorkerEvent lts
	     * @property {string|null} [ip] APWorkerEvent ip
	     * @property {number|Long|null} [uid] APWorkerEvent uid
	     * @property {boolean|null} [success] APWorkerEvent success
	     * @property {number|Long|null} [elapse] APWorkerEvent elapse
	     * @property {number|Long|null} [peer] APWorkerEvent peer
	     * @property {number|null} [ec] APWorkerEvent ec
	     * @property {number|null} [sc] APWorkerEvent sc
	     * @property {string|null} [serverIp] APWorkerEvent serverIp
	     * @property {boolean|null} [firstSuccess] APWorkerEvent firstSuccess
	     * @property {number|null} [responseTime] APWorkerEvent responseTime
	     * @property {string|null} [serviceName] APWorkerEvent serviceName
	     * @property {string|null} [responseDetail] APWorkerEvent responseDetail
	     */

	    /**
	     * Constructs a new APWorkerEvent.
	     * @memberof Events
	     * @classdesc Represents a APWorkerEvent.
	     * @implements IAPWorkerEvent
	     * @constructor
	     * @param {Events.IAPWorkerEvent=} [properties] Properties to set
	     */
	    function APWorkerEvent(properties) {
	      if (properties) for (var keys = keys$3(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	    }
	    /**
	     * APWorkerEvent sid.
	     * @member {string} sid
	     * @memberof Events.APWorkerEvent
	     * @instance
	     */


	    APWorkerEvent.prototype.sid = "";
	    /**
	     * APWorkerEvent cname.
	     * @member {string} cname
	     * @memberof Events.APWorkerEvent
	     * @instance
	     */

	    APWorkerEvent.prototype.cname = "";
	    /**
	     * APWorkerEvent cid.
	     * @member {number|Long} cid
	     * @memberof Events.APWorkerEvent
	     * @instance
	     */

	    APWorkerEvent.prototype.cid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
	    /**
	     * APWorkerEvent lts.
	     * @member {number|Long} lts
	     * @memberof Events.APWorkerEvent
	     * @instance
	     */

	    APWorkerEvent.prototype.lts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
	    /**
	     * APWorkerEvent ip.
	     * @member {string} ip
	     * @memberof Events.APWorkerEvent
	     * @instance
	     */

	    APWorkerEvent.prototype.ip = "";
	    /**
	     * APWorkerEvent uid.
	     * @member {number|Long} uid
	     * @memberof Events.APWorkerEvent
	     * @instance
	     */

	    APWorkerEvent.prototype.uid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
	    /**
	     * APWorkerEvent success.
	     * @member {boolean} success
	     * @memberof Events.APWorkerEvent
	     * @instance
	     */

	    APWorkerEvent.prototype.success = false;
	    /**
	     * APWorkerEvent elapse.
	     * @member {number|Long} elapse
	     * @memberof Events.APWorkerEvent
	     * @instance
	     */

	    APWorkerEvent.prototype.elapse = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
	    /**
	     * APWorkerEvent peer.
	     * @member {number|Long} peer
	     * @memberof Events.APWorkerEvent
	     * @instance
	     */

	    APWorkerEvent.prototype.peer = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
	    /**
	     * APWorkerEvent ec.
	     * @member {number} ec
	     * @memberof Events.APWorkerEvent
	     * @instance
	     */

	    APWorkerEvent.prototype.ec = 0;
	    /**
	     * APWorkerEvent sc.
	     * @member {number} sc
	     * @memberof Events.APWorkerEvent
	     * @instance
	     */

	    APWorkerEvent.prototype.sc = 0;
	    /**
	     * APWorkerEvent serverIp.
	     * @member {string} serverIp
	     * @memberof Events.APWorkerEvent
	     * @instance
	     */

	    APWorkerEvent.prototype.serverIp = "";
	    /**
	     * APWorkerEvent firstSuccess.
	     * @member {boolean} firstSuccess
	     * @memberof Events.APWorkerEvent
	     * @instance
	     */

	    APWorkerEvent.prototype.firstSuccess = false;
	    /**
	     * APWorkerEvent responseTime.
	     * @member {number} responseTime
	     * @memberof Events.APWorkerEvent
	     * @instance
	     */

	    APWorkerEvent.prototype.responseTime = 0;
	    /**
	     * APWorkerEvent serviceName.
	     * @member {string} serviceName
	     * @memberof Events.APWorkerEvent
	     * @instance
	     */

	    APWorkerEvent.prototype.serviceName = "";
	    /**
	     * APWorkerEvent responseDetail.
	     * @member {string} responseDetail
	     * @memberof Events.APWorkerEvent
	     * @instance
	     */

	    APWorkerEvent.prototype.responseDetail = "";
	    /**
	     * Creates a new APWorkerEvent instance using the specified properties.
	     * @function create
	     * @memberof Events.APWorkerEvent
	     * @static
	     * @param {Events.IAPWorkerEvent=} [properties] Properties to set
	     * @returns {Events.APWorkerEvent} APWorkerEvent instance
	     */

	    APWorkerEvent.create = function create(properties) {
	      return new APWorkerEvent(properties);
	    };
	    /**
	     * Encodes the specified APWorkerEvent message. Does not implicitly {@link Events.APWorkerEvent.verify|verify} messages.
	     * @function encode
	     * @memberof Events.APWorkerEvent
	     * @static
	     * @param {Events.IAPWorkerEvent} message APWorkerEvent message or plain object to encode
	     * @param {$protobuf.Writer} [writer] Writer to encode to
	     * @returns {$protobuf.Writer} Writer
	     */


	    APWorkerEvent.encode = function encode(message, writer) {
	      if (!writer) writer = $Writer.create();
	      if (message.sid != null && Object.hasOwnProperty.call(message, "sid")) writer.uint32(
	      /* id 1, wireType 2 =*/
	      10).string(message.sid);
	      if (message.cname != null && Object.hasOwnProperty.call(message, "cname")) writer.uint32(
	      /* id 2, wireType 2 =*/
	      18).string(message.cname);
	      if (message.cid != null && Object.hasOwnProperty.call(message, "cid")) writer.uint32(
	      /* id 3, wireType 0 =*/
	      24).int64(message.cid);
	      if (message.lts != null && Object.hasOwnProperty.call(message, "lts")) writer.uint32(
	      /* id 4, wireType 0 =*/
	      32).int64(message.lts);
	      if (message.ip != null && Object.hasOwnProperty.call(message, "ip")) writer.uint32(
	      /* id 5, wireType 2 =*/
	      42).string(message.ip);
	      if (message.uid != null && Object.hasOwnProperty.call(message, "uid")) writer.uint32(
	      /* id 6, wireType 0 =*/
	      48).int64(message.uid);
	      if (message.success != null && Object.hasOwnProperty.call(message, "success")) writer.uint32(
	      /* id 7, wireType 0 =*/
	      56).bool(message.success);
	      if (message.elapse != null && Object.hasOwnProperty.call(message, "elapse")) writer.uint32(
	      /* id 8, wireType 0 =*/
	      64).int64(message.elapse);
	      if (message.peer != null && Object.hasOwnProperty.call(message, "peer")) writer.uint32(
	      /* id 9, wireType 0 =*/
	      72).int64(message.peer);
	      if (message.ec != null && Object.hasOwnProperty.call(message, "ec")) writer.uint32(
	      /* id 10, wireType 0 =*/
	      80).int32(message.ec);
	      if (message.sc != null && Object.hasOwnProperty.call(message, "sc")) writer.uint32(
	      /* id 11, wireType 0 =*/
	      88).int32(message.sc);
	      if (message.serverIp != null && Object.hasOwnProperty.call(message, "serverIp")) writer.uint32(
	      /* id 12, wireType 2 =*/
	      98).string(message.serverIp);
	      if (message.firstSuccess != null && Object.hasOwnProperty.call(message, "firstSuccess")) writer.uint32(
	      /* id 13, wireType 0 =*/
	      104).bool(message.firstSuccess);
	      if (message.responseTime != null && Object.hasOwnProperty.call(message, "responseTime")) writer.uint32(
	      /* id 14, wireType 0 =*/
	      112).int32(message.responseTime);
	      if (message.serviceName != null && Object.hasOwnProperty.call(message, "serviceName")) writer.uint32(
	      /* id 15, wireType 2 =*/
	      122).string(message.serviceName);
	      if (message.responseDetail != null && Object.hasOwnProperty.call(message, "responseDetail")) writer.uint32(
	      /* id 16, wireType 2 =*/
	      130).string(message.responseDetail);
	      return writer;
	    };
	    /**
	     * Encodes the specified APWorkerEvent message, length delimited. Does not implicitly {@link Events.APWorkerEvent.verify|verify} messages.
	     * @function encodeDelimited
	     * @memberof Events.APWorkerEvent
	     * @static
	     * @param {Events.IAPWorkerEvent} message APWorkerEvent message or plain object to encode
	     * @param {$protobuf.Writer} [writer] Writer to encode to
	     * @returns {$protobuf.Writer} Writer
	     */


	    APWorkerEvent.encodeDelimited = function encodeDelimited(message, writer) {
	      return this.encode(message, writer).ldelim();
	    };
	    /**
	     * Decodes a APWorkerEvent message from the specified reader or buffer.
	     * @function decode
	     * @memberof Events.APWorkerEvent
	     * @static
	     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	     * @param {number} [length] Message length if known beforehand
	     * @returns {Events.APWorkerEvent} APWorkerEvent
	     * @throws {Error} If the payload is not a reader or valid buffer
	     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	     */


	    APWorkerEvent.decode = function decode(reader, length) {
	      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
	      var end = length === undefined ? reader.len : reader.pos + length,
	          message = new $root.Events.APWorkerEvent();

	      while (reader.pos < end) {
	        var tag = reader.uint32();

	        switch (tag >>> 3) {
	          case 1:
	            message.sid = reader.string();
	            break;

	          case 2:
	            message.cname = reader.string();
	            break;

	          case 3:
	            message.cid = reader.int64();
	            break;

	          case 4:
	            message.lts = reader.int64();
	            break;

	          case 5:
	            message.ip = reader.string();
	            break;

	          case 6:
	            message.uid = reader.int64();
	            break;

	          case 7:
	            message.success = reader.bool();
	            break;

	          case 8:
	            message.elapse = reader.int64();
	            break;

	          case 9:
	            message.peer = reader.int64();
	            break;

	          case 10:
	            message.ec = reader.int32();
	            break;

	          case 11:
	            message.sc = reader.int32();
	            break;

	          case 12:
	            message.serverIp = reader.string();
	            break;

	          case 13:
	            message.firstSuccess = reader.bool();
	            break;

	          case 14:
	            message.responseTime = reader.int32();
	            break;

	          case 15:
	            message.serviceName = reader.string();
	            break;

	          case 16:
	            message.responseDetail = reader.string();
	            break;

	          default:
	            reader.skipType(tag & 7);
	            break;
	        }
	      }

	      return message;
	    };
	    /**
	     * Decodes a APWorkerEvent message from the specified reader or buffer, length delimited.
	     * @function decodeDelimited
	     * @memberof Events.APWorkerEvent
	     * @static
	     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	     * @returns {Events.APWorkerEvent} APWorkerEvent
	     * @throws {Error} If the payload is not a reader or valid buffer
	     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	     */


	    APWorkerEvent.decodeDelimited = function decodeDelimited(reader) {
	      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
	      return this.decode(reader, reader.uint32());
	    };
	    /**
	     * Verifies a APWorkerEvent message.
	     * @function verify
	     * @memberof Events.APWorkerEvent
	     * @static
	     * @param {Object.<string,*>} message Plain object to verify
	     * @returns {string|null} `null` if valid, otherwise the reason why it is not
	     */


	    APWorkerEvent.verify = function verify(message) {
	      if (typeof message !== "object" || message === null) return "object expected";
	      if (message.sid != null && message.hasOwnProperty("sid")) if (!$util.isString(message.sid)) return "sid: string expected";
	      if (message.cname != null && message.hasOwnProperty("cname")) if (!$util.isString(message.cname)) return "cname: string expected";
	      if (message.cid != null && message.hasOwnProperty("cid")) if (!$util.isInteger(message.cid) && !(message.cid && $util.isInteger(message.cid.low) && $util.isInteger(message.cid.high))) return "cid: integer|Long expected";
	      if (message.lts != null && message.hasOwnProperty("lts")) if (!$util.isInteger(message.lts) && !(message.lts && $util.isInteger(message.lts.low) && $util.isInteger(message.lts.high))) return "lts: integer|Long expected";
	      if (message.ip != null && message.hasOwnProperty("ip")) if (!$util.isString(message.ip)) return "ip: string expected";
	      if (message.uid != null && message.hasOwnProperty("uid")) if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high))) return "uid: integer|Long expected";
	      if (message.success != null && message.hasOwnProperty("success")) if (typeof message.success !== "boolean") return "success: boolean expected";
	      if (message.elapse != null && message.hasOwnProperty("elapse")) if (!$util.isInteger(message.elapse) && !(message.elapse && $util.isInteger(message.elapse.low) && $util.isInteger(message.elapse.high))) return "elapse: integer|Long expected";
	      if (message.peer != null && message.hasOwnProperty("peer")) if (!$util.isInteger(message.peer) && !(message.peer && $util.isInteger(message.peer.low) && $util.isInteger(message.peer.high))) return "peer: integer|Long expected";
	      if (message.ec != null && message.hasOwnProperty("ec")) if (!$util.isInteger(message.ec)) return "ec: integer expected";
	      if (message.sc != null && message.hasOwnProperty("sc")) if (!$util.isInteger(message.sc)) return "sc: integer expected";
	      if (message.serverIp != null && message.hasOwnProperty("serverIp")) if (!$util.isString(message.serverIp)) return "serverIp: string expected";
	      if (message.firstSuccess != null && message.hasOwnProperty("firstSuccess")) if (typeof message.firstSuccess !== "boolean") return "firstSuccess: boolean expected";
	      if (message.responseTime != null && message.hasOwnProperty("responseTime")) if (!$util.isInteger(message.responseTime)) return "responseTime: integer expected";
	      if (message.serviceName != null && message.hasOwnProperty("serviceName")) if (!$util.isString(message.serviceName)) return "serviceName: string expected";
	      if (message.responseDetail != null && message.hasOwnProperty("responseDetail")) if (!$util.isString(message.responseDetail)) return "responseDetail: string expected";
	      return null;
	    };
	    /**
	     * Creates a APWorkerEvent message from a plain object. Also converts values to their respective internal types.
	     * @function fromObject
	     * @memberof Events.APWorkerEvent
	     * @static
	     * @param {Object.<string,*>} object Plain object
	     * @returns {Events.APWorkerEvent} APWorkerEvent
	     */


	    APWorkerEvent.fromObject = function fromObject(object) {
	      if (object instanceof $root.Events.APWorkerEvent) return object;
	      var message = new $root.Events.APWorkerEvent();
	      if (object.sid != null) message.sid = String(object.sid);
	      if (object.cname != null) message.cname = String(object.cname);
	      if (object.cid != null) if ($util.Long) (message.cid = $util.Long.fromValue(object.cid)).unsigned = false;else if (typeof object.cid === "string") message.cid = _parseInt$3(object.cid, 10);else if (typeof object.cid === "number") message.cid = object.cid;else if (typeof object.cid === "object") message.cid = new $util.LongBits(object.cid.low >>> 0, object.cid.high >>> 0).toNumber();
	      if (object.lts != null) if ($util.Long) (message.lts = $util.Long.fromValue(object.lts)).unsigned = false;else if (typeof object.lts === "string") message.lts = _parseInt$3(object.lts, 10);else if (typeof object.lts === "number") message.lts = object.lts;else if (typeof object.lts === "object") message.lts = new $util.LongBits(object.lts.low >>> 0, object.lts.high >>> 0).toNumber();
	      if (object.ip != null) message.ip = String(object.ip);
	      if (object.uid != null) if ($util.Long) (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;else if (typeof object.uid === "string") message.uid = _parseInt$3(object.uid, 10);else if (typeof object.uid === "number") message.uid = object.uid;else if (typeof object.uid === "object") message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
	      if (object.success != null) message.success = Boolean(object.success);
	      if (object.elapse != null) if ($util.Long) (message.elapse = $util.Long.fromValue(object.elapse)).unsigned = false;else if (typeof object.elapse === "string") message.elapse = _parseInt$3(object.elapse, 10);else if (typeof object.elapse === "number") message.elapse = object.elapse;else if (typeof object.elapse === "object") message.elapse = new $util.LongBits(object.elapse.low >>> 0, object.elapse.high >>> 0).toNumber();
	      if (object.peer != null) if ($util.Long) (message.peer = $util.Long.fromValue(object.peer)).unsigned = false;else if (typeof object.peer === "string") message.peer = _parseInt$3(object.peer, 10);else if (typeof object.peer === "number") message.peer = object.peer;else if (typeof object.peer === "object") message.peer = new $util.LongBits(object.peer.low >>> 0, object.peer.high >>> 0).toNumber();
	      if (object.ec != null) message.ec = object.ec | 0;
	      if (object.sc != null) message.sc = object.sc | 0;
	      if (object.serverIp != null) message.serverIp = String(object.serverIp);
	      if (object.firstSuccess != null) message.firstSuccess = Boolean(object.firstSuccess);
	      if (object.responseTime != null) message.responseTime = object.responseTime | 0;
	      if (object.serviceName != null) message.serviceName = String(object.serviceName);
	      if (object.responseDetail != null) message.responseDetail = String(object.responseDetail);
	      return message;
	    };
	    /**
	     * Creates a plain object from a APWorkerEvent message. Also converts values to other types if specified.
	     * @function toObject
	     * @memberof Events.APWorkerEvent
	     * @static
	     * @param {Events.APWorkerEvent} message APWorkerEvent
	     * @param {$protobuf.IConversionOptions} [options] Conversion options
	     * @returns {Object.<string,*>} Plain object
	     */


	    APWorkerEvent.toObject = function toObject(message, options) {
	      if (!options) options = {};
	      var object = {};

	      if (options.defaults) {
	        object.sid = "";
	        object.cname = "";

	        if ($util.Long) {
	          var long = new $util.Long(0, 0, false);
	          object.cid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	        } else object.cid = options.longs === String ? "0" : 0;

	        if ($util.Long) {
	          var long = new $util.Long(0, 0, false);
	          object.lts = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	        } else object.lts = options.longs === String ? "0" : 0;

	        object.ip = "";

	        if ($util.Long) {
	          var long = new $util.Long(0, 0, false);
	          object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	        } else object.uid = options.longs === String ? "0" : 0;

	        object.success = false;

	        if ($util.Long) {
	          var long = new $util.Long(0, 0, false);
	          object.elapse = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	        } else object.elapse = options.longs === String ? "0" : 0;

	        if ($util.Long) {
	          var long = new $util.Long(0, 0, false);
	          object.peer = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	        } else object.peer = options.longs === String ? "0" : 0;

	        object.ec = 0;
	        object.sc = 0;
	        object.serverIp = "";
	        object.firstSuccess = false;
	        object.responseTime = 0;
	        object.serviceName = "";
	        object.responseDetail = "";
	      }

	      if (message.sid != null && message.hasOwnProperty("sid")) object.sid = message.sid;
	      if (message.cname != null && message.hasOwnProperty("cname")) object.cname = message.cname;
	      if (message.cid != null && message.hasOwnProperty("cid")) if (typeof message.cid === "number") object.cid = options.longs === String ? String(message.cid) : message.cid;else object.cid = options.longs === String ? $util.Long.prototype.toString.call(message.cid) : options.longs === Number ? new $util.LongBits(message.cid.low >>> 0, message.cid.high >>> 0).toNumber() : message.cid;
	      if (message.lts != null && message.hasOwnProperty("lts")) if (typeof message.lts === "number") object.lts = options.longs === String ? String(message.lts) : message.lts;else object.lts = options.longs === String ? $util.Long.prototype.toString.call(message.lts) : options.longs === Number ? new $util.LongBits(message.lts.low >>> 0, message.lts.high >>> 0).toNumber() : message.lts;
	      if (message.ip != null && message.hasOwnProperty("ip")) object.ip = message.ip;
	      if (message.uid != null && message.hasOwnProperty("uid")) if (typeof message.uid === "number") object.uid = options.longs === String ? String(message.uid) : message.uid;else object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
	      if (message.success != null && message.hasOwnProperty("success")) object.success = message.success;
	      if (message.elapse != null && message.hasOwnProperty("elapse")) if (typeof message.elapse === "number") object.elapse = options.longs === String ? String(message.elapse) : message.elapse;else object.elapse = options.longs === String ? $util.Long.prototype.toString.call(message.elapse) : options.longs === Number ? new $util.LongBits(message.elapse.low >>> 0, message.elapse.high >>> 0).toNumber() : message.elapse;
	      if (message.peer != null && message.hasOwnProperty("peer")) if (typeof message.peer === "number") object.peer = options.longs === String ? String(message.peer) : message.peer;else object.peer = options.longs === String ? $util.Long.prototype.toString.call(message.peer) : options.longs === Number ? new $util.LongBits(message.peer.low >>> 0, message.peer.high >>> 0).toNumber() : message.peer;
	      if (message.ec != null && message.hasOwnProperty("ec")) object.ec = message.ec;
	      if (message.sc != null && message.hasOwnProperty("sc")) object.sc = message.sc;
	      if (message.serverIp != null && message.hasOwnProperty("serverIp")) object.serverIp = message.serverIp;
	      if (message.firstSuccess != null && message.hasOwnProperty("firstSuccess")) object.firstSuccess = message.firstSuccess;
	      if (message.responseTime != null && message.hasOwnProperty("responseTime")) object.responseTime = message.responseTime;
	      if (message.serviceName != null && message.hasOwnProperty("serviceName")) object.serviceName = message.serviceName;
	      if (message.responseDetail != null && message.hasOwnProperty("responseDetail")) object.responseDetail = message.responseDetail;
	      return object;
	    };
	    /**
	     * Converts this APWorkerEvent to JSON.
	     * @function toJSON
	     * @memberof Events.APWorkerEvent
	     * @instance
	     * @returns {Object.<string,*>} JSON object
	     */


	    APWorkerEvent.prototype.toJSON = function toJSON() {
	      return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
	    };

	    return APWorkerEvent;
	  }();

	  Events.WorkerEvent = function () {
	    /**
	     * Properties of a WorkerEvent.
	     * @memberof Events
	     * @interface IWorkerEvent
	     * @property {string|null} [sid] WorkerEvent sid
	     * @property {string|null} [cname] WorkerEvent cname
	     * @property {number|Long|null} [cid] WorkerEvent cid
	     * @property {number|Long|null} [lts] WorkerEvent lts
	     * @property {string|null} [ip] WorkerEvent ip
	     * @property {number|Long|null} [uid] WorkerEvent uid
	     * @property {boolean|null} [success] WorkerEvent success
	     * @property {number|Long|null} [elapse] WorkerEvent elapse
	     * @property {number|Long|null} [peer] WorkerEvent peer
	     * @property {string|null} [command] WorkerEvent command
	     * @property {string|null} [actionType] WorkerEvent actionType
	     * @property {string|null} [url] WorkerEvent url
	     * @property {string|null} [payload] WorkerEvent payload
	     * @property {number|null} [serverCode] WorkerEvent serverCode
	     * @property {number|null} [code] WorkerEvent code
	     * @property {string|null} [traceId] WorkerEvent traceId
	     * @property {number|null} [workerType] WorkerEvent workerType
	     * @property {number|null} [responseTime] WorkerEvent responseTime
	     * @property {number|Long|null} [requestId] WorkerEvent requestId
	     * @property {number|null} [packIndex] WorkerEvent packIndex
	     * @property {boolean|null} [requestByUser] WorkerEvent requestByUser
	     * @property {string|null} [tid] WorkerEvent tid
	     * @property {string|null} [productType] WorkerEvent productType
	     */

	    /**
	     * Constructs a new WorkerEvent.
	     * @memberof Events
	     * @classdesc Represents a WorkerEvent.
	     * @implements IWorkerEvent
	     * @constructor
	     * @param {Events.IWorkerEvent=} [properties] Properties to set
	     */
	    function WorkerEvent(properties) {
	      if (properties) for (var keys = keys$3(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	    }
	    /**
	     * WorkerEvent sid.
	     * @member {string} sid
	     * @memberof Events.WorkerEvent
	     * @instance
	     */


	    WorkerEvent.prototype.sid = "";
	    /**
	     * WorkerEvent cname.
	     * @member {string} cname
	     * @memberof Events.WorkerEvent
	     * @instance
	     */

	    WorkerEvent.prototype.cname = "";
	    /**
	     * WorkerEvent cid.
	     * @member {number|Long} cid
	     * @memberof Events.WorkerEvent
	     * @instance
	     */

	    WorkerEvent.prototype.cid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
	    /**
	     * WorkerEvent lts.
	     * @member {number|Long} lts
	     * @memberof Events.WorkerEvent
	     * @instance
	     */

	    WorkerEvent.prototype.lts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
	    /**
	     * WorkerEvent ip.
	     * @member {string} ip
	     * @memberof Events.WorkerEvent
	     * @instance
	     */

	    WorkerEvent.prototype.ip = "";
	    /**
	     * WorkerEvent uid.
	     * @member {number|Long} uid
	     * @memberof Events.WorkerEvent
	     * @instance
	     */

	    WorkerEvent.prototype.uid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
	    /**
	     * WorkerEvent success.
	     * @member {boolean} success
	     * @memberof Events.WorkerEvent
	     * @instance
	     */

	    WorkerEvent.prototype.success = false;
	    /**
	     * WorkerEvent elapse.
	     * @member {number|Long} elapse
	     * @memberof Events.WorkerEvent
	     * @instance
	     */

	    WorkerEvent.prototype.elapse = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
	    /**
	     * WorkerEvent peer.
	     * @member {number|Long} peer
	     * @memberof Events.WorkerEvent
	     * @instance
	     */

	    WorkerEvent.prototype.peer = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
	    /**
	     * WorkerEvent command.
	     * @member {string} command
	     * @memberof Events.WorkerEvent
	     * @instance
	     */

	    WorkerEvent.prototype.command = "";
	    /**
	     * WorkerEvent actionType.
	     * @member {string} actionType
	     * @memberof Events.WorkerEvent
	     * @instance
	     */

	    WorkerEvent.prototype.actionType = "";
	    /**
	     * WorkerEvent url.
	     * @member {string} url
	     * @memberof Events.WorkerEvent
	     * @instance
	     */

	    WorkerEvent.prototype.url = "";
	    /**
	     * WorkerEvent payload.
	     * @member {string} payload
	     * @memberof Events.WorkerEvent
	     * @instance
	     */

	    WorkerEvent.prototype.payload = "";
	    /**
	     * WorkerEvent serverCode.
	     * @member {number} serverCode
	     * @memberof Events.WorkerEvent
	     * @instance
	     */

	    WorkerEvent.prototype.serverCode = 0;
	    /**
	     * WorkerEvent code.
	     * @member {number} code
	     * @memberof Events.WorkerEvent
	     * @instance
	     */

	    WorkerEvent.prototype.code = 0;
	    /**
	     * WorkerEvent traceId.
	     * @member {string} traceId
	     * @memberof Events.WorkerEvent
	     * @instance
	     */

	    WorkerEvent.prototype.traceId = "";
	    /**
	     * WorkerEvent workerType.
	     * @member {number} workerType
	     * @memberof Events.WorkerEvent
	     * @instance
	     */

	    WorkerEvent.prototype.workerType = 0;
	    /**
	     * WorkerEvent responseTime.
	     * @member {number} responseTime
	     * @memberof Events.WorkerEvent
	     * @instance
	     */

	    WorkerEvent.prototype.responseTime = 0;
	    /**
	     * WorkerEvent requestId.
	     * @member {number|Long} requestId
	     * @memberof Events.WorkerEvent
	     * @instance
	     */

	    WorkerEvent.prototype.requestId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
	    /**
	     * WorkerEvent packIndex.
	     * @member {number} packIndex
	     * @memberof Events.WorkerEvent
	     * @instance
	     */

	    WorkerEvent.prototype.packIndex = 0;
	    /**
	     * WorkerEvent requestByUser.
	     * @member {boolean} requestByUser
	     * @memberof Events.WorkerEvent
	     * @instance
	     */

	    WorkerEvent.prototype.requestByUser = false;
	    /**
	     * WorkerEvent tid.
	     * @member {string} tid
	     * @memberof Events.WorkerEvent
	     * @instance
	     */

	    WorkerEvent.prototype.tid = "";
	    /**
	     * WorkerEvent productType.
	     * @member {string} productType
	     * @memberof Events.WorkerEvent
	     * @instance
	     */

	    WorkerEvent.prototype.productType = "";
	    /**
	     * Creates a new WorkerEvent instance using the specified properties.
	     * @function create
	     * @memberof Events.WorkerEvent
	     * @static
	     * @param {Events.IWorkerEvent=} [properties] Properties to set
	     * @returns {Events.WorkerEvent} WorkerEvent instance
	     */

	    WorkerEvent.create = function create(properties) {
	      return new WorkerEvent(properties);
	    };
	    /**
	     * Encodes the specified WorkerEvent message. Does not implicitly {@link Events.WorkerEvent.verify|verify} messages.
	     * @function encode
	     * @memberof Events.WorkerEvent
	     * @static
	     * @param {Events.IWorkerEvent} message WorkerEvent message or plain object to encode
	     * @param {$protobuf.Writer} [writer] Writer to encode to
	     * @returns {$protobuf.Writer} Writer
	     */


	    WorkerEvent.encode = function encode(message, writer) {
	      if (!writer) writer = $Writer.create();
	      if (message.sid != null && Object.hasOwnProperty.call(message, "sid")) writer.uint32(
	      /* id 1, wireType 2 =*/
	      10).string(message.sid);
	      if (message.cname != null && Object.hasOwnProperty.call(message, "cname")) writer.uint32(
	      /* id 2, wireType 2 =*/
	      18).string(message.cname);
	      if (message.cid != null && Object.hasOwnProperty.call(message, "cid")) writer.uint32(
	      /* id 3, wireType 0 =*/
	      24).int64(message.cid);
	      if (message.lts != null && Object.hasOwnProperty.call(message, "lts")) writer.uint32(
	      /* id 4, wireType 0 =*/
	      32).int64(message.lts);
	      if (message.ip != null && Object.hasOwnProperty.call(message, "ip")) writer.uint32(
	      /* id 5, wireType 2 =*/
	      42).string(message.ip);
	      if (message.uid != null && Object.hasOwnProperty.call(message, "uid")) writer.uint32(
	      /* id 6, wireType 0 =*/
	      48).int64(message.uid);
	      if (message.success != null && Object.hasOwnProperty.call(message, "success")) writer.uint32(
	      /* id 7, wireType 0 =*/
	      56).bool(message.success);
	      if (message.elapse != null && Object.hasOwnProperty.call(message, "elapse")) writer.uint32(
	      /* id 8, wireType 0 =*/
	      64).int64(message.elapse);
	      if (message.peer != null && Object.hasOwnProperty.call(message, "peer")) writer.uint32(
	      /* id 9, wireType 0 =*/
	      72).int64(message.peer);
	      if (message.command != null && Object.hasOwnProperty.call(message, "command")) writer.uint32(
	      /* id 10, wireType 2 =*/
	      82).string(message.command);
	      if (message.actionType != null && Object.hasOwnProperty.call(message, "actionType")) writer.uint32(
	      /* id 11, wireType 2 =*/
	      90).string(message.actionType);
	      if (message.url != null && Object.hasOwnProperty.call(message, "url")) writer.uint32(
	      /* id 12, wireType 2 =*/
	      98).string(message.url);
	      if (message.payload != null && Object.hasOwnProperty.call(message, "payload")) writer.uint32(
	      /* id 13, wireType 2 =*/
	      106).string(message.payload);
	      if (message.serverCode != null && Object.hasOwnProperty.call(message, "serverCode")) writer.uint32(
	      /* id 14, wireType 0 =*/
	      112).int32(message.serverCode);
	      if (message.code != null && Object.hasOwnProperty.call(message, "code")) writer.uint32(
	      /* id 15, wireType 0 =*/
	      120).int32(message.code);
	      if (message.traceId != null && Object.hasOwnProperty.call(message, "traceId")) writer.uint32(
	      /* id 16, wireType 2 =*/
	      130).string(message.traceId);
	      if (message.workerType != null && Object.hasOwnProperty.call(message, "workerType")) writer.uint32(
	      /* id 17, wireType 0 =*/
	      136).int32(message.workerType);
	      if (message.responseTime != null && Object.hasOwnProperty.call(message, "responseTime")) writer.uint32(
	      /* id 18, wireType 0 =*/
	      144).int32(message.responseTime);
	      if (message.requestId != null && Object.hasOwnProperty.call(message, "requestId")) writer.uint32(
	      /* id 19, wireType 0 =*/
	      152).int64(message.requestId);
	      if (message.packIndex != null && Object.hasOwnProperty.call(message, "packIndex")) writer.uint32(
	      /* id 20, wireType 0 =*/
	      160).int32(message.packIndex);
	      if (message.requestByUser != null && Object.hasOwnProperty.call(message, "requestByUser")) writer.uint32(
	      /* id 21, wireType 0 =*/
	      168).bool(message.requestByUser);
	      if (message.tid != null && Object.hasOwnProperty.call(message, "tid")) writer.uint32(
	      /* id 22, wireType 2 =*/
	      178).string(message.tid);
	      if (message.productType != null && Object.hasOwnProperty.call(message, "productType")) writer.uint32(
	      /* id 23, wireType 2 =*/
	      186).string(message.productType);
	      return writer;
	    };
	    /**
	     * Encodes the specified WorkerEvent message, length delimited. Does not implicitly {@link Events.WorkerEvent.verify|verify} messages.
	     * @function encodeDelimited
	     * @memberof Events.WorkerEvent
	     * @static
	     * @param {Events.IWorkerEvent} message WorkerEvent message or plain object to encode
	     * @param {$protobuf.Writer} [writer] Writer to encode to
	     * @returns {$protobuf.Writer} Writer
	     */


	    WorkerEvent.encodeDelimited = function encodeDelimited(message, writer) {
	      return this.encode(message, writer).ldelim();
	    };
	    /**
	     * Decodes a WorkerEvent message from the specified reader or buffer.
	     * @function decode
	     * @memberof Events.WorkerEvent
	     * @static
	     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	     * @param {number} [length] Message length if known beforehand
	     * @returns {Events.WorkerEvent} WorkerEvent
	     * @throws {Error} If the payload is not a reader or valid buffer
	     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	     */


	    WorkerEvent.decode = function decode(reader, length) {
	      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
	      var end = length === undefined ? reader.len : reader.pos + length,
	          message = new $root.Events.WorkerEvent();

	      while (reader.pos < end) {
	        var tag = reader.uint32();

	        switch (tag >>> 3) {
	          case 1:
	            message.sid = reader.string();
	            break;

	          case 2:
	            message.cname = reader.string();
	            break;

	          case 3:
	            message.cid = reader.int64();
	            break;

	          case 4:
	            message.lts = reader.int64();
	            break;

	          case 5:
	            message.ip = reader.string();
	            break;

	          case 6:
	            message.uid = reader.int64();
	            break;

	          case 7:
	            message.success = reader.bool();
	            break;

	          case 8:
	            message.elapse = reader.int64();
	            break;

	          case 9:
	            message.peer = reader.int64();
	            break;

	          case 10:
	            message.command = reader.string();
	            break;

	          case 11:
	            message.actionType = reader.string();
	            break;

	          case 12:
	            message.url = reader.string();
	            break;

	          case 13:
	            message.payload = reader.string();
	            break;

	          case 14:
	            message.serverCode = reader.int32();
	            break;

	          case 15:
	            message.code = reader.int32();
	            break;

	          case 16:
	            message.traceId = reader.string();
	            break;

	          case 17:
	            message.workerType = reader.int32();
	            break;

	          case 18:
	            message.responseTime = reader.int32();
	            break;

	          case 19:
	            message.requestId = reader.int64();
	            break;

	          case 20:
	            message.packIndex = reader.int32();
	            break;

	          case 21:
	            message.requestByUser = reader.bool();
	            break;

	          case 22:
	            message.tid = reader.string();
	            break;

	          case 23:
	            message.productType = reader.string();
	            break;

	          default:
	            reader.skipType(tag & 7);
	            break;
	        }
	      }

	      return message;
	    };
	    /**
	     * Decodes a WorkerEvent message from the specified reader or buffer, length delimited.
	     * @function decodeDelimited
	     * @memberof Events.WorkerEvent
	     * @static
	     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	     * @returns {Events.WorkerEvent} WorkerEvent
	     * @throws {Error} If the payload is not a reader or valid buffer
	     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	     */


	    WorkerEvent.decodeDelimited = function decodeDelimited(reader) {
	      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
	      return this.decode(reader, reader.uint32());
	    };
	    /**
	     * Verifies a WorkerEvent message.
	     * @function verify
	     * @memberof Events.WorkerEvent
	     * @static
	     * @param {Object.<string,*>} message Plain object to verify
	     * @returns {string|null} `null` if valid, otherwise the reason why it is not
	     */


	    WorkerEvent.verify = function verify(message) {
	      if (typeof message !== "object" || message === null) return "object expected";
	      if (message.sid != null && message.hasOwnProperty("sid")) if (!$util.isString(message.sid)) return "sid: string expected";
	      if (message.cname != null && message.hasOwnProperty("cname")) if (!$util.isString(message.cname)) return "cname: string expected";
	      if (message.cid != null && message.hasOwnProperty("cid")) if (!$util.isInteger(message.cid) && !(message.cid && $util.isInteger(message.cid.low) && $util.isInteger(message.cid.high))) return "cid: integer|Long expected";
	      if (message.lts != null && message.hasOwnProperty("lts")) if (!$util.isInteger(message.lts) && !(message.lts && $util.isInteger(message.lts.low) && $util.isInteger(message.lts.high))) return "lts: integer|Long expected";
	      if (message.ip != null && message.hasOwnProperty("ip")) if (!$util.isString(message.ip)) return "ip: string expected";
	      if (message.uid != null && message.hasOwnProperty("uid")) if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high))) return "uid: integer|Long expected";
	      if (message.success != null && message.hasOwnProperty("success")) if (typeof message.success !== "boolean") return "success: boolean expected";
	      if (message.elapse != null && message.hasOwnProperty("elapse")) if (!$util.isInteger(message.elapse) && !(message.elapse && $util.isInteger(message.elapse.low) && $util.isInteger(message.elapse.high))) return "elapse: integer|Long expected";
	      if (message.peer != null && message.hasOwnProperty("peer")) if (!$util.isInteger(message.peer) && !(message.peer && $util.isInteger(message.peer.low) && $util.isInteger(message.peer.high))) return "peer: integer|Long expected";
	      if (message.command != null && message.hasOwnProperty("command")) if (!$util.isString(message.command)) return "command: string expected";
	      if (message.actionType != null && message.hasOwnProperty("actionType")) if (!$util.isString(message.actionType)) return "actionType: string expected";
	      if (message.url != null && message.hasOwnProperty("url")) if (!$util.isString(message.url)) return "url: string expected";
	      if (message.payload != null && message.hasOwnProperty("payload")) if (!$util.isString(message.payload)) return "payload: string expected";
	      if (message.serverCode != null && message.hasOwnProperty("serverCode")) if (!$util.isInteger(message.serverCode)) return "serverCode: integer expected";
	      if (message.code != null && message.hasOwnProperty("code")) if (!$util.isInteger(message.code)) return "code: integer expected";
	      if (message.traceId != null && message.hasOwnProperty("traceId")) if (!$util.isString(message.traceId)) return "traceId: string expected";
	      if (message.workerType != null && message.hasOwnProperty("workerType")) if (!$util.isInteger(message.workerType)) return "workerType: integer expected";
	      if (message.responseTime != null && message.hasOwnProperty("responseTime")) if (!$util.isInteger(message.responseTime)) return "responseTime: integer expected";
	      if (message.requestId != null && message.hasOwnProperty("requestId")) if (!$util.isInteger(message.requestId) && !(message.requestId && $util.isInteger(message.requestId.low) && $util.isInteger(message.requestId.high))) return "requestId: integer|Long expected";
	      if (message.packIndex != null && message.hasOwnProperty("packIndex")) if (!$util.isInteger(message.packIndex)) return "packIndex: integer expected";
	      if (message.requestByUser != null && message.hasOwnProperty("requestByUser")) if (typeof message.requestByUser !== "boolean") return "requestByUser: boolean expected";
	      if (message.tid != null && message.hasOwnProperty("tid")) if (!$util.isString(message.tid)) return "tid: string expected";
	      if (message.productType != null && message.hasOwnProperty("productType")) if (!$util.isString(message.productType)) return "productType: string expected";
	      return null;
	    };
	    /**
	     * Creates a WorkerEvent message from a plain object. Also converts values to their respective internal types.
	     * @function fromObject
	     * @memberof Events.WorkerEvent
	     * @static
	     * @param {Object.<string,*>} object Plain object
	     * @returns {Events.WorkerEvent} WorkerEvent
	     */


	    WorkerEvent.fromObject = function fromObject(object) {
	      if (object instanceof $root.Events.WorkerEvent) return object;
	      var message = new $root.Events.WorkerEvent();
	      if (object.sid != null) message.sid = String(object.sid);
	      if (object.cname != null) message.cname = String(object.cname);
	      if (object.cid != null) if ($util.Long) (message.cid = $util.Long.fromValue(object.cid)).unsigned = false;else if (typeof object.cid === "string") message.cid = _parseInt$3(object.cid, 10);else if (typeof object.cid === "number") message.cid = object.cid;else if (typeof object.cid === "object") message.cid = new $util.LongBits(object.cid.low >>> 0, object.cid.high >>> 0).toNumber();
	      if (object.lts != null) if ($util.Long) (message.lts = $util.Long.fromValue(object.lts)).unsigned = false;else if (typeof object.lts === "string") message.lts = _parseInt$3(object.lts, 10);else if (typeof object.lts === "number") message.lts = object.lts;else if (typeof object.lts === "object") message.lts = new $util.LongBits(object.lts.low >>> 0, object.lts.high >>> 0).toNumber();
	      if (object.ip != null) message.ip = String(object.ip);
	      if (object.uid != null) if ($util.Long) (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;else if (typeof object.uid === "string") message.uid = _parseInt$3(object.uid, 10);else if (typeof object.uid === "number") message.uid = object.uid;else if (typeof object.uid === "object") message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
	      if (object.success != null) message.success = Boolean(object.success);
	      if (object.elapse != null) if ($util.Long) (message.elapse = $util.Long.fromValue(object.elapse)).unsigned = false;else if (typeof object.elapse === "string") message.elapse = _parseInt$3(object.elapse, 10);else if (typeof object.elapse === "number") message.elapse = object.elapse;else if (typeof object.elapse === "object") message.elapse = new $util.LongBits(object.elapse.low >>> 0, object.elapse.high >>> 0).toNumber();
	      if (object.peer != null) if ($util.Long) (message.peer = $util.Long.fromValue(object.peer)).unsigned = false;else if (typeof object.peer === "string") message.peer = _parseInt$3(object.peer, 10);else if (typeof object.peer === "number") message.peer = object.peer;else if (typeof object.peer === "object") message.peer = new $util.LongBits(object.peer.low >>> 0, object.peer.high >>> 0).toNumber();
	      if (object.command != null) message.command = String(object.command);
	      if (object.actionType != null) message.actionType = String(object.actionType);
	      if (object.url != null) message.url = String(object.url);
	      if (object.payload != null) message.payload = String(object.payload);
	      if (object.serverCode != null) message.serverCode = object.serverCode | 0;
	      if (object.code != null) message.code = object.code | 0;
	      if (object.traceId != null) message.traceId = String(object.traceId);
	      if (object.workerType != null) message.workerType = object.workerType | 0;
	      if (object.responseTime != null) message.responseTime = object.responseTime | 0;
	      if (object.requestId != null) if ($util.Long) (message.requestId = $util.Long.fromValue(object.requestId)).unsigned = false;else if (typeof object.requestId === "string") message.requestId = _parseInt$3(object.requestId, 10);else if (typeof object.requestId === "number") message.requestId = object.requestId;else if (typeof object.requestId === "object") message.requestId = new $util.LongBits(object.requestId.low >>> 0, object.requestId.high >>> 0).toNumber();
	      if (object.packIndex != null) message.packIndex = object.packIndex | 0;
	      if (object.requestByUser != null) message.requestByUser = Boolean(object.requestByUser);
	      if (object.tid != null) message.tid = String(object.tid);
	      if (object.productType != null) message.productType = String(object.productType);
	      return message;
	    };
	    /**
	     * Creates a plain object from a WorkerEvent message. Also converts values to other types if specified.
	     * @function toObject
	     * @memberof Events.WorkerEvent
	     * @static
	     * @param {Events.WorkerEvent} message WorkerEvent
	     * @param {$protobuf.IConversionOptions} [options] Conversion options
	     * @returns {Object.<string,*>} Plain object
	     */


	    WorkerEvent.toObject = function toObject(message, options) {
	      if (!options) options = {};
	      var object = {};

	      if (options.defaults) {
	        object.sid = "";
	        object.cname = "";

	        if ($util.Long) {
	          var long = new $util.Long(0, 0, false);
	          object.cid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	        } else object.cid = options.longs === String ? "0" : 0;

	        if ($util.Long) {
	          var long = new $util.Long(0, 0, false);
	          object.lts = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	        } else object.lts = options.longs === String ? "0" : 0;

	        object.ip = "";

	        if ($util.Long) {
	          var long = new $util.Long(0, 0, false);
	          object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	        } else object.uid = options.longs === String ? "0" : 0;

	        object.success = false;

	        if ($util.Long) {
	          var long = new $util.Long(0, 0, false);
	          object.elapse = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	        } else object.elapse = options.longs === String ? "0" : 0;

	        if ($util.Long) {
	          var long = new $util.Long(0, 0, false);
	          object.peer = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	        } else object.peer = options.longs === String ? "0" : 0;

	        object.command = "";
	        object.actionType = "";
	        object.url = "";
	        object.payload = "";
	        object.serverCode = 0;
	        object.code = 0;
	        object.traceId = "";
	        object.workerType = 0;
	        object.responseTime = 0;

	        if ($util.Long) {
	          var long = new $util.Long(0, 0, false);
	          object.requestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	        } else object.requestId = options.longs === String ? "0" : 0;

	        object.packIndex = 0;
	        object.requestByUser = false;
	        object.tid = "";
	        object.productType = "";
	      }

	      if (message.sid != null && message.hasOwnProperty("sid")) object.sid = message.sid;
	      if (message.cname != null && message.hasOwnProperty("cname")) object.cname = message.cname;
	      if (message.cid != null && message.hasOwnProperty("cid")) if (typeof message.cid === "number") object.cid = options.longs === String ? String(message.cid) : message.cid;else object.cid = options.longs === String ? $util.Long.prototype.toString.call(message.cid) : options.longs === Number ? new $util.LongBits(message.cid.low >>> 0, message.cid.high >>> 0).toNumber() : message.cid;
	      if (message.lts != null && message.hasOwnProperty("lts")) if (typeof message.lts === "number") object.lts = options.longs === String ? String(message.lts) : message.lts;else object.lts = options.longs === String ? $util.Long.prototype.toString.call(message.lts) : options.longs === Number ? new $util.LongBits(message.lts.low >>> 0, message.lts.high >>> 0).toNumber() : message.lts;
	      if (message.ip != null && message.hasOwnProperty("ip")) object.ip = message.ip;
	      if (message.uid != null && message.hasOwnProperty("uid")) if (typeof message.uid === "number") object.uid = options.longs === String ? String(message.uid) : message.uid;else object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
	      if (message.success != null && message.hasOwnProperty("success")) object.success = message.success;
	      if (message.elapse != null && message.hasOwnProperty("elapse")) if (typeof message.elapse === "number") object.elapse = options.longs === String ? String(message.elapse) : message.elapse;else object.elapse = options.longs === String ? $util.Long.prototype.toString.call(message.elapse) : options.longs === Number ? new $util.LongBits(message.elapse.low >>> 0, message.elapse.high >>> 0).toNumber() : message.elapse;
	      if (message.peer != null && message.hasOwnProperty("peer")) if (typeof message.peer === "number") object.peer = options.longs === String ? String(message.peer) : message.peer;else object.peer = options.longs === String ? $util.Long.prototype.toString.call(message.peer) : options.longs === Number ? new $util.LongBits(message.peer.low >>> 0, message.peer.high >>> 0).toNumber() : message.peer;
	      if (message.command != null && message.hasOwnProperty("command")) object.command = message.command;
	      if (message.actionType != null && message.hasOwnProperty("actionType")) object.actionType = message.actionType;
	      if (message.url != null && message.hasOwnProperty("url")) object.url = message.url;
	      if (message.payload != null && message.hasOwnProperty("payload")) object.payload = message.payload;
	      if (message.serverCode != null && message.hasOwnProperty("serverCode")) object.serverCode = message.serverCode;
	      if (message.code != null && message.hasOwnProperty("code")) object.code = message.code;
	      if (message.traceId != null && message.hasOwnProperty("traceId")) object.traceId = message.traceId;
	      if (message.workerType != null && message.hasOwnProperty("workerType")) object.workerType = message.workerType;
	      if (message.responseTime != null && message.hasOwnProperty("responseTime")) object.responseTime = message.responseTime;
	      if (message.requestId != null && message.hasOwnProperty("requestId")) if (typeof message.requestId === "number") object.requestId = options.longs === String ? String(message.requestId) : message.requestId;else object.requestId = options.longs === String ? $util.Long.prototype.toString.call(message.requestId) : options.longs === Number ? new $util.LongBits(message.requestId.low >>> 0, message.requestId.high >>> 0).toNumber() : message.requestId;
	      if (message.packIndex != null && message.hasOwnProperty("packIndex")) object.packIndex = message.packIndex;
	      if (message.requestByUser != null && message.hasOwnProperty("requestByUser")) object.requestByUser = message.requestByUser;
	      if (message.tid != null && message.hasOwnProperty("tid")) object.tid = message.tid;
	      if (message.productType != null && message.hasOwnProperty("productType")) object.productType = message.productType;
	      return object;
	    };
	    /**
	     * Converts this WorkerEvent to JSON.
	     * @function toJSON
	     * @memberof Events.WorkerEvent
	     * @instance
	     * @returns {Object.<string,*>} JSON object
	     */


	    WorkerEvent.prototype.toJSON = function toJSON() {
	      return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
	    };

	    return WorkerEvent;
	  }();

	  return Events;
	}();

	var events_pb = $root;

	function isEventCustomReportParams(params) {
	  checkValidString(params.reportId, "params.reportId", 0, 100, false);
	  checkValidString(params.category, "params.category", 0, 100, false);
	  checkValidString(params.event, "params.event", 0, 100, false);
	  checkValidString(params.label, "params.label", 0, 100, false);
	  checkValidNumber(params.value, "params.value", minSafeInteger$2, maxSafeInteger$2, false);
	  return true;
	}
	var EVENT_BASE_TEMPLATE = {
	  sid: "",
	  lts: 0,
	  success: null,
	  cname: null,
	  uid: null,
	  peer: null,
	  cid: null,
	  elapse: null,
	  extend: null,
	  vid: 0
	};
	var AgoraRTCEvent;

	(function (AgoraRTCEvent) {
	  AgoraRTCEvent["PUBLISH"] = "publish";
	  AgoraRTCEvent["SUBSCRIBE"] = "subscribe";
	  AgoraRTCEvent["SESSION_INIT"] = "session_init";
	  AgoraRTCEvent["JOIN_CHOOSE_SERVER"] = "join_choose_server";
	  AgoraRTCEvent["REQ_USER_ACCOUNT"] = "req_user_account";
	  AgoraRTCEvent["JOIN_GATEWAY"] = "join_gateway";
	  AgoraRTCEvent["STREAM_SWITCH"] = "stream_switch";
	  AgoraRTCEvent["REQUEST_PROXY_WORKER_MANAGER"] = "request_proxy_worker_manager";
	  AgoraRTCEvent["REQUEST_PROXY_APPCENTER"] = "request_proxy_appcenter";
	  AgoraRTCEvent["FIRST_VIDEO_RECEIVED"] = "first_video_received";
	  AgoraRTCEvent["FIRST_AUDIO_RECEIVED"] = "first_audio_received";
	  AgoraRTCEvent["FIRST_VIDEO_DECODE"] = "first_video_decode";
	  AgoraRTCEvent["FIRST_AUDIO_DECODE"] = "first_audio_decode";
	  AgoraRTCEvent["ON_ADD_AUDIO_STREAM"] = "on_add_audio_stream";
	  AgoraRTCEvent["ON_ADD_VIDEO_STREAM"] = "on_add_video_stream";
	  AgoraRTCEvent["ON_UPDATE_STREAM"] = "on_update_stream";
	  AgoraRTCEvent["ON_REMOVE_STREAM"] = "on_remove_stream";
	  AgoraRTCEvent["USER_ANALYTICS"] = "req_user_analytics";
	})(AgoraRTCEvent || (AgoraRTCEvent = {}));

	var AgoraRTCEventUploadType;

	(function (AgoraRTCEventUploadType) {
	  AgoraRTCEventUploadType["SESSION"] = "io.agora.pb.Wrtc.Session";
	  AgoraRTCEventUploadType["JOIN_CHOOSE_SERVER"] = "io.agora.pb.Wrtc.JoinChooseServer";
	  AgoraRTCEventUploadType["REQ_USER_ACCOUNT"] = "io.agora.pb.Wrtc.ReqUserAccount";
	  AgoraRTCEventUploadType["JOIN_GATEWAT"] = "io.agora.pb.Wrtc.JoinGateway";
	  AgoraRTCEventUploadType["PUBLISH"] = "io.agora.pb.Wrtc.Publish";
	  AgoraRTCEventUploadType["SUBSCRIBE"] = "io.agora.pb.Wrtc.Subscribe";
	  AgoraRTCEventUploadType["STREAM_SWITCH"] = "io.agora.pb.Wrtc.StreamSwitch";
	  AgoraRTCEventUploadType["AUDIO_SENDING_STOPPED"] = "io.agora.pb.Wrtc.AudioSendingStopped";
	  AgoraRTCEventUploadType["VIDEO_SENDING_STOPPED"] = "io.agora.pb.Wrtc.VideoSendingStopped";
	  AgoraRTCEventUploadType["REQUEST_PROXY_APPCENTER"] = "io.agora.pb.Wrtc.RequestProxyAppCenter";
	  AgoraRTCEventUploadType["REQUEST_PROXY_WORKER_MANAGER"] = "io.agora.pb.Wrtc.RequestProxyWorkerManager";
	  AgoraRTCEventUploadType["API_INVOKE"] = "io.agora.pb.Wrtc.ApiInvoke";
	  AgoraRTCEventUploadType["FIRST_VIDEO_RECEIVED"] = "io.agora.pb.Wrtc.FirstVideoReceived";
	  AgoraRTCEventUploadType["FIRST_AUDIO_RECEIVED"] = "io.agora.pb.Wrtc.FirstAudioReceived";
	  AgoraRTCEventUploadType["FIRST_VIDEO_DECODE"] = "io.agora.pb.Wrtc.FirstVideoDecode";
	  AgoraRTCEventUploadType["FIRST_AUDIO_DECODE"] = "io.agora.pb.Wrtc.FirstAudioDecode";
	  AgoraRTCEventUploadType["ON_ADD_AUDIO_STREAM"] = "io.agora.pb.Wrtc.OnAddAudioStream";
	  AgoraRTCEventUploadType["ON_ADD_VIDEO_STREAM"] = "io.agora.pb.Wrtc.OnAddVideoStream";
	  AgoraRTCEventUploadType["ON_UPDATE_STREAM"] = "io.agora.pb.Wrtc.OnUpdateStream";
	  AgoraRTCEventUploadType["ON_REMOVE_STREAM"] = "io.agora.pb.Wrtc.OnRemoveStream";
	  AgoraRTCEventUploadType["JOIN_CHANNEL_TIMEOUT"] = "io.agora.pb.Wrtc.JoinChannelTimeout";
	  AgoraRTCEventUploadType["PEER_PUBLISH_STATUS"] = "io.agora.pb.Wrtc.PeerPublishStatus";
	  AgoraRTCEventUploadType["USER_ANALYTICS"] = "io.agora.pb.Wrtc.UserAnalytics";
	})(AgoraRTCEventUploadType || (AgoraRTCEventUploadType = {}));

	var AgoraEventUploadId;

	(function (AgoraEventUploadId) {
	  AgoraEventUploadId[AgoraEventUploadId["WORKER_EVENT"] = 156] = "WORKER_EVENT";
	  AgoraEventUploadId[AgoraEventUploadId["AP_WORKER_EVENT"] = 160] = "AP_WORKER_EVENT";
	})(AgoraEventUploadId || (AgoraEventUploadId = {}));

	var isProtobufItem = function (item) {
	  var keys = keys$3(events_pb.Events);

	  if (includes$4(keys).call(keys, item.type)) return true;
	  return false;
	};

	var AgoraAPIName;

	(function (AgoraAPIName) {
	  AgoraAPIName["CREATE_CLIENT"] = "createClient";
	  AgoraAPIName["CHECK_SYSTEM_REQUIREMENTS"] = "checkSystemRequirements";
	  /**
	   * Track checker
	   */

	  AgoraAPIName["CHECK_VIDEO_TRACK_IS_ACTIVE"] = "checkVideoTrackIsActive";
	  AgoraAPIName["CHECK_AUDIO_TRACK_IS_ACTIVE"] = "checkAudioTrackIsActive";
	  /**
	   * Track Creator
	   */

	  AgoraAPIName["CREATE_MIC_AUDIO_TRACK"] = "createMicrophoneAudioTrack";
	  AgoraAPIName["CREATE_CUSTOM_AUDIO_TRACK"] = "createCustomAudioTrack";
	  AgoraAPIName["CREATE_BUFFER_AUDIO_TRACK"] = "createBufferSourceAudioTrack";
	  AgoraAPIName["CREATE_CAM_VIDEO_TRACK"] = "createCameraVideoTrack";
	  AgoraAPIName["CREATE_CUSTOM_VIDEO_TRACK"] = "createCustomVideoTrack";
	  AgoraAPIName["CREATE_MIC_AND_CAM_TRACKS"] = "createMicrophoneAndCameraTracks";
	  AgoraAPIName["CREATE_SCREEN_VIDEO_TRACK"] = "createScreenVideoTrack";
	  /**
	   * Client 相关
	   */

	  AgoraAPIName["SET_ENCRYPTION_CONFIG"] = "Client.setEncryptionConfig";
	  AgoraAPIName["START_PROXY_SERVER"] = "Client.startProxyServer";
	  AgoraAPIName["STOP_PROXY_SERVER"] = "Client.stopProxyServer";
	  AgoraAPIName["SET_PROXY_SERVER"] = "Client.setProxyServer";
	  AgoraAPIName["SET_TURN_SERVER"] = "Client.setTurnServer";
	  AgoraAPIName["SET_CLIENT_ROLE"] = "Client.setClientRole";
	  AgoraAPIName["SET_LOW_STREAM_PARAMETER"] = "Client.setLowStreamParameter";
	  AgoraAPIName["ENABLE_DUAL_STREAM"] = "Client.enableDualStream";
	  AgoraAPIName["DISABLE_DUAL_STREAM"] = "Client.disableDualStream";
	  AgoraAPIName["JOIN"] = "Client.join";
	  AgoraAPIName["LEAVE"] = "Client.leave";
	  AgoraAPIName["PUBLISH"] = "Client.publish";
	  AgoraAPIName["UNPUBLISH"] = "Client.unpublish";
	  AgoraAPIName["SUBSCRIBE"] = "Client.subscribe";
	  AgoraAPIName["UNSUBSCRIBE"] = "Client.unsubscribe";
	  AgoraAPIName["RENEW_TOKEN"] = "Client.renewToken";
	  AgoraAPIName["SET_REMOTE_VIDEO_STREAM_TYPE"] = "Client.setRemoteVideoStreamType";
	  AgoraAPIName["SET_STREAM_FALLBACK_OPTION"] = "Client.setStreamFallbackOption";
	  AgoraAPIName["ENABLE_AUDIO_VOLUME_INDICATOR"] = "Client.enableAudioVolumeIndicator";
	  AgoraAPIName["SEND_CUSTOM_REPORT_MESSAGE"] = "Client.sendCustomReportMessage";
	  /**
	   * 推流相关
	   */

	  AgoraAPIName["ON_LIVE_STREAM_WARNING"] = "Client.onLiveStreamWarning";
	  AgoraAPIName["ON_LIVE_STREAM_ERROR"] = "Client.onLiveStreamingError";
	  AgoraAPIName["START_LIVE_STREAMING"] = "Client.startLiveStreaming";
	  AgoraAPIName["SET_LIVE_TRANSCODING"] = "Client.setLiveTranscoding";
	  AgoraAPIName["STOP_LIVE_STREAMING"] = "Client.stopLiveStreaming";
	  AgoraAPIName["ADD_INJECT_STREAM_URL"] = "Client.addInjectStreamUrl";
	  AgoraAPIName["REMOVE_INJECT_STREAM_URL"] = "Client.removeInjectStreamUrl";
	  /**
	   * 跨直播间连麦
	   */

	  AgoraAPIName["START_CHANNEL_MEDIA_RELAY"] = "Client.startChannelMediaRelay";
	  AgoraAPIName["UPDATE_CHANNEL_MEDIA_RELAY"] = "Client.updateChannelMediaRelay";
	  AgoraAPIName["STOP_CHANNEL_MEDIA_RELAY"] = "Client.stopChannelMediaRelay";
	  /**
	   * 配置下发
	   */

	  AgoraAPIName["REQUEST_CONFIG_DISTRIBUTE"] = "_config-distribute-request";
	  AgoraAPIName["SET_CONFIG_DISTRIBUTE"] = "_configDistribute";
	  /**
	   * Tracks
	   */

	  AgoraAPIName["LOCAL_TRACK_SET_MUTED"] = "LocalTrack.setMute";
	  AgoraAPIName["LOCAL_AUDIO_TRACK_PLAY"] = "LocalAudioTrack.play";
	  AgoraAPIName["LOCAL_AUDIO_TRACK_PLAY_IN_ELEMENT"] = "LocalAudioTrack.playInElement";
	  AgoraAPIName["LOCAL_AUDIO_TRACK_STOP"] = "LocalAudioTrack.stop";
	  AgoraAPIName["LOCAL_AUDIO_TRACK_SET_VOLUME"] = "LocalAudioTrack.setVolume";
	  AgoraAPIName["MIC_AUDIO_TRACK_SET_DEVICE"] = "MicrophoneAudioTrack.setDevice";
	  AgoraAPIName["BUFFER_AUDIO_TRACK_START"] = "BufferSourceAudioTrack.startProcessAudioBuffer";
	  AgoraAPIName["BUFFER_AUDIO_TRACK_STOP"] = "BufferSourceAudioTrack.stopProcessAudioBuffer";
	  AgoraAPIName["BUFFER_AUDIO_TRACK_PAUSE"] = "BufferSourceAudioTrack.pauseProcessAudioBuffer";
	  AgoraAPIName["BUFFER_AUDIO_TRACK_RESUME"] = "BufferSourceAudioTrack.resumeProcessAudioBuffer";
	  AgoraAPIName["BUFFER_AUDIO_TRACK_SEEK"] = "BufferSourceAudioTrack.seekAudioBuffer";
	  AgoraAPIName["LOCAL_VIDEO_TRACK_PLAY"] = "LocalVideoTrack.play";
	  AgoraAPIName["LOCAL_VIDEO_TRACK_STOP"] = "LocalVideoTrack.stop";
	  AgoraAPIName["LOCAL_VIDEO_TRACK_BEAUTY"] = "LocalVideoTrack.setBeautyEffect";
	  AgoraAPIName["CAM_VIDEO_TRACK_SET_DEVICE"] = "CameraVideoTrack.setDevice";
	  AgoraAPIName["CAM_VIDEO_TRACK_SET_ENCODER_CONFIG"] = "CameraVideoTrack.setEncoderConfiguration";
	  AgoraAPIName["REMOTE_VIDEO_TRACK_PLAY"] = "RemoteVideoTrack.play";
	  AgoraAPIName["REMOTE_VIDEO_TRACK_STOP"] = "RemoteVideoTrack.stop";
	  AgoraAPIName["REMOTE_AUDIO_TRACK_PLAY"] = "RemoteAudioTrack.play";
	  AgoraAPIName["REMOTE_AUDIO_TRACK_STOP"] = "RemoteAudioTrack.stop";
	  AgoraAPIName["REMOTE_AUDIO_SET_VOLUME"] = "RemoteAudioTrack.setVolume";
	  AgoraAPIName["REMOTE_AUDIO_SET_OUTPUT_DEVICE"] = "RemoteAudioTrack.setOutputDevice";
	  /**
	   * Others
	   */

	  AgoraAPIName["STREAM_TYPE_CHANGE"] = "streamTypeChange";
	})(AgoraAPIName || (AgoraAPIName = {}));

	var AgoraAPITag;

	(function (AgoraAPITag) {
	  AgoraAPITag["TRACER"] = "tracer";
	})(AgoraAPITag || (AgoraAPITag = {}));

	var DeviceManagerState;

	(function (DeviceManagerState) {
	  DeviceManagerState["IDLE"] = "IDLE";
	  DeviceManagerState["INITING"] = "INITING";
	  DeviceManagerState["INITEND"] = "INITEND";
	})(DeviceManagerState || (DeviceManagerState = {}));

	var DeviceManagerEvent;

	(function (DeviceManagerEvent) {
	  DeviceManagerEvent["STATE_CHANGE"] = "state_change";
	  DeviceManagerEvent["RECORDING_DEVICE_CHANGED"] = "recordingDeviceChanged";
	  DeviceManagerEvent["PLAYOUT_DEVICE_CHANGED"] = "playoutDeviceChanged";
	  DeviceManagerEvent["CAMERA_DEVICE_CHANGED"] = "cameraDeviceChanged";
	})(DeviceManagerEvent || (DeviceManagerEvent = {}));

	var AP_ERROR_CODE_TYPE;

	(function (AP_ERROR_CODE_TYPE) {
	  AP_ERROR_CODE_TYPE[AP_ERROR_CODE_TYPE["ACCESS_POINT"] = 101] = "ACCESS_POINT";
	  AP_ERROR_CODE_TYPE[AP_ERROR_CODE_TYPE["UNILBS"] = 201] = "UNILBS";
	  AP_ERROR_CODE_TYPE[AP_ERROR_CODE_TYPE["STRING_UID_ALLOCATOR"] = 901] = "STRING_UID_ALLOCATOR";
	})(AP_ERROR_CODE_TYPE || (AP_ERROR_CODE_TYPE = {}));

	var STRING_UID_ALLOCATOR_ERROR_CODE;

	(function (STRING_UID_ALLOCATOR_ERROR_CODE) {
	  STRING_UID_ALLOCATOR_ERROR_CODE[STRING_UID_ALLOCATOR_ERROR_CODE["IIIEGAL_APPID"] = 1] = "IIIEGAL_APPID";
	  STRING_UID_ALLOCATOR_ERROR_CODE[STRING_UID_ALLOCATOR_ERROR_CODE["IIIEGAL_UID"] = 2] = "IIIEGAL_UID";
	  STRING_UID_ALLOCATOR_ERROR_CODE[STRING_UID_ALLOCATOR_ERROR_CODE["INTERNAL_ERROR"] = 3] = "INTERNAL_ERROR";
	})(STRING_UID_ALLOCATOR_ERROR_CODE || (STRING_UID_ALLOCATOR_ERROR_CODE = {}));

	var UNILBS_ERROR_CODE;

	(function (UNILBS_ERROR_CODE) {
	  UNILBS_ERROR_CODE[UNILBS_ERROR_CODE["INVALID_VENDOR_KEY"] = 5] = "INVALID_VENDOR_KEY";
	  UNILBS_ERROR_CODE[UNILBS_ERROR_CODE["INVALID_CHANNEL_NAME"] = 7] = "INVALID_CHANNEL_NAME";
	  UNILBS_ERROR_CODE[UNILBS_ERROR_CODE["INTERNAL_ERROR"] = 8] = "INTERNAL_ERROR";
	  UNILBS_ERROR_CODE[UNILBS_ERROR_CODE["NO_AUTHORIZED"] = 9] = "NO_AUTHORIZED";
	  UNILBS_ERROR_CODE[UNILBS_ERROR_CODE["DYNAMIC_KEY_TIMEOUT"] = 10] = "DYNAMIC_KEY_TIMEOUT";
	  UNILBS_ERROR_CODE[UNILBS_ERROR_CODE["NO_ACTIVE_STATUS"] = 11] = "NO_ACTIVE_STATUS";
	  UNILBS_ERROR_CODE[UNILBS_ERROR_CODE["DYNAMIC_KEY_EXPIRED"] = 13] = "DYNAMIC_KEY_EXPIRED";
	  UNILBS_ERROR_CODE[UNILBS_ERROR_CODE["STATIC_USE_DYNAMIC_KEY"] = 14] = "STATIC_USE_DYNAMIC_KEY";
	  UNILBS_ERROR_CODE[UNILBS_ERROR_CODE["DYNAMIC_USE_STATIC_KEY"] = 15] = "DYNAMIC_USE_STATIC_KEY";
	  UNILBS_ERROR_CODE[UNILBS_ERROR_CODE["USER_OVERLOAD"] = 16] = "USER_OVERLOAD";
	  UNILBS_ERROR_CODE[UNILBS_ERROR_CODE["FORBIDDEN_REGION"] = 18] = "FORBIDDEN_REGION";
	  UNILBS_ERROR_CODE[UNILBS_ERROR_CODE["CANNOT_MEET_AREA_DEMAND"] = 19] = "CANNOT_MEET_AREA_DEMAND";
	})(UNILBS_ERROR_CODE || (UNILBS_ERROR_CODE = {}));

	var ACCESS_POINT_ERROR_CODE;

	(function (ACCESS_POINT_ERROR_CODE) {
	  ACCESS_POINT_ERROR_CODE[ACCESS_POINT_ERROR_CODE["NO_FLAG_SET"] = 100] = "NO_FLAG_SET";
	  ACCESS_POINT_ERROR_CODE[ACCESS_POINT_ERROR_CODE["FLAG_SET_BUT_EMPTY"] = 101] = "FLAG_SET_BUT_EMPTY";
	  ACCESS_POINT_ERROR_CODE[ACCESS_POINT_ERROR_CODE["INVALID_FALG_SET"] = 102] = "INVALID_FALG_SET";
	  ACCESS_POINT_ERROR_CODE[ACCESS_POINT_ERROR_CODE["NO_SERVICE_AVAILABLE"] = 200] = "NO_SERVICE_AVAILABLE";
	  ACCESS_POINT_ERROR_CODE[ACCESS_POINT_ERROR_CODE["NO_SERVICE_AVAILABLE_P2P"] = 201] = "NO_SERVICE_AVAILABLE_P2P";
	  ACCESS_POINT_ERROR_CODE[ACCESS_POINT_ERROR_CODE["NO_SERVICE_AVAILABLE_VOICE"] = 202] = "NO_SERVICE_AVAILABLE_VOICE";
	  ACCESS_POINT_ERROR_CODE[ACCESS_POINT_ERROR_CODE["NO_SERVICE_AVAILABLE_WEBRTC"] = 203] = "NO_SERVICE_AVAILABLE_WEBRTC";
	  ACCESS_POINT_ERROR_CODE[ACCESS_POINT_ERROR_CODE["NO_SERVICE_AVAILABLE_CDS"] = 204] = "NO_SERVICE_AVAILABLE_CDS";
	  ACCESS_POINT_ERROR_CODE[ACCESS_POINT_ERROR_CODE["NO_SERVICE_AVAILABLE_CDN"] = 205] = "NO_SERVICE_AVAILABLE_CDN";
	  ACCESS_POINT_ERROR_CODE[ACCESS_POINT_ERROR_CODE["NO_SERVICE_AVAILABLE_TDS"] = 206] = "NO_SERVICE_AVAILABLE_TDS";
	  ACCESS_POINT_ERROR_CODE[ACCESS_POINT_ERROR_CODE["NO_SERVICE_AVAILABLE_REPORT"] = 207] = "NO_SERVICE_AVAILABLE_REPORT";
	  ACCESS_POINT_ERROR_CODE[ACCESS_POINT_ERROR_CODE["NO_SERVICE_AVAILABLE_APP_CENTER"] = 208] = "NO_SERVICE_AVAILABLE_APP_CENTER";
	  ACCESS_POINT_ERROR_CODE[ACCESS_POINT_ERROR_CODE["NO_SERVICE_AVAILABLE_ENV0"] = 209] = "NO_SERVICE_AVAILABLE_ENV0";
	  ACCESS_POINT_ERROR_CODE[ACCESS_POINT_ERROR_CODE["NO_SERVICE_AVAILABLE_VOET"] = 210] = "NO_SERVICE_AVAILABLE_VOET";
	  ACCESS_POINT_ERROR_CODE[ACCESS_POINT_ERROR_CODE["NO_SERVICE_AVAILABLE_STRING_UID"] = 211] = "NO_SERVICE_AVAILABLE_STRING_UID";
	  ACCESS_POINT_ERROR_CODE[ACCESS_POINT_ERROR_CODE["NO_SERVICE_AVAILABLE_WEBRTC_UNILBS"] = 212] = "NO_SERVICE_AVAILABLE_WEBRTC_UNILBS";
	  ACCESS_POINT_ERROR_CODE[ACCESS_POINT_ERROR_CODE["NO_SERVICE_AVAILABLE_UNILBS_FLV"] = 213] = "NO_SERVICE_AVAILABLE_UNILBS_FLV";
	})(ACCESS_POINT_ERROR_CODE || (ACCESS_POINT_ERROR_CODE = {}));

	var GATEWAY_ERROR_CODE;

	(function (GATEWAY_ERROR_CODE) {
	  /**
	   * vos
	   */
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["K_TIMESTAMP_EXPIRED"] = 2] = "K_TIMESTAMP_EXPIRED";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["K_CHANNEL_PERMISSION_INVALID"] = 3] = "K_CHANNEL_PERMISSION_INVALID";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["K_CERTIFICATE_INVALID"] = 4] = "K_CERTIFICATE_INVALID";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["K_CHANNEL_NAME_EMPTY"] = 5] = "K_CHANNEL_NAME_EMPTY";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["K_CHANNEL_NOT_FOUND"] = 6] = "K_CHANNEL_NOT_FOUND";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["K_TICKET_INVALID"] = 7] = "K_TICKET_INVALID";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["K_CHANNEL_CONFLICTED"] = 8] = "K_CHANNEL_CONFLICTED";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["K_SERVICE_NOT_READY"] = 9] = "K_SERVICE_NOT_READY";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["K_SERVICE_TOO_HEAVY"] = 10] = "K_SERVICE_TOO_HEAVY";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["K_UID_BANNED"] = 14] = "K_UID_BANNED";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["K_IP_BANNED"] = 15] = "K_IP_BANNED";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["K_CHANNEL_BANNED"] = 16] = "K_CHANNEL_BANNED";
	  /**
	   * vocs
	   */

	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["WARN_NO_AVAILABLE_CHANNEL"] = 103] = "WARN_NO_AVAILABLE_CHANNEL";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["WARN_LOOKUP_CHANNEL_TIMEOUT"] = 104] = "WARN_LOOKUP_CHANNEL_TIMEOUT";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["WARN_LOOKUP_CHANNEL_REJECTED"] = 105] = "WARN_LOOKUP_CHANNEL_REJECTED";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["WARN_OPEN_CHANNEL_TIMEOUT"] = 106] = "WARN_OPEN_CHANNEL_TIMEOUT";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["WARN_OPEN_CHANNEL_REJECTED"] = 107] = "WARN_OPEN_CHANNEL_REJECTED";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["WARN_REQUEST_DEFERRED"] = 108] = "WARN_REQUEST_DEFERRED";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["ERR_DYNAMIC_KEY_TIMEOUT"] = 109] = "ERR_DYNAMIC_KEY_TIMEOUT";
	  /**
	   * 认证失败，有可能是 ticket 过期
	   */

	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["ERR_NO_AUTHORIZED"] = 110] = "ERR_NO_AUTHORIZED";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["ERR_VOM_SERVICE_UNAVAILABLE"] = 111] = "ERR_VOM_SERVICE_UNAVAILABLE";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["ERR_NO_CHANNEL_AVAILABLE_CODE"] = 112] = "ERR_NO_CHANNEL_AVAILABLE_CODE";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["ERR_MASTER_VOCS_UNAVAILABLE"] = 114] = "ERR_MASTER_VOCS_UNAVAILABLE";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["ERR_INTERNAL_ERROR"] = 115] = "ERR_INTERNAL_ERROR";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["ERR_NO_ACTIVE_STATUS"] = 116] = "ERR_NO_ACTIVE_STATUS";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["ERR_INVALID_UID"] = 117] = "ERR_INVALID_UID";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["ERR_DYNAMIC_KEY_EXPIRED"] = 118] = "ERR_DYNAMIC_KEY_EXPIRED";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["ERR_STATIC_USE_DYANMIC_KE"] = 119] = "ERR_STATIC_USE_DYANMIC_KE";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["ERR_DYNAMIC_USE_STATIC_KE"] = 120] = "ERR_DYNAMIC_USE_STATIC_KE";
	  /**
	   * internal
	   */

	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["ERR_NO_VOCS_AVAILABLE"] = 2000] = "ERR_NO_VOCS_AVAILABLE";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["ERR_NO_VOS_AVAILABLE"] = 2001] = "ERR_NO_VOS_AVAILABLE";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["ERR_JOIN_CHANNEL_TIMEOUT"] = 2002] = "ERR_JOIN_CHANNEL_TIMEOUT";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["ERR_REPEAT_JOIN_CHANNEL"] = 2003] = "ERR_REPEAT_JOIN_CHANNEL";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["ERR_JOIN_BY_MULTI_IP"] = 2004] = "ERR_JOIN_BY_MULTI_IP";
	  /**
	   * new in 2.9 gateway
	   */

	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["ERR_NOT_JOINED"] = 2011] = "ERR_NOT_JOINED";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["ERR_REPEAT_JOIN_REQUEST"] = 2012] = "ERR_REPEAT_JOIN_REQUEST";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["ERR_INVALID_VENDOR_KEY"] = 2013] = "ERR_INVALID_VENDOR_KEY";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["ERR_INVALID_CHANNEL_NAME"] = 2014] = "ERR_INVALID_CHANNEL_NAME";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["ERR_INVALID_STRINGUID"] = 2015] = "ERR_INVALID_STRINGUID";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["ERR_TOO_MANY_USERS"] = 2016] = "ERR_TOO_MANY_USERS";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["ERR_SET_CLIENT_ROLE_TIMEOUT"] = 2017] = "ERR_SET_CLIENT_ROLE_TIMEOUT";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["ERR_SET_CLIENT_ROLE_NO_PERMISSION"] = 2018] = "ERR_SET_CLIENT_ROLE_NO_PERMISSION";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["ERR_SET_CLIENT_ROLE_ALREADY_IN_USE"] = 2019] = "ERR_SET_CLIENT_ROLE_ALREADY_IN_USE";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["ERR_PUBLISH_REQUEST_INVALID"] = 2020] = "ERR_PUBLISH_REQUEST_INVALID";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["ERR_SUBSCRIBE_REQUEST_INVALID"] = 2021] = "ERR_SUBSCRIBE_REQUEST_INVALID";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["ERR_NOT_SUPPORTED_MESSAGE"] = 2022] = "ERR_NOT_SUPPORTED_MESSAGE";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["ERR_ILLEAGAL_PLUGIN"] = 2023] = "ERR_ILLEAGAL_PLUGIN";
	  /**
	   * 快速重连相关
	   */

	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["ERR_REJOIN_TOKEN_INVALID"] = 2024] = "ERR_REJOIN_TOKEN_INVALID";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["ERR_REJOIN_USER_NOT_JOINED"] = 2025] = "ERR_REJOIN_USER_NOT_JOINED";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["ERR_INVALID_OPTIONAL_INFO"] = 2027] = "ERR_INVALID_OPTIONAL_INFO";
	  /**
	   * join 加密
	   */

	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["ILLEGAL_AES_PASSWORD"] = 2028] = "ILLEGAL_AES_PASSWORD";
	  /**
	   * for test
	   */

	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["ERR_TEST_RECOVER"] = 9000] = "ERR_TEST_RECOVER";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["ERR_TEST_TRYNEXT"] = 9001] = "ERR_TEST_TRYNEXT";
	  GATEWAY_ERROR_CODE[GATEWAY_ERROR_CODE["ERR_TEST_RETRY"] = 9002] = "ERR_TEST_RETRY";
	})(GATEWAY_ERROR_CODE || (GATEWAY_ERROR_CODE = {}));

	function isRetryConfiguration(config) {
	  checkValidNumber(config.timeout, "config.timeout", 0, 100000);
	  checkValidNumber(config.timeoutFactor, "config.timeoutFactor", 0, 100, false);
	  checkValidNumber(config.maxRetryCount, "config.maxRetryConfig", 0, Infinity);
	  checkValidNumber(config.maxRetryTimeout, "config.maxRetryTimeout", 0, Infinity);
	  return true;
	}

	function isClientConfig(config) {
	  checkValidEnum(config.codec, "config.codec", ["vp8", "h264"]);
	  checkValidEnum(config.mode, "config.mode", ["rtc", "live"]);

	  if (config.proxyServer !== undefined) {
	    checkValidString(config.proxyServer, "config.proxyServer", 1, 10000);
	  }

	  if (config.turnServer !== undefined) {
	    isTurnServerConfig(config.turnServer);
	  }

	  if (config.httpRetryConfig !== undefined) {
	    isRetryConfiguration(config.httpRetryConfig);
	  }

	  if (config.websocketRetryConfig !== undefined) {
	    isRetryConfiguration(config.websocketRetryConfig);
	  }

	  return true;
	}
	function isTurnServerConfig(turnServer) {
	  checkValidString(turnServer.turnServerURL, "turnServerURL");
	  checkValidString(turnServer.username, "username");
	  checkValidString(turnServer.password, "password");
	  checkValidNumber(turnServer.udpport, "udpport", 1, 99999, true);

	  if (turnServer.forceturn) {
	    checkValidBoolean(turnServer.forceturn, "forceturn");
	  }

	  if (turnServer.tcpport) {
	    checkValidNumber(turnServer.tcpport, "tcpport", 1, 99999, true);
	  }

	  return true;
	}
	function isEncryptionMode(encryptionMode) {
	  checkValidEnum(encryptionMode, "encryptionMode", ["aes-128-xts", "aes-256-xts", "aes-128-ecb", "sm4-128-ecb", "none"]);
	  return true;
	}
	function isClientRole(role) {
	  checkValidEnum(role, "role", ["audience", "host"]);
	  return true;
	}
	var ClientEvents;

	(function (ClientEvents) {
	  ClientEvents["CONNECTION_STATE_CHANGE"] = "connection-state-change";
	  ClientEvents["MEDIA_RECONNECT_START"] = "media-reconnect-start";
	  ClientEvents["MEDIA_RECONNECT_END"] = "media-reconnect-end";
	  ClientEvents["USER_JOINED"] = "user-joined";
	  ClientEvents["USER_LEAVED"] = "user-left";
	  ClientEvents["USER_PUBLISHED"] = "user-published";
	  ClientEvents["USER_UNPUBLISHED"] = "user-unpublished";
	  ClientEvents["USER_INFO_UPDATED"] = "user-info-updated";
	  ClientEvents["CLIENT_BANNED"] = "client-banned";
	  ClientEvents["CHANNEL_MEDIA_RELAY_STATE"] = "channel-media-relay-state";
	  ClientEvents["CHANNEL_MEDIA_RELAY_EVENT"] = "channel-media-relay-event";
	  ClientEvents["VOLUME_INDICATOR"] = "volume-indicator";
	  ClientEvents["CRYPT_ERROR"] = "crypt-error";
	  ClientEvents["ON_TOKEN_PRIVILEGE_WILL_EXPIRE"] = "token-privilege-will-expire";
	  ClientEvents["ON_TOKEN_PRIVILEGE_DID_EXPIRE"] = "token-privilege-did-expire";
	  ClientEvents["NETWORK_QUALITY"] = "network-quality";
	  ClientEvents["STREAM_TYPE_CHANGED"] = "stream-type-changed";
	  ClientEvents["STREAM_FALLBACK"] = "stream-fallback";
	  ClientEvents["RECEIVE_METADATA"] = "receive-metadata";
	  ClientEvents["STREAM_MESSAGE"] = "stream-message";
	  ClientEvents["LIVE_STREAMING_ERROR"] = "live-streaming-error";
	  ClientEvents["LIVE_STREAMING_WARNING"] = "live-streaming-warning";
	  ClientEvents["INJECT_STREAM_STATUS"] = "stream-inject-status";
	  ClientEvents["EXCEPTION"] = "exception";
	  ClientEvents["ERROR"] = "error";
	})(ClientEvents || (ClientEvents = {}));

	var SignalConnectionState;

	(function (SignalConnectionState) {
	  SignalConnectionState["CONNECTING"] = "connecting";
	  SignalConnectionState["CONNECTED"] = "connected";
	  SignalConnectionState["RECONNECTING"] = "reconnecting";
	  SignalConnectionState["CLOSED"] = "closed";
	})(SignalConnectionState || (SignalConnectionState = {}));

	var SignalEvent;

	(function (SignalEvent) {
	  SignalEvent["WS_CONNECTED"] = "ws_connected";
	  SignalEvent["WS_RECONNECTING"] = "ws_reconnecting";
	  SignalEvent["WS_CLOSED"] = "ws_closed";
	  /** 收到了 Binary 的网关消息 */

	  SignalEvent["ON_BINARY_DATA"] = "on_binary_data";
	  /** 请求大重连，更新网关地址 */

	  SignalEvent["REQUEST_RECOVER"] = "request_recover";
	  SignalEvent["REQUEST_JOIN_INFO"] = "request_join_info";
	  SignalEvent["REQUEST_REJOIN_INFO"] = "req_rejoin_info";
	  /** P2P 连接是否建在 */

	  SignalEvent["IS_P2P_DISCONNECTED"] = "is_p2p_dis";
	  /** 当 ws 即将发生大重连时，通知上层把 p2p 干掉 */

	  SignalEvent["DISCONNECT_P2P"] = "dis_p2p";
	  SignalEvent["NEED_RENEW_SESSION"] = "need-sid";
	  /** 需要上报 JOIN_GATEWAY 失败 */

	  SignalEvent["REPORT_JOIN_GATEWAY"] = "report_join_gateway";
	  /** 发送的请求超时或成功时抛出事件 */

	  SignalEvent["REQUEST_TIMEOUT"] = "request_timeout";
	  SignalEvent["REQUEST_SUCCESS"] = "request_success";
	})(SignalEvent || (SignalEvent = {}));

	var SignalRequestType;

	(function (SignalRequestType) {
	  SignalRequestType["PING"] = "ping";
	  SignalRequestType["PING_BACK"] = "ping_back";
	  SignalRequestType["JOIN"] = "join_v2";
	  SignalRequestType["REJOIN"] = "rejoin";
	  SignalRequestType["LEAVE"] = "leave";
	  SignalRequestType["SET_CLIENT_ROLE"] = "set_client_role";
	  SignalRequestType["PUBLISH"] = "publish";
	  SignalRequestType["UNPUBLISH"] = "unpublish";
	  SignalRequestType["SUBSCRIBE"] = "subscribe";
	  SignalRequestType["UNSUBSCRIBE"] = "unsubscribe";
	  SignalRequestType["SUBSCRIBE_CHANGE"] = "subscribe_change";
	  SignalRequestType["TRAFFIC_STATS"] = "traffic_stats";
	  SignalRequestType["RENEW_TOKEN"] = "renew_token";
	  SignalRequestType["SWITCH_VIDEO_STREAM"] = "switch_video_stream";
	  SignalRequestType["SET_FALLBACK_OPTION"] = "set_fallback_option";
	  SignalRequestType["GATEWAY_INFO"] = "gateway_info";
	  SignalRequestType["CONTROL"] = "control";
	  SignalRequestType["SEND_METADATA"] = "send_metadata";
	  SignalRequestType["DATA_STREAM"] = "data_stream";
	})(SignalRequestType || (SignalRequestType = {}));

	var SignalUploadType;

	(function (SignalUploadType) {
	  SignalUploadType["PUBLISH_STATS"] = "publish_stats";
	  SignalUploadType["PUBLISH_RELATED_STATS"] = "publish_related_stats";
	  SignalUploadType["SUBSCRIBE_STATS"] = "subscribe_stats";
	  SignalUploadType["SUBSCRIBE_RELATED_STATS"] = "subscribe_related_stats";
	})(SignalUploadType || (SignalUploadType = {}));

	var SignalNotifyType;

	(function (SignalNotifyType) {
	  SignalNotifyType["ON_USER_ONLINE"] = "on_user_online";
	  SignalNotifyType["ON_USER_OFFLINE"] = "on_user_offline";
	  SignalNotifyType["ON_STREAM_FALLBACK_UPDATE"] = "on_stream_fallback_update";
	  SignalNotifyType["ON_PUBLISH_STREAM"] = "on_publish_stream";
	  SignalNotifyType["ON_UPLINK_STATS"] = "on_uplink_stats";
	  SignalNotifyType["ON_P2P_LOST"] = "on_p2p_lost";
	  SignalNotifyType["ON_REMOVE_STREAM"] = "on_remove_stream";
	  SignalNotifyType["ON_ADD_AUDIO_STREAM"] = "on_add_audio_stream";
	  SignalNotifyType["ON_ADD_VIDEO_STREAM"] = "on_add_video_stream";
	  SignalNotifyType["ON_TOKEN_PRIVILEGE_WILL_EXPIRE"] = "on_token_privilege_will_expire";
	  SignalNotifyType["ON_TOKEN_PRIVILEGE_DID_EXPIRE"] = "on_token_privilege_did_expire";
	  SignalNotifyType["ON_USER_BANNED"] = "on_user_banned";
	  SignalNotifyType["ON_NOTIFICATION"] = "on_notification";
	  SignalNotifyType["ON_CRYPT_ERROR"] = "on_crypt_error";
	  SignalNotifyType["MUTE_AUDIO"] = "mute_audio";
	  SignalNotifyType["MUTE_VIDEO"] = "mute_video";
	  SignalNotifyType["UNMUTE_AUDIO"] = "unmute_audio";
	  SignalNotifyType["UNMUTE_VIDEO"] = "unmute_video";
	  SignalNotifyType["RECEIVE_METADATA"] = "receive_metadata";
	  SignalNotifyType["ON_DATA_STREAM"] = "on_data_stream";
	  /**
	   * 使用 Native API 才会触发，透传即可
	   */

	  SignalNotifyType["ENABLE_LOCAL_VIDEO"] = "enable_local_video";
	  SignalNotifyType["DISABLE_LOCAL_VIDEO"] = "disable_local_video";
	  SignalNotifyType["ENABLE_LOCAL_AUDIO"] = "enable_local_audio";
	  SignalNotifyType["DISABLE_LOCAL_AUDIO"] = "disable_local_audio";
	})(SignalNotifyType || (SignalNotifyType = {}));

	var StreamConnectionEvents;

	(function (StreamConnectionEvents) {
	  StreamConnectionEvents["CONNECTION_STATE_CHANGE"] = "CONNECTION_STATE_CHANGE";
	  StreamConnectionEvents["NEED_ANSWER"] = "NEED_ANSWER";
	  StreamConnectionEvents["NEED_RENEGOTIATE"] = "NEED_RENEGOTIATE";
	  /** 本地检测到的 P2P 断开 */

	  StreamConnectionEvents["P2P_LOST"] = "P2P_LOST";
	  /** 网关检测到的 P2P 断开 */

	  StreamConnectionEvents["GATEWAY_P2P_LOST"] = "GATEWAY_P2P_LOST";
	  StreamConnectionEvents["NEED_UNPUB"] = "NEED_UNPUB";
	  StreamConnectionEvents["NEED_UNSUB"] = "NEED_UNSUB";
	  StreamConnectionEvents["NEED_UPLOAD"] = "NEED_UPLOAD";
	  StreamConnectionEvents["START_RECONNECT"] = "START_RECONNECT";
	  StreamConnectionEvents["END_RECONNECT"] = "END_RECONNECT";
	  StreamConnectionEvents["NEED_SIGNAL_RTT"] = "NEED_SIGNAL_RTT";
	})(StreamConnectionEvents || (StreamConnectionEvents = {}));

	var AudioSourceEvents;

	(function (AudioSourceEvents) {
	  AudioSourceEvents["AUDIO_SOURCE_STATE_CHANGE"] = "audio_source_state_change";
	  /** 第一次收到 MediaStreamTrack 的数据 */

	  AudioSourceEvents["RECEIVE_TRACK_BUFFER"] = "receive_track_buffer";
	  AudioSourceEvents["ON_AUDIO_BUFFER"] = "on_audio_buffer";
	})(AudioSourceEvents || (AudioSourceEvents = {}));

	var DEFAULT_LOCAL_AUDIO_TRACK_STATS = {
	  sendVolumeLevel: 0,
	  sendBitrate: 0,
	  sendBytes: 0,
	  sendPackets: 0,
	  sendPacketsLost: 0
	};
	var DEFAULT_LOCAL_VIDEO_TRACK_STATS = {
	  sendBytes: 0,
	  sendBitrate: 0,
	  sendPackets: 0,
	  sendPacketsLost: 0,
	  sendResolutionHeight: 0,
	  sendResolutionWidth: 0,
	  captureResolutionHeight: 0,
	  captureResolutionWidth: 0,
	  targetSendBitrate: 0,
	  totalDuration: 0,
	  totalFreezeTime: 0
	};
	var DEFAULT_REMOTE_AUDIO_TRACK_STATS = {
	  transportDelay: 0,
	  end2EndDelay: 0,
	  receiveBitrate: 0,
	  receiveLevel: 0,
	  receiveBytes: 0,
	  receiveDelay: 0,
	  receivePackets: 0,
	  receivePacketsLost: 0,
	  totalDuration: 0,
	  totalFreezeTime: 0,
	  freezeRate: 0,
	  packetLossRate: 0,
	  publishDuration: -1
	};
	var DEFAULT_NETWORK_QUALITY_STATS = {
	  uplinkNetworkQuality: 0,
	  downlinkNetworkQuality: 0
	};
	var DEFAULT_REMOTE_VIDEO_TRACK_STATS = {
	  transportDelay: 0,
	  end2EndDelay: 0,
	  receiveBitrate: 0,
	  receiveBytes: 0,
	  receiveDelay: 0,
	  receivePackets: 0,
	  receivePacketsLost: 0,
	  receiveResolutionHeight: 0,
	  receiveResolutionWidth: 0,
	  totalDuration: 0,
	  totalFreezeTime: 0,
	  freezeRate: 0,
	  packetLossRate: 0,
	  publishDuration: -1
	};

	var WebSocketManagerEvents;

	(function (WebSocketManagerEvents) {
	  WebSocketManagerEvents["CONNECTED"] = "websocket:connected";
	  WebSocketManagerEvents["RECONNECTING"] = "websocket:reconnecting";
	  /**
	   * 这个事件和 RECONNECTING 的区别是，RECONNECTING 是一个状态事件，这个是每次尝试连接 ws 都会触发
	   * 可以通过订阅这个事件更改底层 WebSocket 的重连模式
	   */

	  WebSocketManagerEvents["WILL_RECONNECT"] = "websocket:will_reconnect";
	  WebSocketManagerEvents["CLOSED"] = "websocket:closed";
	  WebSocketManagerEvents["FAILED"] = "websocket:failed";
	  WebSocketManagerEvents["ON_MESSAGE"] = "websocket:on_message";
	  WebSocketManagerEvents["REQUEST_NEW_URLS"] = "websocket:request_new_urls";
	})(WebSocketManagerEvents || (WebSocketManagerEvents = {}));

	var LiveStreamingServiceMode;

	(function (LiveStreamingServiceMode) {
	  /** 转码推流 */
	  LiveStreamingServiceMode["TRANSCODE"] = "mix_streaming";
	  /** 不转码直接推流 */

	  LiveStreamingServiceMode["RAW"] = "raw_streaming";
	  /** 外部地址推流 */

	  LiveStreamingServiceMode["INJECT"] = "inject_streaming";
	})(LiveStreamingServiceMode || (LiveStreamingServiceMode = {}));

	var DEFAULT_LIVE_STREAMING_TRANSCODING_USER = {
	  alpha: 1,
	  height: 640,
	  width: 360,
	  x: 0,
	  y: 0,
	  zOrder: 0,
	  audioChannel: 0
	};
	var DEFAULT_LIVE_STREAMING_TRANSCODING_IMAGE = {
	  x: 0,
	  y: 0,
	  width: 160,
	  height: 160,
	  zOrder: 255,
	  alpha: 1
	};

	function checkValidImage(image, name) {
	  checkValidString(image.url, name + ".url", 1, 1000, false);

	  if (!isEmpty(image.x)) {
	    checkValidNumber(image.x, name + ".x", 0, 10000);
	  }

	  if (!isEmpty(image.y)) {
	    checkValidNumber(image.y, name + ".y", 0, 10000);
	  }

	  if (!isEmpty(image.width)) {
	    checkValidNumber(image.width, name + ".width", 0, 10000);
	  }

	  if (!isEmpty(image.height)) {
	    checkValidNumber(image.height, name + ".height", 0, 10000);
	  }

	  if (!isEmpty(image.zOrder)) {
	    checkValidNumber(image.zOrder, name + ".zOrder", 0, 255);
	  }

	  if (!isEmpty(image.alpha)) {
	    checkValidNumber(image.alpha, name + ".alpha", 0, 1, false);
	  }
	}

	function isLiveStreamingTranscodingConfig(config) {
	  if (!isEmpty(config.width)) {
	    checkValidNumber(config.width, "config.width", 0, 10000);
	  }

	  if (!isEmpty(config.height)) {
	    checkValidNumber(config.height, "config.height", 0, 10000);
	  }

	  if (!isEmpty(config.videoBitrate)) {
	    checkValidNumber(config.videoBitrate, "config.videoBitrate", 1, 1000000);
	  }

	  if (!isEmpty(config.videoFrameRate)) {
	    checkValidNumber(config.videoFrameRate, "config.videoFrameRate");
	  }

	  if (!isEmpty(config.lowLatency)) {
	    checkValidBoolean(config.lowLatency, "config.lowLatency");
	  }

	  if (!isEmpty(config.audioSampleRate)) {
	    checkValidEnum(config.audioSampleRate, "config.audioSampleRate", [32000, 44100, 48000]);
	  }

	  if (!isEmpty(config.audioBitrate)) {
	    checkValidNumber(config.audioBitrate, "config.audioBitrate", 1, 128);
	  }

	  if (!isEmpty(config.audioChannels)) {
	    checkValidEnum(config.audioChannels, "config.audioChannels", [1, 2, 3, 4, 5]);
	  }

	  if (!isEmpty(config.videoGop)) {
	    checkValidNumber(config.videoGop, "config.videoGop");
	  }

	  if (!isEmpty(config.videoCodecProfile)) {
	    checkValidEnum(config.videoCodecProfile, "config.videoCodecProfile", [66, 77, 100]);
	  }

	  if (!isEmpty(config.userCount)) {
	    checkValidNumber(config.userCount, "config.userCount", 0, 17);
	  }

	  if (!isEmpty(config.backgroundColor)) {
	    checkValidNumber(config.backgroundColor, "config.backgroundColor", 0, 16777215);
	  }

	  if (!isEmpty(config.userConfigExtraInfo)) {
	    checkValidString(config.userConfigExtraInfo, "config.userConfigExtraInfo", 0, 4096, false);
	  }

	  if (config.transcodingUsers && !isEmpty(config.transcodingUsers)) {
	    var _context;

	    checkValidArray(config.transcodingUsers, "config.transcodingUsers");

	    forEach$3(_context = config.transcodingUsers).call(_context, function (user, index) {
	      checkValidUID(user.uid);

	      if (!isEmpty(user.x)) {
	        checkValidNumber(user.x, "transcodingUser[" + index + "].x", 0, 10000);
	      }

	      if (!isEmpty(user.y)) {
	        checkValidNumber(user.y, "transcodingUser[" + index + "].y", 0, 10000);
	      }

	      if (!isEmpty(user.width)) {
	        checkValidNumber(user.width, "transcodingUser[" + index + "].width", 0, 10000);
	      }

	      if (!isEmpty(user.height)) {
	        checkValidNumber(user.height, "transcodingUser[" + index + "].height", 0, 10000);
	      }

	      if (!isEmpty(user.zOrder)) {
	        checkValidNumber(user.zOrder - 1, "transcodingUser[" + index + "].zOrder", 0, 100);
	      }

	      if (!isEmpty(user.alpha)) {
	        checkValidNumber(user.alpha, "transcodingUser[" + index + "].alpha", 0, 1, false);
	      }
	    });
	  }

	  if (!isEmpty(config.watermark)) {
	    checkValidImage(config.watermark, "watermark");
	  }

	  if (!isEmpty(config.backgroundImage)) {
	    checkValidImage(config.backgroundImage, "backgroundImage");
	  }

	  if (config.images && !isEmpty(config.images)) {
	    var _context2;

	    checkValidArray(config.images, "config.images");

	    forEach$3(_context2 = config.images).call(_context2, function (image, index) {
	      checkValidImage(image, "images[" + index + "]");
	    });
	  }

	  return true;
	}
	var DEFAULT_TRANSCODING_CONFIG = {
	  audioBitrate: 48,
	  audioChannels: 1,
	  audioSampleRate: 48000,
	  backgroundColor: 0x000000,
	  height: 360,
	  lowLatency: false,
	  videoBitrate: 400,
	  videoCodecProfile: 100,
	  videoCodecType: 1,
	  videoFrameRate: 15,
	  videoGop: 30,
	  width: 640,
	  images: [],
	  userConfigs: [],
	  userConfigExtraInfo: ""
	};
	var DEFAULT_INJECT_CONFIG = {
	  audioBitrate: 48,
	  audioChannels: 2,
	  audioVolume: 100,
	  audioSampleRate: 48000,
	  height: 0,
	  width: 0,
	  videoBitrate: 400,
	  videoFramerate: 15,
	  videoGop: 30
	};
	var LiveStreamingUapSignalEvents;

	(function (LiveStreamingUapSignalEvents) {
	  LiveStreamingUapSignalEvents["WARNING"] = "@live_uap-warning";
	  LiveStreamingUapSignalEvents["ERROR"] = "@line_uap-error";
	  LiveStreamingUapSignalEvents["PUBLISH_STREAM_STATUS"] = "@live_uap-publish-status";
	  LiveStreamingUapSignalEvents["INJECT_STREAM_STATUS"] = "@live_uap-inject-status";
	  LiveStreamingUapSignalEvents["WORKER_STATUS"] = "@live_uap-worker-status";
	  LiveStreamingUapSignalEvents["REQUEST_NEW_ADDRESS"] = "@live_uap-request-address";
	})(LiveStreamingUapSignalEvents || (LiveStreamingUapSignalEvents = {}));

	var LiveStreamingInternalEvents;

	(function (LiveStreamingInternalEvents) {
	  LiveStreamingInternalEvents["REQUEST_WORKER_MANAGER_LIST"] = "@live_req_worker_manager";
	})(LiveStreamingInternalEvents || (LiveStreamingInternalEvents = {}));

	var LIVE_STREAM_ERROR_CODE;

	(function (LIVE_STREAM_ERROR_CODE) {
	  LIVE_STREAM_ERROR_CODE[LIVE_STREAM_ERROR_CODE["LIVE_STREAM_RESPONSE_SUCCEED"] = 200] = "LIVE_STREAM_RESPONSE_SUCCEED";
	  LIVE_STREAM_ERROR_CODE[LIVE_STREAM_ERROR_CODE["LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM"] = 454] = "LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM";
	  LIVE_STREAM_ERROR_CODE[LIVE_STREAM_ERROR_CODE["LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR"] = 450] = "LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR";
	  LIVE_STREAM_ERROR_CODE[LIVE_STREAM_ERROR_CODE["LIVE_STREAM_RESPONSE_BAD_STREAM"] = 451] = "LIVE_STREAM_RESPONSE_BAD_STREAM";
	  LIVE_STREAM_ERROR_CODE[LIVE_STREAM_ERROR_CODE["LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR"] = 400] = "LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR";
	  LIVE_STREAM_ERROR_CODE[LIVE_STREAM_ERROR_CODE["LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST"] = 404] = "LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST";
	  LIVE_STREAM_ERROR_CODE[LIVE_STREAM_ERROR_CODE["LIVE_STREAM_RESPONSE_NOT_AUTHORIZED"] = 456] = "LIVE_STREAM_RESPONSE_NOT_AUTHORIZED";
	  LIVE_STREAM_ERROR_CODE[LIVE_STREAM_ERROR_CODE["LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE"] = 457] = "LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE";
	  LIVE_STREAM_ERROR_CODE[LIVE_STREAM_ERROR_CODE["LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN"] = 429] = "LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN";
	  LIVE_STREAM_ERROR_CODE[LIVE_STREAM_ERROR_CODE["LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH"] = 452] = "LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH";
	  LIVE_STREAM_ERROR_CODE[LIVE_STREAM_ERROR_CODE["LIVE_STREAM_RESPONSE_NOT_SUPPORTED"] = 453] = "LIVE_STREAM_RESPONSE_NOT_SUPPORTED";
	  LIVE_STREAM_ERROR_CODE[LIVE_STREAM_ERROR_CODE["LIVE_STREAM_RESPONSE_MAX_STREAM_NUM"] = 455] = "LIVE_STREAM_RESPONSE_MAX_STREAM_NUM";
	  LIVE_STREAM_ERROR_CODE[LIVE_STREAM_ERROR_CODE["LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR"] = 500] = "LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR";
	  LIVE_STREAM_ERROR_CODE[LIVE_STREAM_ERROR_CODE["LIVE_STREAM_RESPONSE_WORKER_LOST"] = 501] = "LIVE_STREAM_RESPONSE_WORKER_LOST";
	  LIVE_STREAM_ERROR_CODE[LIVE_STREAM_ERROR_CODE["LIVE_STREAM_RESPONSE_RESOURCE_LIMIT"] = 502] = "LIVE_STREAM_RESPONSE_RESOURCE_LIMIT";
	  LIVE_STREAM_ERROR_CODE[LIVE_STREAM_ERROR_CODE["LIVE_STREAM_RESPONSE_WORKER_QUIT"] = 503] = "LIVE_STREAM_RESPONSE_WORKER_QUIT";
	  LIVE_STREAM_ERROR_CODE[LIVE_STREAM_ERROR_CODE["ERROR_FAIL_SEND_MESSAGE"] = 504] = "ERROR_FAIL_SEND_MESSAGE";
	  LIVE_STREAM_ERROR_CODE[LIVE_STREAM_ERROR_CODE["PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE"] = 30] = "PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE";
	  LIVE_STREAM_ERROR_CODE[LIVE_STREAM_ERROR_CODE["PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT"] = 31] = "PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT";
	  LIVE_STREAM_ERROR_CODE[LIVE_STREAM_ERROR_CODE["PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH"] = 32] = "PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH";
	  LIVE_STREAM_ERROR_CODE[LIVE_STREAM_ERROR_CODE["PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN"] = 33] = "PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN"; // PUBLISH_STREAM_STATUS_ERROR_FIRST_FRAME_CONNECT	= 34,
	  // PUBLISH_STREAM_STATUS_ERROR_FIRST_FRAME_AUDIO = 35,
	  // PUBLISH_STREAM_STATUS_ERROR_FIRST_FRAME_VIDEO = 36,
	})(LIVE_STREAM_ERROR_CODE || (LIVE_STREAM_ERROR_CODE = {}));

	function isBeautyEffectOptions(options) {
	  if (options.smoothnessLevel !== undefined) {
	    checkValidNumber(options.smoothnessLevel, "options.smoothnessLevel", 0, 1, false);
	  }

	  if (options.lighteningLevel !== undefined) {
	    checkValidNumber(options.lighteningLevel, "options.lighteningLevel", 0, 1, false);
	  }

	  if (options.rednessLevel !== undefined) {
	    checkValidNumber(options.rednessLevel, "options.rednessLevel", 0, 1, false);
	  }

	  if (options.lighteningContrastLevel !== undefined) {
	    checkValidEnum(options.lighteningContrastLevel, "options.lighteningContrastLevel", [0, 1, 2]);
	  }

	  return true;
	}

	function isChannelMediaRelayInfo(info) {
	  if (!info.channelName) {
	    throw new AgoraRTCError(AgoraRTCErrorCode.INVALID_PARAMS, "invalid channelName in info");
	  }

	  if (!info.uid || typeof info.uid !== "number") {
	    throw new AgoraRTCError(AgoraRTCErrorCode.INVALID_PARAMS, "invalid uid in info, uid must be a number");
	  }

	  if (info.token) {
	    checkValidString(info.token, "info.token", 1, 2047);
	  }

	  checkValidUID(info.uid);
	  checkValidChannelName(info.channelName);
	  return true;
	}
	/**
	 * 内部错误码
	 */

	var CHANNEL_MEDIA_ERROR;

	(function (CHANNEL_MEDIA_ERROR) {
	  CHANNEL_MEDIA_ERROR["CONNECT_FAILED"] = "connect failed";
	  CHANNEL_MEDIA_ERROR["CONNECT_TIMEOUT"] = "connect timeout";
	  CHANNEL_MEDIA_ERROR["WS_DISCONNECTED"] = "websocket disconnected";
	  CHANNEL_MEDIA_ERROR["REQUEST_TIMEOUT"] = "request timeout";
	  CHANNEL_MEDIA_ERROR["REQUEST_FAILED"] = "request failed";
	  CHANNEL_MEDIA_ERROR["WAIT_STATUS_TIMEOUT"] = "wait status timeout";
	  CHANNEL_MEDIA_ERROR["WAIT_STATUS_ERROR"] = "wait status error";
	  CHANNEL_MEDIA_ERROR["BAD_STATE"] = "bad state";
	  CHANNEL_MEDIA_ERROR["WS_ABORT"] = "ws abort";
	  CHANNEL_MEDIA_ERROR["AP_REQUEST_TIMEOUT"] = "AP request timeout";
	  CHANNEL_MEDIA_ERROR["AP_JSON_PARSE_ERROR"] = "AP json parse error";
	  CHANNEL_MEDIA_ERROR["AP_REQUEST_ERROR"] = "AP request error";
	  CHANNEL_MEDIA_ERROR["AP_REQUEST_ABORT"] = "AP request abort";
	})(CHANNEL_MEDIA_ERROR || (CHANNEL_MEDIA_ERROR = {}));

	var CHANNEL_MEDIA_RELAY_MESSAGE_TYPE;

	(function (CHANNEL_MEDIA_RELAY_MESSAGE_TYPE) {
	  CHANNEL_MEDIA_RELAY_MESSAGE_TYPE[CHANNEL_MEDIA_RELAY_MESSAGE_TYPE["SetSdkProfile"] = 0] = "SetSdkProfile";
	  CHANNEL_MEDIA_RELAY_MESSAGE_TYPE[CHANNEL_MEDIA_RELAY_MESSAGE_TYPE["SetSourceChannel"] = 1] = "SetSourceChannel";
	  CHANNEL_MEDIA_RELAY_MESSAGE_TYPE[CHANNEL_MEDIA_RELAY_MESSAGE_TYPE["SetSourceUserId"] = 2] = "SetSourceUserId";
	  CHANNEL_MEDIA_RELAY_MESSAGE_TYPE[CHANNEL_MEDIA_RELAY_MESSAGE_TYPE["SetDestChannel"] = 3] = "SetDestChannel";
	  CHANNEL_MEDIA_RELAY_MESSAGE_TYPE[CHANNEL_MEDIA_RELAY_MESSAGE_TYPE["StartPacketTransfer"] = 4] = "StartPacketTransfer";
	  CHANNEL_MEDIA_RELAY_MESSAGE_TYPE[CHANNEL_MEDIA_RELAY_MESSAGE_TYPE["StopPacketTransfer"] = 5] = "StopPacketTransfer";
	  CHANNEL_MEDIA_RELAY_MESSAGE_TYPE[CHANNEL_MEDIA_RELAY_MESSAGE_TYPE["UpdateDestChannel"] = 6] = "UpdateDestChannel";
	  CHANNEL_MEDIA_RELAY_MESSAGE_TYPE[CHANNEL_MEDIA_RELAY_MESSAGE_TYPE["Reconnect"] = 7] = "Reconnect";
	  CHANNEL_MEDIA_RELAY_MESSAGE_TYPE[CHANNEL_MEDIA_RELAY_MESSAGE_TYPE["SetVideoProfile"] = 8] = "SetVideoProfile";
	})(CHANNEL_MEDIA_RELAY_MESSAGE_TYPE || (CHANNEL_MEDIA_RELAY_MESSAGE_TYPE = {}));

	var GatewayEvent;

	(function (GatewayEvent) {
	  /** 不可恢复的 disconnect */
	  GatewayEvent["DISCONNECT"] = "disconnect";
	  GatewayEvent["CONNECTION_STATE_CHANGE"] = "connection-state-change";
	  GatewayEvent["NETWORK_QUALITY"] = "network-quality";
	  GatewayEvent["STREAM_TYPE_CHANGE"] = "stream-type-change";
	  GatewayEvent["IS_P2P_DISCONNECTED"] = "is-p2p-dis";
	  GatewayEvent["DISCONNECT_P2P"] = "dis-p2p";
	  GatewayEvent["REQUEST_NEW_GATEWAY_LIST"] = "req-gate-url";
	  GatewayEvent["NEED_RENEW_SESSION"] = "need-sid";
	})(GatewayEvent || (GatewayEvent = {}));

	function isScreenSourceType(mediaSource) {
	  checkValidEnum(mediaSource, "mediaSource", ["screen", "window", "application"]);
	  return true;
	}
	var TrackInternalEvent;

	(function (TrackInternalEvent) {
	  TrackInternalEvent["NEED_RENEGOTIATE"] = "@need_renegotiate";
	  TrackInternalEvent["NEED_REPLACE_TRACK"] = "@need_replace_track";
	  TrackInternalEvent["NEED_CLOSE"] = "@need_close";
	  TrackInternalEvent["NEED_ADD_TRACK"] = "@need_add_track";
	  TrackInternalEvent["NEED_REMOVE_TRACK"] = "@need_remove_track";
	  TrackInternalEvent["NEED_SESSION_ID"] = "@need_sid";
	  TrackInternalEvent["GET_STATS"] = "@get_stats";
	  TrackInternalEvent["GET_LOW_VIDEO_TRACK"] = "@get_low_video_track";
	})(TrackInternalEvent || (TrackInternalEvent = {}));

	var TrackHint;

	(function (TrackHint) {
	  /** 标记这个 Track 是否来自屏幕共享 */
	  TrackHint["SCREEN_TRACK"] = "screen_track";
	  /** 标记这个 Track 是否来自于小流 */

	  TrackHint["LOW_STREAM"] = "low_stream";
	})(TrackHint || (TrackHint = {}));

	function isLowStreamParameter(streamParameter) {
	  if (!streamParameter) {
	    throw new AgoraRTCError(AgoraRTCErrorCode.INVALID_PARAMS);
	  }

	  if (!isEmpty(streamParameter.width)) {
	    checkValidNumber(streamParameter.width, "streamParameter.width");
	  }

	  if (!isEmpty(streamParameter.height)) {
	    checkValidNumber(streamParameter.height, "streamParameter.height");
	  }

	  if (!isEmpty(streamParameter.framerate)) {
	    checkValidNumber(streamParameter.framerate, "streamParameter.framerate");
	  }

	  if (!isEmpty(streamParameter.bitrate)) {
	    checkValidNumber(streamParameter.bitrate, "streamParameter.bitrate");
	  }

	  return true;
	}
	var LocalTrackEvents;

	(function (LocalTrackEvents) {
	  LocalTrackEvents["SOURCE_STATE_CHANGE"] = "source-state-change";
	  LocalTrackEvents["TRACK_ENDED"] = "track-ended";
	  LocalTrackEvents["BEAUTY_EFFECT_OVERLOAD"] = "beauty-effect-overload";
	})(LocalTrackEvents || (LocalTrackEvents = {}));

	var RemoteTrackEvents;

	(function (RemoteTrackEvents) {
	  RemoteTrackEvents["FIRST_FRAME_DECODED"] = "first-frame-decoded";
	})(RemoteTrackEvents || (RemoteTrackEvents = {}));

	var AREAS_LIST = ["AFRICA"
	/* AFRICA */
	, "ASIA"
	/* ASIA */
	, "CHINA"
	/* CHINA */
	, "EUROPE"
	/* EUROPE */
	, "GLOBAL"
	/* GLOBAL */
	, "INDIA"
	/* INDIA */
	, "JAPAN"
	/* JAPAN */
	, "NORTH_AMERICA"
	/* NORTH_AMERICA */
	, "OCEANIA"
	/* OCEANIA */
	, "OVERSEA"
	/* OVERSEA */
	, "SOUTH_AMERICA"
	/* SOUTH_AMERICA */
	];
	var AREA_DOMAIN_MAP = {
	  CHINA: {},
	  ASIA: {
	    CODE: "AS"
	    /* ASIA */
	    ,
	    WEBCS_DOMAIN: ["ap-web-1-asia.agora.io"],
	    WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-asia.agora.io"],
	    PROXY_CS: ["proxy-ap-web-asia.agora.io"],
	    CDS_AP: ["cds-ap-web-asia.agora.io", "cds-ap-web-asia2.agora.io"],
	    ACCOUNT_REGISTER: ["sua-ap-web-asia.agora.io", "sua-ap-web-asia2.agora.io"],
	    UAP_AP: ["uap-ap-web-asia.agora.io", "uap-ap-web-asia2.agora.io"],
	    EVENT_REPORT_DOMAIN: ["statscollector-1-asia.agora.io"],
	    EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-asia.agora.io"],
	    LOG_UPLOAD_SERVER: ["logservice-asia.agora.io"]
	  },
	  NORTH_AMERICA: {
	    CODE: "NA"
	    /* NORTH_AMERICA */
	    ,
	    WEBCS_DOMAIN: ["ap-web-1-north-america.agora.io"],
	    WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-north-america.agora.io"],
	    PROXY_CS: ["proxy-ap-web-america.agora.io"],
	    CDS_AP: ["cds-ap-web-america.agora.io", "cds-ap-web-america2.agora.io"],
	    ACCOUNT_REGISTER: ["sua-ap-web-america.agora.io", "sua-ap-web-america2.agora.io"],
	    UAP_AP: ["uap-ap-web-america.agora.io", "uap-ap-web-america2.agora.io"],
	    EVENT_REPORT_DOMAIN: ["statscollector-1-north-america.agora.io"],
	    EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-north-america.agora.io"],
	    LOG_UPLOAD_SERVER: ["logservice-north-america.agora.io"]
	  },
	  EUROPE: {
	    CODE: "EU"
	    /* EUROPE */
	    ,
	    WEBCS_DOMAIN: ["ap-web-1-europe.agora.io"],
	    WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-europe.agora.io"],
	    PROXY_CS: ["proxy-ap-web-europe.agora.io"],
	    CDS_AP: ["cds-ap-web-europe.agora.io", "cds-ap-web-europe2.agora.io"],
	    ACCOUNT_REGISTER: ["sua-ap-web-europe.agora.io", "sua-ap-web-europe.agora.io"],
	    UAP_AP: ["uap-ap-web-europe.agora.io", "uap-ap-web-europe2.agora.io"],
	    EVENT_REPORT_DOMAIN: ["statscollector-1-europe.agora.io"],
	    EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-europe.agora.io"],
	    LOG_UPLOAD_SERVER: ["logservice-europe.agora.io"]
	  },
	  JAPAN: {
	    CODE: "JP"
	    /* JAPAN */
	    ,
	    WEBCS_DOMAIN: ["ap-web-1-japan.agora.io"],
	    WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-japan.agora.io"],
	    PROXY_CS: ["proxy-ap-web-japan.agora.io"],
	    CDS_AP: ["cds-ap-web-japan.agora.io", "cds-ap-web-japan2.agora.io"],
	    ACCOUNT_REGISTER: ["sua-ap-web-japan.agora.io", "sua-ap-web-japan2.agora.io"],
	    UAP_AP: ["uap-ap-web-japan.agora.io", "	uap-ap-web-japan2.agora.io"],
	    EVENT_REPORT_DOMAIN: ["statscollector-1-japan.agora.io"],
	    EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-japan.agora.io"],
	    LOG_UPLOAD_SERVER: ["logservice-japan.agora.io"]
	  },
	  INDIA: {
	    CODE: "IN"
	    /* INDIA */
	    ,
	    WEBCS_DOMAIN: ["ap-web-1-india.agora.io"],
	    WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-india.agora.io"],
	    PROXY_CS: ["proxy-ap-web-india.agora.io"],
	    CDS_AP: ["cds-ap-web-india.agora.io", "cds-ap-web-india2.agora.io"],
	    ACCOUNT_REGISTER: ["sua-ap-web-india.agora.io", "sua-ap-web-india2.agora.io"],
	    UAP_AP: ["uap-ap-web-india.agora.io", "uap-ap-web-india2.agora.io"],
	    EVENT_REPORT_DOMAIN: ["statscollector-1-india.agora.io"],
	    EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-india.agora.io"],
	    LOG_UPLOAD_SERVER: ["logservice-india.agora.io"]
	  },
	  OVERSEA: {
	    CODE: "OVERSEA"
	    /* OVERSEA */
	    ,
	    WEBCS_DOMAIN: ["ap-web-1-oversea.agora.io"],
	    WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-oversea.agora.io"],
	    PROXY_CS: ["proxy-ap-web-oversea.agora.io"],
	    CDS_AP: ["cds-ap-web-oversea.agora.io"],
	    ACCOUNT_REGISTER: ["sua-ap-web-oversea.agora.io"],
	    UAP_AP: ["uap-ap-web-oversea.agora.io"],
	    EVENT_REPORT_DOMAIN: ["statscollector-1-oversea.agora.io"],
	    EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-oversea.agora.io"],
	    LOG_UPLOAD_SERVER: ["logservice-oversea.agora.io"]
	  },
	  GLOBAL: {
	    CODE: "GLOBAL"
	    /* GLOBAL */
	    ,
	    WEBCS_DOMAIN: ["webrtc2-ap-web-1.agora.io"],
	    WEBCS_DOMAIN_BACKUP_LIST: ["webrtc2-ap-web-3.agora.io"],
	    PROXY_CS: ["ap-proxy-1.agora.io", "ap-proxy-2.agora.io"],
	    CDS_AP: ["cds-ap-web-1.agora.io", "cds-ap-web-3.agora.io"],
	    ACCOUNT_REGISTER: ["sua-ap-web-1.agora.io", "sua-ap-web-3.agora.io"],
	    UAP_AP: ["uap-ap-web-1.agora.io", "uap-ap-web-3.agora.io"],
	    EVENT_REPORT_DOMAIN: ["statscollector-1.agora.io"],
	    EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2.agora.io"],
	    LOG_UPLOAD_SERVER: ["logservice.agora.io"]
	  },
	  // 预埋，尚未部署，需要的话联系运维部署
	  OCEANIA: {
	    CODE: "OC"
	    /* OCEANIA */
	    ,
	    WEBCS_DOMAIN: ["ap-web-1-oceania.agora.io"],
	    WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-oceania.agora.io"],
	    PROXY_CS: ["proxy-ap-web-oceania.agora.io"],
	    CDS_AP: ["cds-ap-web-oceania.agora.io", "cds-ap-web-oceania2.agora.io"],
	    ACCOUNT_REGISTER: ["sua-ap-web-oceania.agora.io", "sua-ap-web-oceania2.agora.io"],
	    UAP_AP: ["uap-ap-web-oceania.agora.io", "uap-ap-web-oceania2.agora.io"],
	    EVENT_REPORT_DOMAIN: ["statscollector-1-oceania.agora.io"],
	    EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-oceania.agora.io"],
	    LOG_UPLOAD_SERVER: ["logservice-oceania.agora.io"]
	  },
	  SOUTH_AMERICA: {
	    CODE: "SA"
	    /* SOUTH_AMERICA */
	    ,
	    WEBCS_DOMAIN: ["ap-web-1-south-america.agora.io"],
	    WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-south-america.agora.io"],
	    PROXY_CS: ["proxy-ap-web-south-america.agora.io"],
	    CDS_AP: ["cds-ap-web-south-america.agora.io", "cds-ap-web-south-america2.agora.io"],
	    ACCOUNT_REGISTER: ["sua-ap-web-south-america.agora.io", "sua-ap-web-south-america2.agora.io"],
	    UAP_AP: ["uap-ap-web-south-america.agora.io", "uap-ap-web-south-america2.agora.io"],
	    EVENT_REPORT_DOMAIN: ["statscollector-1-south-america.agora.io"],
	    EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-south-america.agora.io"],
	    LOG_UPLOAD_SERVER: ["logservice-south-america.agora.io"]
	  },
	  AFRICA: {
	    CODE: "AF"
	    /* AFRICA */
	    ,
	    WEBCS_DOMAIN: ["ap-web-1-africa.agora.io"],
	    WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-africa.agora.io"],
	    PROXY_CS: ["proxy-ap-web-africa.agora.io"],
	    CDS_AP: ["cds-ap-web-africa.agora.io", "cds-ap-web-africa2.agora.io"],
	    ACCOUNT_REGISTER: ["sua-ap-web-africa.agora.io", "sua-ap-web-africa2.agora.io"],
	    UAP_AP: ["uap-ap-web-africa.agora.io", "uap-ap-web-africa2.agora.io"],
	    EVENT_REPORT_DOMAIN: ["statscollector-1-africa.agora.io"],
	    EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-africa.agora.io"],
	    LOG_UPLOAD_SERVER: ["logservice-south-africa.agora.io"]
	  }
	}; // 全球版本才有 .cn 的域名
	// @ts-ignore

	if (IS_GLOBAL_VERSION) {
	  AREA_DOMAIN_MAP["CHINA"] = {
	    CODE: "CN"
	    /* CHINA */
	    ,
	    WEBCS_DOMAIN: ["webrtc2-ap-web-2.agoraio.cn"],
	    WEBCS_DOMAIN_BACKUP_LIST: ["webrtc2-ap-web-4.agoraio.cn"],
	    PROXY_CS: ["proxy-ap-web.agoraio.cn"],
	    CDS_AP: ["cds-ap-web-2.agoraio.cn", "cds-ap-web-4.agoraio.cn"],
	    ACCOUNT_REGISTER: ["sua-ap-web-2.agoraio.cn", "sua-ap-web-4.agoraio.cn"],
	    UAP_AP: ["uap-ap-web-2.agoraio.cn", "uap-ap-web-4.agoraio.cn"],
	    EVENT_REPORT_DOMAIN: ["statscollector-3.agoraio.cn"],
	    EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-4.agoraio.cn"],
	    LOG_UPLOAD_SERVER: ["logservice-china.agora.io"]
	  };
	}

	function getBrowserInfo(userAgent) {
	  var _context, _context2, _context3, _context4;

	  var ua = userAgent || navigator.userAgent;
	  var matchResult = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || []; // for opera

	  if (matchResult[1] === "Chrome") {
	    var tem = ua.match(/(OPR(?=\/))\/?(\d+)/i);

	    if (tem !== null) {
	      matchResult = tem;
	    }
	  } // for Safari version


	  if (matchResult[1] === "Safari") {
	    var tem = ua.match(/version\/(\d+)/i);

	    if (tem !== null) {
	      matchResult[2] = tem[1];
	    }
	  } // for QQ


	  if (indexOf$3(_context = ua.toLowerCase()).call(_context, "qqbrowser") !== -1) {
	    var tem = ua.match(/(qqbrowser(?=\/))\/?(\d+)/i);

	    if (tem !== null) {
	      matchResult = tem;
	    }
	  } // for weChat


	  if (indexOf$3(_context2 = ua.toLowerCase()).call(_context2, "micromessenger") !== -1) {
	    var tem = ua.match(/(micromessenger(?=\/))\/?(\d+)/i);

	    if (tem !== null) {
	      matchResult = tem;
	    }
	  } // for Edge


	  if (indexOf$3(_context3 = ua.toLowerCase()).call(_context3, "edge") !== -1) {
	    var tem = ua.match(/(edge(?=\/))\/?(\d+)/i);

	    if (tem !== null) {
	      matchResult = tem;
	    }
	  } // for IE


	  if (indexOf$3(_context4 = ua.toLowerCase()).call(_context4, "trident") !== -1) {
	    var tem = /\brv[ :]+(\d+)/g.exec(ua) || [];

	    if (tem !== null) {
	      matchResult = ["", "IE", tem[1]];
	    }
	  }

	  var os = null;
	  var clientStrings = [{
	    s: BrowserOS.WIN_10,
	    r: /(Windows 10.0|Windows NT 10.0)/
	  }, {
	    s: BrowserOS.WIN_81,
	    r: /(Windows 8.1|Windows NT 6.3)/
	  }, {
	    s: BrowserOS.WIN_8,
	    r: /(Windows 8|Windows NT 6.2)/
	  }, {
	    s: BrowserOS.WIN_7,
	    r: /(Windows 7|Windows NT 6.1)/
	  }, {
	    s: BrowserOS.WIN_VISTA,
	    r: /Windows NT 6.0/
	  }, {
	    s: BrowserOS.WIN_SERVER_2003,
	    r: /Windows NT 5.2/
	  }, {
	    s: BrowserOS.WIN_XP,
	    r: /(Windows NT 5.1|Windows XP)/
	  }, {
	    s: BrowserOS.WIN_2000,
	    r: /(Windows NT 5.0|Windows 2000)/
	  }, {
	    s: BrowserOS.ANDROID,
	    r: /Android/
	  }, {
	    s: BrowserOS.OPEN_BSD,
	    r: /OpenBSD/
	  }, {
	    s: BrowserOS.SUN_OS,
	    r: /SunOS/
	  }, {
	    s: BrowserOS.LINUX,
	    r: /(Linux|X11)/
	  }, {
	    s: BrowserOS.IOS,
	    r: /(iPhone|iPad|iPod)/
	  }, {
	    s: BrowserOS.MAC_OS_X,
	    r: /Mac OS X/
	  }, {
	    s: BrowserOS.MAC_OS,
	    r: /(MacPPC|MacIntel|Mac_PowerPC|Macintosh)/
	  }, {
	    s: BrowserOS.QNX,
	    r: /QNX/
	  }, {
	    s: BrowserOS.UNIX,
	    r: /UNIX/
	  }, {
	    s: BrowserOS.BEOS,
	    r: /BeOS/
	  }, {
	    s: BrowserOS.OS_2,
	    r: /OS\/2/
	  }, {
	    s: BrowserOS.SEARCH_BOT,
	    r: /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask Jeeves\/Teoma|ia_archiver)/
	  }];

	  for (var id in clientStrings) {
	    var cs = clientStrings[id];

	    if (cs.r.test(ua)) {
	      os = cs.s;
	      break;
	    }
	  }

	  var info = {
	    name: matchResult[1],
	    version: matchResult[2],
	    os: os
	  };
	  return info;
	}
	function isChrome() {
	  var info = getBrowserInfo();
	  return info.name === BrowserName.CHROME;
	}
	function isEdge() {
	  var info = getBrowserInfo();
	  return info.name === BrowserName.EDGE;
	}
	function isFirefox() {
	  var info = getBrowserInfo();
	  return info.name === BrowserName.FIREFOX;
	}
	function isQQBrowser() {
	  var info = getBrowserInfo();
	  return info.name === BrowserName.QQ;
	}
	function isWechatBrowser() {
	  var info = getBrowserInfo();
	  return info.name === BrowserName.WECHAT;
	}
	function isLegacyChrome() {
	  return window.navigator.appVersion && window.navigator.appVersion.match(/Chrome\/([\w\W]*?)\./) !== null && window.navigator.appVersion.match(/Chrome\/([\w\W]*?)\./)[1] <= 35;
	}
	function isChromeKernel() {
	  var info = getBrowserInfo();

	  if (info.name === BrowserName.EDGE || info.name === BrowserName.SAFARI) {
	    return false;
	  }

	  var ua = navigator.userAgent.toLocaleLowerCase();
	  return !!ua.match(/chrome\/[\d]./i);
	}

	var values = entryVirtual('Array').values;

	var values$1 = values;

	var ArrayPrototype$d = Array.prototype;

	var DOMIterables$1 = {
	  DOMTokenList: true,
	  NodeList: true
	};

	var values_1 = function (it) {
	  var own = it.values;
	  return it === ArrayPrototype$d || (it instanceof Array && own === ArrayPrototype$d.values)
	    // eslint-disable-next-line no-prototype-builtins
	    || DOMIterables$1.hasOwnProperty(classof(it)) ? values$1 : own;
	};

	var values$2 = values_1;

	// `Array.from` method implementation
	// https://tc39.github.io/ecma262/#sec-array.from
	var arrayFrom = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
	  var O = toObject(arrayLike);
	  var C = typeof this == 'function' ? this : Array;
	  var argumentsLength = arguments.length;
	  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
	  var mapping = mapfn !== undefined;
	  var index = 0;
	  var iteratorMethod = getIteratorMethod(O);
	  var length, result, step, iterator, next;
	  if (mapping) mapfn = bindContext(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2);
	  // if the target is not iterable or it's an array with the default iterator - use a simple case
	  if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
	    iterator = iteratorMethod.call(O);
	    next = iterator.next;
	    result = new C();
	    for (;!(step = next.call(iterator)).done; index++) {
	      createProperty(result, index, mapping
	        ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true)
	        : step.value
	      );
	    }
	  } else {
	    length = toLength(O.length);
	    result = new C(length);
	    for (;length > index; index++) {
	      createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
	    }
	  }
	  result.length = index;
	  return result;
	};

	var INCORRECT_ITERATION$1 = !checkCorrectnessOfIteration(function (iterable) {
	  Array.from(iterable);
	});

	// `Array.from` method
	// https://tc39.github.io/ecma262/#sec-array.from
	_export({ target: 'Array', stat: true, forced: INCORRECT_ITERATION$1 }, {
	  from: arrayFrom
	});

	var from_1 = path.Array.from;

	var from_1$1 = from_1;

	var from_1$2 = from_1$1;

	// `Date.now` method
	// https://tc39.github.io/ecma262/#sec-date.now
	_export({ target: 'Date', stat: true }, {
	  now: function now() {
	    return new Date().getTime();
	  }
	});

	var now = path.Date.now;

	var now$1 = now;

	var now$2 = now$1;

	// `Object.create` method
	// https://tc39.github.io/ecma262/#sec-object.create
	_export({ target: 'Object', stat: true, sham: !descriptors }, {
	  create: objectCreate
	});

	var Object$1 = path.Object;

	var create$2 = function create(P, D) {
	  return Object$1.create(P, D);
	};

	var create$3 = create$2;

	var create$4 = create$3;

	// `Object.setPrototypeOf` method
	// https://tc39.github.io/ecma262/#sec-object.setprototypeof
	_export({ target: 'Object', stat: true }, {
	  setPrototypeOf: objectSetPrototypeOf
	});

	var setPrototypeOf = path.Object.setPrototypeOf;

	var setPrototypeOf$1 = setPrototypeOf;

	var setPrototypeOf$2 = setPrototypeOf$1;

	/**
	 * @ignore
	 */

	/** @en
	 * @ignore
	 */
	var EventEmitter$1 =
	/** @class */
	function () {
	  function EventEmitter() {
	    this._events = {};
	    /** @internal */

	    this.addListener = this.on;
	  }
	  /**
	   * 指定一个事件名，获取当前所有监听这个事件的回调函数。
	   *
	   * @param event - 事件名称。
	   */

	  /** @en
	   * Gets all the listeners for a specified event.
	   *
	   * @param event The event name.
	   */


	  EventEmitter.prototype.getListeners = function (event) {
	    var _context;

	    return this._events[event] ? map$5(_context = this._events[event]).call(_context, function (e) {
	      return e.listener;
	    }) : [];
	  };
	  /**
	   * 监听一个指定的事件，当事件触发时会调用传入的回调函数。
	   *
	   * @param event - 指定事件的名称。
	   * @param listener - 传入的回调函数。
	   */

	  /** @en
	   * Listens for a specified event.
	   *
	   * When the specified event happens, the SDK triggers the callback that you pass.
	   * @param event The event name.
	   * @param listener The callback to trigger.
	   */


	  EventEmitter.prototype.on = function (event, listener) {
	    if (!this._events[event]) {
	      this._events[event] = [];
	    }

	    var listeners = this._events[event];

	    if (this._indexOfListener(listeners, listener) === -1) {
	      listeners.push({
	        listener: listener,
	        once: false
	      });
	    }
	  };
	  /**
	   * 监听一个指定的事件，当事件触发时会调用传入的回调函数。
	   *
	   * 当监听后事件第一次触发时，该监听和回调函数就会被立刻移除，也就是只监听一次指定事件。
	   *
	   * @param event - 指定事件的名称。
	   * @param listener - 传入的回调函数。
	   */

	  /** @en
	   * Listens for a specified event once.
	   *
	   * When the specified event happens, the SDK triggers the callback that you pass and then removes the listener.
	   * @param event The event name.
	   * @param listener The callback to trigger.
	   */


	  EventEmitter.prototype.once = function (event, listener) {
	    if (!this._events[event]) {
	      this._events[event] = [];
	    }

	    var listeners = this._events[event];

	    if (this._indexOfListener(listeners, listener) === -1) {
	      listeners.push({
	        listener: listener,
	        once: true
	      });
	    }
	  };
	  /**
	   * 取消一个指定事件的监听。
	   *
	   * @param event - 指定事件的名称。
	   * @param listener - 监听事件时传入的回调函数。
	   */

	  /** @en
	   * Removes the listener for a specified event.
	   *
	   * @param event The event name.
	   * @param listener The callback that corresponds to the event listener.
	   */


	  EventEmitter.prototype.off = function (event, listener) {
	    if (!this._events[event]) {
	      return;
	    }

	    var listeners = this._events[event];

	    var index = this._indexOfListener(listeners, listener);

	    if (index !== -1) {
	      splice$2(listeners).call(listeners, index, 1);
	    }

	    if (this._events[event].length === 0) {
	      delete this._events[event];
	    }
	  };
	  /**
	   * 指定一个事件，取消其所有的监听。
	   *
	   * @param event - 指定事件的名称，如果没有指定事件，则取消所有事件的所有监听。
	   */

	  /** @en
	   * Removes all listeners for a specified event.
	   *
	   * @param event The event name. If left empty, all listeners for all events are removed.
	   */


	  EventEmitter.prototype.removeAllListeners = function (event) {
	    if (!event) {
	      this._events = {};
	      return;
	    }

	    delete this._events[event];
	  };
	  /** @internal */


	  EventEmitter.prototype.emit = function (event) {
	    var _context2;

	    var args = [];

	    for (var _i = 1; _i < arguments.length; _i++) {
	      args[_i - 1] = arguments[_i];
	    }

	    if (!this._events[event]) {
	      this._events[event] = [];
	    }

	    var listeners = map$5(_context2 = this._events[event]).call(_context2, function (l) {
	      return l;
	    });

	    for (var i = 0; i < listeners.length; i += 1) {
	      var listener = listeners[i];

	      if (listener.once) {
	        this.off(event, listener.listener);
	      }

	      listener.listener.apply(this, args || []);
	    }
	  };

	  EventEmitter.prototype._indexOfListener = function (listeners, listener) {
	    var i = listeners.length;

	    while (i--) {
	      if (listeners[i].listener === listener) {
	        return i;
	      }
	    }

	    return -1;
	  };

	  return EventEmitter;
	}();

	var __extends = undefined && undefined.__extends || function () {
	  var extendStatics = function (d, b) {
	    extendStatics = setPrototypeOf$2 || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    };

	    return extendStatics(d, b);
	  };

	  return function (d, b) {
	    extendStatics(d, b);

	    function __() {
	      this.constructor = d;
	    }

	    d.prototype = b === null ? create$4(b) : (__.prototype = b.prototype, new __());
	  };
	}();

	var AgoraExceptionMonitor =
	/** @class */
	function (_super) {
	  __extends(AgoraExceptionMonitor, _super);

	  function AgoraExceptionMonitor() {
	    var _this = _super !== null && _super.apply(this, arguments) || this;

	    _this.resultStorage = new map$2();
	    return _this;
	  }

	  AgoraExceptionMonitor.prototype.setLocalAudioStats = function (uid, track, stats) {
	    this.record("AUDIO_INPUT_LEVEL_TOO_LOW", uid, this.checkAudioInputLevel(stats));
	    this.record("SEND_AUDIO_BITRATE_TOO_LOW", uid, this.checkSendAudioBitrate(stats));
	  };

	  AgoraExceptionMonitor.prototype.setLocalVideoStats = function (uid, track, stats) {
	    this.record("SEND_VIDEO_BITRATE_TOO_LOW", uid, this.checkSendVideoBitrate(stats));
	    this.record("FRAMERATE_INPUT_TOO_LOW", uid, this.checkFramerateInput(stats, track));
	    this.record("FRAMERATE_SENT_TOO_LOW", uid, this.checkFramerateSent(stats));
	  };

	  AgoraExceptionMonitor.prototype.setRemoteAudioStats = function (track, stats) {
	    var uid = track.getUserId();
	    this.record("AUDIO_OUTPUT_LEVEL_TOO_LOW", uid, this.checkAudioOutputLevel(stats));
	  };

	  AgoraExceptionMonitor.prototype.setRemoteVideoStats = function (track, stats) {
	    var uid = track.getUserId();
	    this.record("RECV_VIDEO_DECODE_FAILED", uid, this.checkVideoDecode(stats));
	  };

	  AgoraExceptionMonitor.prototype.record = function (code, uid, result) {
	    if (!this.resultStorage.has(code)) {
	      this.resultStorage.set(code, {
	        result: [],
	        isPrevNormal: true
	      });
	    }

	    var resultItem = this.resultStorage.get(code);
	    if (!resultItem) return;
	    resultItem.result.push(result);

	    if (resultItem.result.length >= 5) {
	      var _context;

	      var isCurNormal = includes$4(_context = resultItem.result).call(_context, true);

	      if (resultItem.isPrevNormal && !isCurNormal) {
	        this.emit("exception", RTCExceptionCodeMap[code], code, uid);
	      }

	      if (!resultItem.isPrevNormal && isCurNormal) {
	        this.emit("exception", RTCExceptionCodeMap[code] + 2000, code + "_RECOVER", uid);
	      }

	      resultItem.isPrevNormal = isCurNormal;
	      resultItem.result = [];
	    }
	  };

	  AgoraExceptionMonitor.prototype.checkAudioOutputLevel = function (stats) {
	    if (stats.receiveBitrate > 0 && stats.receiveLevel === 0) {
	      return false;
	    }

	    return true;
	  };

	  AgoraExceptionMonitor.prototype.checkAudioInputLevel = function (stats) {
	    return stats.sendVolumeLevel !== 0;
	  };

	  AgoraExceptionMonitor.prototype.checkFramerateInput = function (stats, track) {
	    var setFramerate = null;

	    if (track._encoderConfig && track._encoderConfig.frameRate) {
	      setFramerate = constrainLongToNumber(track._encoderConfig.frameRate);
	    }

	    var inputFramerate = stats.captureFrameRate;
	    if (!setFramerate || !inputFramerate) return true;

	    if (setFramerate > 10 && inputFramerate < 5 || setFramerate < 10 && setFramerate >= 5 && inputFramerate <= 1) {
	      return false;
	    }

	    return true;
	  };

	  AgoraExceptionMonitor.prototype.checkFramerateSent = function (stats) {
	    if (stats.captureFrameRate && stats.sendFrameRate && stats.captureFrameRate > 5 && stats.sendFrameRate <= 1) {
	      return false;
	    }

	    return true;
	  };

	  AgoraExceptionMonitor.prototype.checkSendVideoBitrate = function (stats) {
	    return stats.sendBitrate !== 0;
	  };

	  AgoraExceptionMonitor.prototype.checkSendAudioBitrate = function (stats) {
	    return stats.sendBitrate !== 0;
	  };

	  AgoraExceptionMonitor.prototype.checkVideoDecode = function (stats) {
	    if (stats.receiveBitrate !== 0 && stats.decodeFrameRate === 0) {
	      return false;
	    }

	    return true;
	  };

	  return AgoraExceptionMonitor;
	}(EventEmitter$1);
	var RTCExceptionCodeMap = {
	  FRAMERATE_INPUT_TOO_LOW: 1001,
	  FRAMERATE_SENT_TOO_LOW: 1002,
	  SEND_VIDEO_BITRATE_TOO_LOW: 1003,
	  RECV_VIDEO_DECODE_FAILED: 1005,
	  AUDIO_INPUT_LEVEL_TOO_LOW: 2001,
	  AUDIO_OUTPUT_LEVEL_TOO_LOW: 2002,
	  SEND_AUDIO_BITRATE_TOO_LOW: 2003
	};

	var __assign = undefined && undefined.__assign || function () {
	  __assign = assign$2 || function (t) {
	    for (var s, i = 1, n = arguments.length; i < n; i++) {
	      s = arguments[i];

	      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	    }

	    return t;
	  };

	  return __assign.apply(this, arguments);
	};

	var AgoraRTCStatsCollector =
	/** @class */
	function () {
	  function AgoraRTCStatsCollector(clientId) {
	    var _this = this;

	    this.localConnectionsMap = new map$2();
	    this.remoteConnectionsMap = new map$2();
	    this.trafficStatsPeerList = [];

	    this.updateStats = function () {
	      var _context, _context3;

	      forEach$3(_context = _this.remoteConnectionsMap).call(_context, function (res) {
	        var _context2;

	        var lastAudioStats = res.audioStats;
	        var lastVideoStats = res.videoStats;
	        var lastPcStats = res.pcStats;

	        var currentAudioStats = __assign({}, DEFAULT_REMOTE_AUDIO_TRACK_STATS);

	        var currentVideoStats = __assign({}, DEFAULT_REMOTE_VIDEO_TRACK_STATS);

	        var currentNetworkStats = __assign({}, DEFAULT_NETWORK_QUALITY_STATS);

	        var pcStats = res.connection.pc.getStats();
	        var audioPcStats = pcStats.audioRecv[0];
	        var videoPcStats = pcStats.videoRecv[0];
	        var lastVideoPcStats = lastPcStats ? lastPcStats.videoRecv[0] : undefined;

	        var trafficStats = _this.trafficStats && find$2(_context2 = _this.trafficStats.peer_delay).call(_context2, function (t) {
	          return t.peer_uid === res.connection.getUserId();
	        });

	        if (audioPcStats) {
	          if (audioPcStats.codec === "opus" || audioPcStats.codec === "aac") {
	            currentAudioStats.codecType = audioPcStats.codec;
	          }

	          if (audioPcStats.outputLevel) {
	            currentAudioStats.receiveLevel = Math.round(audioPcStats.outputLevel * 32767);
	          } else if (res.connection.user.audioTrack) {
	            currentAudioStats.receiveLevel = Math.round(res.connection.user.audioTrack.getVolumeLevel() * 32767);
	          }

	          currentAudioStats.receiveBytes = audioPcStats.bytes;
	          currentAudioStats.receivePackets = audioPcStats.packets;
	          currentAudioStats.receivePacketsLost = audioPcStats.packetsLost;
	          currentAudioStats.packetLossRate = currentAudioStats.receivePacketsLost / currentAudioStats.receivePackets;
	          currentAudioStats.receiveBitrate = lastAudioStats ? 8 * Math.max(0, currentAudioStats.receiveBytes - lastAudioStats.receiveBytes) : 0;
	          currentAudioStats.totalDuration = lastAudioStats ? lastAudioStats.totalDuration + 1 : 1;
	          currentAudioStats.totalFreezeTime = lastAudioStats ? lastAudioStats.totalFreezeTime : 0;
	          currentAudioStats.freezeRate = currentAudioStats.totalFreezeTime / currentAudioStats.totalDuration;
	          currentAudioStats.receiveDelay = audioPcStats.jitterBufferMs;
	          var audioTrack = res.connection.user.audioTrack;

	          if (currentAudioStats.totalDuration > 10 && AgoraRTCStatsCollector.isRemoteAudioFreeze(audioTrack)) {
	            currentAudioStats.totalFreezeTime += 1;
	          }
	        }

	        if (videoPcStats) {
	          if (videoPcStats.codec === "H264" || videoPcStats.codec === "VP8") {
	            currentVideoStats.codecType = videoPcStats.codec;
	          }

	          currentVideoStats.receiveBytes = videoPcStats.bytes;
	          currentVideoStats.receiveBitrate = lastVideoStats ? 8 * Math.max(0, currentVideoStats.receiveBytes - lastVideoStats.receiveBytes) : 0;
	          currentVideoStats.decodeFrameRate = videoPcStats.decodeFrameRate;
	          currentVideoStats.renderFrameRate = videoPcStats.decodeFrameRate;

	          if (videoPcStats.outputFrame) {
	            currentVideoStats.renderFrameRate = videoPcStats.outputFrame.frameRate;
	          }

	          if (videoPcStats.receivedFrame) {
	            currentVideoStats.receiveFrameRate = videoPcStats.receivedFrame.frameRate;
	            currentVideoStats.receiveResolutionHeight = videoPcStats.receivedFrame.height;
	            currentVideoStats.receiveResolutionWidth = videoPcStats.receivedFrame.width;
	          } else if (res.connection.user.videoTrack) {
	            currentVideoStats.receiveResolutionHeight = res.connection.user.videoTrack._videoHeight || 0;
	            currentVideoStats.receiveResolutionHeight = res.connection.user.videoTrack._videoWidth || 0;
	          }

	          if (videoPcStats.framesRateFirefox !== undefined) {
	            currentVideoStats.receiveFrameRate = Math.round(videoPcStats.framesRateFirefox);
	          }

	          currentVideoStats.receivePackets = videoPcStats.packets;
	          currentVideoStats.receivePacketsLost = videoPcStats.packetsLost;
	          currentVideoStats.packetLossRate = currentVideoStats.receivePacketsLost / currentVideoStats.receivePackets;
	          currentVideoStats.totalDuration = lastVideoStats ? lastVideoStats.totalDuration + 1 : 1;
	          currentVideoStats.totalFreezeTime = lastVideoStats ? lastVideoStats.totalFreezeTime : 0;
	          currentVideoStats.receiveDelay = videoPcStats.jitterBufferMs || 0;
	          var videoTrack = res.connection.user.videoTrack;

	          if (AgoraRTCStatsCollector.isRemoteVideoFreeze(videoTrack, videoPcStats, lastVideoPcStats)) {
	            currentVideoStats.totalFreezeTime += 1;
	          }

	          currentVideoStats.freezeRate = currentVideoStats.totalFreezeTime / currentVideoStats.totalDuration;
	        }

	        if (trafficStats) {
	          currentAudioStats.end2EndDelay = trafficStats.B_ad;
	          currentVideoStats.end2EndDelay = trafficStats.B_vd;
	          currentAudioStats.transportDelay = trafficStats.B_ed;
	          currentVideoStats.transportDelay = trafficStats.B_ed;
	          currentNetworkStats.uplinkNetworkQuality = trafficStats.B_punq ? trafficStats.B_punq : 0;
	          currentNetworkStats.downlinkNetworkQuality = trafficStats.B_pdnq ? trafficStats.B_punq : 0;
	        }

	        res.audioStats = currentAudioStats;
	        res.videoStats = currentVideoStats;
	        res.pcStats = pcStats;
	        res.networkStats = currentNetworkStats;

	        if (res.connection.user.audioTrack) {
	          _this.exceptionMonitor.setRemoteAudioStats(res.connection.user.audioTrack, currentAudioStats);
	        }

	        if (res.connection.user.videoTrack) {
	          _this.exceptionMonitor.setRemoteVideoStats(res.connection.user.videoTrack, currentVideoStats);
	        }
	      });

	      forEach$3(_context3 = _this.localConnectionsMap).call(_context3, function (res) {
	        var lastAudioStats = res.audioStats;
	        var lastVideoStats = res.videoStats;

	        var currentAudioStats = __assign({}, DEFAULT_LOCAL_AUDIO_TRACK_STATS);

	        var currentVideoStats = __assign({}, DEFAULT_LOCAL_VIDEO_TRACK_STATS);

	        var pcStats = res.connection.pc.getStats();
	        var audioPcStats = pcStats.audioSend[0];
	        var videoPcStats = pcStats.videoSend[0];
	        var uid = res.connection.getUserId();

	        if (audioPcStats) {
	          if (audioPcStats.codec === "opus" || audioPcStats.codec === "aac") {
	            currentAudioStats.codecType = audioPcStats.codec;
	          }

	          if (audioPcStats.inputLevel) {
	            currentAudioStats.sendVolumeLevel = Math.round(audioPcStats.inputLevel * 32767);
	          } else if (res.connection.audioTrack) {
	            currentAudioStats.sendVolumeLevel = Math.round(res.connection.audioTrack.getVolumeLevel() * 32767);
	          }

	          currentAudioStats.sendBytes = audioPcStats.bytes;
	          currentAudioStats.sendPackets = audioPcStats.packets;
	          currentAudioStats.sendPacketsLost = audioPcStats.packetsLost;
	          currentAudioStats.sendBitrate = lastAudioStats ? 8 * Math.max(0, currentAudioStats.sendBytes - lastAudioStats.sendBytes) : 0;
	        }

	        if (videoPcStats) {
	          if (videoPcStats.codec === "H264" || videoPcStats.codec === "VP8") {
	            currentVideoStats.codecType = videoPcStats.codec;
	          }

	          currentVideoStats.sendBytes = videoPcStats.bytes;
	          currentVideoStats.sendBitrate = lastVideoStats ? 8 * Math.max(0, currentVideoStats.sendBytes - lastVideoStats.sendBytes) : 0;

	          if (videoPcStats.inputFrame) {
	            currentVideoStats.captureFrameRate = videoPcStats.inputFrame.frameRate;
	            currentVideoStats.captureResolutionHeight = videoPcStats.inputFrame.height;
	            currentVideoStats.captureResolutionWidth = videoPcStats.inputFrame.width;
	          } else if (res.connection.videoTrack) {
	            currentVideoStats.captureResolutionWidth = res.connection.videoTrack._videoWidth || 0;
	            currentVideoStats.captureResolutionHeight = res.connection.videoTrack._videoHeight || 0;
	          }

	          if (videoPcStats.sentFrame) {
	            currentVideoStats.sendFrameRate = videoPcStats.sentFrame.frameRate;
	            currentVideoStats.sendResolutionHeight = videoPcStats.sentFrame.height;
	            currentVideoStats.sendResolutionWidth = videoPcStats.sentFrame.width;
	          } else if (res.connection.videoTrack) {
	            currentVideoStats.sendResolutionWidth = res.connection.videoTrack._videoWidth || 0;
	            currentVideoStats.sendResolutionHeight = res.connection.videoTrack._videoHeight || 0;
	          }

	          if (videoPcStats.avgEncodeMs) {
	            currentVideoStats.encodeDelay = videoPcStats.avgEncodeMs;
	          }

	          if (res.connection.videoTrack && res.connection.videoTrack._encoderConfig && res.connection.videoTrack._encoderConfig.bitrateMax) {
	            currentVideoStats.targetSendBitrate = res.connection.videoTrack._encoderConfig.bitrateMax * 1000;
	          }

	          currentVideoStats.sendPackets = videoPcStats.packets;
	          currentVideoStats.sendPacketsLost = videoPcStats.packetsLost;
	          currentVideoStats.totalDuration = lastVideoStats ? lastVideoStats.totalDuration + 1 : 1;
	          currentVideoStats.totalFreezeTime = lastVideoStats ? lastVideoStats.totalFreezeTime : 0;

	          if (_this.isLocalVideoFreeze(videoPcStats)) {
	            currentVideoStats.totalFreezeTime += 1;
	          }
	        }

	        res.audioStats = currentAudioStats;
	        res.videoStats = currentVideoStats;

	        if (res.audioStats && res.connection.audioTrack) {
	          _this.exceptionMonitor.setLocalAudioStats(uid, res.connection.audioTrack, res.audioStats);
	        }

	        if (res.videoStats && res.connection.videoTrack) {
	          _this.exceptionMonitor.setLocalVideoStats(uid, res.connection.videoTrack, res.videoStats);
	        }
	      });
	    };

	    this.clientId = clientId;
	    this.updateStatsInterval = window.setInterval(this.updateStats, 1000);
	    this.exceptionMonitor = new AgoraExceptionMonitor();
	    this.exceptionMonitor.on("exception", function (code, message, uid) {
	      _this.onStatsException && _this.onStatsException(code, message, uid);
	    });
	  }

	  AgoraRTCStatsCollector.prototype.reset = function () {
	    this.localConnectionsMap = new map$2();
	    this.remoteConnectionsMap = new map$2();
	    this.trafficStats = undefined;
	    this.trafficStatsPeerList = [];
	    this.uplinkStats = undefined;
	  };

	  AgoraRTCStatsCollector.prototype.getLocalAudioTrackStats = function (connectionId) {
	    var target = this.localConnectionsMap.get(connectionId);
	    if (target && target.audioStats) return target.audioStats;
	    return __assign({}, DEFAULT_LOCAL_AUDIO_TRACK_STATS);
	  };

	  AgoraRTCStatsCollector.prototype.getLocalVideoTrackStats = function (connectionId) {
	    var target = this.localConnectionsMap.get(connectionId);
	    if (target && target.videoStats) return target.videoStats;
	    return __assign({}, DEFAULT_LOCAL_VIDEO_TRACK_STATS);
	  };

	  AgoraRTCStatsCollector.prototype.getRemoteAudioTrackStats = function (connectionId) {
	    var _context4;

	    var target = this.remoteConnectionsMap.get(connectionId);

	    if (!target || !target.audioStats) {
	      return __assign({}, DEFAULT_REMOTE_AUDIO_TRACK_STATS);
	    }

	    if (!this.trafficStats) return target.audioStats;

	    var trafficPeer = find$2(_context4 = this.trafficStats.peer_delay).call(_context4, function (peer) {
	      return peer.peer_uid === target.connection.user.uid;
	    });

	    if (trafficPeer) {
	      target.audioStats.publishDuration = trafficPeer.B_ppad + (now$2() - this.trafficStats.timestamp);
	    }

	    return target.audioStats;
	  };

	  AgoraRTCStatsCollector.prototype.getRemoteNetworkQualityStats = function (connectionId) {
	    var target = this.remoteConnectionsMap.get(connectionId);

	    if (!target || !target.networkStats) {
	      return __assign({}, DEFAULT_NETWORK_QUALITY_STATS);
	    }

	    return target.networkStats;
	  };

	  AgoraRTCStatsCollector.prototype.getRemoteVideoTrackStats = function (connectionId) {
	    var _context5;

	    var target = this.remoteConnectionsMap.get(connectionId);

	    if (!target || !target.videoStats) {
	      return __assign({}, DEFAULT_REMOTE_VIDEO_TRACK_STATS);
	    }

	    if (!this.trafficStats) return target.videoStats;

	    var trafficPeer = find$2(_context5 = this.trafficStats.peer_delay).call(_context5, function (peer) {
	      return peer.peer_uid === target.connection.user.uid;
	    });

	    if (trafficPeer) {
	      target.videoStats.publishDuration = trafficPeer.B_ppvd + (now$2() - this.trafficStats.timestamp);
	    }

	    return target.videoStats;
	  };
	  /**
	   * 返回的状态中 `Duration` 默认为 0.
	   * 需要外层手动调用 `gateway` 的方法获取准确的时长
	   */


	  AgoraRTCStatsCollector.prototype.getRTCStats = function () {
	    var _context6, _context7;

	    var sendBytes = 0;
	    var sendBitrate = 0;
	    var recvBytes = 0;
	    var recvBitrate = 0;

	    forEach$3(_context6 = this.localConnectionsMap).call(_context6, function (item) {
	      if (item.audioStats) {
	        sendBytes += item.audioStats.sendBytes;
	        sendBitrate += item.audioStats.sendBitrate;
	      }

	      if (item.videoStats) {
	        sendBytes += item.videoStats.sendBytes;
	        sendBitrate += item.videoStats.sendBitrate;
	      }
	    });

	    forEach$3(_context7 = this.remoteConnectionsMap).call(_context7, function (item) {
	      if (item.audioStats) {
	        recvBytes += item.audioStats.receiveBytes;
	        recvBitrate += item.audioStats.receiveBitrate;
	      }

	      if (item.videoStats) {
	        recvBytes += item.videoStats.receiveBytes;
	        recvBitrate += item.videoStats.receiveBitrate;
	      }
	    });

	    var userCount = 1;

	    if (this.trafficStats) {
	      userCount += this.trafficStats.peer_delay.length;
	    }

	    return {
	      Duration: 0,
	      UserCount: userCount,
	      SendBitrate: sendBitrate,
	      SendBytes: sendBytes,
	      RecvBytes: recvBytes,
	      RecvBitrate: recvBitrate,
	      OutgoingAvailableBandwidth: this.uplinkStats ? this.uplinkStats.B_uab / 1000 : 0,
	      RTT: this.trafficStats ? this.trafficStats.B_acd * 2 : 0
	    };
	  };

	  AgoraRTCStatsCollector.prototype.removeConnection = function (connectionId) {
	    this.localConnectionsMap.delete(connectionId);
	    this.remoteConnectionsMap.delete(connectionId);
	  };

	  AgoraRTCStatsCollector.prototype.addLocalConnection = function (connection) {
	    var connectionId = connection.connectionId;
	    if (this.localConnectionsMap.has(connectionId)) return;
	    this.localConnectionsMap.set(connectionId, {
	      connection: connection
	    });
	  };

	  AgoraRTCStatsCollector.prototype.addRemoteConnection = function (connection) {
	    var connectionId = connection.connectionId;
	    if (this.remoteConnectionsMap.has(connectionId)) return;
	    this.remoteConnectionsMap.set(connectionId, {
	      connection: connection
	    });
	  };

	  AgoraRTCStatsCollector.prototype.updateTrafficStats = function (stats) {
	    var _context8;

	    var _this = this;

	    var newPeerList = filter$2(_context8 = stats.peer_delay).call(_context8, function (peer) {
	      var _context9;

	      return indexOf$3(_context9 = _this.trafficStatsPeerList).call(_context9, peer.peer_uid) === -1;
	    }); // 一旦出现了新的 peer，上报 publish duration


	    forEach$3(newPeerList).call(newPeerList, function (peer) {
	      var _context10, _context11;

	      var connection = find$2(_context10 = from_1$2(values$2(_context11 = _this.remoteConnectionsMap).call(_context11))).call(_context10, function (c) {
	        return c.connection._userId === peer.peer_uid;
	      });

	      if (peer.B_ppad === undefined || peer.B_ppvd === undefined) {
	        return;
	      }

	      _this.onUploadPublishDuration && _this.onUploadPublishDuration(peer.peer_uid, peer.B_ppad, peer.B_ppvd, connection ? now$2() - connection.connection.startTime : 0);

	      _this.trafficStatsPeerList.push(peer.peer_uid);
	    });

	    this.trafficStats = stats;
	  };

	  AgoraRTCStatsCollector.prototype.updateUplinkStats = function (stats) {
	    if (this.uplinkStats && this.uplinkStats.B_fir !== stats.B_fir) {
	      logger.debug("[" + this.clientId + "]: Period fir changes to " + stats.B_fir);
	    }

	    this.uplinkStats = stats;
	  };
	  /** 如果没有订阅视频，不需要统计视频卡顿，但是因为网关的设计，视频没有订阅时 PC 依然有其状态 */


	  AgoraRTCStatsCollector.isRemoteVideoFreeze = function (track, stats, lastStats) {
	    if (!track) return false;
	    var isFreezeTimeUpdate = !!lastStats && stats.framesDecodeFreezeTime > lastStats.framesDecodeFreezeTime;
	    var isDecodeCountUpdate = lastStats ? stats.framesDecodeCount > lastStats.framesDecodeCount : true;
	    /**
	     * 当卡顿时间更新或者没有新的帧解码时认为这一秒内发生了卡顿
	     */

	    return isFreezeTimeUpdate || !isDecodeCountUpdate;
	  };

	  AgoraRTCStatsCollector.isRemoteAudioFreeze = function (track) {
	    if (!track) return false;
	    return track._isFreeze();
	  };

	  AgoraRTCStatsCollector.prototype.isLocalVideoFreeze = function (stats) {
	    if (!stats.inputFrame || !stats.sentFrame) return false;
	    if (stats.inputFrame.frameRate > 5 && stats.sentFrame.frameRate < 3) return true;
	    return false;
	  };

	  return AgoraRTCStatsCollector;
	}();

	function proxyServerInfoToProxyServerAddress(info) {
	  if (!info.address || !info.tcp) {
	    throw new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_RESPONSE, "Invalid address format " + info);
	  }

	  if (info.address.match(/^[\.\:\d]+$/)) {
	    return info.address.replace(/[^\d]/g, "-") + ".edge.agora.io";
	  } else {
	    logger.info("Cannot recognized as IP address " + info.address + ". Used As Host instead");
	    return info.address + ":" + info.tcp;
	  }
	}
	/**
	 * 将 ChooseServer 服务的返回转成 gateway 地址
	 * gateway 有 2 种域名 `.agora.io` 和 `.agoraio.cn`，逻辑上是优先请求的哪个域名，然后逐一分配
	 */

	function chooseServerResponseToGatewayInfo(res, requestURL) {
	  var _context2;

	  var domains = IS_GLOBAL_VERSION ? [".agora.io", ".agoraio.cn"] : [".agora.io"];
	  var domainIndex = domains[1] && indexOf$3(requestURL).call(requestURL, domains[1]) !== -1 ? 1 : 0;
	  res.addresses = res.addresses || [];

	  var gatewayAddrs = map$5(_context2 = res.addresses).call(_context2, function (address) {
	    if (address.ip.match(/^[\.\:\d]+$/)) {
	      return address.ip.replace(/[^\d]/g, "-") + ".edge" + domains[domainIndex++ % domains.length] + ":" + address.port;
	    } else {
	      logger.info("Cannot recognized as IP address " + address.ip + ". Used As Host instead");
	      return address.ip + ":" + address.port;
	    }
	  });

	  return {
	    gatewayAddrs: gatewayAddrs,
	    uid: res.uid,
	    cid: res.cid,
	    vid: res.detail && res.detail[8],
	    uni_lbs_ip: res.detail && res.detail[1],
	    res: res
	  };
	}
	/**
	 * 通过读取带有 wss 的网关地址，自动生成一个 turn server config
	 * **Note:** 通过websocket端口+30找到TCP/UDP TURN的设置
	 */

	function gatewayURLToTurnConfig(url) {
	  var match = url.match(/wss\:\/\/([^:]+):(\d+)/);
	  if (!match) return null;
	  return {
	    username: DEFAULT_TURN_CONFIG.username,
	    password: DEFAULT_TURN_CONFIG.password,
	    turnServerURL: match[1],
	    tcpport: _parseInt$3(match[2]) + 30,
	    udpport: _parseInt$3(match[2]) + 30,
	    forceturn: false
	  };
	}
	function liveStreamingServerResponseToResult(res, mode) {
	  var _context3;

	  var addressList = map$5(_context3 = res.servers).call(_context3, function (server, serverId) {
	    return IS_GLOBAL_VERSION ? "wss://" + server.address.replace(/\./g, "-") + ".edge." + (serverId % 2 === 0 ? "agora.io" : "agoraio.cn") + ":" + server.wss + "?serviceName=" + encodeURIComponent(mode) : "wss://" + server.address.replace(/\./g, "-") + ".edge.agora.io:" + server.wss + "?serviceName=" + encodeURIComponent(mode);
	  });

	  return {
	    addressList: addressList,
	    workerToken: res.workerToken,
	    vid: res.vid
	  };
	}
	function constrainLongToNumber(value) {
	  if (typeof value === "number") return value;
	  return value.exact || value.ideal || value.max || value.min || 0;
	}
	function getStreamPublishAttributes(track) {
	  var encoderConfig = track._encoderConfig;
	  if (!encoderConfig) return {};
	  var attr = {
	    resolution: encoderConfig.width && encoderConfig.height ? constrainLongToNumber(encoderConfig.width) + "x" + constrainLongToNumber(encoderConfig.height) : undefined,
	    maxVideoBW: encoderConfig.bitrateMax,
	    minVideoBW: encoderConfig.bitrateMin
	  };

	  if (typeof encoderConfig.frameRate === "number") {
	    attr.maxFrameRate = encoderConfig.frameRate;
	    attr.minFrameRate = encoderConfig.frameRate;
	  } else if (encoderConfig.frameRate) {
	    attr.maxFrameRate = encoderConfig.frameRate.max || encoderConfig.frameRate.ideal || encoderConfig.frameRate.exact || encoderConfig.frameRate.min;
	    attr.minFrameRate = encoderConfig.frameRate.min || encoderConfig.frameRate.ideal || encoderConfig.frameRate.exact || encoderConfig.frameRate.max;
	  }

	  return attr;
	}
	function getDefaultLowStreamParameter() {
	  var parameter = {
	    width: 160,
	    height: 120,
	    framerate: 15,
	    bitrate: 50
	  };
	  return parameter;
	}
	function getPublishBandwidthUploadStats(stats) {
	  var uploadStats = {
	    id: "bweforvideo",
	    timestamp: new Date(stats.timestamp).toISOString(),
	    type: "VideoBwe"
	  };

	  if (stats.bitrate.retransmit) {
	    uploadStats.A_rb = stats.bitrate.retransmit.toString();
	  }

	  if (stats.bitrate.targetEncoded) {
	    uploadStats.A_teb = stats.bitrate.targetEncoded.toString();
	  }

	  uploadStats.A_aeb = stats.bitrate.actualEncoded.toString();
	  uploadStats.A_tb = stats.bitrate.transmit.toString();

	  if (stats.sendBandwidth !== undefined) {
	    uploadStats.A_asb = stats.sendBandwidth.toString();
	  }

	  return uploadStats;
	}
	function getPublishVideoInputStats(stats, lastStats) {
	  var videoStats = stats.videoSend[0];
	  if (!videoStats) return null;
	  var lastVideoFrame = lastStats && lastStats.videoSend[0] ? lastStats.videoSend[0].inputFrame : undefined;
	  var uploadStats = {
	    id: getRandomString(10, ""),
	    timestamp: new Date(stats.timestamp).toISOString(),
	    mediaType: "video",
	    type: "ssrc",
	    ssrc: videoStats.ssrc.toString()
	  };

	  if (videoStats.inputFrame) {
	    if (!lastVideoFrame || videoStats.inputFrame.height !== lastVideoFrame.height) {
	      uploadStats.A_fhi = videoStats.inputFrame.height ? videoStats.inputFrame.height.toString() : "0";
	    }

	    if (!lastVideoFrame || videoStats.inputFrame.width !== lastVideoFrame.width) {
	      uploadStats.A_fwi = videoStats.inputFrame.width ? videoStats.inputFrame.width.toString() : "0";
	    }

	    if (!lastVideoFrame || videoStats.inputFrame.frameRate !== lastVideoFrame.frameRate) {
	      uploadStats.A_fri = videoStats.inputFrame.frameRate ? videoStats.inputFrame.frameRate.toString() : "0";
	    }
	  }

	  return uploadStats;
	}
	function getPublishVideoUploadStats(stats, videoTrack) {
	  var videoStats = stats.videoSend[0];
	  if (!videoStats) return null;
	  var uploadStats = {
	    id: getRandomString(10, ""),
	    timestamp: new Date(stats.timestamp).toISOString(),
	    mediaType: "video",
	    type: "ssrc",
	    ssrc: videoStats.ssrc.toString()
	  };
	  uploadStats.A_vstd = !videoTrack._originMediaStreamTrack.enabled || !videoTrack._mediaStreamTrack.enabled ? "1" : "0";

	  if (videoStats.sentFrame) {
	    uploadStats.A_fhs = videoStats.sentFrame.height.toString();
	    uploadStats.A_frs = videoStats.sentFrame.frameRate.toString();
	    uploadStats.A_fws = videoStats.sentFrame.width.toString();
	  }

	  switch (videoStats.adaptionChangeReason) {
	    case "none":
	      {
	        uploadStats.A_ac = "0";
	        break;
	      }

	    case "cpu":
	      {
	        uploadStats.A_ac = "1";
	        break;
	      }

	    case "bandwidth":
	      {
	        uploadStats.A_ac = "2";
	        break;
	      }

	    case "other":
	      {
	        uploadStats.A_ac = "3";
	        break;
	      }
	  }

	  uploadStats.A_nr = videoStats.nacksCount.toString();

	  if (videoStats.avgEncodeMs) {
	    uploadStats.A_aem = videoStats.avgEncodeMs.toFixed(0).toString();
	  }

	  return uploadStats;
	}
	function getPublishAudioUploadStats(stats, audioTrack) {
	  var audioStats = stats.audioSend[0];
	  if (!audioStats) return null;
	  var uploadStats = {
	    id: getRandomString(10, ""),
	    timestamp: new Date(stats.timestamp).toISOString(),
	    mediaType: "audio",
	    type: "ssrc",
	    ssrc: audioStats.ssrc.toString()
	  };
	  uploadStats.A_astd = !audioTrack._originMediaStreamTrack.enabled || !audioTrack._mediaStreamTrack.enabled ? "1" : "0";

	  if (audioStats.inputLevel) {
	    uploadStats.A_ail = Math.round(100 * audioStats.inputLevel).toString();
	  } else {
	    // 不支持获取 inputLevel 使用 PCM 计算的
	    uploadStats.A_ail = Math.round(audioTrack._source.getAudioAvgLevel() * 100).toString();
	  }

	  uploadStats.A_apil = Math.round(audioTrack._source.getAudioAvgLevel() * 100).toString();
	  return uploadStats;
	}
	function getSubscribeVideoUploadStats(stats, videoTrack) {
	  var videoStats = stats.videoRecv[0];
	  if (!videoStats) return null;
	  var uploadStats = {
	    id: getRandomString(10, ""),
	    timestamp: new Date(stats.timestamp).toISOString(),
	    mediaType: "video",
	    type: "ssrc",
	    ssrc: videoStats.ssrc.toString()
	  };
	  uploadStats.bytesReceived = videoStats.bytes.toString();
	  uploadStats.packetsLost = videoStats.packetsLost.toString();
	  uploadStats.packetsReceived = videoStats.packets.toString();

	  if (videoStats.framesRateFirefox) {
	    uploadStats.A_frr = videoStats.framesRateFirefox.toString();
	  }

	  if (videoStats.receivedFrame) {
	    uploadStats.A_frr = videoStats.receivedFrame.frameRate.toString();
	  }

	  uploadStats.A_frd = videoStats.decodeFrameRate.toString();

	  if (videoStats.outputFrame) {
	    uploadStats.A_fro = videoStats.outputFrame.frameRate.toString();
	  }

	  if (videoStats.jitterBufferMs !== undefined) {
	    uploadStats.A_jbm = videoStats.jitterBufferMs.toString();
	  }

	  if (videoStats.currentDelayMs !== undefined) {
	    uploadStats.A_cdm = videoStats.currentDelayMs.toString();
	  }

	  uploadStats.A_fs = videoStats.firsCount.toString();
	  uploadStats.A_ns = videoStats.nacksCount.toString();
	  uploadStats.A_ps = videoStats.plisCount.toString();

	  if (videoTrack) {
	    uploadStats.A_vrtd = !videoTrack._originMediaStreamTrack.enabled || !videoTrack._mediaStreamTrack.enabled ? "1" : "0";
	  }

	  if (videoTrack._player && videoTrack._player.freezeTimeCounterList.length > 0) {
	    var _context4;

	    uploadStats.A_vrft = splice$2(_context4 = videoTrack._player.freezeTimeCounterList).call(_context4, 0, 1)[0].toString();
	  }

	  return uploadStats;
	}
	function getSubscribeAudioUploadStats(stats, audioTrack) {
	  var audioStats = stats.audioRecv[0];
	  if (!audioStats) return null;
	  var uploadStats = {
	    id: getRandomString(10, ""),
	    timestamp: new Date(stats.timestamp).toISOString(),
	    mediaType: "audio",
	    type: "ssrc",
	    ssrc: audioStats.ssrc.toString()
	  };
	  uploadStats.bytesReceived = audioStats.bytes.toString();
	  uploadStats.packetsLost = audioStats.packetsLost.toString();
	  uploadStats.packetsReceived = audioStats.packets.toString();

	  if (audioStats.outputLevel) {
	    uploadStats.A_aol = Math.round(audioStats.outputLevel * 100).toString();
	  } else {
	    // 如果浏览器无法输出 outputLevel
	    uploadStats.A_aol = Math.round(audioTrack._source.getAudioAvgLevel() * 100).toString();
	  } // 如果浏览器无法输出 outputLevel


	  uploadStats.A_apol = Math.round(audioTrack._source.getAudioAvgLevel() * 100).toString();

	  if (audioTrack) {
	    uploadStats.A_artd = !audioTrack._originMediaStreamTrack.enabled || !audioTrack._mediaStreamTrack.enabled ? "1" : "0";
	  }

	  uploadStats.A_jr = audioStats.jitterMs.toString();
	  uploadStats.A_jbm = audioStats.jitterBufferMs.toString();
	  uploadStats.A_cdm = audioStats.jitterBufferMs.toString();
	  return uploadStats;
	}
	function getPublishVideoRelatedUploadStats(stats) {
	  var videoStats = stats.videoSend[0];
	  if (!videoStats) return null;
	  return {
	    mediaType: "video",
	    isVideoMute: false,
	    frameRateInput: videoStats.inputFrame && videoStats.inputFrame.frameRate.toString(),
	    frameRateSent: videoStats.sentFrame && videoStats.sentFrame.frameRate.toString(),
	    googRtt: videoStats.rttMs.toString()
	  };
	}
	function getSubscribeVideoRelatedUploadStats(stats, uid, lastStats, track) {
	  var videoStats = stats.videoRecv[0];
	  var lastVideoStats = lastStats ? lastStats.videoRecv[0] : undefined;
	  if (!videoStats) return null;
	  var isFreeze = AgoraRTCStatsCollector.isRemoteVideoFreeze(track, videoStats, lastVideoStats);
	  var relatedStats = {
	    mediaType: "video",
	    isVideoMute: false,
	    peerId: uid,
	    frameRateReceived: videoStats.receivedFrame && videoStats.receivedFrame.frameRate.toString(),
	    frameRateDecoded: videoStats.decodedFrame && videoStats.decodedFrame.frameRate.toString(),
	    isFreeze: isFreeze,
	    bytesReceived: videoStats.bytes.toString(),
	    packetsReceived: videoStats.packets.toString(),
	    packetsLost: videoStats.packetsLost.toString()
	  };

	  if (videoStats.framesRateFirefox) {
	    relatedStats.frameRateDecoded = videoStats.framesRateFirefox.toString();
	    relatedStats.frameRateReceived = videoStats.framesRateFirefox.toString();
	  }

	  return relatedStats;
	}
	function getSubscribeAudioRelatedUploadStats(stats, uid, track) {
	  var audioStats = stats.audioRecv[0];
	  if (!audioStats) return null;
	  var isFreeze = AgoraRTCStatsCollector.isRemoteAudioFreeze(track);
	  var relatedStats = {
	    mediaType: "audio",
	    isAudioMute: false,
	    peerId: uid,
	    googJitterReceived: audioStats.jitterBufferMs.toString(),
	    isFreeze: isFreeze,
	    bytesReceived: audioStats.bytes.toString(),
	    packetsReceived: audioStats.packets.toString(),
	    packetsLost: audioStats.packetsLost.toString(),
	    frameReceived: audioStats.receivedFrames.toString(),
	    frameDropped: audioStats.droppedFrames.toString()
	  };
	  return relatedStats;
	}
	function getNetworkQuality(quality) {
	  if (quality >= 0 && quality < 0.17) {
	    return 1;
	  } else if (quality >= 0.17 && quality < 0.36) {
	    return 2;
	  } else if (quality >= 0.36 && quality < 0.59) {
	    return 3;
	  } else if (quality >= 0.59 && quality <= 1) {
	    return 4;
	  } else if (quality > 1) {
	    return 5;
	  }

	  return 0;
	}

	var _context2;

	var __assign$1 = undefined && undefined.__assign || function () {
	  __assign$1 = assign$2 || function (t) {
	    for (var s, i = 1, n = arguments.length; i < n; i++) {
	      s = arguments[i];

	      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	    }

	    return t;
	  };

	  return __assign$1.apply(this, arguments);
	};

	var __spreadArrays = undefined && undefined.__spreadArrays || function () {
	  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

	  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

	  return r;
	};
	function getUTF8StringByteLength(str) {
	  return window.TextEncoder ? new TextEncoder().encode(str).length : str.length;
	}
	function dividePackage(source, key, mtu) {
	  var _a, _b;

	  var payload = source[key];

	  if (!payload || !(typeof payload === "string")) {
	    return [source];
	  }

	  source[key] = "";
	  var baseSize = getUTF8StringByteLength(stringify$2(source));
	  var headIndex = 0;
	  var payloadArr = [];
	  var currentSize = 0;

	  for (var i = 0; i < payload.length; i++) {
	    /** ASCII 字符占1个字节，其他字符占3个字节 */
	    currentSize += payload.charCodeAt(i) <= 127 ? 1 : 3;
	    if (currentSize <= mtu - baseSize) continue;
	    payloadArr[payloadArr.length] = __assign$1(__assign$1({}, source), (_a = {}, _a[key] = payload.substring(headIndex, i), _a));
	    headIndex = i;
	    currentSize = payload.charCodeAt(i) <= 127 ? 1 : 3;
	  }

	  if (headIndex !== payload.length - 1) payloadArr[payloadArr.length] = __assign$1(__assign$1({}, source), (_b = {}, _b[key] = payload.substring(headIndex), _b));
	  return payloadArr;
	}
	function domLoadedPromise() {
	  return new promise$3(function (resolve) {
	    if (document.body) {
	      resolve();
	    } else {
	      window.addEventListener("load", function () {
	        return resolve();
	      });
	    }
	  });
	}
	/**
	 * 将在 timeout 时间后 resolve
	 */

	function wait(timeout) {
	  return new promise$3(function (resolve) {
	    window.setTimeout(resolve, timeout);
	  });
	}
	/**
	 * 将在 timeout 时间后 reject 一个 TIMEOUT 错误
	 */

	function timeout(timeout) {
	  var err = new AgoraRTCError(AgoraRTCErrorCode.TIMEOUT, "timeout");
	  return new promise$3(function (_, reject) {
	    window.setTimeout(function () {
	      return reject(err);
	    }, timeout);
	  });
	}
	/**
	 * 如果一个 Promise 没有在 timeout 时间内 reject/resolve，就 reject 一个 TIMEOUT
	 */

	function withTimeout(promise, time) {
	  if (time === Infinity) return promise;
	  return promise$3.race([promise, timeout(time)]);
	}
	function getRandomString(length, prefix) {
	  if (length === void 0) {
	    length = 7;
	  }

	  var str = Math.random().toString(16).substr(2, length).toLowerCase();
	  if (str.length === length) return "" + prefix + str;
	  return "" + prefix + str + getRandomString(length - str.length, "");
	}
	function generateProcessID() {
	  return "process-" + getRandomString(8, "") + "-" + getRandomString(4, "") + "-" + getRandomString(4, "") + "-" + getRandomString(4, "") + "-" + getRandomString(12, "");
	}
	function generateSessionID() {
	  return getRandomString(32, "").toUpperCase();
	}
	var noop$1 = function () {};
	function checkMediaStreamTrackResolution(track) {
	  return new promise$3(function (resolve, reject) {
	    var video = document.createElement("video");
	    video.setAttribute("autoplay", "");
	    video.setAttribute("muted", ""); // in Firefox, attr "muted" will not take effect immediately. So setting `muted` attr is needed

	    video.muted = true;
	    video.autoplay = true; // in iOS, not this attribute will not trigger 'playing' event

	    video.setAttribute("playsinline", "");
	    video.setAttribute("style", "position: absolute; top: 0; left: 0; width: 1px; height: 1px");
	    document.body.appendChild(video);
	    video.addEventListener("playing", function () {
	      // Firefox will triger this event twice
	      if (video.videoWidth || !isFirefox()) {
	        resolve([video.videoWidth, video.videoHeight]);
	        document.body.removeChild(video);
	      }
	    });
	    video.srcObject = new MediaStream([track]);
	  });
	}
	/**
	 * 当第一个 Promise resolve 时 resolve
	 * 当所有 Promise reject 时 reject
	 * https://github.com/tc39/proposal-promise-any/issues/6
	 */

	function PromiseAny(promises) {
	  return promise$3.all(map$5(promises).call(promises, function (promise) {
	    return promise.then(function (val) {
	      throw val;
	    }, function (reason) {
	      return reason;
	    });
	  })).then(function (reasons) {
	    throw reasons;
	  }, function (firstResolved) {
	    return firstResolved;
	  });
	}
	/**
	 * emit 一个事件，并假定 handler 会异步地处理事件，将 handler 的返回作为这个函数的 Promise 的返回，将 handler 的异常作为 Promise 的异常
	 * 如果检测到没有 handler 会抛出 UNEXPECTED_ERROR
	 */

	function emitAsPromise(emitter, event) {
	  var args = [];

	  for (var _i = 2; _i < arguments.length; _i++) {
	    args[_i - 2] = arguments[_i];
	  }

	  if (emitter.getListeners(event).length === 0) {
	    return promise$3.reject(new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_ERROR, "can not emit promise"));
	  }

	  return new promise$3(function (resolve, reject) {
	    emitter.emit.apply(emitter, __spreadArrays([event], args, [resolve, reject]));
	  });
	}
	/**
	 * emit 一个事件，并假定 handler 会异步地处理事件，将 handler 的返回作为这个函数的 Promise 的返回，将 handler 的异常作为 Promise 的异常
	 * 要求返回的 Promise 为 Promise<void>
	 * 如果检测到没有 handler 会直接 resolve
	 */

	function emitAsPromiseNoResponse(emitter, event) {
	  var args = [];

	  for (var _i = 2; _i < arguments.length; _i++) {
	    args[_i - 2] = arguments[_i];
	  }

	  if (emitter.getListeners(event).length === 0) {
	    return promise$3.resolve();
	  }

	  return emitAsPromise.apply(void 0, __spreadArrays([emitter, event], args));
	}
	/**
	 * emit 一个事件，并假定 handler 会同步地处理事件，将 handler 的返回作为这个函数的返回，将 handler 的异常直接抛出
	 * **Note:**
	 * 如果没有 handler 直接返回 `null`
	 */

	function emitAsInvokerNoResponse(emitter, event) {
	  var args = [];

	  for (var _i = 2; _i < arguments.length; _i++) {
	    args[_i - 2] = arguments[_i];
	  }

	  if (emitter.getListeners(event).length === 0) {
	    return null;
	  }

	  return emitAsInvoker.apply(void 0, __spreadArrays([emitter, event], args));
	}
	/**
	 * emit 一个事件，并假定 handler 会同步地处理事件，将 handler 的返回作为这个函数的返回，将 handler 的异常直接抛出
	 */

	function emitAsInvoker(emitter, event) {
	  var args = [];

	  for (var _i = 2; _i < arguments.length; _i++) {
	    args[_i - 2] = arguments[_i];
	  }

	  var result = null;
	  var error = null;
	  emitter.emit.apply(emitter, __spreadArrays([event], args, [function (res) {
	    result = res;
	  }, function (err) {
	    error = err;
	  }]));

	  if (error !== null) {
	    throw error;
	  }

	  if (result === null) {
	    throw new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_ERROR, "handler is not sync");
	  }

	  return result;
	}
	function removeItemFromList(list, item) {
	  var index = indexOf$3(list).call(list, item);

	  if (index === -1) {
	    return;
	  }

	  splice$2(list).call(list, index, 1);
	}
	function getUniqueList(list) {
	  var newList = [];

	  forEach$3(list).call(list, function (item) {
	    if (indexOf$3(newList).call(newList, item) === -1) {
	      newList.push(item);
	    }
	  });

	  return newList;
	}
	function nextTick(func) {
	  promise$3.resolve().then(func);
	}
	function jsonClone(obj) {
	  return JSON.parse(stringify$2(obj));
	}
	/**
	 * 判断数组内的元素是否相同（不要求顺序相同）
	 */

	function compareArray(a, b) {
	  if (a.length !== b.length) return false;

	  var _loop_1 = function (i) {
	    var aItem = a[i];

	    var countsInA = filter$2(a).call(a, function (item) {
	      return item === aItem;
	    }).length;

	    var countsInB = filter$2(b).call(b, function (item) {
	      return item === aItem;
	    }).length;

	    if (countsInA !== countsInB) return {
	      value: false
	    };
	  };

	  for (var i = 0; i < a.length; i += 1) {
	    var state_1 = _loop_1(i);

	    if (typeof state_1 === "object") return state_1.value;
	  }

	  return true;
	}
	var runOnceFlagMap = {};
	/**
	 * 传入一个 key 然后执行一个函数，对于相同的 key，这个函数只会被执行一次
	 */

	function runOnce(func, key) {
	  if (runOnceFlagMap[key]) return;
	  runOnceFlagMap[key] = true;
	  func();
	}
	function detectSecureContext() {
	  if (typeof isSecureContext === "boolean") {
	    return isSecureContext;
	  }

	  return location.protocol === "https:" || location.protocol === "file:" || location.hostname === "localhost" || location.hostname === "127.0.0.1" || location.hostname === "::1";
	}
	function base64ToUint8Array(base64Str) {
	  var raw = window.atob(base64Str);
	  var result = new Uint8Array(new ArrayBuffer(raw.length));

	  for (var i = 0; i < raw.length; i += 1) {
	    result[i] = raw.charCodeAt(i);
	  }

	  return result;
	}
	function uint8ArrayToBase64(array) {
	  var result = "";

	  for (var i = 0; i < array.length; i += 1) {
	    result += String.fromCharCode(array[i]);
	  }

	  return window.btoa(result);
	}
	/**
	export const BEST_BITRATE: { [key: number]: [number, number, number] } = {
	  19200: [200, 150, 100],
	  76800: [500, 400, 200],
	  307200: [1300, 800, 250],
	  921600: [2500, 2000, 400],
	  2073600: [4500, 3000, 700],
	  8294400: [10000, 8500, 1000],
	};
	*/

	var BEST_BITRATE_PARAMS = [
	/** 120p -> 240p */
	[[100, 0.00520833333333333], [66.6666666666666, 0.00434027777777778], [66.6666666666667, 0.00173611111111111]],
	/** 240p -> 480p */
	[[233.333333333333, 0.00347222222222222], [266.666666666667], [0.00173611111111111], [183.333333333333, 0.000217013888888889]],
	/** 480p -> 720p */
	[[700, 0.001953125], [200, 0.001953125], [175, 0.000244140625]],
	/** 720p -> 1080p */
	[[899.999999999998, 0.00173611111111111], [1200, 0.000868055555555556], [160, 0.000260416666666667]],
	/** 1080p -> 4k */
	[[2666.66666666667, 0.000884130658436214], [1166.66666666667, 0.000884130658436214], [600, 0.0000482253]]];
	function getBestBitrateFromEncoderConfig(mode, config) {
	  if (mode === "motion") {
	    // 如果流畅优先，移除最低码率
	    logger.debug("adjust bitrate for motion, (" + config.bitrateMax + ", " + config.bitrateMin + "}) -> (" + config.bitrateMax + ", undefined)");
	    return {
	      max: config.bitrateMax
	    };
	  }

	  if (!config.width || !config.height) {
	    return {
	      max: config.bitrateMax,
	      min: config.bitrateMin
	    };
	  }

	  var resolution = constrainLongToNumber(config.width) * constrainLongToNumber(config.height);
	  /**
	   * 30 fps 时码率不变
	   * 5 fps 时码率为 1/4
	   * 小于 5 fps 认为是 5 fps
	   */

	  var frameRateRatio = Math.max(0.25, 0.1 + 0.03 * constrainLongToNumber(config.frameRate || 20));
	  var params = BEST_BITRATE_PARAMS[0]; // 太小，不指定码率

	  if (resolution < 19200) {
	    return {};
	  } else if (resolution < 76800) {
	    params = BEST_BITRATE_PARAMS[0];
	  } else if (resolution < 307200) {
	    params = BEST_BITRATE_PARAMS[1];
	  } else if (resolution < 921600) {
	    params = BEST_BITRATE_PARAMS[2];
	  } else if (resolution < 2073600) {
	    params = BEST_BITRATE_PARAMS[3];
	  } else if (resolution < 8294400) {
	    params = BEST_BITRATE_PARAMS[4];
	  } else {
	    return {
	      min: config.bitrateMin,
	      max: config.bitrateMax
	    };
	  }

	  var bitrateList = [Math.round((params[0][0] + params[0][1] * resolution) * frameRateRatio), Math.round((params[1][0] + params[1][1] * resolution) * frameRateRatio), Math.round((params[2][0] + params[2][1] * resolution) * frameRateRatio)]; // 如果清晰优先，确保最低码率大于 SDK 内部计算出的最低码率

	  var res = {
	    min: Math.max(bitrateList[2], config.bitrateMin || 0),
	    max: Math.max(bitrateList[2], config.bitrateMax || bitrateList[0])
	  };
	  logger.debug("adjust bitrate for detail, (" + config.bitrateMax + ", " + config.bitrateMin + "}) -> (" + res.max + ", " + res.min + ")");
	  return res;
	}

	var ThrottleManager =
	/** @class */
	function () {
	  function ThrottleManager() {
	    this.fnMap = new map$2();
	  }

	  ThrottleManager.prototype.throttleByKey = function (fn, name, threshold, skipFn) {
	    var _this = this;

	    var args = [];

	    for (var _i = 4; _i < arguments.length; _i++) {
	      args[_i - 4] = arguments[_i];
	    }

	    if (this.fnMap.has(name)) {
	      var oldMember = this.fnMap.get(name); // 改变了时间间隔，则立即执行待执行函数，并设置新的待执行函数计时器

	      if (oldMember.threshold !== threshold) {
	        oldMember.fn.apply(oldMember, oldMember.args);
	        clearTimeout(oldMember.timer);
	        var timer = window.setTimeout(function () {
	          // 从 map 中获取同 name 的待执行函数并执行
	          var member = _this.fnMap.get(name);

	          member && member.fn.apply(member, member.args);

	          _this.fnMap.delete(name);
	        }, threshold);
	        this.fnMap.set(name, {
	          fn: fn,
	          threshold: threshold,
	          timer: timer,
	          args: args,
	          skipFn: skipFn
	        });
	      } else {
	        // 当前待执行函数被覆盖时执行的函数
	        oldMember.skipFn && oldMember.skipFn.apply(oldMember, oldMember.args); // 时间间隔没有改变，直接更新 map 中的函数

	        this.fnMap.set(name, __assign$1(__assign$1({}, oldMember), {
	          fn: fn,
	          args: args,
	          skipFn: skipFn
	        }));
	      }
	    } else {
	      // 新加入待执行节流函数
	      var timer = window.setTimeout(function () {
	        // 从 map 中获取同 name 的待执行函数并执行
	        var member = _this.fnMap.get(name);

	        member && member.fn.apply(member, member.args);

	        _this.fnMap.delete(name);
	      }, threshold);
	      this.fnMap.set(name, {
	        fn: fn,
	        threshold: threshold,
	        timer: timer,
	        args: args,
	        skipFn: skipFn
	      });
	    }
	  };

	  return ThrottleManager;
	}();

	var throttleManager = new ThrottleManager();
	var throttleByKey = bind$3(_context2 = throttleManager.throttleByKey).call(_context2, throttleManager);

	var WebAudioContext = window.AudioContext || window.webkitAudioContext;
	var audioContext = null;
	var audioContextStateChangeEmitter = new EventEmitter$1();
	createAudioContext();

	function createAudioContext() {
	  if (!WebAudioContext) {
	    // not support
	    logger.error("your browser is not support web audio");
	    return;
	  }

	  audioContext = new WebAudioContext();

	  audioContext.onstatechange = function () {
	    audioContextStateChangeEmitter.emit("state-change");
	  };

	  unmute(audioContext); // webAudioUnlock(audioContext);
	}

	function getAudioContext() {
	  if (!audioContext) {
	    throw new AgoraRTCError(AgoraRTCErrorCode.NOT_SUPPORTED, "can not create audio context");
	  }

	  return audioContext;
	}
	/**
	 * Safari 的 AudioNode.disconnect 不支持 disconnect 指定节点，只能操作全部节点
	 * 这里的 polyfill 是通过 _inputNodes 保存全部已经 connect 的节点
	 * 然后在 disconnect 后，将那些预期不应该被 disconnect 的节点重新 connect
	 */

	function polyfillAudioNode(node) {
	  if (detectAudioNodeDisconnectDestination()) return;
	  logger.debug("polyfill audio node");
	  var nativeConnect = node.connect;
	  var nativeDisconnect = node.disconnect;

	  node.connect = function (destination, outputIndex, inputIndex) {
	    var _context;

	    if (!node._inputNodes) {
	      node._inputNodes = [];
	    }

	    if (includes$4(_context = node._inputNodes).call(_context, destination)) {
	      return node;
	    }

	    if (destination instanceof AudioNode) {
	      node._inputNodes.push(destination);

	      nativeConnect.call(node, destination, outputIndex, inputIndex);
	    } else {
	      nativeConnect.call(node, destination, outputIndex);
	    }

	    return node;
	  };

	  node.disconnect = function (destination, output, input) {
	    nativeDisconnect.call(node);

	    if (!destination) {
	      node._inputNodes = [];
	    } else {
	      removeItemFromList(node._inputNodes, destination);
	    }

	    for (var _a = 0, _b = node._inputNodes; _a < _b.length; _a++) {
	      var n = _b[_a];
	      nativeConnect.call(node, n);
	    }
	  };
	}
	function decodeAudioData(buffer) {
	  var context = getAudioContext();
	  return new promise$3(function (resolve, reject) {
	    /**
	     * Safari 目前还不支持 Promise-based 写法
	     */
	    context.decodeAudioData(buffer, function (data) {
	      resolve(data);
	    }, function (e) {
	      reject(new AgoraRTCError(AgoraRTCErrorCode.DECODE_AUDIO_FILE_FAILED, e.toString()));
	    });
	  });
	}
	var isSupportDisconnectDestination = null;

	function detectAudioNodeDisconnectDestination() {
	  if (isSupportDisconnectDestination !== null) return isSupportDisconnectDestination;
	  var context = getAudioContext();
	  var node1 = context.createBufferSource();
	  var node2 = context.createGain();
	  var node3 = context.createGain();
	  node1.connect(node2);
	  node1.connect(node3);
	  node1.disconnect(node2);
	  var result = false; // 如果是支持移除指定节点的浏览器，重复移除节点会报错

	  try {
	    node1.disconnect(node2);
	  } catch (e) {
	    result = true;
	  }

	  node1.disconnect();
	  isSupportDisconnectDestination = result;
	  return result;
	} // Timer to replace requestAnimationFrame when current tab was switched to backend.


	function audioTimerLoop(callback, frequency) {
	  var freq = 1 / frequency;
	  var aCtx = getAudioContext();
	  var silence = aCtx.createGain();
	  silence.gain.value = 0;
	  silence.connect(aCtx.destination);
	  var stopped = false;

	  var onOSCend = function () {
	    if (stopped) {
	      silence = null;
	      return;
	    }

	    var osc = aCtx.createOscillator();
	    osc.onended = onOSCend;
	    osc.connect(silence);
	    osc.start(0);
	    osc.stop(aCtx.currentTime + freq);
	    callback(aCtx.currentTime);
	  };

	  onOSCend(); // return a function to stop our loop

	  return function () {
	    stopped = true;
	  };
	}
	/**
	 * 将节点输入的 AudioBuffer 返回，将节点输出的 AudioBuffer 设置成 silence
	 */

	function silenceScriptProcessHandler(e) {
	  for (var i = 0; i < e.outputBuffer.numberOfChannels; i += 1) {
	    var channelData = e.outputBuffer.getChannelData(i);

	    for (var j = 0; j < channelData.length; j += 1) {
	      channelData[j] = 0;
	    }
	  }

	  return e.inputBuffer;
	}
	/**
	 * @author Spencer Evans evans.spencer@gmail.com
	 * unmute is a disgusting hack that helps..
	 * 	1) automatically resume web audio contexts on user interaction
	 * 	2) ios only: web audio play on the media channel rather than the ringer channel
	 * 	3) ios only: disable the media playback widget and airplay.
	 * 	4) automatically pause and resume web audio when the page is hidden.
	 * Auto resuming works by checking context state and calling resume during any resumable event.
	 * Media channel playback and media widget disabling work by playing an airplay-disabled silent html audio track in the background.
	 * Automatic pausing when the page is hidden is supported by both the page visibility api AND blur events because ios has a poor implementation of the page visibility api.
	 * This is all really gross and apple should really fix their janky browser.
	 * This code isn't optimized in any fashion, it is just whipped up to help someone out on stack overflow, its just meant as an example.
	 */

	/**
	 * Enables unmute.
	 * @param context A reference to the web audio context to "unmute".
	 */

	function unmute(context) {
	  var pageVisibilityAPI;

	  if (document.hidden !== undefined) {
	    pageVisibilityAPI = {
	      hidden: "hidden",
	      visibilitychange: "visibilitychange"
	    };
	  } else if (document.webkitHidden !== undefined) {
	    pageVisibilityAPI = {
	      hidden: "webkitHidden",
	      visibilitychange: "webkitvisibilitychange"
	    };
	  } else if (document.mozHidden !== undefined) {
	    pageVisibilityAPI = {
	      hidden: "mozHidden",
	      visibilitychange: "mozvisibilitychange"
	    };
	  } else if (document.msHidden !== undefined) {
	    pageVisibilityAPI = {
	      hidden: "msHidden",
	      visibilitychange: "msvisibilitychange"
	    };
	  } // Determine if ios


	  var ua = navigator.userAgent.toLowerCase();
	  var isIOS = indexOf$3(ua).call(ua, "iphone") >= 0 && indexOf$3(ua).call(ua, "like iphone") < 0 || indexOf$3(ua).call(ua, "ipad") >= 0 && indexOf$3(ua).call(ua, "like ipad") < 0 || indexOf$3(ua).call(ua, "ipod") >= 0 && indexOf$3(ua).call(ua, "like ipod") < 0; // Track page state

	  var isPageActive = true;
	  var isPageVisible = true;
	  var iosIsPageFocused = true; // iOS has a buggy page visibility API, luckily it dispatches blur and focus events on the window when vis change events should fire.
	  // Track desired audio state

	  var suspendAudio = false;
	  var audioUnlockingEvents = ["click", "contextmenu", "auxclick", "dblclick", "mousedown", "mouseup", "touchend", "keydown", "keyup"]; // Track web audio state

	  var contextUnlockingEnabled = false; // Track html audio state

	  var tag;
	  var tagUnlockingEnabled = false;
	  var tagPendingChange = false;

	  function contextStateCheck(tryResuming) {
	    if (context.state === "running") {
	      // No need to watch for unlocking events while running
	      toggleContextUnlocking(false); // Check if our state matches

	      if (suspendAudio) {
	        // We want to be suspended, we can suspend at any time
	        context.suspend().then(context_promiseHandler, context_promiseHandler);
	      }
	    } else if (context.state !== "closed") {
	      // Interrupted or suspended, check if our state matches
	      if (!suspendAudio) {
	        // We want to be running
	        toggleContextUnlocking(true);

	        if (tryResuming) {
	          context.resume().then(context_promiseHandler, context_promiseHandler);
	        }
	      } else {
	        // We don't want to be running, so no need to watch for unlocking events
	        toggleContextUnlocking(false);
	      }
	    }
	  }

	  function toggleContextUnlocking(enable) {
	    if (contextUnlockingEnabled === enable) return;
	    contextUnlockingEnabled = enable;

	    for (var _i = 0, audioUnlockingEvents_1 = audioUnlockingEvents; _i < audioUnlockingEvents_1.length; _i += 1) {
	      var evt = audioUnlockingEvents_1[_i];

	      if (enable) {
	        window.addEventListener(evt, context_unlockingEvent, {
	          capture: true,
	          passive: true
	        });
	      } else {
	        // @ts-ignore
	        window.removeEventListener(evt, context_unlockingEvent, {
	          capture: true,
	          passive: true
	        });
	      }
	    }
	  }

	  function context_statechange() {
	    contextStateCheck(true);
	  }

	  function context_promiseHandler() {
	    contextStateCheck(false);
	  }

	  function context_unlockingEvent() {
	    contextStateCheck(true);
	  }

	  function tagStateCheck(tryChange) {
	    // We have a pending state change, let that resolve first
	    if (tagPendingChange) return;

	    if (!tag.paused) {
	      // No need to watch for unlocking events while running
	      toggleTagUnlocking(false); // Check if our state matches

	      if (suspendAudio) {
	        // We want to be suspended, we can suspend at any time
	        tag.pause(); // instant action, so no need to set as pending
	      }
	    } else {
	      // Tag isn't playing, check if our state matches
	      if (!suspendAudio) {
	        // We want to be running
	        if (tryChange) {
	          // Try forcing a change, so stop watching for unlocking events while attempt is in progress
	          toggleTagUnlocking(false); // Attempt to play

	          tagPendingChange = true;
	          var p = void 0;

	          try {
	            p = tag.play();

	            if (p) {
	              p.then(tag_promiseHandler, tag_promiseHandler);
	            } else {
	              tag.addEventListener("playing", tag_promiseHandler);
	              tag.addEventListener("abort", tag_promiseHandler);
	              tag.addEventListener("error", tag_promiseHandler);
	            }
	          } catch (err) {
	            tag_promiseHandler();
	          }
	        } else {
	          // We're not going to try resuming this time, but make sure unlocking events are enabled
	          toggleTagUnlocking(true);
	        }
	      } else {
	        // We don't want to be running, so no need to watch for unlocking events
	        toggleTagUnlocking(false);
	      }
	    }
	  }

	  function toggleTagUnlocking(enable) {
	    if (tagUnlockingEnabled === enable) return;
	    tagUnlockingEnabled = enable;

	    for (var _i = 0, audioUnlockingEvents_2 = audioUnlockingEvents; _i < audioUnlockingEvents_2.length; _i++) {
	      var evt = audioUnlockingEvents_2[_i];

	      if (enable) {
	        window.addEventListener(evt, tag_unlockingEvent, {
	          capture: true,
	          passive: true
	        });
	      } else {
	        // @ts-ignore
	        window.removeEventListener(evt, tag_unlockingEvent, {
	          capture: true,
	          passive: true
	        });
	      }
	    }
	  }

	  function tag_promiseHandler() {
	    tag.removeEventListener("playing", tag_promiseHandler);
	    tag.removeEventListener("abort", tag_promiseHandler);
	    tag.removeEventListener("error", tag_promiseHandler); // Tag started playing, so we're not suspended

	    tagPendingChange = false;
	    tagStateCheck(false);
	  }

	  function tag_unlockingEvent() {
	    tagStateCheck(true);
	  }
	  /**
	   * Called when the page becomes active.
	   */


	  function pageActivated() {
	    suspendAudio = false;

	    if (tag) {
	      tagStateCheck(true); // tag first to ensure media channel start first
	    }

	    contextStateCheck(true);
	  }
	  /*
	  suspendAudio = true;
	  contextStateCheck(true); // context first to be sure it stops before the tag
	  if (tag) {
	    tagStateCheck(true);
	  }
	  */

	  /**
	   * Updates page active state.
	   */


	  function pageStateCheck() {
	    if (isPageVisible && iosIsPageFocused) {
	      if (!isPageActive) {
	        isPageActive = true;
	        pageActivated();
	      }
	    } else {
	      if (isPageActive) {
	        isPageActive = false;
	      }
	    }
	  }
	  /**
	   * Handle visibility api events.
	   */


	  function doc_visChange() {
	    if (pageVisibilityAPI) {
	      // @ts-ignore
	      if (document[pageVisibilityAPI.hidden] === isPageActive) {
	        // @ts-ignore
	        isPageVisible = !document[pageVisibilityAPI.hidden];
	        pageStateCheck();
	      }
	    }
	  }
	  /**
	   * Handles blur events (ios only).
	   */


	  function win_focusChange(evt) {
	    if (evt && evt.target !== window) return;

	    if (document.hasFocus()) {
	      if (iosIsPageFocused) return;
	      iosIsPageFocused = true;
	      pageStateCheck();
	    } else {
	      if (!iosIsPageFocused) return;
	      iosIsPageFocused = false;
	      pageStateCheck();
	    }
	  }
	  /**
	   * A utility function for decompressing the base64 silence string.
	   * @param c The number of times the string is repeated in the string segment.
	   * @param a The string to repeat.
	   */


	  function poorManHuffman(c, a) {
	    var e = "";

	    for (e = a; c > 1; c--) {
	      e += a;
	    }

	    return e;
	  } // Watch for tag state changes and check initial state


	  if (isIOS) {
	    // Is ios, we need to play an html track in the background and disable the widget
	    // NOTE: media widget / airplay MUST be disabled with this super gross hack to create the audio tag, setting the attribute in js doesn't work
	    var tmp = document.createElement("div");
	    tmp.innerHTML = "<audio x-webkit-airplay='deny'></audio>";
	    tag = tmp.children.item(0);
	    tag.controls = false;
	    tag.disableRemotePlayback = true; // Airplay like controls on other devices, prevents casting of the tag

	    tag.preload = "auto"; // Set the src to a short bit of url encoded as a silent mp3
	    // NOTE The silence MP3 must be high quality, when web audio sounds are played in parallel the web audio sound is mixed to match the bitrate of the html sound
	    // 0.01 seconds of silence VBR220-260 Joint Stereo 859B
	    // tag.src = "data:audio/mpeg;base64,//uQxAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAACAAACcQCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA//////////////////////////////////////////////////////////////////8AAABhTEFNRTMuMTAwA8MAAAAAAAAAABQgJAUHQQAB9AAAAnGMHkkIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//sQxAADgnABGiAAQBCqgCRMAAgEAH///////////////7+n/9FTuQsQH//////2NG0jWUGlio5gLQTOtIoeR2WX////X4s9Atb/JRVCbBUpeRUq//////////////////9RUi0f2jn/+xDECgPCjAEQAABN4AAANIAAAAQVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVQ==";
	    // The str below is a "compressed" version using poor mans huffman encoding, saves about 0.5kb

	    tag.src = "data:audio/mpeg;base64,//uQx" + poorManHuffman(23, "A") + "WGluZwAAAA8AAAACAAACcQCA" + poorManHuffman(16, "gICA") + poorManHuffman(66, "/") + "8AAABhTEFNRTMuMTAwA8MAAAAAAAAAABQgJAUHQQAB9AAAAnGMHkkI" + poorManHuffman(320, "A") + "//sQxAADgnABGiAAQBCqgCRMAAgEAH" + poorManHuffman(15, "/") + "7+n/9FTuQsQH//////2NG0jWUGlio5gLQTOtIoeR2WX////X4s9Atb/JRVCbBUpeRUq" + poorManHuffman(18, "/") + "9RUi0f2jn/+xDECgPCjAEQAABN4AAANIAAAAQVTEFNRTMuMTAw" + poorManHuffman(97, "V") + "Q==";
	    tag.loop = true;
	    tag.load(); // Try to play right off the bat

	    tagStateCheck(true);
	  } // Watch for context state changes and check initial state


	  context.onstatechange = context_statechange; // NOTE: the onstatechange callback property is more widely supported than the statechange event	context.addEventListener("statechange", context_statechange);

	  contextStateCheck(false); // Watch for page state changes and check initial page state

	  if (pageVisibilityAPI) {
	    document.addEventListener(pageVisibilityAPI.visibilitychange, doc_visChange, true);
	  }

	  if (isIOS) {
	    // Watch for blur / focus events on ios because it doesn't dispatch vis change events properly
	    window.addEventListener("focus", win_focusChange, true);
	    window.addEventListener("blur", win_focusChange, true);
	  }

	  doc_visChange();
	  win_focusChange();
	}

	var browserCompatibility = {
	  getDisplayMedia: false,
	  getStreamFromExtension: false,
	  supportUnifiedPlan: false,
	  supportMinBitrate: false,
	  supportSetRtpSenderParameters: false,
	  supportDualStream: true,
	  webAudioMediaStreamDest: false,
	  supportReplaceTrack: false,
	  supportWebGL: false,
	  webAudioWithAEC: false,
	  supportRequestFrame: false,
	  supportShareAudio: false
	};
	function updateAgoraRTCCompatibility() {
	  var browserInfo = getBrowserInfo();
	  browserCompatibility.getDisplayMedia = detectGetDisplayMedia();
	  browserCompatibility.getStreamFromExtension = browserInfo.name === BrowserName.CHROME && Number(browserInfo.version) > 34;
	  browserCompatibility.supportUnifiedPlan = detectIsUnifiedPlanDefault(); // TODO: feature detection?

	  browserCompatibility.supportMinBitrate = browserInfo.name === BrowserName.CHROME || browserInfo.name === BrowserName.EDGE;
	  browserCompatibility.supportSetRtpSenderParameters = detectSupportSetRtpSenderParameters();

	  if (browserInfo.name === BrowserName.SAFARI || isWechatBrowser()) {
	    browserCompatibility.supportDualStream = false;
	  }

	  browserCompatibility.webAudioMediaStreamDest = detectIsSupportWebAudioMediaStreamDest();
	  browserCompatibility.supportReplaceTrack = detectReplaceTrack();
	  browserCompatibility.supportWebGL = detectWebGL();
	  browserCompatibility.supportRequestFrame = detectIsSupportRequestFrame();

	  if (!isChromeKernel()) {
	    browserCompatibility.webAudioWithAEC = true;
	  }

	  browserCompatibility.supportShareAudio = detectSupportShareAudio();
	  logger.info("browser compatibility", stringify$2(browserCompatibility), stringify$2(browserInfo));
	}
	function getCompatibility() {
	  return browserCompatibility;
	}

	function detectGetDisplayMedia(info) {
	  if (navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia) {
	    return true;
	  }

	  return false;
	}
	/**
	 * codes from https://docs.google.com/document/d/1-ZfikoUtoJa9k-GZG1daN0BU3IjIanQ_JSscHxQesvU/edit#
	 */


	function detectIsUnifiedPlanDefault() {
	  // Safari supports addTransceiver() but not Unified Plan when
	  // currentDirection is not defined.
	  return false;
	}

	function detectIsSupportRequestFrame() {
	  // @ts-ignore
	  return !!window.CanvasCaptureMediaStreamTrack;
	}

	function detectIsSupportWebAudioMediaStreamDest() {
	  /**
	   * safari 12 以下都有 mediaStreamDest API 也都有输出
	   * 但是输出的 MediaStream 是没有数据的，不太好 feature detect
	   */
	  return false;
	}

	function detectReplaceTrack() {
	  if (!window.RTCRtpSender) {
	    return false;
	  }

	  if (typeof RTCRtpSender.prototype.replaceTrack === "function") {
	    return true;
	  }

	  return false;
	}

	function detectWebGL() {
	  return typeof WebGLRenderingContext !== "undefined";
	}

	function detectSupportShareAudio() {
	  // https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getDisplayMedia
	  // Windows 支持分享整个系统的音频，Linux 和 Mac 支持分享单个标签页的音频。
	  var browserInfo = getBrowserInfo();

	  if (browserInfo.os === BrowserOS.WIN_10 || browserInfo.os === BrowserOS.WIN_81 || browserInfo.os === BrowserOS.WIN_7 || browserInfo.os === BrowserOS.LINUX || browserInfo.os === BrowserOS.MAC_OS || browserInfo.os === BrowserOS.MAC_OS_X) {
	    if (browserInfo.name === BrowserName.CHROME && Number(browserInfo.version) >= 74) {
	      return true;
	    }
	  }

	  return false;
	} // https://github.com/webrtc/samples/blob/gh-pages/src/content/peerconnection/bandwidth/js/main.js#L181


	function detectSupportSetRtpSenderParameters() {
	  var browserInfo = getBrowserInfo();

	  if (!window.RTCRtpSender || !window.RTCRtpSender.prototype.setParameters || !window.RTCRtpSender.prototype.getParameters) {
	    return false;
	  }

	  if (isChromeKernel()) return true;
	  if (browserInfo.name === BrowserName.SAFARI) return true;
	  if (browserInfo.name === BrowserName.FIREFOX && Number(browserInfo.version) >= 64) return true;
	  return false;
	}

	var __awaiter$1 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = promise$3))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var __generator$1 = undefined && undefined.__generator || function (thisArg, body) {
	  var _ = {
	    label: 0,
	    sent: function () {
	      if (t[0] & 1) throw t[1];
	      return t[1];
	    },
	    trys: [],
	    ops: []
	  },
	      f,
	      y,
	      t,
	      g;
	  return g = {
	    next: verb(0),
	    "throw": verb(1),
	    "return": verb(2)
	  }, typeof symbol$2 === "function" && (g[iterator$2] = function () {
	    return this;
	  }), g;

	  function verb(n) {
	    return function (v) {
	      return step([n, v]);
	    };
	  }

	  function step(op) {
	    if (f) throw new TypeError("Generator is already executing.");

	    while (_) try {
	      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	      if (y = 0, t) op = [op[0] & 2, t.value];

	      switch (op[0]) {
	        case 0:
	        case 1:
	          t = op;
	          break;

	        case 4:
	          _.label++;
	          return {
	            value: op[1],
	            done: false
	          };

	        case 5:
	          _.label++;
	          y = op[1];
	          op = [0];
	          continue;

	        case 7:
	          op = _.ops.pop();

	          _.trys.pop();

	          continue;

	        default:
	          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
	            _ = 0;
	            continue;
	          }

	          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
	            _.label = op[1];
	            break;
	          }

	          if (op[0] === 6 && _.label < t[1]) {
	            _.label = t[1];
	            t = op;
	            break;
	          }

	          if (t && _.label < t[2]) {
	            _.label = t[2];

	            _.ops.push(op);

	            break;
	          }

	          if (t[2]) _.ops.pop();

	          _.trys.pop();

	          continue;
	      }

	      op = body.call(thisArg, _);
	    } catch (e) {
	      op = [6, e];
	      y = 0;
	    } finally {
	      f = t = 0;
	    }

	    if (op[0] & 5) throw op[1];
	    return {
	      value: op[0] ? op[1] : void 0,
	      done: true
	    };
	  }
	};
	function isElectron() {
	  return !!getElectronInstance();
	}
	function getElectronScreenStream(sourceId, config) {
	  return __awaiter$1(this, void 0, void 0, function () {
	    var getMaxValue, getUserMediaConfig;
	    return __generator$1(this, function (_a) {
	      switch (_a.label) {
	        case 0:
	          getMaxValue = function (value, defaultValue) {
	            if (!value) return defaultValue;

	            if (typeof value !== "number") {
	              return value.max || value.exact || value.ideal || value.min || defaultValue;
	            }

	            return value;
	          };

	          getUserMediaConfig = {
	            audio: false,
	            video: {
	              mandatory: {
	                chromeMediaSource: "desktop",
	                chromeMediaSourceId: sourceId,
	                maxHeight: getMaxValue(config.height, 1080),
	                maxWidth: getMaxValue(config.width, 1920)
	              }
	            }
	          };

	          if (config.frameRate && typeof config.frameRate !== "number") {
	            getUserMediaConfig.video.mandatory.maxFrameRate = config.frameRate.max;
	            getUserMediaConfig.video.mandatory.minFrameRate = config.frameRate.min;
	          } else if (typeof config.frameRate === "number") {
	            getUserMediaConfig.video.mandatory.maxFrameRate = config.frameRate;
	          }

	          return [4
	          /*yield*/
	          , navigator.mediaDevices.getUserMedia(getUserMediaConfig)];

	        case 1:
	          /**
	           * 这里暂时不 catch 错误，抛到统一处理 getUserMedia 错误的上层
	           */
	          return [2
	          /*return*/
	          , _a.sent()];
	      }
	    });
	  });
	}
	function getElectronScreenStreamByUserSelect(config) {
	  return __awaiter$1(this, void 0, void 0, function () {
	    var sources, sourceId;
	    return __generator$1(this, function (_a) {
	      switch (_a.label) {
	        case 0:
	          return [4
	          /*yield*/
	          , getElectronScreenSources(config.mediaSource)];

	        case 1:
	          sources = _a.sent();
	          return [4
	          /*yield*/
	          , showElectronSelectSourceWindow(sources)];

	        case 2:
	          sourceId = _a.sent();
	          return [4
	          /*yield*/
	          , getElectronScreenStream(sourceId, config)];

	        case 3:
	          return [2
	          /*return*/
	          , _a.sent()];
	      }
	    });
	  });
	}
	function getElectronScreenSources(type) {
	  return __awaiter$1(this, void 0, void 0, function () {
	    var sourceTypes, electron, getSourcesPromise, err_1;
	    return __generator$1(this, function (_a) {
	      switch (_a.label) {
	        case 0:
	          sourceTypes = ["window", "screen"];

	          if (type === "application" || type === "window") {
	            sourceTypes = ["window"];
	          }

	          if (type === "screen") {
	            sourceTypes = ["screen"];
	          }

	          electron = getElectronInstance();

	          if (!electron) {
	            throw new AgoraRTCError(AgoraRTCErrorCode.ELECTRON_IS_NULL);
	          }

	          getSourcesPromise = null;

	          try {
	            getSourcesPromise = electron.desktopCapturer.getSources({
	              types: sourceTypes
	            }); // @ts-ignore
	          } catch (e) {
	            /**
	             * 如果这里发生来错误，说明不支持 promise api
	             */
	            getSourcesPromise = null;
	          } // @ts-ignore


	          if (!getSourcesPromise || !getSourcesPromise.then) {
	            getSourcesPromise = new promise$3(function (resolve, reject) {
	              electron.desktopCapturer.getSources({
	                types: sourceTypes
	              }, function (err, sources) {
	                if (err) {
	                  reject(err);
	                  return;
	                }

	                resolve(sources);
	              });
	            });
	          }

	          _a.label = 1;

	        case 1:
	          _a.trys.push([1, 3,, 4]);

	          return [4
	          /*yield*/
	          , getSourcesPromise];

	        case 2:
	          return [2
	          /*return*/
	          , _a.sent()];

	        case 3:
	          err_1 = _a.sent();
	          throw new AgoraRTCError(AgoraRTCErrorCode.ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR, err_1.toString());

	        case 4:
	          return [2
	          /*return*/
	          ];
	      }
	    });
	  });
	}
	/**
	 * 显示一个界面展示所有的 sources，当用户完成选择时，resolve 目标的 sourceId
	 */

	function showElectronSelectSourceWindow(sources) {
	  return new promise$3(function (resolve, reject) {
	    // header
	    var header = document.createElement("div");
	    header.innerText = "share screen";
	    header.setAttribute("style", "text-align: center; height: 25px; line-height: 25px; border-radius: 4px 4px 0 0; background: #D4D2D4; border-bottom:  solid 1px #B9B8B9;"); // section

	    var section = document.createElement("div");
	    section.setAttribute("style", "width: 100%; height: 500px; padding: 15px 25px ; box-sizing: border-box;");
	    var tip = document.createElement("div");
	    tip.innerText = "Agora Web Screensharing wants to share the contents of your screen with webdemo.agorabeckon.com. Choose what you'd like to share.";
	    tip.setAttribute("style", "height: 12%;");
	    var box = document.createElement("div");
	    box.setAttribute("style", "width: 100%; height: 80%; background: #FFF; border:  solid 1px #CBCBCB; display: flex; flex-wrap: wrap; justify-content: space-around; overflow-y: scroll; padding: 0 15px; box-sizing: border-box;");
	    var bottom = document.createElement("div");
	    bottom.setAttribute("style", "text-align: right; padding: 16px 0;");
	    var cancel = document.createElement("button");
	    cancel.innerHTML = "cancel";
	    cancel.setAttribute("style", "width: 85px;");

	    cancel.onclick = function () {
	      document.body.removeChild(dialog);
	      /**
	       * 这里抛出的 Error 对象模拟原生的 NotAllowedError 对象
	       * 方便上层统一处理
	       */

	      var notAllowedError = new Error("NotAllowedError");
	      notAllowedError.name = "NotAllowedError";
	      reject(notAllowedError);
	    };

	    bottom.appendChild(cancel);
	    section.appendChild(tip);
	    section.appendChild(box);
	    section.appendChild(bottom); // dialog

	    var dialog = document.createElement("div");
	    dialog.setAttribute("style", "position: fixed; z-index: 99999999; top: 50%; left: 50%; width: 620px; height: 525px; background: #ECECEC; border-radius: 4px; -webkit-transform: translate(-50%,-50%); transform: translate(-50%,-50%);");
	    dialog.appendChild(header);
	    dialog.appendChild(section);
	    document.body.appendChild(dialog); // select box

	    map$5(sources).call(sources, function (source) {
	      if (source.id) {
	        var item = document.createElement("div");
	        item.setAttribute("style", "width: 30%; height: 160px; padding: 20px 0; text-align: center;box-sizing: content-box;");
	        item.innerHTML = "<div style=\"height: 120px; display: table-cell; vertical-align: middle;\">" + "<img style=\"width: 100%; background: #333333; box-shadow: 1px 1px 1px 1px rgba(0, 0, 0, 0.2);\" src=" + source.thumbnail.toDataURL() + " />" + "</div>" + "<span style=\"\theight: 40px; line-height: 40px; display: inline-block; width: 70%; word-break: keep-all; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;\">" + source.name + "</span>";

	        item.onclick = function () {
	          document.body.removeChild(dialog);
	          resolve(source.id);
	        };

	        box.appendChild(item);
	      }
	    });
	  });
	}
	var electron = null;

	function getElectronInstance() {
	  if (electron) return electron;

	  try {
	    /**
	     * 这段代码只在运行环境在 Electron 下时才有效
	     */
	    // @ts-ignore
	    electron = window.require("electron");
	    return electron;
	  } catch (e) {
	    return null;
	  }
	}

	var lockId = 1;

	var PromiseMutex =
	/** @class */
	function () {
	  function PromiseMutex(name) {
	    this.lockingPromise = promise$3.resolve();
	    this.locks = 0;
	    this.name = "";
	    this.lockId = lockId++;

	    if (name) {
	      this.name = name;
	    }

	    logger.debug("[lock-" + this.name + "-" + this.lockId + "] is created.");
	  }

	  defineProperty$4(PromiseMutex.prototype, "isLocked", {
	    get: function () {
	      return this.locks > 0;
	    },
	    enumerable: true,
	    configurable: true
	  });

	  PromiseMutex.prototype.lock = function () {
	    var _this = this;

	    this.locks += 1;
	    logger.debug("[lock-" + this.name + "-" + this.lockId + "] is locked, current queue " + this.locks + ".");
	    var unlockNext;
	    var willLock = new promise$3(function (resolve) {
	      unlockNext = function () {
	        _this.locks -= 1;
	        logger.debug("[lock-" + _this.name + "-" + _this.lockId + "] is not locked, current queue " + _this.locks + ".");
	        resolve();
	      };
	    });
	    var willUnlock = this.lockingPromise.then(function () {
	      return unlockNext;
	    });
	    this.lockingPromise = this.lockingPromise.then(function () {
	      return willLock;
	    });
	    return willUnlock;
	  };

	  return PromiseMutex;
	}();

	var __awaiter$2 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = promise$3))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var __generator$2 = undefined && undefined.__generator || function (thisArg, body) {
	  var _ = {
	    label: 0,
	    sent: function () {
	      if (t[0] & 1) throw t[1];
	      return t[1];
	    },
	    trys: [],
	    ops: []
	  },
	      f,
	      y,
	      t,
	      g;
	  return g = {
	    next: verb(0),
	    "throw": verb(1),
	    "return": verb(2)
	  }, typeof symbol$2 === "function" && (g[iterator$2] = function () {
	    return this;
	  }), g;

	  function verb(n) {
	    return function (v) {
	      return step([n, v]);
	    };
	  }

	  function step(op) {
	    if (f) throw new TypeError("Generator is already executing.");

	    while (_) try {
	      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	      if (y = 0, t) op = [op[0] & 2, t.value];

	      switch (op[0]) {
	        case 0:
	        case 1:
	          t = op;
	          break;

	        case 4:
	          _.label++;
	          return {
	            value: op[1],
	            done: false
	          };

	        case 5:
	          _.label++;
	          y = op[1];
	          op = [0];
	          continue;

	        case 7:
	          op = _.ops.pop();

	          _.trys.pop();

	          continue;

	        default:
	          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
	            _ = 0;
	            continue;
	          }

	          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
	            _.label = op[1];
	            break;
	          }

	          if (op[0] === 6 && _.label < t[1]) {
	            _.label = t[1];
	            t = op;
	            break;
	          }

	          if (t && _.label < t[2]) {
	            _.label = t[2];

	            _.ops.push(op);

	            break;
	          }

	          if (t[2]) _.ops.pop();

	          _.trys.pop();

	          continue;
	      }

	      op = body.call(thisArg, _);
	    } catch (e) {
	      op = [6, e];
	      y = 0;
	    } finally {
	      f = t = 0;
	    }

	    if (op[0] & 5) throw op[1];
	    return {
	      value: op[0] ? op[1] : void 0,
	      done: true
	    };
	  }
	};
	/**
	 * 全局 getUserMedia 锁，确保每次 GUM 时上一个 GUM 已经完成
	 *
	 * 该目前只用于 Safari 和 iOS 浏览器，https://bugs.webkit.org/show_bug.cgi?id=179363
	 *
	 * 防止 SDK Device 模块和用户同时触发 GUM 导致用户 GUN 返回的 track 被 mute。
	 */

	var SAFARI_GLOBAL_GUM_LOCK = new PromiseMutex("safari");
	var HAS_GUM_AUDIO = false;
	var HAS_GUM_VIDEO = false;
	function getLocalStream(config, id) {
	  return __awaiter$2(this, void 0, void 0, function () {
	    var retryCount, stream, e_1, errorName, err;
	    return __generator$2(this, function (_a) {
	      switch (_a.label) {
	        case 0:
	          retryCount = 0;
	          stream = null;
	          _a.label = 1;

	        case 1:
	          if (!(retryCount < 2)) return [3
	          /*break*/
	          , 8];
	          _a.label = 2;

	        case 2:
	          _a.trys.push([2, 4,, 7]);

	          return [4
	          /*yield*/
	          , getUserMedia(config, id, retryCount > 0)];

	        case 3:
	          stream = _a.sent();
	          return [3
	          /*break*/
	          , 8];

	        case 4:
	          e_1 = _a.sent();

	          if (e_1 instanceof AgoraRTCError) {
	            logger.error("[" + id + "] " + e_1.toString());
	            throw e_1;
	          }

	          errorName = e_1.name || e_1.code || e_1;
	          err = handleGetUserMediaError(errorName, e_1.message);
	          if (!(err.code === AgoraRTCErrorCode.MEDIA_OPTION_INVALID)) return [3
	          /*break*/
	          , 6];
	          logger.debug("[" + id + "] detect media option invalid, retry");
	          retryCount += 1;
	          return [4
	          /*yield*/
	          , wait(500)];

	        case 5:
	          _a.sent();

	          return [3
	          /*break*/
	          , 1];

	        case 6:
	          logger.error("[" + id + "] " + err.toString());
	          throw err;

	        case 7:
	          return [3
	          /*break*/
	          , 1];

	        case 8:
	          if (!stream) {
	            throw new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_ERROR, "can not find stream after getUserMedia");
	          }

	          return [2
	          /*return*/
	          , stream];
	      }
	    });
	  });
	}
	/**
	 * @param forceNoResolution 如果采集失败，打开这个开关强制不指定分辨率进行采集
	 */

	function getUserMedia(config, trackId, forceNoResolution) {
	  return __awaiter$2(this, void 0, void 0, function () {
	    var compatibility, mediaStream, stream_1, stream_2, sourceId, stream_3, videoConstraints, stream_4, options, stream_5, constraint, browserInfo, unlock, stream, e_2;
	    return __generator$2(this, function (_a) {
	      switch (_a.label) {
	        case 0:
	          /**
	           * 这里假设有 adapter.js 的存在，所有的采集直接调用 navigator.mediaDevice.getUserMedia
	           */
	          if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
	            throw new AgoraRTCError(AgoraRTCErrorCode.NOT_SUPPORTED, "can not find getUserMedia");
	          }

	          if (forceNoResolution) {
	            if (config.video) {
	              delete config.video.width;
	              delete config.video.height;
	            }

	            if (config.screen) {
	              delete config.screen.width;
	              delete config.screen.height;
	            }
	          }

	          compatibility = getCompatibility();
	          mediaStream = new MediaStream();

	          if (config.audioSource) {
	            mediaStream.addTrack(config.audioSource);
	          }

	          if (config.videoSource) {
	            mediaStream.addTrack(config.videoSource);
	          } // 如果没有任何采集 constraints， 直接返回构造出来的 MediaStream


	          if (!config.audio && !config.video && !config.screen) {
	            logger.debug("Using Video Source/ Audio Source");
	            return [2
	            /*return*/
	            , mediaStream];
	          }

	          if (!config.screen) return [3
	          /*break*/
	          , 13];
	          if (!isElectron()) return [3
	          /*break*/
	          , 5];
	          if (!config.screen.sourceId) return [3
	          /*break*/
	          , 2];
	          return [4
	          /*yield*/
	          , getElectronScreenStream(config.screen.sourceId, config.screen)];

	        case 1:
	          stream_1 = _a.sent();
	          replaceMediaStream(mediaStream, stream_1);
	          return [3
	          /*break*/
	          , 4];

	        case 2:
	          return [4
	          /*yield*/
	          , getElectronScreenStreamByUserSelect(config.screen)];

	        case 3:
	          stream_2 = _a.sent();
	          replaceMediaStream(mediaStream, stream_2);
	          _a.label = 4;

	        case 4:
	          return [3
	          /*break*/
	          , 13];

	        case 5:
	          if (!(isChrome() && config.screen.extensionId && config.screen.mandatory)) return [3
	          /*break*/
	          , 8];

	          if (!compatibility.getStreamFromExtension) {
	            throw new AgoraRTCError(AgoraRTCErrorCode.NOT_SUPPORTED, "This browser does not support screen sharing");
	          }

	          logger.debug("[" + trackId + "] Screen access on chrome stable, looking for extension\"");
	          return [4
	          /*yield*/
	          , getSourceIdFromExtension(config.screen.extensionId, trackId)];

	        case 6:
	          sourceId = _a.sent();
	          config.screen.mandatory.chromeMediaSourceId = sourceId;
	          return [4
	          /*yield*/
	          , navigator.mediaDevices.getUserMedia({
	            video: {
	              mandatory: config.screen.mandatory
	            }
	          })];

	        case 7:
	          stream_3 = _a.sent();
	          replaceMediaStream(mediaStream, stream_3);
	          return [3
	          /*break*/
	          , 13];

	        case 8:
	          if (!compatibility.getDisplayMedia) return [3
	          /*break*/
	          , 10];
	          config.screen.mediaSource && isScreenSourceType(config.screen.mediaSource);
	          videoConstraints = {
	            width: config.screen.width,
	            height: config.screen.height,
	            frameRate: config.screen.frameRate,
	            displaySurface: config.screen.mediaSource === "screen" ? "monitor" : config.screen.mediaSource
	          };
	          logger.debug("[" + trackId + "] getDisplayMedia:", stringify$2({
	            video: videoConstraints,
	            audio: !!config.screenAudio
	          }));
	          return [4
	          /*yield*/
	          , navigator.mediaDevices.getDisplayMedia({
	            video: videoConstraints,
	            audio: !!config.screenAudio
	          })];

	        case 9:
	          stream_4 = _a.sent();
	          replaceMediaStream(mediaStream, stream_4);
	          return [3
	          /*break*/
	          , 13];

	        case 10:
	          if (!isFirefox()) return [3
	          /*break*/
	          , 12];
	          config.screen.mediaSource && isScreenSourceType(config.screen.mediaSource);
	          options = {
	            video: {
	              mediaSource: config.screen.mediaSource,
	              width: config.screen.width,
	              height: config.screen.height,
	              frameRate: config.screen.frameRate
	            }
	          };
	          logger.debug("[" + trackId + "] getUserMedia: " + stringify$2(options));
	          return [4
	          /*yield*/
	          , navigator.mediaDevices.getUserMedia(options)];

	        case 11:
	          stream_5 = _a.sent();
	          replaceMediaStream(mediaStream, stream_5);
	          return [3
	          /*break*/
	          , 13];

	        case 12:
	          logger.error("[" + trackId + "] This browser does not support screenSharing");
	          throw new AgoraRTCError(AgoraRTCErrorCode.NOT_SUPPORTED, "This browser does not support screen sharing");

	        case 13:
	          /**
	           * 处理 screen sharing only 的情况
	           */
	          if (!config.video && !config.audio) {
	            return [2
	            /*return*/
	            , mediaStream];
	          }

	          constraint = {
	            video: config.video,
	            audio: config.audio
	          };
	          logger.debug("[" + trackId + "] GetUserMedia", stringify$2(constraint));
	          browserInfo = getBrowserInfo();
	          unlock = null;
	          if (!(browserInfo.name === BrowserName.SAFARI || browserInfo.os === BrowserOS.IOS)) return [3
	          /*break*/
	          , 15];
	          return [4
	          /*yield*/
	          , SAFARI_GLOBAL_GUM_LOCK.lock()];

	        case 14:
	          unlock = _a.sent();
	          _a.label = 15;

	        case 15:
	          _a.trys.push([15, 17,, 18]);

	          return [4
	          /*yield*/
	          , navigator.mediaDevices.getUserMedia(constraint)];

	        case 16:
	          stream = _a.sent();
	          return [3
	          /*break*/
	          , 18];

	        case 17:
	          e_2 = _a.sent();
	          unlock && unlock();
	          throw e_2;

	        case 18:
	          if (!!constraint.audio) {
	            HAS_GUM_AUDIO = true;
	          }

	          if (!!constraint.video) {
	            HAS_GUM_VIDEO = true;
	          }

	          replaceMediaStream(mediaStream, stream);
	          unlock && unlock();
	          return [2
	          /*return*/
	          , mediaStream];
	      }
	    });
	  });
	}
	/**
	 * 将原生的 DomException 转成对应的 AgoraRTCError
	 */


	function handleGetUserMediaError(errorName, message) {
	  switch (errorName) {
	    /**
	     * firefox: camera possessed by other process?
	     * chrome: probably resolution not supported
	     *
	     * 取消指定分辨率，重试
	     */
	    case "Starting video failed":
	    case "OverconstrainedError":
	    case "TrackStartError":
	      {
	        return new AgoraRTCError(AgoraRTCErrorCode.MEDIA_OPTION_INVALID, errorName + ": " + message);
	      }

	    case "NotFoundError":
	    case "DevicesNotFoundError":
	      {
	        return new AgoraRTCError(AgoraRTCErrorCode.DEVICE_NOT_FOUND, errorName + ": " + message);
	      }

	    case "NotSupportedError":
	      {
	        return new AgoraRTCError(AgoraRTCErrorCode.NOT_SUPPORTED, errorName + ": " + message);
	      }

	    /** chrome */

	    case "InvalidStateError":
	    /** firefox/electron */

	    case "NotAllowedError":
	    /** firefox */

	    case "PERMISSION_DENIED":
	    /** chrome  */

	    case "PermissionDeniedError":
	      {
	        return new AgoraRTCError(AgoraRTCErrorCode.PERMISSION_DENIED, errorName + ": " + message);
	      }

	    case "ConstraintNotSatisfiedError":
	      {
	        return new AgoraRTCError(AgoraRTCErrorCode.CONSTRAINT_NOT_SATISFIED, errorName + ": " + message);
	      }

	    default:
	      {
	        logger.error("getUserMedia unexpected error", errorName);
	        return new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_ERROR, errorName + ": " + message);
	      }
	  }
	}
	/**
	 * **Note:** 这里假设所有的 MediaStream 都至多有 1 个 audioTrack 或者 videoTrack
	 */

	function replaceMediaStream(oldStream, newStream) {
	  var oldVideoTrack = oldStream.getVideoTracks()[0];
	  var oldAudioTrack = oldStream.getAudioTracks()[0];
	  var newVideoTrack = newStream.getVideoTracks()[0];
	  var newAudioTrack = newStream.getAudioTracks()[0];

	  if (newAudioTrack) {
	    if (oldAudioTrack) {
	      oldStream.removeTrack(oldAudioTrack);
	    }

	    oldStream.addTrack(newAudioTrack);
	  }

	  if (newVideoTrack) {
	    if (oldVideoTrack) {
	      oldStream.removeTrack(oldVideoTrack);
	    }

	    oldStream.addTrack(newVideoTrack);
	  }
	}
	/**
	 * 通过 chrome 插件获取屏幕共享流的 sourceId
	 */


	function getSourceIdFromExtension(extensionId, streamId) {
	  return new promise$3(function (resolve, reject) {
	    try {
	      // @ts-ignore
	      chrome.runtime.sendMessage(extensionId, {
	        getStream: true
	      }, function (response) {
	        if (!response || !response.streamId) {
	          logger.error("[" + streamId + "] No response from Chrome Plugin. Plugin not installed properly", response);
	          reject(new AgoraRTCError(AgoraRTCErrorCode.CHROME_PLUGIN_NO_RESPONSE, "No response from Chrome Plugin. Plugin not installed properly"));
	          return;
	        }

	        resolve(response.streamId);
	      });
	    } catch (e) {
	      logger.error("[" + streamId + "] AgoraRTC screensharing plugin is not accessible(" + extensionId + ")", e.toString());
	      reject(new AgoraRTCError(AgoraRTCErrorCode.CHROME_PLUGIN_NOT_INSTALL));
	    }
	  });
	}

	var __extends$1 = undefined && undefined.__extends || function () {
	  var extendStatics = function (d, b) {
	    extendStatics = setPrototypeOf$2 || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    };

	    return extendStatics(d, b);
	  };

	  return function (d, b) {
	    extendStatics(d, b);

	    function __() {
	      this.constructor = d;
	    }

	    d.prototype = b === null ? create$4(b) : (__.prototype = b.prototype, new __());
	  };
	}();

	var __awaiter$3 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = promise$3))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var __generator$3 = undefined && undefined.__generator || function (thisArg, body) {
	  var _ = {
	    label: 0,
	    sent: function () {
	      if (t[0] & 1) throw t[1];
	      return t[1];
	    },
	    trys: [],
	    ops: []
	  },
	      f,
	      y,
	      t,
	      g;
	  return g = {
	    next: verb(0),
	    "throw": verb(1),
	    "return": verb(2)
	  }, typeof symbol$2 === "function" && (g[iterator$2] = function () {
	    return this;
	  }), g;

	  function verb(n) {
	    return function (v) {
	      return step([n, v]);
	    };
	  }

	  function step(op) {
	    if (f) throw new TypeError("Generator is already executing.");

	    while (_) try {
	      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	      if (y = 0, t) op = [op[0] & 2, t.value];

	      switch (op[0]) {
	        case 0:
	        case 1:
	          t = op;
	          break;

	        case 4:
	          _.label++;
	          return {
	            value: op[1],
	            done: false
	          };

	        case 5:
	          _.label++;
	          y = op[1];
	          op = [0];
	          continue;

	        case 7:
	          op = _.ops.pop();

	          _.trys.pop();

	          continue;

	        default:
	          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
	            _ = 0;
	            continue;
	          }

	          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
	            _.label = op[1];
	            break;
	          }

	          if (op[0] === 6 && _.label < t[1]) {
	            _.label = t[1];
	            t = op;
	            break;
	          }

	          if (t && _.label < t[2]) {
	            _.label = t[2];

	            _.ops.push(op);

	            break;
	          }

	          if (t[2]) _.ops.pop();

	          _.trys.pop();

	          continue;
	      }

	      op = body.call(thisArg, _);
	    } catch (e) {
	      op = [6, e];
	      y = 0;
	    } finally {
	      f = t = 0;
	    }

	    if (op[0] & 5) throw op[1];
	    return {
	      value: op[0] ? op[1] : void 0,
	      done: true
	    };
	  }
	};

	var DeviceManager =
	/** @class */
	function (_super) {
	  __extends$1(DeviceManager, _super);

	  function DeviceManager() {
	    var _this = _super.call(this) || this;

	    _this._state = DeviceManagerState.IDLE;
	    _this.isAccessMicrophonePermission = false;
	    _this.isAccessCameraPermission = false;
	    /**
	     * 记录所有枚举到的设备和这些设备最后出现的时间
	     */

	    _this.deviceInfoMap = new map$2();

	    _this.init().then(function () {
	      var _context2;

	      /**
	       * 检测设备插拔
	       */
	      if (navigator.mediaDevices && navigator.mediaDevices.addEventListener) {
	        var _context;

	        navigator.mediaDevices.addEventListener("devicechange", bind$3(_context = _this.updateDevicesInfo).call(_context, _this));
	      }

	      window.setInterval(bind$3(_context2 = _this.updateDevicesInfo).call(_context2, _this), 2500);
	    }).catch(function (e) {
	      return logger.error(e.toString());
	    });

	    return _this;
	  }

	  defineProperty$4(DeviceManager.prototype, "state", {
	    get: function () {
	      return this._state;
	    },
	    set: function (state) {
	      if (state === this._state) return;
	      this.emit(DeviceManagerEvent.STATE_CHANGE, state);
	      this._state = state;
	    },
	    enumerable: true,
	    configurable: true
	  });

	  DeviceManager.prototype.enumerateDevices = function (audio, video, skipPermissionCheck) {
	    if (skipPermissionCheck === void 0) {
	      skipPermissionCheck = false;
	    }

	    return __awaiter$3(this, void 0, void 0, function () {
	      var err, info, deviceIsOk, checkAudio, checkVideo, audioStream, videoStream, avStream, unlock, e_1, err, e_2, err, e_3, err, info_1, e_4, err;
	      return __generator$3(this, function (_a) {
	        var _context3, _context4, _context5;

	        switch (_a.label) {
	          case 0:
	            if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
	              err = new AgoraRTCError(AgoraRTCErrorCode.NOT_SUPPORTED, "enumerateDevices() not supported.");
	              return [2
	              /*return*/
	              , err.throw()];
	            }

	            return [4
	            /*yield*/
	            , navigator.mediaDevices.enumerateDevices()];

	          case 1:
	            info = _a.sent();
	            deviceIsOk = this.checkMediaDeviceInfoIsOk(info);
	            checkAudio = this.isAccessMicrophonePermission ? false : audio;
	            checkVideo = this.isAccessCameraPermission ? false : video;

	            if (deviceIsOk.audio) {
	              checkAudio = false;
	            }

	            if (deviceIsOk.video) {
	              checkVideo = false;
	            }

	            audioStream = null;
	            videoStream = null;
	            avStream = null;
	            if (!(!skipPermissionCheck && (checkAudio || checkVideo))) return [3
	            /*break*/
	            , 19];
	            if (!SAFARI_GLOBAL_GUM_LOCK.isLocked) return [3
	            /*break*/
	            , 3];
	            logger.debug("[device manager] wait GUM lock");
	            return [4
	            /*yield*/
	            , SAFARI_GLOBAL_GUM_LOCK.lock()];

	          case 2:
	            unlock = _a.sent();
	            unlock();
	            logger.debug("[device manager] GUM unlock");
	            _a.label = 3;

	          case 3:
	            // 防止重复的 GUM
	            if (HAS_GUM_AUDIO) {
	              checkAudio = false;
	              this.isAccessMicrophonePermission = true;
	            }

	            if (HAS_GUM_VIDEO) {
	              checkVideo = false;
	              this.isAccessCameraPermission = true;
	            }

	            logger.debug("[device manager] check media device permissions", audio, video, checkAudio, checkVideo);
	            if (!(checkAudio && checkVideo)) return [3
	            /*break*/
	            , 8];
	            _a.label = 4;

	          case 4:
	            _a.trys.push([4, 6,, 7]);

	            return [4
	            /*yield*/
	            , navigator.mediaDevices.getUserMedia({
	              audio: true,
	              video: true
	            })];

	          case 5:
	            avStream = _a.sent();
	            return [3
	            /*break*/
	            , 7];

	          case 6:
	            e_1 = _a.sent();
	            err = handleGetUserMediaError(e_1.name || e_1.code || e_1, e_1.message);
	            if (err.code === AgoraRTCErrorCode.PERMISSION_DENIED) throw err;
	            /** 除了 PermissionDenied 以外的错误都无视 */

	            logger.warning("getUserMedia failed in getDevices", err);
	            return [3
	            /*break*/
	            , 7];

	          case 7:
	            this.isAccessCameraPermission = true;
	            this.isAccessMicrophonePermission = true;
	            return [3
	            /*break*/
	            , 18];

	          case 8:
	            if (!checkAudio) return [3
	            /*break*/
	            , 13];
	            _a.label = 9;

	          case 9:
	            _a.trys.push([9, 11,, 12]);

	            return [4
	            /*yield*/
	            , navigator.mediaDevices.getUserMedia({
	              audio: audio
	            })];

	          case 10:
	            audioStream = _a.sent();
	            return [3
	            /*break*/
	            , 12];

	          case 11:
	            e_2 = _a.sent();
	            err = handleGetUserMediaError(e_2.name || e_2.code || e_2, e_2.message);
	            if (err.code === AgoraRTCErrorCode.PERMISSION_DENIED) throw err;
	            /** 除了 PermissionDenied 以外的错误都无视 */

	            logger.warning("getUserMedia failed in getDevices", err);
	            return [3
	            /*break*/
	            , 12];

	          case 12:
	            this.isAccessMicrophonePermission = true;
	            return [3
	            /*break*/
	            , 18];

	          case 13:
	            if (!checkVideo) return [3
	            /*break*/
	            , 18];
	            _a.label = 14;

	          case 14:
	            _a.trys.push([14, 16,, 17]);

	            return [4
	            /*yield*/
	            , navigator.mediaDevices.getUserMedia({
	              video: video
	            })];

	          case 15:
	            videoStream = _a.sent();
	            return [3
	            /*break*/
	            , 17];

	          case 16:
	            e_3 = _a.sent();
	            err = handleGetUserMediaError(e_3.name || e_3.code || e_3, e_3.message);
	            if (err.code === AgoraRTCErrorCode.PERMISSION_DENIED) throw err;
	            /** 除了 PermissionDenied 以外的错误都无视 */

	            logger.warning("getUserMedia failed in getDevices", err);
	            return [3
	            /*break*/
	            , 17];

	          case 17:
	            this.isAccessCameraPermission = true;
	            _a.label = 18;

	          case 18:
	            logger.debug("[device manager] mic permission", audio, "cam permission", video);
	            _a.label = 19;

	          case 19:
	            _a.trys.push([19, 21,, 22]);

	            return [4
	            /*yield*/
	            , navigator.mediaDevices.enumerateDevices()];

	          case 20:
	            info_1 = _a.sent();
	            audioStream && forEach$3(_context3 = audioStream.getTracks()).call(_context3, function (t) {
	              return t.stop();
	            });
	            videoStream && forEach$3(_context4 = videoStream.getTracks()).call(_context4, function (t) {
	              return t.stop();
	            });
	            avStream && forEach$3(_context5 = avStream.getTracks()).call(_context5, function (t) {
	              return t.stop();
	            });
	            return [2
	            /*return*/
	            , info_1];

	          case 21:
	            e_4 = _a.sent();
	            err = new AgoraRTCError(AgoraRTCErrorCode.ENUMERATE_DEVICES_FAILED, e_4.toString());
	            return [2
	            /*return*/
	            , err.throw()];

	          case 22:
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  DeviceManager.prototype.getRecordingDevices = function (skipPermissionCheck) {
	    if (skipPermissionCheck === void 0) {
	      skipPermissionCheck = false;
	    }

	    return __awaiter$3(this, void 0, void 0, function () {
	      var devices;
	      return __generator$3(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            return [4
	            /*yield*/
	            , this.enumerateDevices(true, false, skipPermissionCheck)];

	          case 1:
	            devices = _a.sent();
	            return [2
	            /*return*/
	            , filter$2(devices).call(devices, function (d) {
	              return d.kind === "audioinput";
	            })];
	        }
	      });
	    });
	  };

	  DeviceManager.prototype.getCamerasDevices = function (skipPermissionCheck) {
	    if (skipPermissionCheck === void 0) {
	      skipPermissionCheck = false;
	    }

	    return __awaiter$3(this, void 0, void 0, function () {
	      var devices;
	      return __generator$3(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            return [4
	            /*yield*/
	            , this.enumerateDevices(false, true, skipPermissionCheck)];

	          case 1:
	            devices = _a.sent();
	            return [2
	            /*return*/
	            , filter$2(devices).call(devices, function (d) {
	              return d.kind === "videoinput";
	            })];
	        }
	      });
	    });
	  };

	  DeviceManager.prototype.getSpeakers = function (skipPermissionCheck) {
	    if (skipPermissionCheck === void 0) {
	      skipPermissionCheck = false;
	    }

	    return __awaiter$3(this, void 0, void 0, function () {
	      var devices;
	      return __generator$3(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            return [4
	            /*yield*/
	            , this.enumerateDevices(true, false, skipPermissionCheck)];

	          case 1:
	            devices = _a.sent();
	            return [2
	            /*return*/
	            , filter$2(devices).call(devices, function (d) {
	              return d.kind === "audiooutput";
	            })];
	        }
	      });
	    });
	  };

	  DeviceManager.prototype.searchDeviceNameById = function (deviceId) {
	    var deviceInfo = this.deviceInfoMap.get(deviceId);

	    if (deviceInfo) {
	      return deviceInfo.device.label || deviceInfo.device.deviceId;
	    }

	    return null;
	  };

	  DeviceManager.prototype.searchDeviceIdByName = function (deviceName) {
	    var _context6;

	    var id = null;

	    forEach$3(_context6 = this.deviceInfoMap).call(_context6, function (v) {
	      if (v.device.label === deviceName) id = v.device.deviceId;
	    });

	    return id;
	  };

	  DeviceManager.prototype.getDeviceById = function (deviceId) {
	    return __awaiter$3(this, void 0, void 0, function () {
	      var devices, device;
	      return __generator$3(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            return [4
	            /*yield*/
	            , this.enumerateDevices(true, true, true)];

	          case 1:
	            devices = _a.sent();
	            device = find$2(devices).call(devices, function (d) {
	              return d.deviceId === deviceId;
	            });

	            if (!device) {
	              throw new AgoraRTCError(AgoraRTCErrorCode.DEVICE_NOT_FOUND, "deviceId: " + deviceId);
	            }

	            return [2
	            /*return*/
	            , device];
	        }
	      });
	    });
	  };

	  DeviceManager.prototype.init = function () {
	    return __awaiter$3(this, void 0, void 0, function () {
	      var e_5, err;
	      return __generator$3(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            this.state = DeviceManagerState.INITING;
	            _a.label = 1;

	          case 1:
	            _a.trys.push([1, 3,, 4]);

	            return [4
	            /*yield*/
	            , this.updateDevicesInfo()];

	          case 2:
	            _a.sent();

	            this.state = DeviceManagerState.INITEND;
	            return [3
	            /*break*/
	            , 4];

	          case 3:
	            e_5 = _a.sent();
	            logger.warning("Device Detection functionality cannot start properly.", e_5.toString());
	            this.state = DeviceManagerState.IDLE;

	            if (!detectSecureContext()) {
	              err = new AgoraRTCError(AgoraRTCErrorCode.WEB_SECURITY_RESTRICT, "Your context is limited by web security, please try using https protocol or localhost.");
	              err.throw();
	            } // 如果在 init 阶段枚举设备就报错，大概率是浏览器不支持枚举设备，此时直接抛错不再 resolve 避免上层开启了 interval 不断枚举


	            throw e_5;

	          case 4:
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  DeviceManager.prototype.updateDevicesInfo = function () {
	    return __awaiter$3(this, void 0, void 0, function () {
	      var devices, now, stateChangedDevices;

	      var _this = this;

	      return __generator$3(this, function (_a) {
	        var _context7;

	        switch (_a.label) {
	          case 0:
	            return [4
	            /*yield*/
	            , this.enumerateDevices(true, true, true)];

	          case 1:
	            devices = _a.sent();
	            now = now$2();
	            stateChangedDevices = [];
	            /**
	             * 更新新插入的设备
	             */

	            forEach$3(devices).call(devices, function (device) {
	              /** 如果没有 deviceId 值，忽略这个设备 */
	              if (!device.deviceId) return;

	              var deviceInfo = _this.deviceInfoMap.get(device.deviceId);

	              var deviceState = deviceInfo ? deviceInfo.state : "INACTIVE";

	              if (deviceState !== "ACTIVE") {
	                var info = {
	                  initAt: now,
	                  updateAt: now,
	                  device: device,
	                  state: "ACTIVE"
	                };

	                _this.deviceInfoMap.set(device.deviceId, info);

	                stateChangedDevices.push(info);
	              }

	              if (deviceInfo) {
	                deviceInfo.updateAt = now;
	                /*
	                if (deviceInfo.device.label !== device.label) {
	                  deviceInfo.device = device;
	                  // label changed
	                  stateChangedDevices.push(deviceInfo);
	                }
	                */
	              }
	            });
	            /**
	             * 更新拔出的设备
	             */


	            forEach$3(_context7 = this.deviceInfoMap).call(_context7, function (deviceInfo, deviceId) {
	              if (deviceInfo.state === "ACTIVE" && deviceInfo.updateAt !== now) {
	                deviceInfo.state = "INACTIVE";
	                stateChangedDevices.push(deviceInfo);
	              }
	            });
	            /** 第一次枚举设备时，不统计设备插拔变化 */


	            if (this.state !== DeviceManagerState.INITEND) return [2
	            /*return*/
	            ];

	            forEach$3(stateChangedDevices).call(stateChangedDevices, function (deviceInfo) {
	              switch (deviceInfo.device.kind) {
	                case "audioinput":
	                  {
	                    _this.emit(DeviceManagerEvent.RECORDING_DEVICE_CHANGED, deviceInfo);

	                    break;
	                  }

	                case "videoinput":
	                  {
	                    _this.emit(DeviceManagerEvent.CAMERA_DEVICE_CHANGED, deviceInfo);

	                    break;
	                  }

	                case "audiooutput":
	                  {
	                    _this.emit(DeviceManagerEvent.PLAYOUT_DEVICE_CHANGED, deviceInfo);

	                    break;
	                  }
	              }
	            });

	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };
	  /** 检查媒体设备信息是否可用，判断标准为 deviceId 和 label 不能为空 */


	  DeviceManager.prototype.checkMediaDeviceInfoIsOk = function (info) {
	    var audioDevices = filter$2(info).call(info, function (i) {
	      return i.kind === "audioinput";
	    });

	    var videoDevices = filter$2(info).call(info, function (i) {
	      return i.kind === "videoinput";
	    });

	    var result = {
	      audio: false,
	      video: false
	    };

	    for (var _i = 0, audioDevices_1 = audioDevices; _i < audioDevices_1.length; _i++) {
	      var device = audioDevices_1[_i];

	      if (!!device.label && !!device.deviceId) {
	        result.audio = true;
	        break;
	      }
	    }

	    for (var _a = 0, videoDevices_1 = videoDevices; _a < videoDevices_1.length; _a++) {
	      var device = videoDevices_1[_a];

	      if (!!device.label && !!device.deviceId) {
	        result.video = true;
	        break;
	      }
	    }

	    return result;
	  };

	  return DeviceManager;
	}(EventEmitter$1);
	var deviceManager = new DeviceManager();

	var slice$4 = [].slice;
	var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check

	var wrap$1 = function (scheduler) {
	  return function (handler, timeout /* , ...arguments */) {
	    var boundArgs = arguments.length > 2;
	    var args = boundArgs ? slice$4.call(arguments, 2) : undefined;
	    return scheduler(boundArgs ? function () {
	      // eslint-disable-next-line no-new-func
	      (typeof handler == 'function' ? handler : Function(handler)).apply(this, args);
	    } : handler, timeout);
	  };
	};

	// ie9- setTimeout & setInterval additional parameters fix
	// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers
	_export({ global: true, bind: true, forced: MSIE }, {
	  // `setTimeout` method
	  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout
	  setTimeout: wrap$1(global_1.setTimeout),
	  // `setInterval` method
	  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval
	  setInterval: wrap$1(global_1.setInterval)
	});

	var setTimeout$1 = path.setTimeout;

	var setTimeout$2 = setTimeout$1;

	var __assign$2 = undefined && undefined.__assign || function () {
	  __assign$2 = assign$2 || function (t) {
	    for (var s, i = 1, n = arguments.length; i < n; i++) {
	      s = arguments[i];

	      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	    }

	    return t;
	  };

	  return __assign$2.apply(this, arguments);
	};

	var __awaiter$4 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = promise$3))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var __generator$4 = undefined && undefined.__generator || function (thisArg, body) {
	  var _ = {
	    label: 0,
	    sent: function () {
	      if (t[0] & 1) throw t[1];
	      return t[1];
	    },
	    trys: [],
	    ops: []
	  },
	      f,
	      y,
	      t,
	      g;
	  return g = {
	    next: verb(0),
	    "throw": verb(1),
	    "return": verb(2)
	  }, typeof symbol$2 === "function" && (g[iterator$2] = function () {
	    return this;
	  }), g;

	  function verb(n) {
	    return function (v) {
	      return step([n, v]);
	    };
	  }

	  function step(op) {
	    if (f) throw new TypeError("Generator is already executing.");

	    while (_) try {
	      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	      if (y = 0, t) op = [op[0] & 2, t.value];

	      switch (op[0]) {
	        case 0:
	        case 1:
	          t = op;
	          break;

	        case 4:
	          _.label++;
	          return {
	            value: op[1],
	            done: false
	          };

	        case 5:
	          _.label++;
	          y = op[1];
	          op = [0];
	          continue;

	        case 7:
	          op = _.ops.pop();

	          _.trys.pop();

	          continue;

	        default:
	          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
	            _ = 0;
	            continue;
	          }

	          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
	            _.label = op[1];
	            break;
	          }

	          if (op[0] === 6 && _.label < t[1]) {
	            _.label = t[1];
	            t = op;
	            break;
	          }

	          if (t && _.label < t[2]) {
	            _.label = t[2];

	            _.ops.push(op);

	            break;
	          }

	          if (t[2]) _.ops.pop();

	          _.trys.pop();

	          continue;
	      }

	      op = body.call(thisArg, _);
	    } catch (e) {
	      op = [6, e];
	      y = 0;
	    } finally {
	      f = t = 0;
	    }

	    if (op[0] & 5) throw op[1];
	    return {
	      value: op[0] ? op[1] : void 0,
	      done: true
	    };
	  }
	};
	var sendBytes = 0;
	var recvBytes = 0;
	/**
	 * 只可能发生 4 种错误
	 * - OPERATION_ABORTED 请求操作中止
	 * - NETWORK_TIMEOUT 请求超时
	 * - NETWORK_RESPONSE_ERROR 响应错误，一般是状态码非法
	 * - NETWORK_ERROR 无法定位的网络错误
	 */

	function post$1(url, options, isProtobuf) {
	  return new promise$3(function (resolve, reject) {
	    options.timeout = options.timeout || getParameter("HTTP_CONNECT_TIMEOUT");
	    options.responseType = options.responseType || "json";

	    if (options.data && !isProtobuf) {
	      options.data = stringify$2(options.data);
	      sendBytes += getUTF8StringByteLength(options.data);
	    } else if (isProtobuf) sendBytes += options.data.size;

	    options.headers = options.headers || {};
	    options.headers["Content-Type"] = options.headers["Content-Type"] || "application/json";
	    options.method = "POST";
	    options.url = url;
	    axios$1.request(options).then(function (res) {
	      if (typeof res.data === "string") {
	        recvBytes += getUTF8StringByteLength(res.data);
	      } else if (res.data instanceof ArrayBuffer || res.data instanceof Uint8Array) {
	        recvBytes += res.data.byteLength;
	      } else {
	        recvBytes += getUTF8StringByteLength(stringify$2(res.data));
	      }

	      resolve(res.data);
	    }).catch(function (e) {
	      if (axios$1.isCancel(e)) {
	        reject(new AgoraRTCError(AgoraRTCErrorCode.OPERATION_ABORTED, "cancel token canceled"));
	      } else if (e.code === "ECONNABORTED") {
	        /** axios time out
	         * https://github.com/axios/axios/blob/503418718f669fcc674719fd862b355605d7b41f/lib/adapters/xhr.js
	         */
	        reject(new AgoraRTCError(AgoraRTCErrorCode.NETWORK_TIMEOUT, e.message));
	      } else if (!e.response) {
	        reject(new AgoraRTCError(AgoraRTCErrorCode.NETWORK_ERROR, e.message));
	      } else {
	        /** response error (status code error) */
	        reject(new AgoraRTCError(AgoraRTCErrorCode.NETWORK_RESPONSE_ERROR, e.response.status));
	      }
	    });
	  });
	}
	/**
	 * 使用 Protobuf 数据发起 post 请求。
	 */

	function postProtobuf(url, options) {
	  return __awaiter$4(this, void 0, void 0, function () {
	    var blob, response, e_1;
	    return __generator$4(this, function (_a) {
	      switch (_a.label) {
	        case 0:
	          blob = new Blob([options.data], {
	            type: "buffer"
	          });
	          _a.label = 1;

	        case 1:
	          _a.trys.push([1, 3,, 4]);

	          return [4
	          /*yield*/
	          , post$1(url, __assign$2(__assign$2({}, options), {
	            data: blob,
	            headers: {
	              "Content-Type": "application/octet-stream"
	            }
	          }), true)];

	        case 2:
	          response = _a.sent();
	          return [3
	          /*break*/
	          , 4];

	        case 3:
	          e_1 = _a.sent();
	          throw e_1;

	        case 4:
	          return [2
	          /*return*/
	          , response];
	      }
	    });
	  });
	}

	var getProtobuf = function (key, properties) {
	  var object = events_pb.Events[key].create(properties);
	  var protobuf = events_pb.Events[key].encode(object).finish();
	  return protobuf;
	};

	var __assign$3 = undefined && undefined.__assign || function () {
	  __assign$3 = assign$2 || function (t) {
	    for (var s, i = 1, n = arguments.length; i < n; i++) {
	      s = arguments[i];

	      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	    }

	    return t;
	  };

	  return __assign$3.apply(this, arguments);
	};

	var __awaiter$5 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = promise$3))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var __generator$5 = undefined && undefined.__generator || function (thisArg, body) {
	  var _ = {
	    label: 0,
	    sent: function () {
	      if (t[0] & 1) throw t[1];
	      return t[1];
	    },
	    trys: [],
	    ops: []
	  },
	      f,
	      y,
	      t,
	      g;
	  return g = {
	    next: verb(0),
	    "throw": verb(1),
	    "return": verb(2)
	  }, typeof symbol$2 === "function" && (g[iterator$2] = function () {
	    return this;
	  }), g;

	  function verb(n) {
	    return function (v) {
	      return step([n, v]);
	    };
	  }

	  function step(op) {
	    if (f) throw new TypeError("Generator is already executing.");

	    while (_) try {
	      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	      if (y = 0, t) op = [op[0] & 2, t.value];

	      switch (op[0]) {
	        case 0:
	        case 1:
	          t = op;
	          break;

	        case 4:
	          _.label++;
	          return {
	            value: op[1],
	            done: false
	          };

	        case 5:
	          _.label++;
	          y = op[1];
	          op = [0];
	          continue;

	        case 7:
	          op = _.ops.pop();

	          _.trys.pop();

	          continue;

	        default:
	          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
	            _ = 0;
	            continue;
	          }

	          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
	            _.label = op[1];
	            break;
	          }

	          if (op[0] === 6 && _.label < t[1]) {
	            _.label = t[1];
	            t = op;
	            break;
	          }

	          if (t && _.label < t[2]) {
	            _.label = t[2];

	            _.ops.push(op);

	            break;
	          }

	          if (t[2]) _.ops.pop();

	          _.trys.pop();

	          continue;
	      }

	      op = body.call(thisArg, _);
	    } catch (e) {
	      op = [6, e];
	      y = 0;
	    } finally {
	      f = t = 0;
	    }

	    if (op[0] & 5) throw op[1];
	    return {
	      value: op[0] ? op[1] : void 0,
	      done: true
	    };
	  }
	};

	var __spreadArrays$1 = undefined && undefined.__spreadArrays || function () {
	  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

	  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

	  return r;
	};

	var AgoraRTCEventReport =
	/** @class */
	function () {
	  function AgoraRTCEventReport() {
	    var _context, _context2;

	    /**
	     * 以 sessionID 为 key 存储每次上报都需要带上的基本信息
	     */
	    this.baseInfoMap = new map$2();
	    this.clientList = CLIENT_LIST;
	    /**
	     * 等待上报的事件信息
	     */

	    /** 高优先级的上报信息，立刻上报不会合并 */

	    this.keyEventUploadPendingItems = [];
	    /** 低优先级的上报信息，会根据时间和事件数合并上报 */

	    this.normalEventUploadPendingItems = [];
	    /**
	     * NOTE:
	     * 高优先级的上报逻辑：
	     *  - 触发后立刻加入 keyEvents 队列
	     *  - 加入队列后立刻将队列中全部数据上报，清空队列
	     * > 如果此时队列长度 > 20, 只上报最先入队的 20 个，其余的留在队列中
	     *  - 如果上报失败，将这些数据加回 keyEvents 队列，但是不会触发重试
	     *
	     * 低优先级上报逻辑：
	     *  - 触发后立刻加入 normalEvents 队列
	     * > 如果此时队列长度 > 100, drop 最早入队的数据
	     *  - 如果 normalEvents 长度 > 10, 将队列中的数据全部上报，清空队列
	     * > 如果此时队列长度 > 20, 只上报最先入队的 20 个，其余的留在队列中
	     *  - 如果上报失败，将这些数据加回 normalEvents 队列，但是不会触发重试
	     *
	     * 同时，reports 还会启动一个 3s 执行一次的定时器，定时器的逻辑：
	     *  - 检查 keyEvents 队列，如果发现有值，立刻全部上报并清空队列
	     *  - 检查 normalEvents 队列，如果发现有值并且距离上一次上报 normalEvents 已经过去了 5s，将队列中的数据全部上报，清空队列
	     * > 如果此时队列长度 > 20, 只上报最先入队的 20 个，其余的留在队列中
	     *
	     */

	    /**
	     * 如果调用 api 时还没有拿到 session id，就先缓存在这里
	     */

	    this.apiInvokeUploadPendingItems = [];
	    this.apiInvokeCount = 0;
	    /** 防止上报数据的 lts 字段重复 */

	    this.ltsList = [];
	    /** 上一次上报低优先级事件的时间 */

	    this.lastSendNormalEventTime = now$2();
	    this.customReportCount = 0;
	    this.eventUploadTimer = window.setInterval(bind$3(_context = this.doSend).call(_context, this), getParameter("EVENT_REPORT_SEND_INTERVAL"));
	    this.setSessionIdTimer = window.setInterval(bind$3(_context2 = this.appendSessionId).call(_context2, this), getParameter("EVENT_REPORT_SEND_INTERVAL"));
	  }

	  AgoraRTCEventReport.prototype.reportApiInvoke = function (sessionId, params, throttleTime) {
	    var _this = this;

	    params.timeout = params.timeout || 60 * 1000;
	    params.reportResult = params.reportResult === undefined ? true : params.reportResult;

	    var apiInvokeTime = now$2();

	    this.apiInvokeCount += 1;
	    var invokeId = this.apiInvokeCount;

	    var getApiInvokeParameters = function () {
	      return {
	        tag: params.tag,
	        invokeId: invokeId,
	        sid: sessionId,
	        name: params.name,
	        apiInvokeTime: apiInvokeTime,
	        options: params.options
	      };
	    };

	    var showInvokerLog = !!getParameter("SHOW_REPORT_INVOKER_LOG");

	    if (showInvokerLog) {
	      logger.info(params.name + " start", params.options);
	    }

	    var isApiInvokeEnd = false;
	    wait(params.timeout).then(function () {
	      if (!isApiInvokeEnd) {
	        _this.sendApiInvoke(__assign$3(__assign$3({}, getApiInvokeParameters()), {
	          error: AgoraRTCErrorCode.API_INVOKE_TIMEOUT,
	          success: false
	        }));

	        logger.debug(params.name + " timeout");
	      }
	    });
	    var err = new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_ERROR, params.name + ": this api invoke is end");
	    return {
	      onSuccess: function (value) {
	        var onSuccessFn = function () {
	          if (isApiInvokeEnd) {
	            throw err;
	          }

	          isApiInvokeEnd = true;

	          _this.sendApiInvoke(__assign$3(__assign$3(__assign$3({}, getApiInvokeParameters()), {
	            success: true
	          }), params.reportResult && {
	            result: value
	          }));

	          if (showInvokerLog) {
	            logger.info(params.name + " onSuccess");
	          }

	          return value;
	        };

	        if (throttleTime) {
	          return throttleByKey(onSuccessFn, params.name + "Success", throttleTime, function () {
	            return isApiInvokeEnd = true;
	          });
	        }

	        return onSuccessFn();
	      },
	      onError: function (err) {
	        var onErrorFn = function () {
	          if (isApiInvokeEnd) {
	            throw err;
	          }

	          isApiInvokeEnd = true;

	          _this.sendApiInvoke(__assign$3(__assign$3({}, getApiInvokeParameters()), {
	            success: false,
	            error: err.toString()
	          }));

	          if (showInvokerLog) {
	            logger.info(params.name + " onFailure", err.toString());
	          }
	        };

	        if (throttleTime) {
	          return throttleByKey(onErrorFn, params.name + "Error", throttleTime, function () {
	            return isApiInvokeEnd = true;
	          });
	        }

	        return onErrorFn();
	      }
	    };
	  };

	  AgoraRTCEventReport.prototype.sessionInit = function (sessionId, params) {
	    // 重复的 sessionInit, 只有 sessionId 发生变化的时候才会上报 sessionInit
	    if (this.baseInfoMap.has(sessionId)) {
	      return;
	    }

	    var startTime = now$2();

	    var baseInfo = this.createBaseInfo(sessionId, startTime);
	    baseInfo.cname = params.cname;

	    var extend = assign$2({}, {
	      willUploadConsoleLog: getParameter("UPLOAD_LOG"),
	      areaVersion: IS_GLOBAL_VERSION ? "global" : "oversea",
	      areas: getParameter("AREAS") && getParameter("AREAS").join(",")
	    }, params.extend);

	    var now = now$2();

	    var sessionInfo = __assign$3(__assign$3({}, baseInfo), {
	      eventType: AgoraRTCEvent.SESSION_INIT,
	      appid: params.appid,
	      browser: navigator.userAgent,
	      build: BUILD,
	      lts: now,
	      elapse: now - startTime,
	      extend: stringify$2(extend),
	      mode: params.mode,
	      process: getParameter("PROCESS_ID"),
	      success: true,
	      version: VERSION
	    });

	    this.send({
	      type: AgoraRTCEventUploadType.SESSION,
	      data: sessionInfo
	    }, true);
	  };

	  AgoraRTCEventReport.prototype.joinChooseServer = function (sessionId, params) {
	    var base = this.baseInfoMap.get(sessionId);
	    if (!base) return;
	    var baseInfo = base.info;

	    var now = now$2();

	    var joinChooseServerInfo = __assign$3(__assign$3({}, baseInfo), {
	      eventType: AgoraRTCEvent.JOIN_CHOOSE_SERVER,
	      lts: now,
	      eventElapse: now - params.lts,
	      chooseServerAddr: params.csAddr,
	      errorCode: params.ec,
	      elapse: now - base.startTime,
	      success: params.succ,
	      chooseServerAddrList: stringify$2(params.serverList),
	      uid: params.uid ? _parseInt$3(params.uid) : null,
	      cid: params.cid ? _parseInt$3(params.cid) : null
	    });

	    this.send({
	      type: AgoraRTCEventUploadType.JOIN_CHOOSE_SERVER,
	      data: joinChooseServerInfo
	    }, true);
	  };

	  AgoraRTCEventReport.prototype.reqUserAccount = function (sessionId, params) {
	    var base = this.baseInfoMap.get(sessionId);
	    if (!base) return;
	    var baseInfo = base.info;

	    var now = now$2();

	    var reqUserAccountInfo = __assign$3(__assign$3({}, baseInfo), {
	      eventType: AgoraRTCEvent.REQ_USER_ACCOUNT,
	      lts: now,
	      success: params.success,
	      serverAddress: params.serverAddr,
	      stringUid: params.stringUid,
	      uid: params.uid,
	      errorCode: params.errorCode,
	      elapse: now - base.startTime,
	      eventElapse: now - params.lts,
	      extend: stringify$2(params.extend)
	    });

	    this.send({
	      type: AgoraRTCEventUploadType.REQ_USER_ACCOUNT,
	      data: reqUserAccountInfo
	    }, true);
	  };

	  AgoraRTCEventReport.prototype.joinGateway = function (sessionId, params) {
	    var base = this.baseInfoMap.get(sessionId);
	    if (!base) return;
	    var baseInfo = base.info;

	    if (params.vid) {
	      baseInfo.vid = params.vid;
	    }

	    baseInfo.uid = params.uid;
	    baseInfo.cid = params.cid;

	    var now = now$2();

	    var joinGatewayInfo = __assign$3(__assign$3({}, baseInfo), {
	      eventType: AgoraRTCEvent.JOIN_GATEWAY,
	      lts: now,
	      gatewayAddr: params.addr,
	      success: params.succ,
	      errorCode: params.ec,
	      elapse: now - base.startTime,
	      eventElapse: now - params.lts
	    });

	    if (params.succ) {
	      base.lastJoinSuccessTime = now;
	    }

	    this.send({
	      type: AgoraRTCEventUploadType.JOIN_GATEWAT,
	      data: joinGatewayInfo
	    }, true);
	  };

	  AgoraRTCEventReport.prototype.joinChannelTimeout = function (sessionId, timeout) {
	    var base = this.baseInfoMap.get(sessionId);
	    if (!base) return;

	    var lts = now$2();

	    var message = __assign$3(__assign$3({}, base.info), {
	      lts: lts,
	      timeout: timeout,
	      elapse: lts - base.startTime
	    });

	    this.send({
	      type: AgoraRTCEventUploadType.JOIN_CHANNEL_TIMEOUT,
	      data: message
	    }, true);
	  };

	  AgoraRTCEventReport.prototype.publish = function (sessionId, params) {
	    var base = this.baseInfoMap.get(sessionId);
	    if (!base) return;
	    var baseInfo = base.info;

	    var now = now$2();

	    var publishInfo = __assign$3(__assign$3({}, baseInfo), {
	      eventType: AgoraRTCEvent.PUBLISH,
	      lts: now,
	      eventElapse: now - params.lts,
	      elapse: now - base.startTime,
	      success: params.succ,
	      errorCode: params.ec,
	      videoName: params.videoName,
	      audioName: params.audioName,
	      screenName: params.screenName,
	      screenshare: params.screenshare,
	      audio: params.audio,
	      video: params.video,
	      p2pid: params.p2pid,
	      publishRequestid: params.publishRequestid
	    });

	    this.send({
	      type: AgoraRTCEventUploadType.PUBLISH,
	      data: publishInfo
	    }, true);
	  };

	  AgoraRTCEventReport.prototype.subscribe = function (sessionId, params) {
	    var base = this.baseInfoMap.get(sessionId);
	    if (!base) return;
	    var baseInfo = base.info;

	    var now = now$2();

	    var subscribeInfo = __assign$3(__assign$3({}, baseInfo), {
	      eventType: AgoraRTCEvent.SUBSCRIBE,
	      lts: now,
	      eventElapse: now - params.lts,
	      elapse: now - base.startTime,
	      success: params.succ,
	      errorCode: params.ec,
	      video: params.video,
	      audio: params.audio,
	      subscribeRequestid: params.subscribeRequestid,
	      p2pid: params.p2pid
	    });

	    if (typeof params.peerid === "string") {
	      subscribeInfo.peerSuid = params.peerid;
	    } else {
	      subscribeInfo.peer = params.peerid;
	    }

	    this.send({
	      type: AgoraRTCEventUploadType.SUBSCRIBE,
	      data: subscribeInfo
	    }, true);
	  };

	  AgoraRTCEventReport.prototype.firstRemoteFrame = function (sessionId, eventType, uploadType, params) {
	    var base = this.baseInfoMap.get(sessionId);
	    if (!base) return;
	    var baseInfo = base.info;

	    var now = now$2();

	    var info = __assign$3(__assign$3(__assign$3({}, baseInfo), params), {
	      elapse: now - base.startTime,
	      eventType: eventType,
	      lts: now
	    });

	    this.send({
	      type: uploadType,
	      data: info
	    }, true);
	  };

	  AgoraRTCEventReport.prototype.onGatewayStream = function (sessionId, eventType, uploadType, params) {
	    var base = this.baseInfoMap.get(sessionId);
	    if (!base) return;
	    var baseInfo = base.info;

	    var now = now$2();

	    var info = __assign$3(__assign$3(__assign$3({}, baseInfo), params), {
	      eventType: eventType,
	      lts: now
	    });

	    this.send({
	      type: uploadType,
	      data: info
	    }, true);
	  };

	  AgoraRTCEventReport.prototype.streamSwitch = function (sessionId, params) {
	    var base = this.baseInfoMap.get(sessionId);
	    if (!base) return;
	    var baseInfo = base.info;

	    var now = now$2();

	    var streamSwitchInfo = __assign$3(__assign$3({}, baseInfo), {
	      eventType: AgoraRTCEvent.STREAM_SWITCH,
	      lts: now,
	      isDual: params.isdual,
	      elapse: now - base.startTime,
	      success: params.succ
	    });

	    this.send({
	      type: AgoraRTCEventUploadType.STREAM_SWITCH,
	      data: streamSwitchInfo
	    }, true);
	  };

	  AgoraRTCEventReport.prototype.requestProxyAppCenter = function (sessionId, params) {
	    var base = this.baseInfoMap.get(sessionId);
	    if (!base) return;
	    var baseInfo = base.info;

	    var now = now$2();

	    var requestProxyAppCenterInfo = __assign$3(__assign$3({}, baseInfo), {
	      eventType: AgoraRTCEvent.REQUEST_PROXY_APPCENTER,
	      lts: now,
	      eventElapse: now - params.lts,
	      elapse: now - base.startTime,
	      APAddr: params.APAddr,
	      workerManagerList: params.workerManagerList,
	      response: params.response,
	      errorCode: params.ec,
	      success: params.succ
	    });

	    this.send({
	      type: AgoraRTCEventUploadType.REQUEST_PROXY_APPCENTER,
	      data: requestProxyAppCenterInfo
	    }, true);
	  };

	  AgoraRTCEventReport.prototype.requestProxyWorkerManager = function (sessionId, params) {
	    var base = this.baseInfoMap.get(sessionId);
	    if (!base) return;
	    var baseInfo = base.info;

	    var now = now$2();

	    var requestProxyWorkerManagerInfo = __assign$3(__assign$3({}, baseInfo), {
	      eventType: AgoraRTCEvent.REQUEST_PROXY_WORKER_MANAGER,
	      lts: now,
	      eventElapse: now - params.lts,
	      elapse: now - base.startTime,
	      workerManagerAddr: params.workerManagerAddr,
	      response: params.response,
	      errorCode: params.ec,
	      success: params.succ
	    });

	    this.send({
	      type: AgoraRTCEventUploadType.REQUEST_PROXY_WORKER_MANAGER,
	      data: requestProxyWorkerManagerInfo
	    }, true);
	  };

	  AgoraRTCEventReport.prototype.setProxyServer = function (url) {
	    this.proxyServer = url;

	    if (url) {
	      logger.debug("reportProxyServerurl: " + url);
	    } else {
	      logger.debug("disable reportProxyServerurl: " + url);
	    }
	  };

	  AgoraRTCEventReport.prototype.peerPublishStatus = function (sessionId, params) {
	    var base = this.baseInfoMap.get(sessionId);
	    if (!base) return;
	    var baseInfo = base.info;

	    var now = now$2();

	    var message = __assign$3(__assign$3({}, baseInfo), {
	      subscribeElapse: params.subscribeElapse,
	      peer: params.peer,
	      peerPublishDuration: Math.max(params.audioPublishDuration, params.videoPublishDuration),
	      audiotag: params.audioPublishDuration > 0 ? 1 : -1,
	      videotag: params.videoPublishDuration > 0 ? 1 : -1,
	      lts: now,
	      elapse: now - base.startTime,
	      joinChannelSuccessElapse: now - (base.lastJoinSuccessTime || now)
	    });

	    this.send({
	      type: AgoraRTCEventUploadType.PEER_PUBLISH_STATUS,
	      data: message
	    }, true);
	  };

	  AgoraRTCEventReport.prototype.workerEvent = function (sessionId, params) {
	    var _this = this;

	    var base = this.baseInfoMap.get(sessionId);
	    if (!base) return;
	    var baseInfo = base.info;

	    var now = now$2();

	    var messageBase = __assign$3(__assign$3(__assign$3({}, baseInfo), params), {
	      elapse: now - base.startTime,
	      lts: now,
	      productType: "WebRTC"
	    });

	    var messages = dividePackage(messageBase, "payload", 1300);

	    forEach$3(messages).call(messages, function (message) {
	      return _this.send({
	        type: "WorkerEvent",
	        data: message,
	        isPb: true,
	        id: 156
	      }, true);
	    });
	  };

	  AgoraRTCEventReport.prototype.apworkerEvent = function (sessionId, params) {
	    var base = this.baseInfoMap.get(sessionId);
	    if (!base) return;
	    var baseInfo = base.info;

	    var now = now$2();

	    var message = __assign$3(__assign$3(__assign$3({}, baseInfo), params), {
	      elapse: now - base.startTime,
	      lts: now
	    });

	    this.send({
	      type: "APWorkerEvent",
	      data: message,
	      isPb: true,
	      id: 160
	    }, true);
	  };

	  AgoraRTCEventReport.prototype.sendCustomReportMessage = function (sessionId, params) {
	    return __awaiter$5(this, void 0, void 0, function () {
	      var items, body, e_1;

	      var _this = this;

	      return __generator$5(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            this.customReportCount += params.length;

	            if (this.customReportCount > getParameter("CUSTOM_REPORT_LIMIT")) {
	              throw new AgoraRTCError(AgoraRTCErrorCode.CUSTOM_REPORT_FREQUENCY_TOO_HIGH);
	            }

	            if (!this.customReportCounterTimer) {
	              this.customReportCounterTimer = window.setInterval(function () {
	                _this.customReportCount = 0;
	              }, 5000);
	            }

	            items = map$5(params).call(params, function (param) {
	              return {
	                type: AgoraRTCEventUploadType.USER_ANALYTICS,
	                data: __assign$3({
	                  sid: sessionId
	                }, param)
	              };
	            });
	            body = {
	              msgType: "EventMessages",
	              sentTs: Math.round(now$2() / 1000),
	              payloads: map$5(items).call(items, function (item) {
	                return stringify$2(item);
	              })
	            };
	            _a.label = 1;

	          case 1:
	            _a.trys.push([1, 3,, 4]);

	            return [4
	            /*yield*/
	            , this.postDataToStatsCollector(body)];

	          case 2:
	            _a.sent();

	            return [3
	            /*break*/
	            , 4];

	          case 3:
	            e_1 = _a.sent();
	            logger.error("send custom report message failed", e_1.toString());
	            throw new AgoraRTCError(AgoraRTCErrorCode.CUSTOM_REPORT_SEND_FAILED, e_1.message);

	          case 4:
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  AgoraRTCEventReport.prototype.sendApiInvoke = function (item) {
	    var notReportEvents = getParameter("NOT_REPORT_EVENT");
	    if (item.tag && includes$4(notReportEvents) && includes$4(notReportEvents).call(notReportEvents, item.tag)) return;

	    if (item.sid === null) {
	      this.apiInvokeUploadPendingItems.push(item);
	      return;
	    }

	    var base = this.baseInfoMap.get(item.sid);

	    if (!base) {
	      /** 如果没有提供 sid，进入 pending 队列 */
	      this.apiInvokeUploadPendingItems.push(item);
	      return;
	    }

	    var _a = base.info,
	        cname = _a.cname,
	        uid = _a.uid,
	        cid = _a.cid;
	    item.lts = item.lts || now$2();
	    var data = {
	      invokeId: item.invokeId,
	      sid: item.sid,
	      cname: cname,
	      cid: cid,
	      uid: uid,
	      lts: item.lts,
	      success: item.success,
	      elapse: item.lts - base.startTime,
	      execElapse: item.lts - item.apiInvokeTime,
	      apiName: item.name,
	      options: item.options ? stringify$2(item.options) : undefined,
	      execStates: item.states ? stringify$2(item.states) : undefined,
	      execResult: item.result ? stringify$2(item.result) : undefined,
	      errorCode: item.error ? stringify$2(item.error) : undefined
	    };
	    this.send({
	      type: AgoraRTCEventUploadType.API_INVOKE,
	      data: data
	    }, false);
	  };

	  AgoraRTCEventReport.prototype.appendSessionId = function () {
	    var _context3;

	    var _this = this;

	    var canClearPendingItems = false;

	    forEach$3(_context3 = this.clientList).call(_context3, function (client) {
	      if (client._sessionId) {
	        var _context4;

	        forEach$3(_context4 = _this.apiInvokeUploadPendingItems).call(_context4, function (item) {
	          item.sid = client._sessionId;

	          _this.sendApiInvoke(assign$2({}, item));
	        });

	        canClearPendingItems = true;
	      }
	    });

	    if (canClearPendingItems) this.apiInvokeUploadPendingItems = [];
	  };

	  AgoraRTCEventReport.prototype.send = function (item, isKeyEvent) {
	    if (isKeyEvent) {
	      this.keyEventUploadPendingItems.push(item);
	      this.sendItems(this.keyEventUploadPendingItems, true);
	      return;
	    }

	    this.normalEventUploadPendingItems.push(item);

	    if (this.normalEventUploadPendingItems.length > getParameter("NORMAL_EVENT_QUEUE_CAPACITY")) {
	      var _context5;

	      splice$2(_context5 = this.normalEventUploadPendingItems).call(_context5, 0, 1);
	    }

	    if (this.normalEventUploadPendingItems.length >= 10) {
	      this.sendItems(this.normalEventUploadPendingItems, false);
	    }
	  };

	  AgoraRTCEventReport.prototype.doSend = function () {
	    /**
	     * 先检查关键事件是否有需要发送的
	     */
	    if (this.keyEventUploadPendingItems.length > 0) {
	      this.sendItems(this.keyEventUploadPendingItems, true);
	    }

	    if (this.normalEventUploadPendingItems.length > 0 && now$2() - this.lastSendNormalEventTime >= 5000) {
	      this.sendItems(this.normalEventUploadPendingItems, false);
	    }
	  };

	  AgoraRTCEventReport.prototype.sendItems = function (inputItems, isKey) {
	    var _this = this;
	    /** 待上报的 json 事件队列 */


	    var jsonItems = [];
	    /** 待上报的 protobuf 事件队列 */

	    var pbItems = [];
	    var remainInputItems = [];
	    /** 一次最多同时上报 20 个 */

	    while (inputItems.length) {
	      var item = inputItems.shift();

	      if (isProtobufItem(item)) {
	        pbItems.length < 20 ? pbItems.push(item) : remainInputItems.push(item);
	      } else {
	        jsonItems.length < 20 ? jsonItems.push(item) : remainInputItems.push(item);
	      }
	    }

	    inputItems.push.apply(inputItems, remainInputItems);

	    for (var _i = 0, _a = __spreadArrays$1(jsonItems, pbItems); _i < _a.length; _i++) {
	      var _context6;

	      var item = _a[_i]; // lts 重复

	      if (indexOf$3(_context6 = this.ltsList).call(_context6, item.data.lts) !== -1) {
	        item.data.lts = this.ltsList[this.ltsList.length - 1] + 1;
	        this.ltsList.push(item.data.lts);
	      } else {
	        var _context7;

	        // lts 没有重复，记录这个 lts
	        this.ltsList.push(item.data.lts);

	        sort$2(_context7 = this.ltsList).call(_context7, function (a, b) {
	          return a - b;
	        });
	      }
	    }

	    if (!isKey) this.lastSendNormalEventTime = now$2();
	    var jsonBody = {
	      msgType: "EventMessages",
	      sentTs: Math.round(now$2() / 1000),
	      payloads: map$5(jsonItems).call(jsonItems, function (item) {
	        return stringify$2(item);
	      })
	    }; // TODO: WAIT PROTO FILE TO MAKE PROTOBUF BODY

	    var pbBody = getProtobuf("ProtoRaws", {
	      sentTs: Math.round(now$2() / 1000),
	      payloads: map$5(pbItems).call(pbItems, function (item) {
	        return {
	          id: item.id,
	          msg: getProtobuf(item.type, item.data)
	        };
	      })
	    });

	    var errorHandler = function (items) {
	      return function (e) {
	        // 上报失败
	        if (isKey) {
	          var _context8;

	          _this.keyEventUploadPendingItems = concat$2(_context8 = _this.keyEventUploadPendingItems).call(_context8, items);
	        } else {
	          var _context9;

	          _this.normalEventUploadPendingItems = concat$2(_context9 = _this.normalEventUploadPendingItems).call(_context9, items);

	          if (_this.normalEventUploadPendingItems.length > getParameter("NORMAL_EVENT_QUEUE_CAPACITY")) {
	            var _context10;

	            splice$2(_context10 = _this.normalEventUploadPendingItems).call(_context10, 0, _this.normalEventUploadPendingItems.length - getParameter("NORMAL_EVENT_QUEUE_CAPACITY"));

	            logger.warning("report: drop normal events");
	          }
	        }
	      };
	    };

	    pbItems.length && this.postDataToStatsCollector(pbBody, true).catch(errorHandler(pbItems));
	    jsonItems.length && this.postDataToStatsCollector(jsonBody).catch(errorHandler(jsonItems));
	    return inputItems;
	  };

	  AgoraRTCEventReport.prototype.postDataToStatsCollector = function (body, isProtobuf) {
	    if (isProtobuf === void 0) {
	      isProtobuf = false;
	    }

	    return __awaiter$5(this, void 0, void 0, function () {
	      var eventUploadUrlTail, url, i, _a, e_2;

	      return __generator$5(this, function (_b) {
	        switch (_b.label) {
	          case 0:
	            eventUploadUrlTail = isProtobuf ? "/events/proto-raws" : "/events/messages";
	            url = this.proxyServer ? "https://" + this.proxyServer + "/rs/?h=" + getParameter("EVENT_REPORT_DOMAIN") + "&p=6443&d=" + eventUploadUrlTail : "https://" + getParameter("EVENT_REPORT_DOMAIN") + ":6443" + eventUploadUrlTail;
	            i = 0;
	            _b.label = 1;

	          case 1:
	            if (!(i < 2)) return [3
	            /*break*/
	            , 10];

	            if (i === 1) {
	              url = this.proxyServer ? "https://" + this.proxyServer + "/rs/?h=" + getParameter("EVENT_REPORT_BACKUP_DOMAIN") + "&p=6443&d=" + eventUploadUrlTail : "https://" + getParameter("EVENT_REPORT_BACKUP_DOMAIN") + ":6443" + eventUploadUrlTail;
	            }

	            _b.label = 2;

	          case 2:
	            _b.trys.push([2, 7,, 8]);

	            if (!isProtobuf) return [3
	            /*break*/
	            , 4];
	            return [4
	            /*yield*/
	            , postProtobuf(url, {
	              timeout: 10000,
	              data: body
	            })];

	          case 3:
	            _a = _b.sent();
	            return [3
	            /*break*/
	            , 6];

	          case 4:
	            return [4
	            /*yield*/
	            , post$1(url, {
	              timeout: 10000,
	              data: body
	            })];

	          case 5:
	            _a = _b.sent();
	            _b.label = 6;

	          case 6:
	            return [3
	            /*break*/
	            , 8];

	          case 7:
	            e_2 = _b.sent();

	            if (i === 1) {
	              throw e_2;
	            } else {
	              return [3
	              /*break*/
	              , 9];
	            }

	          case 8:
	            return [2
	            /*return*/
	            ];

	          case 9:
	            i += 1;
	            return [3
	            /*break*/
	            , 1];

	          case 10:
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  AgoraRTCEventReport.prototype.createBaseInfo = function (sessionId, startTime) {
	    var baseInfo = assign$2({}, EVENT_BASE_TEMPLATE);

	    baseInfo.sid = sessionId;
	    this.baseInfoMap.set(sessionId, {
	      info: baseInfo,
	      startTime: startTime
	    });
	    return baseInfo;
	  };

	  return AgoraRTCEventReport;
	}();
	var report = new AgoraRTCEventReport();

	var _a, _b, _c, _d, _e;
	var AP_ERROR_DETAILS = (_a = {}, _a[AP_ERROR_CODE_TYPE.ACCESS_POINT] = (_b = {}, _b[ACCESS_POINT_ERROR_CODE.NO_FLAG_SET] = {
	  desc: "flag is zero",
	  retry: false
	}, _b[ACCESS_POINT_ERROR_CODE.FLAG_SET_BUT_EMPTY] = {
	  desc: "flag is empty",
	  retry: false
	}, _b[ACCESS_POINT_ERROR_CODE.INVALID_FALG_SET] = {
	  desc: "invalid flag",
	  retry: false
	}, _b[ACCESS_POINT_ERROR_CODE.NO_SERVICE_AVAILABLE] = {
	  desc: "no service available",
	  retry: true
	}, _b[ACCESS_POINT_ERROR_CODE.NO_SERVICE_AVAILABLE_P2P] = {
	  desc: "no unilbs p2p service available",
	  retry: true
	}, _b[ACCESS_POINT_ERROR_CODE.NO_SERVICE_AVAILABLE_VOET] = {
	  desc: "no unilbs voice service available",
	  retry: true
	}, _b[ACCESS_POINT_ERROR_CODE.NO_SERVICE_AVAILABLE_WEBRTC] = {
	  desc: "no unilbs webrtc service available",
	  retry: true
	}, _b[ACCESS_POINT_ERROR_CODE.NO_SERVICE_AVAILABLE_CDS] = {
	  desc: "no cds service available",
	  retry: true
	}, _b[ACCESS_POINT_ERROR_CODE.NO_SERVICE_AVAILABLE_CDN] = {
	  desc: "no cdn dispatcher service available",
	  retry: true
	}, _b[ACCESS_POINT_ERROR_CODE.NO_SERVICE_AVAILABLE_TDS] = {
	  desc: "no tds service available",
	  retry: true
	}, _b[ACCESS_POINT_ERROR_CODE.NO_SERVICE_AVAILABLE_REPORT] = {
	  desc: "no unilbs report service available",
	  retry: true
	}, _b[ACCESS_POINT_ERROR_CODE.NO_SERVICE_AVAILABLE_APP_CENTER] = {
	  desc: "no app center service available",
	  retry: true
	}, _b[ACCESS_POINT_ERROR_CODE.NO_SERVICE_AVAILABLE_ENV0] = {
	  desc: "no unilbs sig env0 service available",
	  retry: true
	}, _b[ACCESS_POINT_ERROR_CODE.NO_SERVICE_AVAILABLE_VOET] = {
	  desc: "no unilbs voet service available",
	  retry: true
	}, _b[ACCESS_POINT_ERROR_CODE.NO_SERVICE_AVAILABLE_STRING_UID] = {
	  desc: "no string uid service available",
	  retry: true
	}, _b[ACCESS_POINT_ERROR_CODE.NO_SERVICE_AVAILABLE_WEBRTC_UNILBS] = {
	  desc: "no webrtc unilbs service available",
	  retry: true
	}, _b), _a[AP_ERROR_CODE_TYPE.UNILBS] = (_c = {}, _c[UNILBS_ERROR_CODE.INVALID_VENDOR_KEY] = {
	  desc: "invalid vendor key, can not find appid",
	  retry: false
	}, _c[UNILBS_ERROR_CODE.INVALID_CHANNEL_NAME] = {
	  desc: "invalid channel name",
	  retry: false
	}, _c[UNILBS_ERROR_CODE.INTERNAL_ERROR] = {
	  desc: "unilbs internal error",
	  retry: false
	}, _c[UNILBS_ERROR_CODE.NO_AUTHORIZED] = {
	  desc: "invalid token, authorized failed",
	  retry: false
	}, _c[UNILBS_ERROR_CODE.DYNAMIC_KEY_TIMEOUT] = {
	  desc: "dynamic key or token timeout",
	  retry: false
	}, _c[UNILBS_ERROR_CODE.NO_ACTIVE_STATUS] = {
	  desc: "no active status",
	  retry: false
	}, _c[UNILBS_ERROR_CODE.DYNAMIC_KEY_EXPIRED] = {
	  desc: "dynamic key expired",
	  retry: false
	}, _c[UNILBS_ERROR_CODE.STATIC_USE_DYNAMIC_KEY] = {
	  desc: "static use dynamic key",
	  retry: false
	}, _c[UNILBS_ERROR_CODE.DYNAMIC_USE_STATIC_KEY] = {
	  desc: "dynamic use static key",
	  retry: false
	}, _c[UNILBS_ERROR_CODE.USER_OVERLOAD] = {
	  desc: "amount of users over load",
	  retry: false
	}, _c[UNILBS_ERROR_CODE.FORBIDDEN_REGION] = {
	  desc: "the request is forbidden in this area",
	  retry: false
	}, _c[UNILBS_ERROR_CODE.CANNOT_MEET_AREA_DEMAND] = {
	  desc: "unable to allocate services in this area",
	  retry: false
	}, _c), _a[AP_ERROR_CODE_TYPE.STRING_UID_ALLOCATOR] = (_d = {}, _d[STRING_UID_ALLOCATOR_ERROR_CODE.IIIEGAL_APPID] = {
	  desc: "invalid appid",
	  retry: false
	}, _d[STRING_UID_ALLOCATOR_ERROR_CODE.IIIEGAL_UID] = {
	  desc: "invalid string uid",
	  retry: false
	}, _d[STRING_UID_ALLOCATOR_ERROR_CODE.INTERNAL_ERROR] = {
	  desc: "string uid allocator internal error",
	  retry: true
	}, _d), _a);
	function getApErrorDetail(code) {
	  var errorType = AP_ERROR_DETAILS[Math.floor(code / 10000)];

	  if (!errorType) {
	    return {
	      desc: "unkonw error",
	      retry: false
	    };
	  }

	  var errorDetails = errorType[code % 10000];

	  if (!errorDetails) {
	    // AP 的 choose server 错误码约定
	    // 1 开头不可重试，2 开头可以重试
	    if (Math.floor(code / 10000) === AP_ERROR_CODE_TYPE.ACCESS_POINT) {
	      var errCode = code % 10000;

	      if (errCode.toString()[0] === "1") {
	        return {
	          desc: errCode.toString(),
	          retry: false
	        };
	      }

	      if (errCode.toString()[0] === "2") {
	        return {
	          desc: errCode.toString(),
	          retry: true
	        };
	      }
	    }

	    return {
	      desc: "unkonw error",
	      retry: false
	    };
	  }

	  return errorDetails;
	}
	var SERVER_ERROR_DETAILS = (_e = {}, _e[GATEWAY_ERROR_CODE.K_TIMESTAMP_EXPIRED] = {
	  desc: "K_TIMESTAMP_EXPIRED",
	  action: "failed"
	}, _e[GATEWAY_ERROR_CODE.K_CHANNEL_PERMISSION_INVALID] = {
	  desc: "K_CHANNEL_PERMISSION_INVALID",
	  action: "failed"
	}, _e[GATEWAY_ERROR_CODE.K_CERTIFICATE_INVALID] = {
	  desc: "K_CERTIFICATE_INVALID",
	  action: "failed"
	}, _e[GATEWAY_ERROR_CODE.K_CHANNEL_NAME_EMPTY] = {
	  desc: "K_CHANNEL_NAME_EMPTY",
	  action: "failed"
	}, _e[GATEWAY_ERROR_CODE.K_CHANNEL_NOT_FOUND] = {
	  desc: "K_CHANNEL_NOT_FOUND",
	  action: "failed"
	}, _e[GATEWAY_ERROR_CODE.K_TICKET_INVALID] = {
	  desc: "K_TICKET_INVALID",
	  action: "failed"
	}, _e[GATEWAY_ERROR_CODE.K_CHANNEL_CONFLICTED] = {
	  desc: "K_CHANNEL_CONFLICTED",
	  action: "failed"
	}, _e[GATEWAY_ERROR_CODE.K_SERVICE_NOT_READY] = {
	  desc: "K_SERVICE_NOT_READY",
	  action: "recover"
	}, _e[GATEWAY_ERROR_CODE.K_SERVICE_TOO_HEAVY] = {
	  desc: "K_SERVICE_TOO_HEAVY",
	  action: "tryNext"
	}, _e[GATEWAY_ERROR_CODE.K_UID_BANNED] = {
	  desc: "K_UID_BANNED",
	  action: "failed"
	}, _e[GATEWAY_ERROR_CODE.K_IP_BANNED] = {
	  desc: "K_IP_BANNED",
	  action: "failed"
	}, _e[GATEWAY_ERROR_CODE.ERR_INVALID_VENDOR_KEY] = {
	  desc: "ERR_INVALID_VENDOR_KEY",
	  action: "failed"
	}, _e[GATEWAY_ERROR_CODE.ERR_INVALID_CHANNEL_NAME] = {
	  desc: "ERR_INVALID_CHANNEL_NAME",
	  action: "failed"
	}, _e[GATEWAY_ERROR_CODE.WARN_NO_AVAILABLE_CHANNEL] = {
	  desc: "WARN_NO_AVAILABLE_CHANNEL",
	  action: "failed"
	}, _e[GATEWAY_ERROR_CODE.WARN_LOOKUP_CHANNEL_TIMEOUT] = {
	  desc: "WARN_LOOKUP_CHANNEL_TIMEOUT",
	  action: "tryNext"
	}, _e[GATEWAY_ERROR_CODE.WARN_LOOKUP_CHANNEL_REJECTED] = {
	  desc: "WARN_LOOKUP_CHANNEL_REJECTED",
	  action: "failed"
	}, _e[GATEWAY_ERROR_CODE.WARN_OPEN_CHANNEL_TIMEOUT] = {
	  desc: "WARN_OPEN_CHANNEL_TIMEOUT",
	  action: "tryNext"
	}, _e[GATEWAY_ERROR_CODE.WARN_OPEN_CHANNEL_REJECTED] = {
	  desc: "WARN_OPEN_CHANNEL_REJECTED",
	  action: "failed"
	}, _e[GATEWAY_ERROR_CODE.WARN_REQUEST_DEFERRED] = {
	  desc: "WARN_REQUEST_DEFERRED",
	  action: "failed"
	}, _e[GATEWAY_ERROR_CODE.ERR_DYNAMIC_KEY_TIMEOUT] = {
	  desc: "ERR_DYNAMIC_KEY_TIMEOUT",
	  action: "failed"
	}, _e[GATEWAY_ERROR_CODE.ERR_NO_AUTHORIZED] = {
	  desc: "ERR_NO_AUTHORIZED",
	  action: "failed"
	}, _e[GATEWAY_ERROR_CODE.ERR_VOM_SERVICE_UNAVAILABLE] = {
	  desc: "ERR_VOM_SERVICE_UNAVAILABLE",
	  action: "tryNext"
	}, _e[GATEWAY_ERROR_CODE.ERR_NO_CHANNEL_AVAILABLE_CODE] = {
	  desc: "ERR_NO_CHANNEL_AVAILABLE_CODE",
	  action: "failed"
	}, _e[GATEWAY_ERROR_CODE.ERR_MASTER_VOCS_UNAVAILABLE] = {
	  desc: "ERR_MASTER_VOCS_UNAVAILABLE",
	  action: "tryNext"
	}, _e[GATEWAY_ERROR_CODE.ERR_INTERNAL_ERROR] = {
	  desc: "ERR_INTERNAL_ERROR",
	  action: "tryNext"
	}, _e[GATEWAY_ERROR_CODE.ERR_NO_ACTIVE_STATUS] = {
	  desc: "ERR_NO_ACTIVE_STATUS",
	  action: "failed"
	}, _e[GATEWAY_ERROR_CODE.ERR_INVALID_UID] = {
	  desc: "ERR_INVALID_UID",
	  action: "failed"
	}, _e[GATEWAY_ERROR_CODE.ERR_DYNAMIC_KEY_EXPIRED] = {
	  desc: "ERR_DYNAMIC_KEY_EXPIRED",
	  action: "failed"
	}, _e[GATEWAY_ERROR_CODE.ERR_STATIC_USE_DYANMIC_KE] = {
	  desc: "ERR_STATIC_USE_DYANMIC_KE",
	  action: "failed"
	}, _e[GATEWAY_ERROR_CODE.ERR_DYNAMIC_USE_STATIC_KE] = {
	  desc: "ERR_DYNAMIC_USE_STATIC_KE",
	  action: "failed"
	}, _e[GATEWAY_ERROR_CODE.ERR_NO_VOCS_AVAILABLE] = {
	  desc: "ERR_NO_VOCS_AVAILABLE",
	  action: "tryNext"
	}, _e[GATEWAY_ERROR_CODE.ERR_NO_VOS_AVAILABLE] = {
	  desc: "ERR_NO_VOS_AVAILABLE",
	  action: "tryNext"
	}, _e[GATEWAY_ERROR_CODE.ERR_JOIN_CHANNEL_TIMEOUT] = {
	  desc: "ERR_JOIN_CHANNEL_TIMEOUT",
	  action: "tryNext"
	}, _e[GATEWAY_ERROR_CODE.ERR_JOIN_BY_MULTI_IP] = {
	  desc: "ERR_JOIN_BY_MULTI_IP",
	  action: "recover"
	}, _e[GATEWAY_ERROR_CODE.ERR_NOT_JOINED] = {
	  desc: "ERR_NOT_JOINED",
	  action: "failed"
	}, _e[GATEWAY_ERROR_CODE.ERR_REPEAT_JOIN_REQUEST] = {
	  desc: "ERR_REPEAT_JOIN_REQUEST",
	  action: "quit"
	}, _e[GATEWAY_ERROR_CODE.ERR_REPEAT_JOIN_CHANNEL] = {
	  desc: "ERR_REPEAT_JOIN_CHANNEL",
	  action: "quit"
	}, _e[GATEWAY_ERROR_CODE.ERR_INVALID_VENDOR_KEY] = {
	  desc: "ERR_INVALID_VENDOR_KEY",
	  action: "failed"
	}, _e[GATEWAY_ERROR_CODE.ERR_INVALID_CHANNEL_NAME] = {
	  desc: "ERR_INVALID_CHANNEL_NAME",
	  action: "failed"
	}, _e[GATEWAY_ERROR_CODE.ERR_INVALID_STRINGUID] = {
	  desc: "ERR_INVALID_STRINGUID",
	  action: "failed"
	}, _e[GATEWAY_ERROR_CODE.ERR_TOO_MANY_USERS] = {
	  desc: "ERR_TOO_MANY_USERS",
	  action: "tryNext"
	}, _e[GATEWAY_ERROR_CODE.ERR_SET_CLIENT_ROLE_TIMEOUT] = {
	  desc: "ERR_SET_CLIENT_ROLE_TIMEOUT",
	  action: "failed"
	}, _e[GATEWAY_ERROR_CODE.ERR_SET_CLIENT_ROLE_NO_PERMISSION] = {
	  desc: "ERR_SET_CLIENT_ROLE_TIMEOUT",
	  action: "failed"
	}, _e[GATEWAY_ERROR_CODE.ERR_SET_CLIENT_ROLE_ALREADY_IN_USE] = {
	  desc: "ERR_SET_CLIENT_ROLE_ALREADY_IN_USE",
	  action: "success"
	}, _e[GATEWAY_ERROR_CODE.ERR_PUBLISH_REQUEST_INVALID] = {
	  desc: "ERR_PUBLISH_REQUEST_INVALID",
	  action: "failed"
	}, _e[GATEWAY_ERROR_CODE.ERR_SUBSCRIBE_REQUEST_INVALID] = {
	  desc: "ERR_SUBSCRIBE_REQUEST_INVALID",
	  action: "failed"
	}, _e[GATEWAY_ERROR_CODE.ERR_NOT_SUPPORTED_MESSAGE] = {
	  desc: "ERR_NOT_SUPPORTED_MESSAGE",
	  action: "failed"
	}, _e[GATEWAY_ERROR_CODE.ERR_ILLEAGAL_PLUGIN] = {
	  desc: "ERR_ILLEAGAL_PLUGIN",
	  action: "failed"
	}, _e[GATEWAY_ERROR_CODE.ERR_REJOIN_TOKEN_INVALID] = {
	  desc: "ERR_REJOIN_TOKEN_INVALID",
	  action: "failed"
	}, _e[GATEWAY_ERROR_CODE.ERR_REJOIN_USER_NOT_JOINED] = {
	  desc: "ERR_REJOIN_NOT_JOINED",
	  action: "failed"
	}, _e[GATEWAY_ERROR_CODE.ERR_INVALID_OPTIONAL_INFO] = {
	  desc: "ERR_INVALID_OPTIONAL_INFO",
	  action: "quit"
	}, _e[GATEWAY_ERROR_CODE.ERR_TEST_RECOVER] = {
	  desc: "ERR_TEST_RECOVER",
	  action: "recover"
	}, _e[GATEWAY_ERROR_CODE.ERR_TEST_TRYNEXT] = {
	  desc: "ERR_TEST_TRYNEXT",
	  action: "recover"
	}, _e[GATEWAY_ERROR_CODE.ERR_TEST_RETRY] = {
	  desc: "ERR_TEST_RETRY",
	  action: "recover"
	}, _e[GATEWAY_ERROR_CODE.ILLEGAL_AES_PASSWORD] = {
	  desc: "ERR_TEST_RETRY",
	  action: "failed"
	}, _e);
	/**
	 * 因为请求 type 的不同，同一个错误码可能对应不同的错误
	 */

	function getGatewayErrorDetail(errorCode) {
	  var detail = SERVER_ERROR_DETAILS[errorCode];

	  if (!detail) {
	    return {
	      desc: "UNKNOW_ERROR_" + errorCode,
	      action: "failed"
	    };
	  }

	  return detail;
	}

	var __awaiter$6 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = promise$3))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var __generator$6 = undefined && undefined.__generator || function (thisArg, body) {
	  var _ = {
	    label: 0,
	    sent: function () {
	      if (t[0] & 1) throw t[1];
	      return t[1];
	    },
	    trys: [],
	    ops: []
	  },
	      f,
	      y,
	      t,
	      g;
	  return g = {
	    next: verb(0),
	    "throw": verb(1),
	    "return": verb(2)
	  }, typeof symbol$2 === "function" && (g[iterator$2] = function () {
	    return this;
	  }), g;

	  function verb(n) {
	    return function (v) {
	      return step([n, v]);
	    };
	  }

	  function step(op) {
	    if (f) throw new TypeError("Generator is already executing.");

	    while (_) try {
	      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	      if (y = 0, t) op = [op[0] & 2, t.value];

	      switch (op[0]) {
	        case 0:
	        case 1:
	          t = op;
	          break;

	        case 4:
	          _.label++;
	          return {
	            value: op[1],
	            done: false
	          };

	        case 5:
	          _.label++;
	          y = op[1];
	          op = [0];
	          continue;

	        case 7:
	          op = _.ops.pop();

	          _.trys.pop();

	          continue;

	        default:
	          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
	            _ = 0;
	            continue;
	          }

	          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
	            _.label = op[1];
	            break;
	          }

	          if (op[0] === 6 && _.label < t[1]) {
	            _.label = t[1];
	            t = op;
	            break;
	          }

	          if (t && _.label < t[2]) {
	            _.label = t[2];

	            _.ops.push(op);

	            break;
	          }

	          if (t[2]) _.ops.pop();

	          _.trys.pop();

	          continue;
	      }

	      op = body.call(thisArg, _);
	    } catch (e) {
	      op = [6, e];
	      y = 0;
	    } finally {
	      f = t = 0;
	    }

	    if (op[0] & 5) throw op[1];
	    return {
	      value: op[0] ? op[1] : void 0,
	      done: true
	    };
	  }
	};
	var DEFAULT_RETRY_CONFIG = {
	  timeout: 500,
	  timeoutFactor: 1.5,
	  maxRetryCount: Infinity,
	  maxRetryTimeout: 10000
	};
	function getRetryWaitTime(retryCount, config) {
	  var timeout = config.timeout * Math.pow(config.timeoutFactor, retryCount);
	  return Math.min(config.maxRetryTimeout, timeout);
	}
	/**
	 * 一个基于简单退避的 retry wrapper
	 * 仅当 Promise resolve/reject 时会触发 retry，此时 wrapper 会将 result/error 传入 @param handleResult/@param handleError
	 * 如果 @param handleResult/@param handleError 返回 true 就会触发退避重试策略，否则该函数直接 resolve/reject 这个 result/error
	 */

	function retryable(operation, handleResult, handleError, config) {
	  var _this = this;

	  var retryConfig = assign$2({}, DEFAULT_RETRY_CONFIG, config);

	  var currentTimeout = retryConfig.timeout;

	  var waitNextTry = function () {
	    return __awaiter$6(_this, void 0, void 0, function () {
	      return __generator$6(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            return [4
	            /*yield*/
	            , wait(currentTimeout)];

	          case 1:
	            _a.sent();

	            currentTimeout = currentTimeout * retryConfig.timeoutFactor;
	            currentTimeout = Math.min(retryConfig.maxRetryTimeout, currentTimeout);
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  var isCanceled = false;

	  var cancel = function () {
	    return isCanceled = true;
	  };

	  var promise = new promise$3(function (resolve, reject) {
	    return __awaiter$6(_this, void 0, void 0, function () {
	      var i, res, e_1;
	      return __generator$6(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            handleResult = handleResult || function () {
	              return false;
	            };

	            handleError = handleError || function () {
	              return true;
	            };

	            i = 0;
	            _a.label = 1;

	          case 1:
	            if (!(i < retryConfig.maxRetryCount)) return [3
	            /*break*/
	            , 12];

	            if (isCanceled) {
	              return [2
	              /*return*/
	              , reject(new AgoraRTCError(AgoraRTCErrorCode.OPERATION_ABORTED))];
	            }

	            _a.label = 2;

	          case 2:
	            _a.trys.push([2, 7,, 11]);

	            return [4
	            /*yield*/
	            , operation()];

	          case 3:
	            res = _a.sent();
	            if (!handleResult(res, i)) return [3
	            /*break*/
	            , 5];
	            /** 写在这个位置是为了确保最后一次 operation 的结果可以走完 handleResult，下同 */

	            if (i + 1 === retryConfig.maxRetryCount) {
	              return [2
	              /*return*/
	              , resolve(res)];
	            }

	            return [4
	            /*yield*/
	            , waitNextTry()];

	          case 4:
	            _a.sent();

	            return [3
	            /*break*/
	            , 6];

	          case 5:
	            return [2
	            /*return*/
	            , resolve(res)];

	          case 6:
	            return [3
	            /*break*/
	            , 11];

	          case 7:
	            e_1 = _a.sent();
	            if (!handleError(e_1, i)) return [3
	            /*break*/
	            , 9];

	            if (i + 1 === retryConfig.maxRetryCount) {
	              return [2
	              /*return*/
	              , reject(e_1)];
	            }

	            return [4
	            /*yield*/
	            , waitNextTry()];

	          case 8:
	            _a.sent();

	            return [3
	            /*break*/
	            , 10];

	          case 9:
	            return [2
	            /*return*/
	            , reject(e_1)];

	          case 10:
	            return [3
	            /*break*/
	            , 11];

	          case 11:
	            i += 1;
	            return [3
	            /*break*/
	            , 1];

	          case 12:
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  });
	  promise.cancel = cancel;
	  return promise;
	}

	var __extends$2 = undefined && undefined.__extends || function () {
	  var extendStatics = function (d, b) {
	    extendStatics = setPrototypeOf$2 || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    };

	    return extendStatics(d, b);
	  };

	  return function (d, b) {
	    extendStatics(d, b);

	    function __() {
	      this.constructor = d;
	    }

	    d.prototype = b === null ? create$4(b) : (__.prototype = b.prototype, new __());
	  };
	}();

	var __awaiter$7 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = promise$3))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var __generator$7 = undefined && undefined.__generator || function (thisArg, body) {
	  var _ = {
	    label: 0,
	    sent: function () {
	      if (t[0] & 1) throw t[1];
	      return t[1];
	    },
	    trys: [],
	    ops: []
	  },
	      f,
	      y,
	      t,
	      g;
	  return g = {
	    next: verb(0),
	    "throw": verb(1),
	    "return": verb(2)
	  }, typeof symbol$2 === "function" && (g[iterator$2] = function () {
	    return this;
	  }), g;

	  function verb(n) {
	    return function (v) {
	      return step([n, v]);
	    };
	  }

	  function step(op) {
	    if (f) throw new TypeError("Generator is already executing.");

	    while (_) try {
	      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	      if (y = 0, t) op = [op[0] & 2, t.value];

	      switch (op[0]) {
	        case 0:
	        case 1:
	          t = op;
	          break;

	        case 4:
	          _.label++;
	          return {
	            value: op[1],
	            done: false
	          };

	        case 5:
	          _.label++;
	          y = op[1];
	          op = [0];
	          continue;

	        case 7:
	          op = _.ops.pop();

	          _.trys.pop();

	          continue;

	        default:
	          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
	            _ = 0;
	            continue;
	          }

	          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
	            _.label = op[1];
	            break;
	          }

	          if (op[0] === 6 && _.label < t[1]) {
	            _.label = t[1];
	            t = op;
	            break;
	          }

	          if (t && _.label < t[2]) {
	            _.label = t[2];

	            _.ops.push(op);

	            break;
	          }

	          if (t[2]) _.ops.pop();

	          _.trys.pop();

	          continue;
	      }

	      op = body.call(thisArg, _);
	    } catch (e) {
	      op = [6, e];
	      y = 0;
	    } finally {
	      f = t = 0;
	    }

	    if (op[0] & 5) throw op[1];
	    return {
	      value: op[0] ? op[1] : void 0,
	      done: true
	    };
	  }
	};

	var AgoraWebSocketManager =
	/** @class */
	function (_super) {
	  __extends$2(AgoraWebSocketManager, _super);

	  function AgoraWebSocketManager(name, retryConfig) {
	    var _this = _super.call(this) || this;

	    _this.connectionID = 0;
	    _this.currentURLIndex = 0;
	    _this.reconnectMode = "tryNext";
	    _this._state = "closed";
	    _this.reconnectCount = 0;
	    _this.name = name;
	    _this.retryConfig = retryConfig;
	    return _this;
	  }

	  defineProperty$4(AgoraWebSocketManager.prototype, "url", {
	    get: function () {
	      if (!this.websocket) return null;
	      return this.websocket.url;
	    },
	    enumerable: true,
	    configurable: true
	  });

	  defineProperty$4(AgoraWebSocketManager.prototype, "state", {
	    get: function () {
	      return this._state;
	    },
	    set: function (newState) {
	      if (newState === this._state) return;
	      this._state = newState;

	      if (this._state === "reconnecting") {
	        this.emit(WebSocketManagerEvents.RECONNECTING, this.reconnectMode);
	      } else if (this._state === "connected") {
	        this.emit(WebSocketManagerEvents.CONNECTED);
	      } else if (this._state === "closed") {
	        this.emit(WebSocketManagerEvents.CLOSED);
	      } else if (this._state === "failed") {
	        this.emit(WebSocketManagerEvents.FAILED);
	      }
	    },
	    enumerable: true,
	    configurable: true
	  });

	  AgoraWebSocketManager.prototype.init = function (urls) {
	    var _this = this;

	    return new promise$3(function (resolve, reject) {
	      _this.urls = urls;
	      var url = _this.urls[_this.currentURLIndex];
	      _this.state = "connecting";

	      _this.createWebSocketConnection(url).then(resolve).catch(reject);

	      _this.once(WebSocketManagerEvents.CLOSED, function () {
	        return reject(new AgoraRTCError(AgoraRTCErrorCode.WS_DISCONNECT));
	      });

	      _this.once(WebSocketManagerEvents.CONNECTED, function () {
	        return resolve();
	      });
	    });
	  };
	  /** 主动关闭连接，不触发重连 */


	  AgoraWebSocketManager.prototype.close = function (failed, lazyClose) {
	    this.currentURLIndex = 0;
	    this.reconnectCount = 0;

	    if (this.websocket) {
	      this.websocket.onclose = null;
	      this.websocket.onopen = null;
	      this.websocket.onmessage = null;
	      var ws_1 = this.websocket;

	      if (lazyClose) {
	        setTimeout$2(function () {
	          return ws_1.close();
	        }, 500);
	      } else {
	        ws_1.close();
	      }

	      this.websocket = undefined;
	    }

	    if (failed) {
	      this.state = "failed";
	    } else {
	      this.state = "closed";
	    }
	  };
	  /** 主动触发重连 */


	  AgoraWebSocketManager.prototype.reconnect = function (reconnectMode, reason) {
	    if (!this.websocket) {
	      logger.warning("[" + this.name + "] can not reconnect, no websocket");
	      return;
	    }

	    if (reconnectMode !== undefined) {
	      this.reconnectMode = reconnectMode;
	    }
	    /**
	     * 这里手动触发 websocket 的 onclose
	     * 因为实际测下来主动断开 websocket，在断网情况下 onclose 不会立刻触发
	     */


	    logger.debug("[" + this.name + "] reconnect is triggered initiative");
	    var closeFunc = this.websocket.onclose;
	    this.websocket.onclose = null;
	    this.websocket.close();
	    closeFunc && bind$3(closeFunc).call(closeFunc, this.websocket)({
	      code: 9999,
	      reason: reason
	    });
	  };

	  AgoraWebSocketManager.prototype.sendMessage = function (message) {
	    if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN) {
	      throw new AgoraRTCError(AgoraRTCErrorCode.WS_ABORT, "websocket is not ready");
	    }

	    var msg = stringify$2(message);

	    try {
	      this.websocket.send(msg);
	    } catch (e) {
	      throw new AgoraRTCError(AgoraRTCErrorCode.WS_ERR, "send websocket message error" + e.toString());
	    }
	  };

	  AgoraWebSocketManager.prototype.createWebSocketConnection = function (url) {
	    return __awaiter$7(this, void 0, void 0, function () {
	      var connectionID;

	      var _this = this;

	      return __generator$7(this, function (_a) {
	        this.connectionID += 1;
	        connectionID = this.connectionID;
	        return [2
	        /*return*/
	        , new promise$3(function (resolve, reject) {
	          var _context;

	          if (_this.websocket) {
	            _this.websocket.onclose = null;

	            _this.websocket.close();
	          }
	          /**
	           * **Note:** 测试用
	           * 如果全局配置里指定了目标网关地址，并且这个 websocket 是用于网关的
	           * 就强制修改这个网关地址
	          */


	          if (getParameter("GATEWAY_WSS_ADDRESS") && startsWith$2(_context = _this.name).call(_context, "gateway")) {
	            url = getParameter("GATEWAY_WSS_ADDRESS");
	          }

	          logger.debug("[" + _this.name + "] start connect, url: " + url);

	          try {
	            _this.websocket = new WebSocket(url);
	            _this.websocket.binaryType = "arraybuffer";
	          } catch (e) {
	            var err = new AgoraRTCError(AgoraRTCErrorCode.WS_ERR, "init websocket failed! Error: " + e.toString());
	            logger.error("[" + _this.name + "]" + err);
	            reject(err);
	            return;
	          }

	          wait(5000).then(function () {
	            /** 如果 5s 以后既没有尝试新的连接且也没有连接成功，强制断开 */
	            if (connectionID === _this.connectionID && _this.websocket && _this.websocket.readyState !== WebSocket.OPEN) {
	              _this.websocket && _this.websocket.close();
	            }
	          });

	          _this.websocket.onopen = function () {
	            logger.debug("[" + _this.name + "] websockect opened:", url);
	            /**
	             * 如果在建立连接的过程中断开（没有触发过 onopen）使用 `tryNext`
	             * 如果在连接过程中断开 使用 `retry`
	             */

	            _this.reconnectMode = "retry";
	            _this.state = "connected";
	            _this.reconnectCount = 0;
	            resolve();
	          };

	          _this.websocket.onclose = function (e) {
	            return __awaiter$7(_this, void 0, void 0, function () {
	              var reconnectMode, result;
	              return __generator$7(this, function (_a) {
	                switch (_a.label) {
	                  case 0:
	                    logger.debug("[" + this.name + "] websocket close " + (this.websocket && this.websocket.url) + ", code: " + e.code + ", reason: " + e.reason + ", current mode: " + this.reconnectMode);
	                    if (!(this.reconnectCount < this.retryConfig.maxRetryCount)) return [3
	                    /*break*/
	                    , 2];

	                    if (this.state === "connected") {
	                      this.state = "reconnecting";
	                    }

	                    reconnectMode = emitAsInvokerNoResponse(this, WebSocketManagerEvents.WILL_RECONNECT, this.reconnectMode) || this.reconnectMode;
	                    return [4
	                    /*yield*/
	                    , this.reconnectWithAction(reconnectMode)];

	                  case 1:
	                    result = _a.sent();

	                    if (this.state === "closed") {
	                      logger.debug("[" + this.connectionID + "] ws is closed, no need to reconnect");
	                      return [2
	                      /*return*/
	                      ];
	                    } // 耗尽重连次数，重连失败


	                    if (!result) {
	                      reject(new AgoraRTCError(AgoraRTCErrorCode.WS_DISCONNECT, "websocket reconnect failed: " + e.code));
	                      this.close(true);
	                      return [2
	                      /*return*/
	                      ]; // 重连成功
	                    } else {
	                      resolve();
	                    }

	                    return [3
	                    /*break*/
	                    , 3];

	                  case 2:
	                    reject(new AgoraRTCError(AgoraRTCErrorCode.WS_DISCONNECT, "websocket close: " + e.code));
	                    this.close();
	                    _a.label = 3;

	                  case 3:
	                    return [2
	                    /*return*/
	                    ];
	                }
	              });
	            });
	          };

	          _this.websocket.onmessage = function (e) {
	            _this.emit(WebSocketManagerEvents.ON_MESSAGE, e);
	          };
	        })];
	      });
	    });
	  };
	  /**
	   * 不可能抛出错误，只返回 true/false 表示重连是否成功
	   */


	  AgoraWebSocketManager.prototype.reconnectWithAction = function (action, notCheckCount) {
	    return __awaiter$7(this, void 0, void 0, function () {
	      var timeout, url, url, _a, url, e_1;

	      var _this = this;

	      return __generator$7(this, function (_b) {
	        switch (_b.label) {
	          case 0:
	            if (!notCheckCount && this.reconnectCount >= this.retryConfig.maxRetryCount) {
	              return [2
	              /*return*/
	              , false];
	            }

	            if (!this.urls) {
	              return [2
	              /*return*/
	              , false];
	            }

	            if (this.state === "closed") {
	              return [2
	              /*return*/
	              , false];
	            }
	            /** 如果重连时候发现网络断开，设置一个Promise，当网络重新连接的时候resolve。 为了在网络重新连接的时候快速响应进行重连 */


	            if (!this.onlineReconnectListener && navigator && navigator.onLine !== undefined && !navigator.onLine) {
	              this.onlineReconnectListener = new promise$3(function (resolve) {
	                var handler = function () {
	                  _this.onlineReconnectListener = undefined;
	                  window.removeEventListener("online", handler);
	                  resolve();
	                };

	                window.addEventListener("online", handler);
	              });
	            }

	            timeout = getRetryWaitTime(this.reconnectCount, this.retryConfig);
	            logger.debug("[" + this.name + "] wait " + timeout + "ms to reconnect websocket, mode: " + action);
	            return [4
	            /*yield*/
	            , promise$3.race([wait(timeout), this.onlineReconnectListener || new promise$3(function () {})])];

	          case 1:
	            _b.sent(); // 用户有可能在等待时间内主动关闭了连接，再检查一次
	            // @ts-ignore


	            if (this.state === "closed") {
	              return [2
	              /*return*/
	              , false];
	            }

	            this.reconnectCount += 1;
	            _b.label = 2;

	          case 2:
	            _b.trys.push([2, 12,, 14]);

	            if (!(action === "retry")) return [3
	            /*break*/
	            , 4];
	            url = this.urls[this.currentURLIndex];
	            return [4
	            /*yield*/
	            , this.createWebSocketConnection(url)];

	          case 3:
	            _b.sent();

	            return [3
	            /*break*/
	            , 11];

	          case 4:
	            if (!(action === "tryNext")) return [3
	            /*break*/
	            , 8];
	            this.currentURLIndex += 1;
	            if (!(this.currentURLIndex >= this.urls.length)) return [3
	            /*break*/
	            , 6];
	            return [4
	            /*yield*/
	            , this.reconnectWithAction("recover")];

	          case 5:
	            return [2
	            /*return*/
	            , _b.sent()];

	          case 6:
	            logger.debug("[" + this.name + "] websocket url length: " + this.urls.length + " current index: " + this.currentURLIndex);
	            url = this.urls[this.currentURLIndex];
	            return [4
	            /*yield*/
	            , this.createWebSocketConnection(url)];

	          case 7:
	            _b.sent();

	            return [3
	            /*break*/
	            , 11];

	          case 8:
	            if (!(action === "recover")) return [3
	            /*break*/
	            , 11];
	            logger.debug("[" + this.name + "] request new urls");
	            _a = this;
	            return [4
	            /*yield*/
	            , emitAsPromise(this, WebSocketManagerEvents.REQUEST_NEW_URLS)];

	          case 9:
	            _a.urls = _b.sent();
	            this.currentURLIndex = 0;
	            url = this.urls[this.currentURLIndex];
	            return [4
	            /*yield*/
	            , this.createWebSocketConnection(url)];

	          case 10:
	            _b.sent();

	            _b.label = 11;

	          case 11:
	            return [2
	            /*return*/
	            , true];

	          case 12:
	            e_1 = _b.sent();
	            logger.error("[" + this.name + "] reconnect failed", e_1.toString());
	            return [4
	            /*yield*/
	            , this.reconnectWithAction(action)];

	          case 13:
	            return [2
	            /*return*/
	            , _b.sent()];

	          case 14:
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  return AgoraWebSocketManager;
	}(EventEmitter$1);

	/**
	 * 最基础的移动平均实现
	 */
	var Rolling =
	/** @class */
	function () {
	  function Rolling(size) {
	    this.input = [];
	    this.size = size;
	  }

	  Rolling.prototype.add = function (num) {
	    this.input.push(num);

	    if (this.input.length > this.size) {
	      var _context;

	      splice$2(_context = this.input).call(_context, 0, 1);
	    }
	  };

	  Rolling.prototype.mean = function () {
	    var _context2;

	    if (this.input.length === 0) return 0;
	    return reduce$2(_context2 = this.input).call(_context2, function (a, b) {
	      return a + b;
	    }) / this.input.length;
	  };

	  return Rolling;
	}();

	var __extends$3 = undefined && undefined.__extends || function () {
	  var extendStatics = function (d, b) {
	    extendStatics = setPrototypeOf$2 || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    };

	    return extendStatics(d, b);
	  };

	  return function (d, b) {
	    extendStatics(d, b);

	    function __() {
	      this.constructor = d;
	    }

	    d.prototype = b === null ? create$4(b) : (__.prototype = b.prototype, new __());
	  };
	}();

	var __awaiter$8 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = promise$3))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var __generator$8 = undefined && undefined.__generator || function (thisArg, body) {
	  var _ = {
	    label: 0,
	    sent: function () {
	      if (t[0] & 1) throw t[1];
	      return t[1];
	    },
	    trys: [],
	    ops: []
	  },
	      f,
	      y,
	      t,
	      g;
	  return g = {
	    next: verb(0),
	    "throw": verb(1),
	    "return": verb(2)
	  }, typeof symbol$2 === "function" && (g[iterator$2] = function () {
	    return this;
	  }), g;

	  function verb(n) {
	    return function (v) {
	      return step([n, v]);
	    };
	  }

	  function step(op) {
	    if (f) throw new TypeError("Generator is already executing.");

	    while (_) try {
	      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	      if (y = 0, t) op = [op[0] & 2, t.value];

	      switch (op[0]) {
	        case 0:
	        case 1:
	          t = op;
	          break;

	        case 4:
	          _.label++;
	          return {
	            value: op[1],
	            done: false
	          };

	        case 5:
	          _.label++;
	          y = op[1];
	          op = [0];
	          continue;

	        case 7:
	          op = _.ops.pop();

	          _.trys.pop();

	          continue;

	        default:
	          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
	            _ = 0;
	            continue;
	          }

	          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
	            _.label = op[1];
	            break;
	          }

	          if (op[0] === 6 && _.label < t[1]) {
	            _.label = t[1];
	            t = op;
	            break;
	          }

	          if (t && _.label < t[2]) {
	            _.label = t[2];

	            _.ops.push(op);

	            break;
	          }

	          if (t[2]) _.ops.pop();

	          _.trys.pop();

	          continue;
	      }

	      op = body.call(thisArg, _);
	    } catch (e) {
	      op = [6, e];
	      y = 0;
	    } finally {
	      f = t = 0;
	    }

	    if (op[0] & 5) throw op[1];
	    return {
	      value: op[0] ? op[1] : void 0,
	      done: true
	    };
	  }
	};

	var AgoraRTCSignal =
	/** @class */
	function (_super) {
	  __extends$3(AgoraRTCSignal, _super);

	  function AgoraRTCSignal(spec) {
	    var _this = _super.call(this) || this;

	    _this._connectionState = SignalConnectionState.CLOSED;
	    _this.openConnectionTime = now$2();
	    _this.lastMsgTime = now$2();
	    _this.uploadCache = [];
	    /** 不做平滑 */

	    _this.rttRolling = new Rolling(5);
	    _this.pingpongTimeoutCount = 0;

	    _this.onWebsocketMessage = function (e) {
	      if (e.data instanceof ArrayBuffer) {
	        _this.emit(SignalEvent.ON_BINARY_DATA, e.data);

	        return;
	      }

	      var message = JSON.parse(e.data);
	      _this.lastMsgTime = now$2();

	      if (message.hasOwnProperty("_id")) {
	        var event_1 = "res-@" + message._id;

	        _this.emit(event_1, message._result, message._message);
	      } else if (message.hasOwnProperty("_type")) {
	        _this.emit(message._type, message._message);

	        if (message._type === SignalNotifyType.ON_NOTIFICATION) {
	          _this.handleNotification(message._message);
	        }

	        if (message._type === SignalNotifyType.ON_USER_BANNED) {
	          switch (message._message.error_code) {
	            case 14:
	              _this.close("UID_BANNED"
	              /* UID_BANNED */
	              );

	              break;

	            case 15:
	              _this.close("IP_BANNED"
	              /* IP_BANNED */
	              );

	              break;

	            case 16:
	              _this.close("CHANNEL_BANNED"
	              /* CHANNEL_BANNED */
	              );

	              break;
	          }
	        }
	      }
	    };

	    _this.clientId = spec.clientId;
	    _this.spec = spec;
	    _this.websocket = new AgoraWebSocketManager("gateway-" + _this.clientId, _this.spec.retryConfig);

	    _this.handleWebsocketEvents();

	    window.addEventListener("offline", function () {
	      /** 触发断网时，如果信令是已连接状态，强制断开进行重连 */
	      if (_this.connectionState === SignalConnectionState.CONNECTED) {
	        _this.reconnect("retry", "offline");
	      }
	    });
	    return _this;
	  }

	  defineProperty$4(AgoraRTCSignal.prototype, "connectionState", {
	    get: function () {
	      return this._connectionState;
	    },
	    set: function (state) {
	      if (state === this._connectionState) return;
	      this._connectionState = state;

	      if (state === SignalConnectionState.CONNECTED) {
	        this.emit(SignalEvent.WS_CONNECTED);
	      } else if (state === SignalConnectionState.RECONNECTING) {
	        this.emit(SignalEvent.WS_RECONNECTING);
	      } else if (state === SignalConnectionState.CLOSED) {
	        this.emit(SignalEvent.WS_CLOSED, this._disconnectedReason);
	      }
	    },
	    enumerable: true,
	    configurable: true
	  });

	  defineProperty$4(AgoraRTCSignal.prototype, "url", {
	    get: function () {
	      if (!this.websocket) return null;
	      return this.websocket.url;
	    },
	    enumerable: true,
	    configurable: true
	  });

	  defineProperty$4(AgoraRTCSignal.prototype, "rtt", {
	    get: function () {
	      return this.rttRolling.mean();
	    },
	    enumerable: true,
	    configurable: true
	  });
	  /**
	   * 对于一次网关请求，有 4 种可能的返回：
	   * - 正常返回，网关响应
	   * - WS_ABORT 在网关响应之前 ws 被关闭了
	   * - UNEXPECTED_RESPONSE 网关返回了非预期的返回
	   * @param noNeedToReSend - 如果这个打开，在发送的过程中遇到了网关断开/重试，不会触发重试
	   */


	  AgoraRTCSignal.prototype.request = function (type, payload, noNeedToReSend) {
	    return __awaiter$8(this, void 0, void 0, function () {
	      var requestId, message, connectionID, newWsOpenPromise, responsePromise, response, e_1, errorCode, errorDetail, err;

	      var _this = this;

	      return __generator$8(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            requestId = getRandomString(6, "");
	            message = {
	              _id: requestId,
	              _type: type,
	              _message: payload
	            };
	            connectionID = this.websocket.connectionID;

	            newWsOpenPromise = function () {
	              return new promise$3(function (resolve, reject) {
	                if (_this.connectionState === SignalConnectionState.CONNECTED) {
	                  return resolve();
	                }

	                var onConnected = function () {
	                  _this.off(SignalEvent.WS_CLOSED, onClosed);

	                  resolve();
	                };

	                var onClosed = function () {
	                  _this.off(SignalEvent.WS_CONNECTED, onConnected);

	                  reject(new AgoraRTCError(AgoraRTCErrorCode.WS_ABORT));
	                };

	                _this.once(SignalEvent.WS_CONNECTED, onConnected);

	                _this.once(SignalEvent.WS_CLOSED, onClosed);
	              });
	            };

	            if (!((this.connectionState === SignalConnectionState.CONNECTING || this.connectionState === SignalConnectionState.RECONNECTING) && type !== SignalRequestType.JOIN && type !== SignalRequestType.REJOIN)) return [3
	            /*break*/
	            , 2];
	            return [4
	            /*yield*/
	            , newWsOpenPromise()];

	          case 1:
	            _a.sent();

	            _a.label = 2;

	          case 2:
	            responsePromise = new promise$3(function (resolve, reject) {
	              var finished = false;

	              var onResult = function (result, message) {
	                finished = true;
	                resolve({
	                  isSuccess: result === "success",
	                  message: message || {}
	                });

	                _this.off(SignalEvent.WS_CLOSED, handleWsDisconnect);

	                _this.off(SignalEvent.WS_RECONNECTING, handleWsDisconnect);

	                _this.emit(SignalEvent.REQUEST_SUCCESS, type, payload);
	              };

	              _this.once("res-@" + requestId, onResult);

	              var handleWsDisconnect = function () {
	                reject(new AgoraRTCError(AgoraRTCErrorCode.WS_ABORT, "type: " + type));

	                _this.off(SignalEvent.WS_CLOSED, handleWsDisconnect);

	                _this.off(SignalEvent.WS_RECONNECTING, handleWsDisconnect);

	                _this.off("res-@" + requestId, onResult);
	              };

	              _this.once(SignalEvent.WS_CLOSED, handleWsDisconnect);

	              _this.once(SignalEvent.WS_RECONNECTING, handleWsDisconnect);

	              wait(getParameter("SIGNAL_REQUEST_TIMEOUT")).then(function () {
	                /**
	                 * 如果请求超时，我们这里除了上报和 warning 之外，不做其他处理，原因是：
	                 * - 如果直接抛出错误或者重试，因为连接没有断，对端可能收到两个相同的报文
	                 * - 如果强制断开 WS 触发重连，会导致 session 变更，容易引发重连风暴对上报成功率造成影响
	                 */

	                /** 如果连接已经变了，忽略 */
	                if (_this.websocket.connectionID !== connectionID || finished) return;
	                logger.warning("ws request timeout, type: " + type);

	                _this.emit(SignalEvent.REQUEST_TIMEOUT, type, payload);
	              });
	            });
	            this.websocket.sendMessage(message);
	            response = null;
	            _a.label = 3;

	          case 3:
	            _a.trys.push([3, 5,, 8]);

	            return [4
	            /*yield*/
	            , responsePromise];

	          case 4:
	            response = _a.sent();
	            return [3
	            /*break*/
	            , 8];

	          case 5:
	            e_1 = _a.sent();

	            if (this.connectionState === SignalConnectionState.CLOSED || type === SignalRequestType.LEAVE) {
	              throw new AgoraRTCError(AgoraRTCErrorCode.WS_ABORT);
	            }
	            /** 如果设置了不重发，这里就直接抛出错误 */


	            if (!this.spec.forceWaitGatewayResponse || noNeedToReSend) {
	              return [2
	              /*return*/
	              , e_1.throw()];
	            }

	            if (type === SignalRequestType.JOIN || type === SignalRequestType.REJOIN) {
	              return [2
	              /*return*/
	              , null];
	            }

	            return [4
	            /*yield*/
	            , newWsOpenPromise()];

	          case 6:
	            _a.sent();

	            return [4
	            /*yield*/
	            , this.request(type, payload)];

	          case 7:
	            return [2
	            /*return*/
	            , _a.sent()];

	          case 8:
	            if (response.isSuccess) return [2
	            /*return*/
	            , response.message];
	            errorCode = Number(response.message.error_code || response.message.code);
	            errorDetail = getGatewayErrorDetail(errorCode);
	            err = new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_RESPONSE, errorDetail.desc + ": " + response.message.error_str, {
	              code: errorCode,
	              data: response.message
	            });

	            if (errorDetail.action === "success") {
	              return [2
	              /*return*/
	              , response.message];
	            }

	            logger.warning("[" + this.websocket.connectionID + "] unexpected response from type " + type + ", error_code: " + errorCode + ", message: " + errorDetail.desc + ", action: " + errorDetail.action);
	            if (!(errorDetail.action === "failed")) return [3
	            /*break*/
	            , 9];
	            return [2
	            /*return*/
	            , err.throw()];

	          case 9:
	            if (!(errorDetail.action === "quit")) return [3
	            /*break*/
	            , 10];
	            this.initError = err;
	            this.close();
	            return [2
	            /*return*/
	            , err.throw()];

	          case 10:
	            if (errorCode === GATEWAY_ERROR_CODE.ERR_JOIN_BY_MULTI_IP) {
	              this.multiIpOption = response.message.option;
	              logger.warning("[" + this.clientId + "] detect multi ip, recover");
	              this.reconnect("recover");
	            } else {
	              this.reconnect(errorDetail.action);
	            }

	            if (type === SignalRequestType.JOIN || type === SignalRequestType.REJOIN) {
	              return [2
	              /*return*/
	              , null];
	            }

	            return [4
	            /*yield*/
	            , this.request(type, payload)];

	          case 11:
	            return [2
	            /*return*/
	            , _a.sent()];
	        }
	      });
	    });
	  };
	  /**
	   * 指定 type 和 filter 函数，返回一个等待网关指定通知信息的回调
	   * **Note:** 这个 Promise 永远不会 reject
	   */


	  AgoraRTCSignal.prototype.waitMessage = function (type, filter) {
	    var _this = this;

	    return new promise$3(function (resolve) {
	      var handler = function (message) {
	        var result = filter ? filter(message) : true;

	        if (!result) {
	          return;
	        }

	        _this.off(type, handler);

	        resolve(message);
	      };

	      _this.on(type, handler);
	    });
	  };
	  /**
	   * 和 `send` 不同的是，`upload` 如果 `sendMessage` 失败会将上报内容缓存。
	   * 这些存储的上报内容将在网关再次 ready 后持续重试
	   * **Note:**
	   * - SDK 不保证每个 `upload` 都能到达服务端，因为缓存的上报内容是有上限的，默认的上限是 50
	   * - 上报缓存内容时会有间隔地上报，默认每隔 200ms 上报一个，但是正常上报是即时上报
	   */


	  AgoraRTCSignal.prototype.upload = function (type, payload) {
	    var _this = this;

	    var message = {
	      _type: type,
	      _message: payload
	    };

	    try {
	      this.websocket.sendMessage(message);
	    } catch (e) {
	      // logger.info(`[${this.clientId}] upload failed, cache message`, e);
	      var maxUploadCacheLimit = getParameter("MAX_UPLOAD_CACHE") || 50;
	      this.uploadCache.push(message);

	      if (this.uploadCache.length > maxUploadCacheLimit) {
	        var _context;

	        // drop upload message
	        splice$2(_context = this.uploadCache).call(_context, 0, 1);
	      }

	      if (this.uploadCache.length > 0 && !this.uploadCacheInterval) {
	        this.uploadCacheInterval = window.setInterval(function () {
	          var _context2;

	          if (_this.connectionState !== SignalConnectionState.CONNECTED) return;

	          var currentMessage = splice$2(_context2 = _this.uploadCache).call(_context2, 0, 1)[0];

	          if (_this.uploadCache.length === 0) {
	            window.clearInterval(_this.uploadCacheInterval);
	            _this.uploadCacheInterval = undefined;
	          }

	          _this.upload(currentMessage._type, currentMessage._message);
	        }, getParameter("UPLOAD_CACHE_INTERVAL") || 2000);
	      }
	    }
	  };

	  AgoraRTCSignal.prototype.send = function (type, payload) {
	    var message = {
	      _type: type,
	      _message: payload
	    };
	    this.websocket.sendMessage(message);
	  };

	  AgoraRTCSignal.prototype.init = function (urls) {
	    var _this = this;

	    this.initError = undefined;
	    this.multiIpOption = undefined;
	    this.joinResponse = undefined;
	    this.reconnectToken = undefined;
	    return new promise$3(function (resolve, reject) {
	      _this.once(SignalEvent.WS_CONNECTED, function () {
	        return resolve(_this.joinResponse);
	      });

	      _this.once(SignalEvent.WS_CLOSED, function () {
	        return reject(_this.initError || new AgoraRTCError(AgoraRTCErrorCode.WS_ABORT));
	      });

	      _this.connectionState = SignalConnectionState.CONNECTING;

	      _this.websocket.init(urls).catch(reject);
	    });
	  };
	  /**
	   * 关闭 signal 并且不触发重连
	   */


	  AgoraRTCSignal.prototype.close = function (reason) {
	    if (this.pingpongTimer) {
	      this.pingpongTimeoutCount = 0;
	      window.clearInterval(this.pingpongTimer);
	      this.pingpongTimer = undefined;
	    }

	    this.reconnectToken = undefined;
	    this.joinResponse = undefined;
	    this._disconnectedReason = reason || "LEAVE"
	    /* LEAVE */
	    ;
	    this.connectionState = SignalConnectionState.CLOSED;
	    this.websocket.close();
	  };

	  AgoraRTCSignal.prototype.join = function () {
	    return __awaiter$8(this, void 0, void 0, function () {
	      var joinMessage, joinResponse;
	      return __generator$8(this, function (_a) {
	        var _context3;

	        switch (_a.label) {
	          case 0:
	            if (!!this.joinResponse) return [3
	            /*break*/
	            , 2];
	            joinMessage = emitAsInvoker(this, SignalEvent.REQUEST_JOIN_INFO);
	            return [4
	            /*yield*/
	            , this.request(SignalRequestType.JOIN, joinMessage)];

	          case 1:
	            joinResponse = _a.sent();
	            /**
	             * 出现这个情况说明在 request join message 的过程中 ws 断开或者超时
	             */

	            if (!joinResponse) {
	              this.emit(SignalEvent.REPORT_JOIN_GATEWAY, AgoraRTCErrorCode.TIMEOUT, this.url || "");
	              return [2
	              /*return*/
	              , false];
	            }

	            this.joinResponse = joinResponse;
	            this.reconnectToken = this.joinResponse.rejoin_token;
	            _a.label = 2;

	          case 2:
	            // 连接成功, 开启内部 pingpong
	            this.connectionState = SignalConnectionState.CONNECTED;

	            if (this.pingpongTimer) {
	              window.clearInterval(this.pingpongTimer);
	            }

	            this.pingpongTimer = window.setInterval(bind$3(_context3 = this.handlePingPong).call(_context3, this), 3000);
	            return [2
	            /*return*/
	            , true];
	        }
	      });
	    });
	  };

	  AgoraRTCSignal.prototype.rejoin = function () {
	    return __awaiter$8(this, void 0, void 0, function () {
	      var joinMessage, rejoinResponse;

	      var _this = this;

	      return __generator$8(this, function (_a) {
	        var _context4, _context5;

	        switch (_a.label) {
	          case 0:
	            if (!this.reconnectToken) {
	              throw new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_ERROR, "can not rejoin, no rejoin token");
	            }

	            joinMessage = emitAsInvoker(this, SignalEvent.REQUEST_REJOIN_INFO);
	            joinMessage.token = this.reconnectToken;
	            return [4
	            /*yield*/
	            , this.request(SignalRequestType.REJOIN, joinMessage)];

	          case 1:
	            rejoinResponse = _a.sent();
	            /** 说明在请求 rejoin 的过程中 ws 断开，此时抛弃 */

	            if (!rejoinResponse) {
	              return [2
	              /*return*/
	              , false];
	            }

	            this.connectionState = SignalConnectionState.CONNECTED;

	            if (this.pingpongTimer) {
	              window.clearInterval(this.pingpongTimer);
	            }

	            this.pingpongTimer = window.setInterval(bind$3(_context4 = this.handlePingPong).call(_context4, this), 3000);
	            /**
	             * rejoin 成功，需要模拟 join 的行为向外层抛出事件
	             */

	            rejoinResponse.peers && forEach$3(_context5 = rejoinResponse.peers).call(_context5, function (stream) {
	              _this.emit(SignalNotifyType.ON_USER_ONLINE, {
	                uid: stream.uid
	              });

	              if (stream.audio_mute) {
	                _this.emit(SignalNotifyType.MUTE_AUDIO, {
	                  uid: stream.uid
	                });
	              } else {
	                _this.emit(SignalNotifyType.UNMUTE_AUDIO, {
	                  uid: stream.uid
	                });
	              }

	              if (stream.video_mute) {
	                _this.emit(SignalNotifyType.MUTE_VIDEO, {
	                  uid: stream.uid
	                });
	              } else {
	                _this.emit(SignalNotifyType.UNMUTE_VIDEO, {
	                  uid: stream.uid
	                });
	              }

	              if (stream.audio_enable_local) {
	                _this.emit(SignalNotifyType.ENABLE_LOCAL_AUDIO, {
	                  uid: stream.uid
	                });
	              } else {
	                _this.emit(SignalNotifyType.DISABLE_LOCAL_AUDIO, {
	                  uid: stream.uid
	                });
	              }

	              if (stream.video_enable_local) {
	                _this.emit(SignalNotifyType.ENABLE_LOCAL_VIDEO, {
	                  uid: stream.uid
	                });
	              } else {
	                _this.emit(SignalNotifyType.DISABLE_LOCAL_VIDEO, {
	                  uid: stream.uid
	                });
	              }

	              if (!stream.audio && !stream.video) {
	                _this.emit(SignalNotifyType.ON_REMOVE_STREAM, {
	                  uid: stream.uid,
	                  uint_id: stream.uint_id
	                });
	              }

	              if (stream.audio) {
	                _this.emit(SignalNotifyType.ON_ADD_AUDIO_STREAM, {
	                  uid: stream.uid,
	                  uint_id: stream.uint_id,
	                  audio: true
	                });
	              }

	              if (stream.video) {
	                _this.emit(SignalNotifyType.ON_ADD_VIDEO_STREAM, {
	                  uid: stream.uid,
	                  uint_id: stream.uint_id,
	                  video: true
	                });
	              }
	            });
	            return [2
	            /*return*/
	            , true];
	        }
	      });
	    });
	  };

	  AgoraRTCSignal.prototype.reconnect = function (reconnectMode, reason) {
	    if (this.pingpongTimer) {
	      this.pingpongTimeoutCount = 0;
	      window.clearInterval(this.pingpongTimer);
	      this.pingpongTimer = undefined;
	    }

	    this.websocket.reconnect(reconnectMode, reason);
	  };

	  AgoraRTCSignal.prototype.handleNotification = function (message) {
	    logger.debug("[" + this.clientId + "] receive notification: ", message);
	    var errorDetail = getGatewayErrorDetail(message.code);
	    if (errorDetail.action === "success") return;
	    /**
	     * 在 notification 阶段抛出的错误无法被客户在函数栈里捕获
	     * 这里就不做处理
	     */

	    if (errorDetail.action === "failed") {
	      logger.error("[" + this.clientId + "] ignore error: ", errorDetail.desc);
	      return;
	    }

	    if (errorDetail.action === "quit") {
	      if (errorDetail.desc === "ERR_REPEAT_JOIN_CHANNEL") {
	        this.close("UID_BANNED"
	        /* UID_BANNED */
	        );
	      }

	      this.close();
	      return;
	    }

	    this.reconnect(errorDetail.action);
	  };

	  AgoraRTCSignal.prototype.handlePingPong = function () {
	    var _this = this;

	    if (!this.websocket || this.websocket.state !== "connected") return; // 3s 前发出的 ping 至今没有响应，hardcode 更新 RTT

	    if (this.pingpongTimeoutCount > 0) {
	      this.rttRolling.add(3000);
	    }

	    this.pingpongTimeoutCount += 1;
	    var pingpongTimeout = getParameter("PING_PONG_TIME_OUT");

	    var now = now$2();

	    if (this.pingpongTimeoutCount >= pingpongTimeout) {
	      logger.warning("PINGPONG Timeout. Last Socket Message: " + (now - this.lastMsgTime) + "ms");

	      if (now - this.lastMsgTime > getParameter("WEBSOCKET_TIMEOUT_MIN")) {
	        this.reconnect("retry", "ping_lost");
	        return;
	      }
	    }

	    this.request(SignalRequestType.PING, undefined, true).then(function () {
	      _this.pingpongTimeoutCount = 0;
	      var elapse = now$2() - now;

	      _this.rttRolling.add(elapse);

	      if (!getParameter("REPORT_STATS")) return;

	      _this.send(SignalRequestType.PING_BACK, {
	        pingpongElapse: elapse
	      });
	    }).catch(function (e) {// ignore ping error
	    });
	  };

	  AgoraRTCSignal.prototype.handleWebsocketEvents = function () {
	    var _this = this;

	    this.websocket.on(WebSocketManagerEvents.ON_MESSAGE, this.onWebsocketMessage);
	    this.websocket.on(WebSocketManagerEvents.CLOSED, function () {
	      _this.connectionState = SignalConnectionState.CLOSED;
	    });
	    this.websocket.on(WebSocketManagerEvents.FAILED, function () {
	      _this._disconnectedReason = "NETWORK_ERROR"
	      /* NETWORK_ERROR */
	      ;
	      _this.connectionState = SignalConnectionState.CLOSED;
	    });
	    this.websocket.on(WebSocketManagerEvents.RECONNECTING, function (reconnectMode) {
	      _this.joinResponse = undefined;

	      if (_this.connectionState === SignalConnectionState.CONNECTED) {
	        _this.connectionState = SignalConnectionState.RECONNECTING;
	      } else {
	        _this.connectionState = SignalConnectionState.CONNECTING;
	      }
	    });
	    /** 只可能会把 retry -> tryNext */

	    this.websocket.on(WebSocketManagerEvents.WILL_RECONNECT, function (reconnectMode, callback) {
	      var isP2PDisconnected = emitAsInvoker(_this, SignalEvent.IS_P2P_DISCONNECTED); // 如果 p2p 断开，走大重连

	      if (isP2PDisconnected && reconnectMode === "retry") {
	        _this.reconnectToken = undefined; // 一旦走大重连，需要更新 session id

	        _this.emit(SignalEvent.NEED_RENEW_SESSION);

	        _this.emit(SignalEvent.DISCONNECT_P2P);

	        return callback("tryNext");
	      } else if (reconnectMode !== "retry") {
	        _this.reconnectToken = undefined; // 一旦走大重连，需要更新 session id

	        _this.emit(SignalEvent.NEED_RENEW_SESSION);

	        _this.emit(SignalEvent.DISCONNECT_P2P);
	      }

	      callback(reconnectMode);
	    });
	    this.websocket.on(WebSocketManagerEvents.CONNECTED, function () {
	      _this.openConnectionTime = now$2();

	      if (_this.reconnectToken) {
	        // rejoin
	        _this.rejoin().catch(function (e) {
	          // 快速加会出错，走大重连
	          logger.warning("[" + _this.clientId + "] rejoin failed " + e);

	          _this.reconnect("tryNext");
	        });

	        return;
	      }

	      _this.join().catch(function (e) {
	        _this.emit(SignalEvent.REPORT_JOIN_GATEWAY, e.code, _this.url || "");
	        /**
	         * 如果在 join 过程中出现了 `NO_AUTHORIZED` 错误
	         * 说明是 `ticket` 过期，需要重新请求 AP
	         */


	        if (e instanceof AgoraRTCError) {
	          if (e.code === AgoraRTCErrorCode.UNEXPECTED_RESPONSE && e.data.code === GATEWAY_ERROR_CODE.ERR_NO_AUTHORIZED) {
	            logger.warning("[" + _this.clientId + "] reconnect no authorized, recover");

	            _this.reconnect("recover");

	            return;
	          }
	        }

	        logger.error("[" + _this.clientId + "] join gateway request failed", e.toString());

	        if (_this.spec.forceWaitGatewayResponse) {
	          _this.reconnect("tryNext");
	        } else {
	          _this.initError = e;

	          _this.close();
	        }
	      });
	    });
	    this.websocket.on(WebSocketManagerEvents.REQUEST_NEW_URLS, function (resolve, reject) {
	      emitAsPromise(_this, SignalEvent.REQUEST_RECOVER, _this.multiIpOption).then(resolve).catch(reject);
	    });
	  };

	  return AgoraRTCSignal;
	}(EventEmitter$1);

	var __extends$4 = undefined && undefined.__extends || function () {
	  var extendStatics = function (d, b) {
	    extendStatics = setPrototypeOf$2 || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    };

	    return extendStatics(d, b);
	  };

	  return function (d, b) {
	    extendStatics(d, b);

	    function __() {
	      this.constructor = d;
	    }

	    d.prototype = b === null ? create$4(b) : (__.prototype = b.prototype, new __());
	  };
	}();

	var Track =
	/** @class */
	function (_super) {
	  __extends$4(Track, _super);

	  function Track(track, trackId) {
	    var _this = _super.call(this) || this;
	    /** 用于描述这个 Track 的一些额外信息 */


	    _this._hints = [];
	    _this._ID = trackId || getRandomString(8, "track-");
	    _this._originMediaStreamTrack = track;
	    _this._mediaStreamTrack = track;
	    return _this;
	  }

	  Track.prototype.getTrackId = function () {
	    return this._ID;
	  };

	  Track.prototype.getMediaStreamTrack = function () {
	    return this._mediaStreamTrack;
	  };

	  return Track;
	}(EventEmitter$1);

	var __extends$5 = undefined && undefined.__extends || function () {
	  var extendStatics = function (d, b) {
	    extendStatics = setPrototypeOf$2 || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    };

	    return extendStatics(d, b);
	  };

	  return function (d, b) {
	    extendStatics(d, b);

	    function __() {
	      this.constructor = d;
	    }

	    d.prototype = b === null ? create$4(b) : (__.prototype = b.prototype, new __());
	  };
	}();

	var __awaiter$9 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = promise$3))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var __generator$9 = undefined && undefined.__generator || function (thisArg, body) {
	  var _ = {
	    label: 0,
	    sent: function () {
	      if (t[0] & 1) throw t[1];
	      return t[1];
	    },
	    trys: [],
	    ops: []
	  },
	      f,
	      y,
	      t,
	      g;
	  return g = {
	    next: verb(0),
	    "throw": verb(1),
	    "return": verb(2)
	  }, typeof symbol$2 === "function" && (g[iterator$2] = function () {
	    return this;
	  }), g;

	  function verb(n) {
	    return function (v) {
	      return step([n, v]);
	    };
	  }

	  function step(op) {
	    if (f) throw new TypeError("Generator is already executing.");

	    while (_) try {
	      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	      if (y = 0, t) op = [op[0] & 2, t.value];

	      switch (op[0]) {
	        case 0:
	        case 1:
	          t = op;
	          break;

	        case 4:
	          _.label++;
	          return {
	            value: op[1],
	            done: false
	          };

	        case 5:
	          _.label++;
	          y = op[1];
	          op = [0];
	          continue;

	        case 7:
	          op = _.ops.pop();

	          _.trys.pop();

	          continue;

	        default:
	          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
	            _ = 0;
	            continue;
	          }

	          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
	            _.label = op[1];
	            break;
	          }

	          if (op[0] === 6 && _.label < t[1]) {
	            _.label = t[1];
	            t = op;
	            break;
	          }

	          if (t && _.label < t[2]) {
	            _.label = t[2];

	            _.ops.push(op);

	            break;
	          }

	          if (t[2]) _.ops.pop();

	          _.trys.pop();

	          continue;
	      }

	      op = body.call(thisArg, _);
	    } catch (e) {
	      op = [6, e];
	      y = 0;
	    } finally {
	      f = t = 0;
	    }

	    if (op[0] & 5) throw op[1];
	    return {
	      value: op[0] ? op[1] : void 0,
	      done: true
	    };
	  }
	};

	var LocalTrack =
	/** @class */
	function (_super) {
	  __extends$5(LocalTrack, _super);

	  function LocalTrack(track, trackId) {
	    var _this = _super.call(this, track, trackId) || this;

	    _this._enabled = true;
	    _this._isClosed = false;
	    _this._trackProcessors = [];

	    _this._handleTrackEnded = function () {
	      _this.emit(LocalTrackEvents.TRACK_ENDED);
	    };

	    _this._enabledMutex = new PromiseMutex("" + trackId);
	    track.addEventListener("ended", _this._handleTrackEnded);
	    return _this;
	  }

	  LocalTrack.prototype.getTrackLabel = function () {
	    return this._originMediaStreamTrack.label;
	  };

	  LocalTrack.prototype.close = function () {
	    var _context;

	    this.stop();

	    forEach$3(_context = this._trackProcessors).call(_context, function (p) {
	      return p.destroy();
	    });

	    this._trackProcessors = [];

	    this._originMediaStreamTrack.stop();

	    if (this._mediaStreamTrack !== this._originMediaStreamTrack) {
	      this._mediaStreamTrack.stop();

	      this._mediaStreamTrack = null;
	    }

	    this._originMediaStreamTrack = null;
	    this._enabledMutex = null;
	    logger.debug("[" + this.getTrackId() + "] close");
	    this.emit(TrackInternalEvent.NEED_CLOSE);
	    this._isClosed = true;
	  };

	  LocalTrack.prototype._registerTrackProcessor = function (processor) {
	    return __awaiter$9(this, void 0, void 0, function () {
	      var lastProcessor;

	      var _this = this;

	      return __generator$9(this, function (_a) {
	        var _context2;

	        switch (_a.label) {
	          case 0:
	            if (indexOf$3(_context2 = this._trackProcessors).call(_context2, processor) !== -1) return [2
	            /*return*/
	            ];
	            lastProcessor = this._trackProcessors[this._trackProcessors.length - 1];

	            this._trackProcessors.push(processor);

	            processor.onOutputChange = function () {
	              return __awaiter$9(_this, void 0, void 0, function () {
	                var newTrack;
	                return __generator$9(this, function (_a) {
	                  switch (_a.label) {
	                    case 0:
	                      newTrack = processor.output || this._originMediaStreamTrack;
	                      this._mediaStreamTrack = newTrack;

	                      this._updatePlayerSource();

	                      return [4
	                      /*yield*/
	                      , emitAsPromiseNoResponse(this, TrackInternalEvent.NEED_REPLACE_TRACK, this._mediaStreamTrack)];

	                    case 1:
	                      _a.sent();

	                      return [2
	                      /*return*/
	                      ];
	                  }
	                });
	              });
	            };

	            if (!lastProcessor) return [3
	            /*break*/
	            , 2];

	            lastProcessor.onOutputChange = function () {
	              return __awaiter$9(_this, void 0, void 0, function () {
	                return __generator$9(this, function (_a) {
	                  switch (_a.label) {
	                    case 0:
	                      if (!lastProcessor.output) return [2
	                      /*return*/
	                      ];
	                      return [4
	                      /*yield*/
	                      , processor.setInput(lastProcessor.output)];

	                    case 1:
	                      _a.sent();

	                      return [2
	                      /*return*/
	                      ];
	                  }
	                });
	              });
	            };

	            return [4
	            /*yield*/
	            , processor.setInput(lastProcessor.output || lastProcessor.input || this._originMediaStreamTrack)];

	          case 1:
	            _a.sent();

	            return [3
	            /*break*/
	            , 4];

	          case 2:
	            return [4
	            /*yield*/
	            , processor.setInput(this._originMediaStreamTrack)];

	          case 3:
	            _a.sent();

	            _a.label = 4;

	          case 4:
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  LocalTrack.prototype._getOutputFromProcessors = function () {
	    if (this._trackProcessors.length === 0) return this._originMediaStreamTrack;
	    var lastProcessor = this._trackProcessors[this._trackProcessors.length - 1];
	    return lastProcessor.output || lastProcessor.input || this._originMediaStreamTrack;
	  }; // 更换原始的 mediaStreamTrack


	  LocalTrack.prototype._updateOriginMediaStreamTrack = function (track, stopOldTrack) {
	    return __awaiter$9(this, void 0, void 0, function () {
	      var output;
	      return __generator$9(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            if (track === this._originMediaStreamTrack) return [2
	            /*return*/
	            ];

	            this._originMediaStreamTrack.removeEventListener("ended", this._handleTrackEnded);

	            if (stopOldTrack) {
	              this._originMediaStreamTrack.stop();
	            }

	            track.addEventListener("ended", this._handleTrackEnded);
	            this._originMediaStreamTrack = track;
	            if (!(this._trackProcessors.length > 0)) return [3
	            /*break*/
	            , 2];
	            return [4
	            /*yield*/
	            , this._trackProcessors[0].setInput(track)];

	          case 1:
	            _a.sent();

	            output = this._getOutputFromProcessors();
	            this._mediaStreamTrack = output;
	            return [3
	            /*break*/
	            , 3];

	          case 2:
	            this._mediaStreamTrack = this._originMediaStreamTrack;
	            _a.label = 3;

	          case 3:
	            this._updatePlayerSource();

	            return [4
	            /*yield*/
	            , emitAsPromiseNoResponse(this, TrackInternalEvent.NEED_REPLACE_TRACK, this._mediaStreamTrack)];

	          case 4:
	            _a.sent();

	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  LocalTrack.prototype._getDefaultPlayerConfig = function () {
	    return {};
	  };

	  return LocalTrack;
	}(Track);

	var __awaiter$a = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = promise$3))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var __generator$a = undefined && undefined.__generator || function (thisArg, body) {
	  var _ = {
	    label: 0,
	    sent: function () {
	      if (t[0] & 1) throw t[1];
	      return t[1];
	    },
	    trys: [],
	    ops: []
	  },
	      f,
	      y,
	      t,
	      g;
	  return g = {
	    next: verb(0),
	    "throw": verb(1),
	    "return": verb(2)
	  }, typeof symbol$2 === "function" && (g[iterator$2] = function () {
	    return this;
	  }), g;

	  function verb(n) {
	    return function (v) {
	      return step([n, v]);
	    };
	  }

	  function step(op) {
	    if (f) throw new TypeError("Generator is already executing.");

	    while (_) try {
	      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	      if (y = 0, t) op = [op[0] & 2, t.value];

	      switch (op[0]) {
	        case 0:
	        case 1:
	          t = op;
	          break;

	        case 4:
	          _.label++;
	          return {
	            value: op[1],
	            done: false
	          };

	        case 5:
	          _.label++;
	          y = op[1];
	          op = [0];
	          continue;

	        case 7:
	          op = _.ops.pop();

	          _.trys.pop();

	          continue;

	        default:
	          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
	            _ = 0;
	            continue;
	          }

	          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
	            _.label = op[1];
	            break;
	          }

	          if (op[0] === 6 && _.label < t[1]) {
	            _.label = t[1];
	            t = op;
	            break;
	          }

	          if (t && _.label < t[2]) {
	            _.label = t[2];

	            _.ops.push(op);

	            break;
	          }

	          if (t[2]) _.ops.pop();

	          _.trys.pop();

	          continue;
	      }

	      op = body.call(thisArg, _);
	    } catch (e) {
	      op = [6, e];
	      y = 0;
	    } finally {
	      f = t = 0;
	    }

	    if (op[0] & 5) throw op[1];
	    return {
	      value: op[0] ? op[1] : void 0,
	      done: true
	    };
	  }
	};
	/**
	 * 理论上来说任何情况下 SDK 都不会使用 <audio> 标签去播放音频，统一使用 WebAudio
	 *
	 * 但是在 Chrome 上，使用 WebAudio 会导致回声消除失效
	 *
	 * 在找到可行方案之前，仅在这个情况下会使用 <audio> 标签
	 * https://bugs.chromium.org/p/chromium/issues/detail?id=687574
	 */

	var AudioElementPlayCenter =
	/** @class */
	function () {
	  function AudioElementPlayCenter() {
	    this.elementMap = new map$2();
	    this.elementsNeedToResume = [];
	    this.sinkIdMap = new map$2();
	    this.autoResumeAudioElement();
	  }

	  AudioElementPlayCenter.prototype.setSinkID = function (trackId, deviceID) {
	    return __awaiter$a(this, void 0, void 0, function () {
	      var element, e_1;
	      return __generator$a(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            element = this.elementMap.get(trackId);
	            this.sinkIdMap.set(trackId, deviceID);

	            if (!element) {
	              return [2
	              /*return*/
	              ];
	            }

	            _a.label = 1;

	          case 1:
	            _a.trys.push([1, 3,, 4]);

	            return [4
	            /*yield*/
	            , element.setSinkId(deviceID)];

	          case 2:
	            _a.sent();

	            return [3
	            /*break*/
	            , 4];

	          case 3:
	            e_1 = _a.sent();
	            throw new AgoraRTCError(AgoraRTCErrorCode.PERMISSION_DENIED, "can not set sink id: " + e_1.toString());

	          case 4:
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  AudioElementPlayCenter.prototype.play = function (track, trackId) {
	    var _this = this;

	    if (this.elementMap.has(trackId)) return;
	    var element = document.createElement("audio");
	    element.autoplay = true;
	    element.srcObject = new MediaStream([track]);
	    this.elementMap.set(trackId, element);
	    var sinkID = this.sinkIdMap.get(trackId);

	    if (sinkID) {
	      element.setSinkId(sinkID).catch(function (e) {
	        logger.warning("[" + trackId + "] set sink id failed", e.toString());
	      });
	    }

	    var promise = element.play();
	    if (!promise || !promise.then) return;
	    /**
	     * 使用 audioElement 调用 play 是有可能被 Autoplay 拦住的
	     * 我们需要处理这个情况
	     */

	    promise.catch(function (e) {
	      logger.warning("audio element play warning", e.toString());
	      /**
	       * 如果播放被中断/同步调用 stop等情况也可能触发播放报错，需要过滤这种情况
	       */

	      if (!_this.elementMap.has(trackId)) return;
	      /** 只处理 Autoplay 错误 */

	      if (e.name === "NotAllowedError") {
	        logger.warning("detected audio element autoplay failed");

	        _this.elementsNeedToResume.push(element);

	        nextTick(function () {
	          _this.onAutoplayFailed && _this.onAutoplayFailed();
	        });
	      }
	    });
	  };

	  AudioElementPlayCenter.prototype.updateTrack = function (trackId, track) {
	    var element = this.elementMap.get(trackId);
	    if (!element) return;
	    element.srcObject = new MediaStream([track]);
	  };

	  AudioElementPlayCenter.prototype.isPlaying = function (trackId) {
	    return this.elementMap.has(trackId);
	  };

	  AudioElementPlayCenter.prototype.setVolume = function (trackId, volume) {
	    var element = this.elementMap.get(trackId);
	    if (!element) return;
	    volume = Math.max(0, Math.min(100, volume));
	    element.volume = volume / 100;
	  };

	  AudioElementPlayCenter.prototype.stop = function (trackId) {
	    var _context, _context2;

	    var element = this.elementMap.get(trackId);
	    this.sinkIdMap.delete(trackId);
	    if (!element) return;

	    var resumeIndex = indexOf$3(_context = this.elementsNeedToResume).call(_context, element);

	    splice$2(_context2 = this.elementsNeedToResume).call(_context2, resumeIndex, 1);

	    element.srcObject = null;
	    element.remove();
	    this.elementMap.delete(trackId);
	  };
	  /**
	   * 监听页面事件，自动恢复音频播放
	   */


	  AudioElementPlayCenter.prototype.autoResumeAudioElement = function () {
	    var _this = this;

	    var resumeAudio = function () {
	      var _context3;

	      forEach$3(_context3 = _this.elementsNeedToResume).call(_context3, function (element) {
	        element.play().then(function (_) {
	          logger.debug("Auto resume audio element success");
	        }).catch(function (e) {
	          logger.warning("Auto resume audio element failed!", e);
	        });
	      });

	      _this.elementsNeedToResume = [];
	    };

	    domLoadedPromise().then(function () {
	      document.body.addEventListener("touchstart", resumeAudio, true);
	      document.body.addEventListener("mousedown", resumeAudio, true);
	    });
	  };

	  return AudioElementPlayCenter;
	}();

	var audioElementPlayCenter = new AudioElementPlayCenter();

	var __extends$6 = undefined && undefined.__extends || function () {
	  var extendStatics = function (d, b) {
	    extendStatics = setPrototypeOf$2 || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    };

	    return extendStatics(d, b);
	  };

	  return function (d, b) {
	    extendStatics(d, b);

	    function __() {
	      this.constructor = d;
	    }

	    d.prototype = b === null ? create$4(b) : (__.prototype = b.prototype, new __());
	  };
	}();

	var NativeAudioTrack =
	/** @class */
	function (_super) {
	  __extends$6(NativeAudioTrack, _super);

	  function NativeAudioTrack(track, isRemoteTrack) {
	    var _this = _super.call(this) || this;

	    _this.trackMediaType = "audio";
	    _this.isPlaying = false;
	    _this.isCurrentTrackCloned = false;
	    _this.isRemoteTrack = false;

	    if (track.kind !== "audio") {
	      throw new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_ERROR);
	    }

	    _this.track = track;
	    var ms = new MediaStream([_this.track]);
	    _this.isRemoteTrack = !!isRemoteTrack;
	    _this.maxVolume = 100;
	    _this.minVolume = 0;
	    _this.audioPlayer = new cordovaPluginAgoraRtc_NativePlayer.AudioPlayer(track);

	    _this.audioPlayer.getVolumeRange().then(function (range) {
	      _this.maxVolume = range.max;
	      _this.minVolume = range.min; // logger.debug(`[native_audio_track] audio volume range [${this.minVolume},${this.maxVolume}]`);
	    });

	    return _this;
	  }

	  defineProperty$4(NativeAudioTrack.prototype, "outputTrack", {
	    get: function () {
	      return this.track;
	    },
	    enumerable: true,
	    configurable: true
	  });

	  defineProperty$4(NativeAudioTrack.prototype, "isFreeze", {
	    get: function () {
	      return false;
	    },
	    enumerable: true,
	    configurable: true
	  });

	  defineProperty$4(NativeAudioTrack.prototype, "isPlayed", {
	    get: function () {
	      return true;
	    },
	    enumerable: true,
	    configurable: true
	  });

	  NativeAudioTrack.prototype.setVolume = function (volume) {
	    // throw new Error("Method not implemented.");
	    this.audioPlayer.setVolume(Math.round(volume * this.maxVolume / 100)).then().catch();
	  };

	  NativeAudioTrack.prototype.createOutputTrack = function () {
	    // throw new Error("Method not implemented.");
	    return this.track;
	  };

	  NativeAudioTrack.prototype.getAudioLevel = function () {
	    var val = Math.round(this.audioPlayer.getVolume() * 100 / this.maxVolume); // logger.debug(`[native_audio_track] audio volume [${this.audioPlayer.getVolume()},${val}]`);

	    return Math.round(this.audioPlayer.getVolume() * 100 / this.maxVolume);
	  };

	  NativeAudioTrack.prototype.getAudioAvgLevel = function () {
	    // throw new Error("Method not implemented.");
	    return 0;
	  }; // .ON_AUDIO_BUFFER


	  NativeAudioTrack.prototype.removeAllListeners = function (eventtype) {};

	  NativeAudioTrack.prototype.stopGetAudioBuffer = function () {};

	  NativeAudioTrack.prototype.startGetAudioBuffer = function (frameSize) {};

	  NativeAudioTrack.prototype.updateTrack = function (track) {
	    this.track = track;
	    this.isCurrentTrackCloned = false;
	    this.audioPlayer.updateTrack(track);
	  };

	  NativeAudioTrack.prototype.play = function () {};

	  NativeAudioTrack.prototype.stop = function () {};

	  NativeAudioTrack.prototype.destroy = function () {};

	  return NativeAudioTrack;
	}(EventEmitter$1);

	var __extends$7 = undefined && undefined.__extends || function () {
	  var extendStatics = function (d, b) {
	    extendStatics = setPrototypeOf$2 || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    };

	    return extendStatics(d, b);
	  };

	  return function (d, b) {
	    extendStatics(d, b);

	    function __() {
	      this.constructor = d;
	    }

	    d.prototype = b === null ? create$4(b) : (__.prototype = b.prototype, new __());
	  };
	}();

	var __assign$4 = undefined && undefined.__assign || function () {
	  __assign$4 = assign$2 || function (t) {
	    for (var s, i = 1, n = arguments.length; i < n; i++) {
	      s = arguments[i];

	      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	    }

	    return t;
	  };

	  return __assign$4.apply(this, arguments);
	};

	var __awaiter$b = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = promise$3))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var __generator$b = undefined && undefined.__generator || function (thisArg, body) {
	  var _ = {
	    label: 0,
	    sent: function () {
	      if (t[0] & 1) throw t[1];
	      return t[1];
	    },
	    trys: [],
	    ops: []
	  },
	      f,
	      y,
	      t,
	      g;
	  return g = {
	    next: verb(0),
	    "throw": verb(1),
	    "return": verb(2)
	  }, typeof symbol$2 === "function" && (g[iterator$2] = function () {
	    return this;
	  }), g;

	  function verb(n) {
	    return function (v) {
	      return step([n, v]);
	    };
	  }

	  function step(op) {
	    if (f) throw new TypeError("Generator is already executing.");

	    while (_) try {
	      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	      if (y = 0, t) op = [op[0] & 2, t.value];

	      switch (op[0]) {
	        case 0:
	        case 1:
	          t = op;
	          break;

	        case 4:
	          _.label++;
	          return {
	            value: op[1],
	            done: false
	          };

	        case 5:
	          _.label++;
	          y = op[1];
	          op = [0];
	          continue;

	        case 7:
	          op = _.ops.pop();

	          _.trys.pop();

	          continue;

	        default:
	          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
	            _ = 0;
	            continue;
	          }

	          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
	            _.label = op[1];
	            break;
	          }

	          if (op[0] === 6 && _.label < t[1]) {
	            _.label = t[1];
	            t = op;
	            break;
	          }

	          if (t && _.label < t[2]) {
	            _.label = t[2];

	            _.ops.push(op);

	            break;
	          }

	          if (t[2]) _.ops.pop();

	          _.trys.pop();

	          continue;
	      }

	      op = body.call(thisArg, _);
	    } catch (e) {
	      op = [6, e];
	      y = 0;
	    } finally {
	      f = t = 0;
	    }

	    if (op[0] & 5) throw op[1];
	    return {
	      value: op[0] ? op[1] : void 0,
	      done: true
	    };
	  }
	};

	var LocalAudioTrack =
	/** @class */
	function (_super) {
	  __extends$7(LocalAudioTrack, _super);

	  function LocalAudioTrack(track, encoderConfig, trackId) {
	    var _this = _super.call(this, track, trackId) || this;

	    _this.trackMediaType = "audio";
	    _this._enabled = true;
	    _this._useAudioElement = false;
	    _this._encoderConfig = encoderConfig;
	    _this._source = new NativeAudioTrack(track);
	    var compatibility = getCompatibility();

	    if (!compatibility.webAudioWithAEC) {
	      _this._useAudioElement = true;
	    }

	    return _this;
	  }

	  defineProperty$4(LocalAudioTrack.prototype, "isPlaying", {
	    get: function () {
	      return this._useAudioElement ? audioElementPlayCenter.isPlaying(this.getTrackId()) : this._source.isPlayed;
	    },
	    enumerable: true,
	    configurable: true
	  });

	  LocalAudioTrack.prototype.setVolume = function (volume) {
	    var _this = this;

	    checkValidNumber(volume, "volume", 0, 100);
	    var executor = report.reportApiInvoke(null, {
	      tag: AgoraAPITag.TRACER,
	      name: AgoraAPIName.LOCAL_AUDIO_TRACK_SET_VOLUME,
	      options: [this.getTrackId(), volume]
	    }, 300);

	    this._source.setVolume(volume);

	    try {
	      // 有可能浏览器不支持 webaudio track output
	      var newTrack = this._source.createOutputTrack();

	      if (this._mediaStreamTrack !== newTrack) {
	        this._mediaStreamTrack = newTrack;
	        emitAsPromiseNoResponse(this, TrackInternalEvent.NEED_REPLACE_TRACK, this._mediaStreamTrack).then(function () {
	          logger.debug("[" + _this.getTrackId() + "] replace web audio track success");
	        }).catch(function (e) {
	          logger.warning("[" + _this.getTrackId() + "] replace web audio track failed", e);
	        });
	      }
	    } catch (e) {}

	    executor.onSuccess();
	  };

	  LocalAudioTrack.prototype.getVolumeLevel = function () {
	    return this._source.getAudioLevel();
	  };

	  LocalAudioTrack.prototype.setPlaybackDevice = function (deviceId) {
	    return __awaiter$b(this, void 0, void 0, function () {
	      var executor, e_1;
	      return __generator$b(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            executor = report.reportApiInvoke(null, {
	              tag: AgoraAPITag.TRACER,
	              name: AgoraAPIName.REMOTE_AUDIO_SET_OUTPUT_DEVICE,
	              options: [this.getTrackId(), deviceId]
	            });

	            if (!this._useAudioElement) {
	              throw new AgoraRTCError(AgoraRTCErrorCode.NOT_SUPPORTED, "your browser does not support setting the audio output device");
	            }

	            _a.label = 1;

	          case 1:
	            _a.trys.push([1, 3,, 4]);

	            return [4
	            /*yield*/
	            , audioElementPlayCenter.setSinkID(this.getTrackId(), deviceId)];

	          case 2:
	            _a.sent();

	            return [3
	            /*break*/
	            , 4];

	          case 3:
	            e_1 = _a.sent();
	            executor.onError(e_1);
	            throw e_1;

	          case 4:
	            executor.onSuccess();
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  LocalAudioTrack.prototype.setEnabled = function (enabled) {
	    return __awaiter$b(this, void 0, void 0, function () {
	      var unlock, e_2, e_3;
	      return __generator$b(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            if (enabled === this._enabled) return [2
	            /*return*/
	            ];
	            logger.info("[" + this.getTrackId() + "] start setEnabled", enabled);
	            return [4
	            /*yield*/
	            , this._enabledMutex.lock()];

	          case 1:
	            unlock = _a.sent();
	            if (!!enabled) return [3
	            /*break*/
	            , 6];
	            this._originMediaStreamTrack.enabled = false;
	            _a.label = 2;

	          case 2:
	            _a.trys.push([2, 4,, 5]);

	            return [4
	            /*yield*/
	            , emitAsPromiseNoResponse(this, TrackInternalEvent.NEED_REMOVE_TRACK, this)];

	          case 3:
	            _a.sent();

	            return [3
	            /*break*/
	            , 5];

	          case 4:
	            e_2 = _a.sent();
	            logger.error("[" + this.getTrackId() + "] setEnabled to false error", e_2.toString());
	            unlock();
	            throw e_2;

	          case 5:
	            this._enabled = false;
	            return [2
	            /*return*/
	            , unlock()];

	          case 6:
	            this._originMediaStreamTrack.enabled = true;
	            _a.label = 7;

	          case 7:
	            _a.trys.push([7, 9,, 10]);

	            return [4
	            /*yield*/
	            , emitAsPromiseNoResponse(this, TrackInternalEvent.NEED_ADD_TRACK, this)];

	          case 8:
	            _a.sent();

	            return [3
	            /*break*/
	            , 10];

	          case 9:
	            e_3 = _a.sent();
	            logger.error("[" + this.getTrackId() + "] setEnabled to true error", e_3.toString());
	            unlock();
	            throw e_3;

	          case 10:
	            logger.info("[" + this.getTrackId() + "] setEnabled to " + enabled + " success");
	            this._enabled = true;
	            unlock();
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  LocalAudioTrack.prototype.getStats = function () {
	    runOnce(function () {
	      logger.warning("[deprecated] LocalAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalAudioStats instead");
	    }, "localAudioTrackGetStatsWarning");
	    var res = emitAsInvokerNoResponse(this, TrackInternalEvent.GET_STATS);
	    if (!res) return __assign$4({}, DEFAULT_LOCAL_AUDIO_TRACK_STATS);
	    return res;
	  };

	  LocalAudioTrack.prototype.setAudioFrameCallback = function (callback, frameSize) {
	    if (frameSize === void 0) {
	      frameSize = 4096;
	    }

	    if (!callback) {
	      this._source.removeAllListeners(AudioSourceEvents.ON_AUDIO_BUFFER);

	      this._source.stopGetAudioBuffer();

	      return;
	    }

	    this._source.startGetAudioBuffer(frameSize);

	    this._source.removeAllListeners(AudioSourceEvents.ON_AUDIO_BUFFER);

	    this._source.on(AudioSourceEvents.ON_AUDIO_BUFFER, function (buffer) {
	      return callback(buffer);
	    });
	  };

	  LocalAudioTrack.prototype.play = function () {
	    var executor = report.reportApiInvoke(null, {
	      tag: AgoraAPITag.TRACER,
	      name: AgoraAPIName.LOCAL_AUDIO_TRACK_PLAY,
	      options: [this.getTrackId()]
	    });
	    logger.debug("[" + this.getTrackId() + "] start audio playback");

	    if (this._useAudioElement) {
	      logger.debug("[" + this.getTrackId() + "] start audio playback in element");
	      audioElementPlayCenter.play(this._mediaStreamTrack, this.getTrackId());
	    } else {
	      this._source.play();
	    }

	    executor.onSuccess();
	  };

	  LocalAudioTrack.prototype.stop = function () {
	    var executor = report.reportApiInvoke(null, {
	      tag: AgoraAPITag.TRACER,
	      name: AgoraAPIName.LOCAL_AUDIO_TRACK_STOP,
	      options: [this.getTrackId()]
	    });
	    logger.debug("[" + this.getTrackId() + "] stop audio playback");

	    if (this._useAudioElement) {
	      audioElementPlayCenter.stop(this.getTrackId());
	    } else {
	      this._source.stop();
	    }

	    executor.onSuccess();
	  };

	  LocalAudioTrack.prototype.close = function () {
	    _super.prototype.close.call(this);

	    this._source.destroy();
	  };

	  LocalAudioTrack.prototype._updatePlayerSource = function () {
	    logger.debug("[track-" + this.getTrackId() + "] update player source track");

	    this._source.updateTrack(this._mediaStreamTrack);

	    if (this._useAudioElement) {
	      audioElementPlayCenter.updateTrack(this.getTrackId(), this._mediaStreamTrack);
	    }
	  };

	  LocalAudioTrack.prototype._updateOriginMediaStreamTrack = function (track, stopOldTrack) {
	    return __awaiter$b(this, void 0, void 0, function () {
	      return __generator$b(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            if (this._originMediaStreamTrack === track) return [2
	            /*return*/
	            ];

	            this._originMediaStreamTrack.removeEventListener("ended", this._handleTrackEnded);

	            track.addEventListener("ended", this._handleTrackEnded);

	            if (stopOldTrack) {
	              this._originMediaStreamTrack.stop();
	            }

	            this._originMediaStreamTrack = track;

	            this._source.updateTrack(this._originMediaStreamTrack);

	            if (!(this._mediaStreamTrack !== this._source.outputTrack)) return [3
	            /*break*/
	            , 2];
	            this._mediaStreamTrack = this._originMediaStreamTrack;

	            this._updatePlayerSource();

	            return [4
	            /*yield*/
	            , emitAsPromiseNoResponse(this, TrackInternalEvent.NEED_REPLACE_TRACK, this._mediaStreamTrack)];

	          case 1:
	            _a.sent();

	            _a.label = 2;

	          case 2:
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  return LocalAudioTrack;
	}(LocalTrack);

	var MicrophoneAudioTrack =
	/** @class */
	function (_super) {
	  __extends$7(MicrophoneAudioTrack, _super);

	  function MicrophoneAudioTrack(track, config, constraints, trackId) {
	    var _this = _super.call(this, track, config.encoderConfig ? getAudioEncoderConfiguration(config.encoderConfig) : {}, trackId) || this;

	    _this._deviceName = "default";
	    _this._enabled = true;
	    _this._config = config;
	    _this._constraints = constraints;
	    _this._deviceName = track.label;
	    return _this;
	  }

	  MicrophoneAudioTrack.prototype.setDevice = function (deviceId) {
	    return __awaiter$b(this, void 0, void 0, function () {
	      var executor, constraints, ms, e_4, e_5;
	      return __generator$b(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            executor = report.reportApiInvoke(null, {
	              tag: AgoraAPITag.TRACER,
	              name: AgoraAPIName.MIC_AUDIO_TRACK_SET_DEVICE,
	              options: [this.getTrackId(), deviceId]
	            });
	            logger.info("[" + this.getTrackId + "] start set device to " + deviceId);
	            _a.label = 1;

	          case 1:
	            _a.trys.push([1, 10,, 11]);

	            return [4
	            /*yield*/
	            , deviceManager.getDeviceById(deviceId)];

	          case 2:
	            _a.sent();

	            constraints = {};
	            constraints.audio = __assign$4({}, this._constraints);
	            constraints.audio.deviceId = {
	              exact: deviceId
	            };
	            /** 采集新的流之前先关闭当前的 track，防止有些设备不支持同时采集 */

	            this._originMediaStreamTrack.stop();

	            ms = null;
	            _a.label = 3;

	          case 3:
	            _a.trys.push([3, 5,, 8]);

	            return [4
	            /*yield*/
	            , getLocalStream(constraints, this.getTrackId())];

	          case 4:
	            ms = _a.sent();
	            return [3
	            /*break*/
	            , 8];

	          case 5:
	            e_4 = _a.sent();
	            logger.error("[track-" + this.getTrackId() + "] setDevice failed", e_4.toString());
	            return [4
	            /*yield*/
	            , getLocalStream({
	              video: this._constraints
	            }, this.getTrackId())];

	          case 6:
	            /** 采集新流发生错误，需要回滚到旧流 */
	            ms = _a.sent();
	            return [4
	            /*yield*/
	            , this._updateOriginMediaStreamTrack(ms.getAudioTracks()[0], false)];

	          case 7:
	            _a.sent();

	            throw e_4;

	          case 8:
	            return [4
	            /*yield*/
	            , this._updateOriginMediaStreamTrack(ms.getAudioTracks()[0], false)];

	          case 9:
	            _a.sent();

	            this._config.microphoneId = deviceId;
	            this._constraints.deviceId = {
	              exact: deviceId
	            };
	            return [3
	            /*break*/
	            , 11];

	          case 10:
	            e_5 = _a.sent();
	            executor.onError(e_5);
	            logger.error("[track-" + this.getTrackId() + "] setDevice error", e_5.toString());
	            throw e_5;

	          case 11:
	            executor.onSuccess();
	            logger.info("[" + this.getTrackId + "] set device to " + deviceId + " success");
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  MicrophoneAudioTrack.prototype.setEnabled = function (enabled, notCloseDevice) {
	    return __awaiter$b(this, void 0, void 0, function () {
	      var unlock, e_6, constraints, deviceId, ms, e_7;
	      return __generator$b(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            if (!notCloseDevice) return [3
	            /*break*/
	            , 2];
	            logger.debug("[" + this.getTrackId + "] setEnabled false (do not close microphone)");
	            return [4
	            /*yield*/
	            , _super.prototype.setEnabled.call(this, enabled)];

	          case 1:
	            return [2
	            /*return*/
	            , _a.sent()];

	          case 2:
	            if (enabled === this._enabled) return [2
	            /*return*/
	            ];
	            logger.info("[" + this.getTrackId() + "] start setEnabled", enabled);
	            return [4
	            /*yield*/
	            , this._enabledMutex.lock()];

	          case 3:
	            unlock = _a.sent();
	            if (!!enabled) return [3
	            /*break*/
	            , 8];
	            this._originMediaStreamTrack.onended = null;

	            this._originMediaStreamTrack.stop();

	            this._enabled = false;
	            _a.label = 4;

	          case 4:
	            _a.trys.push([4, 6,, 7]);

	            return [4
	            /*yield*/
	            , emitAsPromiseNoResponse(this, TrackInternalEvent.NEED_REMOVE_TRACK, this)];

	          case 5:
	            _a.sent();

	            return [3
	            /*break*/
	            , 7];

	          case 6:
	            e_6 = _a.sent();
	            logger.error("[" + this.getTrackId() + "] setEnabled false failed", e_6.toString());
	            unlock();
	            throw e_6;

	          case 7:
	            unlock();
	            return [2
	            /*return*/
	            ];

	          case 8:
	            constraints = __assign$4({}, this._constraints);
	            deviceId = deviceManager.searchDeviceIdByName(this._deviceName);

	            if (deviceId && !constraints.deviceId) {
	              constraints.deviceId = deviceId;
	            }

	            _a.label = 9;

	          case 9:
	            _a.trys.push([9, 13,, 14]);

	            return [4
	            /*yield*/
	            , getLocalStream({
	              audio: this._constraints
	            }, this.getTrackId())];

	          case 10:
	            ms = _a.sent();
	            return [4
	            /*yield*/
	            , this._updateOriginMediaStreamTrack(ms.getAudioTracks()[0], false)];

	          case 11:
	            _a.sent();

	            return [4
	            /*yield*/
	            , emitAsPromiseNoResponse(this, TrackInternalEvent.NEED_ADD_TRACK, this)];

	          case 12:
	            _a.sent();

	            return [3
	            /*break*/
	            , 14];

	          case 13:
	            e_7 = _a.sent();
	            unlock();
	            logger.error("[" + this.getTrackId() + "] setEnabled true failed", e_7.toString());
	            throw e_7;

	          case 14:
	            this._enabled = true;
	            logger.info("[" + this.getTrackId() + "] setEnabled success");
	            unlock();
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  return MicrophoneAudioTrack;
	}(LocalAudioTrack);

	var BufferSourceAudioTrack =
	/** @class */
	function (_super) {
	  __extends$7(BufferSourceAudioTrack, _super);

	  function BufferSourceAudioTrack(source, bufferSource, encodingConfig, trackId) {
	    var _this = _super.call(this, bufferSource.createOutputTrack(), encodingConfig, trackId) || this;

	    _this.source = source;
	    _this._bufferSource = bufferSource;

	    _this._bufferSource.on(AudioSourceEvents.AUDIO_SOURCE_STATE_CHANGE, function (curState) {
	      _this.emit(LocalTrackEvents.SOURCE_STATE_CHANGE, curState);
	    });

	    try {
	      // 有可能浏览器不支持 webaudio track output
	      _this._mediaStreamTrack = _this._source.createOutputTrack();
	    } catch (e) {}

	    return _this;
	  }

	  defineProperty$4(BufferSourceAudioTrack.prototype, "currentState", {
	    get: function () {
	      return this._bufferSource.currentState;
	    },
	    enumerable: true,
	    configurable: true
	  });

	  defineProperty$4(BufferSourceAudioTrack.prototype, "duration", {
	    get: function () {
	      return this._bufferSource.duration;
	    },
	    enumerable: true,
	    configurable: true
	  });

	  BufferSourceAudioTrack.prototype.getCurrentTime = function () {
	    return this._bufferSource.currentTime;
	  };

	  BufferSourceAudioTrack.prototype.startProcessAudioBuffer = function (options) {
	    var executor = report.reportApiInvoke(null, {
	      tag: AgoraAPITag.TRACER,
	      name: AgoraAPIName.BUFFER_AUDIO_TRACK_START,
	      options: [this.getTrackId(), options, this.duration]
	    });
	    options && this._bufferSource.updateOptions(options);

	    this._bufferSource.startProcessAudioBuffer();

	    executor.onSuccess();
	  };

	  BufferSourceAudioTrack.prototype.pauseProcessAudioBuffer = function () {
	    var executor = report.reportApiInvoke(null, {
	      tag: AgoraAPITag.TRACER,
	      name: AgoraAPIName.BUFFER_AUDIO_TRACK_PAUSE,
	      options: [this.getTrackId()]
	    });

	    this._bufferSource.pauseProcessAudioBuffer();

	    executor.onSuccess();
	  };

	  BufferSourceAudioTrack.prototype.seekAudioBuffer = function (time) {
	    var executor = report.reportApiInvoke(null, {
	      tag: AgoraAPITag.TRACER,
	      name: AgoraAPIName.BUFFER_AUDIO_TRACK_SEEK,
	      options: [this.getTrackId()]
	    });

	    this._bufferSource.seekAudioBuffer(time);

	    executor.onSuccess();
	  };

	  BufferSourceAudioTrack.prototype.resumeProcessAudioBuffer = function () {
	    var executor = report.reportApiInvoke(null, {
	      tag: AgoraAPITag.TRACER,
	      name: AgoraAPIName.BUFFER_AUDIO_TRACK_RESUME,
	      options: [this.getTrackId()]
	    });

	    this._bufferSource.resumeProcessAudioBuffer();

	    executor.onSuccess();
	  };

	  BufferSourceAudioTrack.prototype.stopProcessAudioBuffer = function () {
	    var executor = report.reportApiInvoke(null, {
	      tag: AgoraAPITag.TRACER,
	      name: AgoraAPIName.BUFFER_AUDIO_TRACK_STOP,
	      options: [this.getTrackId()]
	    });

	    this._bufferSource.stopProcessAudioBuffer();

	    executor.onSuccess();
	  };

	  return BufferSourceAudioTrack;
	}(LocalAudioTrack);

	var MixingAudioTrack =
	/** @class */
	function (_super) {
	  __extends$7(MixingAudioTrack, _super);

	  function MixingAudioTrack() {
	    var _this = this;

	    var context = getAudioContext();
	    var destNode = context.createMediaStreamDestination();
	    var track = destNode.stream.getAudioTracks()[0];
	    _this = _super.call(this, track) || this;

	    try {
	      // 有可能浏览器不支持 webaudio track output
	      _this._mediaStreamTrack = _this._source.createOutputTrack();
	    } catch (e) {}

	    _this.destNode = destNode;
	    _this.trackList = [];
	    return _this;
	  }

	  MixingAudioTrack.prototype.hasAudioTrack = function (track) {
	    var _context;

	    return indexOf$3(_context = this.trackList).call(_context, track) !== -1;
	  };

	  MixingAudioTrack.prototype.addAudioTrack = function (track) {
	    var _context2;

	    if (indexOf$3(_context2 = this.trackList).call(_context2, track) !== -1) {
	      logger.warning("track is already added");
	      return;
	    }

	    logger.debug("add " + track.getTrackId() + " to mixing track"); // track._source.outputNode.connect(this.destNode);

	    this.trackList.push(track);
	    this.updateEncoderConfig();
	  };

	  MixingAudioTrack.prototype.removeAudioTrack = function (track) {
	    var _context3;

	    var index = indexOf$3(_context3 = this.trackList).call(_context3, track);

	    if (index === -1) return;
	    logger.debug("remove " + track.getTrackId() + " from mixing track");

	    removeItemFromList(this.trackList, track);
	    this.updateEncoderConfig();
	  }; // 混音后的编码配置取音源编码配置中数值高的配置


	  MixingAudioTrack.prototype.updateEncoderConfig = function () {
	    var _context4;

	    var encoderConfig = {};

	    forEach$3(_context4 = this.trackList).call(_context4, function (track) {
	      if (!track._encoderConfig) return;

	      if ((track._encoderConfig.bitrate || 0) > (encoderConfig.bitrate || 0)) {
	        encoderConfig.bitrate = track._encoderConfig.bitrate;
	      }

	      if ((track._encoderConfig.sampleRate || 0) > (encoderConfig.sampleRate || 0)) {
	        encoderConfig.sampleRate = track._encoderConfig.sampleRate;
	      }

	      if ((track._encoderConfig.sampleSize || 0) > (encoderConfig.sampleSize || 0)) {
	        encoderConfig.sampleSize = track._encoderConfig.sampleSize;
	      }

	      if (track._encoderConfig.stereo) {
	        encoderConfig.stereo = true;
	      }
	    });

	    this._encoderConfig = encoderConfig;
	  };

	  return MixingAudioTrack;
	}(LocalAudioTrack);

	function concatTypedArrays(a, b, contructorOfArray) {
	  var c = new contructorOfArray(a.length + b.length);
	  c.set(a, 0);
	  c.set(b, a.length);
	  return c;
	}

	function fillTypedArrays(a, appendCount) {
	  if (appendCount === 0) {
	    return a;
	  }

	  var c = new a.constructor(a.length + appendCount);
	  var p = new a.constructor(appendCount);
	  c.set(a, 0);
	  c.set(p, a.length);
	  return c;
	}

	function getMessageEncoding(text) {
	  var enc = new TextEncoder();
	  return enc.encode(text);
	}

	var encryptAES = function (secret, key) {
	  var secretLength = secret.length;
	  var encodedSecret = getMessageEncoding(secret);
	  var filledEncodedSecret = fillTypedArrays(encodedSecret, (4 - encodedSecret.length % 4) % 4);
	  var arr = concatTypedArrays([secretLength], new Uint32Array(filledEncodedSecret.buffer), Uint32Array);

	  for (var i = 0; i < arr.length; i++) {
	    arr[i] = arr[i] ^ key;
	    arr[i] = ~arr[i];
	  }

	  return uint8ArrayToBase64(new Uint8Array(arr.buffer));
	};

	var __extends$8 = undefined && undefined.__extends || function () {
	  var extendStatics = function (d, b) {
	    extendStatics = setPrototypeOf$2 || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    };

	    return extendStatics(d, b);
	  };

	  return function (d, b) {
	    extendStatics(d, b);

	    function __() {
	      this.constructor = d;
	    }

	    d.prototype = b === null ? create$4(b) : (__.prototype = b.prototype, new __());
	  };
	}();

	var __assign$5 = undefined && undefined.__assign || function () {
	  __assign$5 = assign$2 || function (t) {
	    for (var s, i = 1, n = arguments.length; i < n; i++) {
	      s = arguments[i];

	      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	    }

	    return t;
	  };

	  return __assign$5.apply(this, arguments);
	};

	var __awaiter$c = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = promise$3))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var __generator$c = undefined && undefined.__generator || function (thisArg, body) {
	  var _ = {
	    label: 0,
	    sent: function () {
	      if (t[0] & 1) throw t[1];
	      return t[1];
	    },
	    trys: [],
	    ops: []
	  },
	      f,
	      y,
	      t,
	      g;
	  return g = {
	    next: verb(0),
	    "throw": verb(1),
	    "return": verb(2)
	  }, typeof symbol$2 === "function" && (g[iterator$2] = function () {
	    return this;
	  }), g;

	  function verb(n) {
	    return function (v) {
	      return step([n, v]);
	    };
	  }

	  function step(op) {
	    if (f) throw new TypeError("Generator is already executing.");

	    while (_) try {
	      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	      if (y = 0, t) op = [op[0] & 2, t.value];

	      switch (op[0]) {
	        case 0:
	        case 1:
	          t = op;
	          break;

	        case 4:
	          _.label++;
	          return {
	            value: op[1],
	            done: false
	          };

	        case 5:
	          _.label++;
	          y = op[1];
	          op = [0];
	          continue;

	        case 7:
	          op = _.ops.pop();

	          _.trys.pop();

	          continue;

	        default:
	          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
	            _ = 0;
	            continue;
	          }

	          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
	            _.label = op[1];
	            break;
	          }

	          if (op[0] === 6 && _.label < t[1]) {
	            _.label = t[1];
	            t = op;
	            break;
	          }

	          if (t && _.label < t[2]) {
	            _.label = t[2];

	            _.ops.push(op);

	            break;
	          }

	          if (t[2]) _.ops.pop();

	          _.trys.pop();

	          continue;
	      }

	      op = body.call(thisArg, _);
	    } catch (e) {
	      op = [6, e];
	      y = 0;
	    } finally {
	      f = t = 0;
	    }

	    if (op[0] & 5) throw op[1];
	    return {
	      value: op[0] ? op[1] : void 0,
	      done: true
	    };
	  }
	};
	/**
	 * 保存所有当前页面上加入 channel 的 uid，防止重复
	 */

	var registeredChannelUIDList = new map$2();

	var AgoraRTCGateway =
	/** @class */
	function (_super) {
	  __extends$8(AgoraRTCGateway, _super);

	  function AgoraRTCGateway(spec) {
	    var _this = _super.call(this) || this;

	    _this.inChannelInfo = {
	      joinAt: null,
	      duration: 0
	    };
	    _this._state = "DISCONNECTED";
	    /**
	     * 正常情况下，重连 PC 都需要发送 `unpublish/unsubscribe`
	     * 但是如果重连 PC 遭遇了 Websocket 重建，此时就无需发送 `unpublish/unsubscribe`
	     */

	    _this.needToSendUnpubUnsub = new map$2();
	    /**
	     * 用于标记 Signal 在这次重连中是否触发了 recover，上报统计用
	     */

	    _this.isSignalRecover = false;
	    _this.hasChangeBGPAddress = false;
	    _this.joinGatewayStartTime = 0;
	    _this._signalTimeout = false;
	    _this.clientId = spec.clientId;
	    _this.spec = spec;
	    _this.signal = new AgoraRTCSignal(__assign$5(__assign$5({}, spec), {
	      retryConfig: spec.websocketRetryConfig
	    }));
	    _this._statsCollector = spec.statsCollector;
	    _this.role = spec.role || "audience";

	    _this.handleSignalEvents();

	    return _this;
	  }

	  defineProperty$4(AgoraRTCGateway.prototype, "state", {
	    get: function () {
	      return this._state;
	    },
	    set: function (newState) {
	      if (newState === this._state) return;
	      var prevState = this._state;
	      this._state = newState;

	      if (newState === "DISCONNECTED" && this._disconnectedReason) {
	        this.emit(GatewayEvent.CONNECTION_STATE_CHANGE, newState, prevState, this._disconnectedReason);
	      } else {
	        this.emit(GatewayEvent.CONNECTION_STATE_CHANGE, newState, prevState);
	      }
	    },
	    enumerable: true,
	    configurable: true
	  });

	  AgoraRTCGateway.prototype.join = function (joinInfo, key) {
	    return __awaiter$c(this, void 0, void 0, function () {
	      var now, registeredUIDList, err, urls, uid, message, e_1;

	      var _this = this;

	      return __generator$c(this, function (_a) {
	        var _context;

	        switch (_a.label) {
	          case 0:
	            if (joinInfo.cloudProxyServer !== "disabled") {
	              this.hasChangeBGPAddress = true;
	            }

	            now = now$2();
	            registeredUIDList = registeredChannelUIDList.get(joinInfo.cname);

	            if (!registeredUIDList) {
	              registeredUIDList = new map$2();
	              registeredChannelUIDList.set(joinInfo.cname, registeredUIDList);
	            }
	            /** 因为 Client.join 已经有了 runtime 参数检查，这里假定 joinInfo 是符合类型要求的 */


	            if (registeredUIDList.has(joinInfo.uid)) {
	              err = new AgoraRTCError(AgoraRTCErrorCode.UID_CONFLICT);
	              report.joinGateway(joinInfo.sid, {
	                lts: now,
	                succ: false,
	                ec: err.code,
	                addr: null,
	                uid: joinInfo.uid,
	                cid: joinInfo.cid
	              });
	              throw err;
	            }

	            registeredUIDList.set(joinInfo.uid, true);
	            this.joinInfo = joinInfo;
	            this.key = key;
	            urls = map$5(_context = joinInfo.gatewayAddrs).call(_context, function (address) {
	              return "wss://" + address;
	            });
	            uid = 0;
	            this.joinGatewayStartTime = now;
	            _a.label = 1;

	          case 1:
	            _a.trys.push([1, 3,, 4]);

	            return [4
	            /*yield*/
	            , this.signal.init(urls)];

	          case 2:
	            message = _a.sent();
	            uid = message.uid;
	            return [3
	            /*break*/
	            , 4];

	          case 3:
	            e_1 = _a.sent();
	            logger.error("[" + this.clientId + "] User join failed", e_1.toString());
	            report.joinGateway(joinInfo.sid, {
	              lts: now,
	              succ: false,
	              ec: e_1.code === AgoraRTCErrorCode.UNEXPECTED_ERROR ? e_1.message : e_1.code,
	              addr: this.signal.url,
	              uid: joinInfo.uid,
	              cid: joinInfo.cid
	            });
	            registeredUIDList.delete(joinInfo.uid);
	            this.signal.close();
	            throw e_1;

	          case 4:
	            /** 连接成功 */
	            this.state = "CONNECTED";
	            this.inChannelInfo.joinAt = now$2();
	            logger.debug("[" + this.clientId + "] Connected to gateway server");
	            this.trafficStatsInterval = window.setInterval(function () {
	              _this.updateTrafficStats().catch(function (e) {
	                logger.warning("[" + _this.clientId + "] get traffic stats error", e.toString());
	              });
	            }, 3000);
	            this.networkQualityInterval = window.setInterval(function () {
	              if (navigator && navigator.onLine !== undefined && !navigator.onLine) {
	                _this.emit(GatewayEvent.NETWORK_QUALITY, {
	                  downlinkNetworkQuality: 6,
	                  uplinkNetworkQuality: 6
	                });
	              } else if (_this._signalTimeout) {
	                _this.emit(GatewayEvent.NETWORK_QUALITY, {
	                  downlinkNetworkQuality: 5,
	                  uplinkNetworkQuality: 5
	                });
	              } else if (_this.state !== "CONNECTED" || !_this._statsCollector.trafficStats) {
	                _this.emit(GatewayEvent.NETWORK_QUALITY, {
	                  uplinkNetworkQuality: 0,
	                  downlinkNetworkQuality: 0
	                });
	              } else {
	                _this.emit(GatewayEvent.NETWORK_QUALITY, {
	                  uplinkNetworkQuality: getNetworkQuality(_this._statsCollector.trafficStats.B_unq),
	                  downlinkNetworkQuality: getNetworkQuality(_this._statsCollector.trafficStats.B_dnq)
	                });
	              }
	            }, 2000);
	            return [2
	            /*return*/
	            , uid];
	        }
	      });
	    });
	  };
	  /**
	   * @param noLeaveMessage - 为 true 表示不向网关发送 leave message，直接断开连接
	   */


	  AgoraRTCGateway.prototype.leave = function (noLeaveMessage) {
	    if (noLeaveMessage === void 0) {
	      noLeaveMessage = false;
	    }

	    return __awaiter$c(this, void 0, void 0, function () {
	      var e_2;
	      return __generator$c(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            // 允许重复离开
	            if (this.state === "DISCONNECTED") {
	              return [2
	              /*return*/
	              ];
	            }

	            this.state = "DISCONNECTING";
	            _a.label = 1;

	          case 1:
	            _a.trys.push([1, 4,, 5]);

	            if (!(!noLeaveMessage && this.signal.connectionState === SignalConnectionState.CONNECTED)) return [3
	            /*break*/
	            , 3]; // 3s 收不到 leave response 直接 close

	            return [4
	            /*yield*/
	            , withTimeout(this.signal.request(SignalRequestType.LEAVE, undefined, true), 3000)];

	          case 2:
	            // 3s 收不到 leave response 直接 close
	            _a.sent();

	            _a.label = 3;

	          case 3:
	            return [3
	            /*break*/
	            , 5];

	          case 4:
	            e_2 = _a.sent(); // 这里抛出的错误一律不管，leave 不允许出错

	            logger.warning("[" + this.clientId + "] leave request failed, ignore", e_2);
	            return [3
	            /*break*/
	            , 5];

	          case 5:
	            this.signal.close();
	            this.reset();
	            this.state = "DISCONNECTED";
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  AgoraRTCGateway.prototype.publish = function (sc, streamType) {
	    return __awaiter$c(this, void 0, void 0, function () {
	      var uid, attr, err;

	      var _this = this;

	      return __generator$c(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            if (!this.joinInfo) {
	              throw new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_ERROR, "publish no joinInfo");
	            }

	            uid = sc.getUserId();
	            attr = sc.videoTrack ? getStreamPublishAttributes(sc.videoTrack) : {};
	            sc.on(StreamConnectionEvents.NEED_ANSWER, function (message, resolve, reject) {
	              var _context2;

	              var publishReq = {
	                state: "offer",
	                stream_type: streamType,
	                p2p_id: sc.pc.ID,
	                sdp: stringify$2(message),
	                audio: !!sc.audioTrack,
	                video: !!sc.videoTrack,
	                screen: sc.videoTrack && indexOf$3(_context2 = sc.videoTrack._hints).call(_context2, TrackHint.SCREEN_TRACK) !== -1,
	                attributes: attr,
	                dtx: sc.audioTrack instanceof MicrophoneAudioTrack ? sc.audioTrack._config.DTX : false,
	                hq: false,
	                lq: false,
	                stereo: false,
	                speech: false,
	                mode: _this.spec.mode,
	                codec: _this.spec.codec,
	                extend: getParameter("PUB_EXTEND")
	              };

	              _this.signal.request(SignalRequestType.PUBLISH, publishReq, true).then(function (response) {
	                if (uid) {
	                  _this.needToSendUnpubUnsub.set(uid, true);
	                }

	                resolve(JSON.parse(response.sdp));
	              }).catch(function (e) {
	                /**
	                 * 发布请求非法，可能是因为和网关的 P2P 状态不一致导致，此时尝试先 unpub 再 pub
	                 * 如果还是失败再回调给用户
	                 */
	                if (message.retry && e.data && e.data.code === GATEWAY_ERROR_CODE.ERR_PUBLISH_REQUEST_INVALID) {
	                  logger.warning("[" + _this.clientId + "] receiver publish error code, retry", e.toString());
	                  return emitAsPromise(sc, StreamConnectionEvents.NEED_UNPUB).then(function () {
	                    message.retry = false;
	                    emitAsPromise(sc, StreamConnectionEvents.NEED_ANSWER, message).then(resolve).catch(reject);
	                  });
	                }
	                /** 如果遭遇了 WS 中断，这个错误暂时不返回给上层，等待下次 WS 重连时触发 repub */


	                if (e.code !== AgoraRTCErrorCode.WS_ABORT) {
	                  reject(e);
	                }
	              });
	            });
	            sc.on(StreamConnectionEvents.NEED_RENEGOTIATE, function (sdp, resolve, reject) {
	              var publishReq = {
	                state: "negotiation",
	                stream_type: streamType,
	                p2p_id: sc.pc.ID,
	                sdp: sdp
	              };

	              _this.signal.request(SignalRequestType.PUBLISH, publishReq, true).then(function (response) {
	                resolve(JSON.parse(response.sdp));
	              }).catch(function (e) {
	                /** 如果遭遇了 WS 中断，这个错误暂时不返回给上层，等待下次 WS 重连时触发 repub */
	                if (e.code !== AgoraRTCErrorCode.WS_ABORT) {
	                  reject(e);
	                }
	              });
	            });
	            sc.on(StreamConnectionEvents.NEED_UNPUB, function (resolve) {
	              if (uid && !_this.needToSendUnpubUnsub.has(uid)) return resolve(false);
	              /** 如果在重连过程中调用  unpub，直接认为成功 */

	              if (_this.state === "RECONNECTING") {
	                return resolve(true);
	              }

	              _this.signal.request(SignalRequestType.UNPUBLISH, {
	                stream_id: sc.getUserId(),
	                stream_type: streamType
	              }, true).then(function () {
	                return resolve(false);
	              }).catch(function (e) {
	                /**
	                 * 因为我已经主动关闭了 pc，无论网关返回什么，也改变不了我已经成功取消发布的事实
	                 */
	                // 如果 P2P 在重连过程中请求 unpub 失败，说明目前网关目前已经断线，需要中止重试
	                logger.warning("unpublish warning: ", e);
	                resolve(true);
	              });
	            });
	            sc.on(StreamConnectionEvents.NEED_UPLOAD, function (uploadType, message) {
	              _this.signal.upload(uploadType, {
	                stream_type: streamType,
	                stats: message
	              });
	            });
	            sc.on(StreamConnectionEvents.NEED_SIGNAL_RTT, function (callback) {
	              callback(_this.signal.rtt);
	            });
	            /** 如果在网关重连过程中发布，将这个 connection 标记成等待重连 */

	            if (this.state === "RECONNECTING") {
	              sc.readyToReconnectPC();
	              return [2
	              /*return*/
	              ];
	              /** 其他情况报错 */
	            } else if (this.state !== "CONNECTED") {
	              err = new AgoraRTCError(AgoraRTCErrorCode.INVALID_OPERATION, "can not publish when connection state is " + this.state);
	              return [2
	              /*return*/
	              , err.throw()];
	            }

	            return [4
	            /*yield*/
	            , sc.startP2PConnection()];

	          case 1:
	            _a.sent();

	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  AgoraRTCGateway.prototype.subscribe = function (sc) {
	    return __awaiter$c(this, void 0, void 0, function () {
	      var uid, err;

	      var _this = this;

	      return __generator$c(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            if (!this.joinInfo) {
	              throw new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_ERROR, "subscribe no joinInfo");
	            }

	            uid = sc.getUserId();
	            sc.on(StreamConnectionEvents.NEED_ANSWER, function (message, resolve, reject) {
	              var subOptions = sc.subscribeOptions;
	              var subscribeReq = {
	                stream_id: sc.getUserId(),
	                audio: !!subOptions.audio,
	                video: !!subOptions.video,
	                mode: _this.spec.mode,
	                codec: _this.spec.codec,
	                p2p_id: sc.pc.ID,
	                sdp: stringify$2(message),
	                tcc: !!getParameter("SUBSCRIBE_TCC"),
	                extend: getParameter("SUB_EXTEND")
	              };

	              _this.signal.request(SignalRequestType.SUBSCRIBE, subscribeReq, true).then(function (response) {
	                _this.needToSendUnpubUnsub.set(uid, true);

	                resolve(JSON.parse(response.sdp));
	              }).catch(function (e) {
	                /**
	                 * 订阅请求非法，可能是因为和网关的 P2P 状态不一致导致，此时尝试先 unsub 再 sub
	                 * 如果还是失败再回调给用户
	                 */
	                if (message.retry && e.data && e.data.code === GATEWAY_ERROR_CODE.ERR_SUBSCRIBE_REQUEST_INVALID) {
	                  logger.warning("[" + _this.clientId + "] receiver subscribe error code, retry", e.toString());
	                  return emitAsPromise(sc, StreamConnectionEvents.NEED_UNSUB).then(function () {
	                    message.retry = false;
	                    emitAsPromise(sc, StreamConnectionEvents.NEED_ANSWER, message).then(resolve).catch(reject);
	                  });
	                }
	                /** 如果遭遇了 WS 中断，这个错误暂时不返回给上层，等待下次 WS 重连时触发 resub */


	                if (e.code !== AgoraRTCErrorCode.WS_ABORT) {
	                  reject(e);
	                }
	              });
	            });
	            sc.on(StreamConnectionEvents.NEED_UNSUB, function (resolve) {
	              if (!_this.needToSendUnpubUnsub.has(uid)) return resolve(false);

	              if (_this.state === "RECONNECTING") {
	                return resolve(true);
	              }

	              _this.signal.request(SignalRequestType.UNSUBSCRIBE, {
	                stream_id: sc.getUserId()
	              }, true).then(function () {
	                return resolve(false);
	              }).catch(function (e) {
	                // 如果 P2P 在重连过程中请求 unsub 失败，说明目前网关目前已经断线，需要中止重试
	                logger.warning("unsubscribe warning", e);
	                resolve(true);
	              });
	            });
	            sc.on(StreamConnectionEvents.NEED_UPLOAD, function (uploadType, message) {
	              _this.signal.upload(uploadType, {
	                stream_id: sc.getUserId(),
	                stats: message
	              });
	            });
	            sc.on(StreamConnectionEvents.NEED_SIGNAL_RTT, function (callback) {
	              callback(_this.signal.rtt);
	            });
	            /** 如果在网关重连过程中发布，将这个 connection 标记成等待重连 */

	            if (this.state === "RECONNECTING") {
	              sc.readyToReconnectPC();
	              return [2
	              /*return*/
	              ];
	              /** 其他情况报错 */
	            } else if (this.state !== "CONNECTED") {
	              err = new AgoraRTCError(AgoraRTCErrorCode.INVALID_OPERATION, "can not subscribe when connection state is " + this.state);
	              return [2
	              /*return*/
	              , err.throw()];
	            }

	            return [4
	            /*yield*/
	            , sc.startP2PConnection()];

	          case 1:
	            _a.sent();

	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  AgoraRTCGateway.prototype.subscribeChange = function (sc, subOptions) {
	    return __awaiter$c(this, void 0, void 0, function () {
	      var err;
	      return __generator$c(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            if (!this.joinInfo) {
	              throw new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_ERROR, "subscribe no joinInfo");
	            }

	            return [4
	            /*yield*/
	            , sc.setSubscribeOptions(subOptions)];

	          case 1:
	            _a.sent();

	            if (this.state === "RECONNECTING") {
	              return [2
	              /*return*/
	              ];
	            } else if (this.state !== "CONNECTED") {
	              err = new AgoraRTCError(AgoraRTCErrorCode.INVALID_OPERATION, "can not subscribe change when connection state is " + this.state);
	              return [2
	              /*return*/
	              , err.throw()];
	            }

	            logger.debug("[" + this.clientId + "] send subscribe change, audio: " + subOptions.audio + ", video: " + subOptions.video);
	            return [4
	            /*yield*/
	            , this.signal.request(SignalRequestType.SUBSCRIBE_CHANGE, {
	              stream_id: sc.getUserId(),
	              audio: !!subOptions.audio,
	              video: !!subOptions.video
	            }, true)];

	          case 2:
	            _a.sent();

	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  AgoraRTCGateway.prototype.unsubscribe = function (sc) {
	    return __awaiter$c(this, void 0, void 0, function () {
	      return __generator$c(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            return [4
	            /*yield*/
	            , sc.closeP2PConnection()];

	          case 1:
	            _a.sent();

	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  AgoraRTCGateway.prototype.getGatewayInfo = function () {
	    return this.signal.request(SignalRequestType.GATEWAY_INFO);
	  };

	  AgoraRTCGateway.prototype.renewToken = function (token) {
	    return this.signal.request(SignalRequestType.RENEW_TOKEN, {
	      token: token
	    });
	  };

	  AgoraRTCGateway.prototype.setClientRole = function (role) {
	    return __awaiter$c(this, void 0, void 0, function () {
	      return __generator$c(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            if (role === this.role) return [2
	            /*return*/
	            ];

	            if (this.state !== "CONNECTED") {
	              this.role = role;
	              return [2
	              /*return*/
	              ];
	            }

	            return [4
	            /*yield*/
	            , this.signal.request(SignalRequestType.SET_CLIENT_ROLE, {
	              role: role
	            })];

	          case 1:
	            _a.sent();

	            this.role = role;
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  AgoraRTCGateway.prototype.setRemoteVideoStreamType = function (uid, streamType) {
	    return __awaiter$c(this, void 0, void 0, function () {
	      return __generator$c(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            return [4
	            /*yield*/
	            , this.signal.request(SignalRequestType.SWITCH_VIDEO_STREAM, {
	              stream_id: uid,
	              stream_type: streamType
	            })];

	          case 1:
	            _a.sent();

	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  AgoraRTCGateway.prototype.setStreamFallbackOption = function (uid, fallbackType) {
	    return __awaiter$c(this, void 0, void 0, function () {
	      return __generator$c(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            return [4
	            /*yield*/
	            , this.signal.request(SignalRequestType.SET_FALLBACK_OPTION, {
	              stream_id: uid,
	              fallback_type: fallbackType
	            })];

	          case 1:
	            _a.sent();

	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  AgoraRTCGateway.prototype.getInChannelInfo = function () {
	    if (this.inChannelInfo.joinAt) {
	      this.inChannelInfo.duration = now$2() - this.inChannelInfo.joinAt;
	    }

	    return __assign$5({}, this.inChannelInfo);
	  };

	  AgoraRTCGateway.prototype.getGatewayVersion = function () {
	    return __awaiter$c(this, void 0, void 0, function () {
	      var res;
	      return __generator$c(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            return [4
	            /*yield*/
	            , this.signal.request(SignalRequestType.GATEWAY_INFO)];

	          case 1:
	            res = _a.sent();
	            return [2
	            /*return*/
	            , res.version];
	        }
	      });
	    });
	  };

	  AgoraRTCGateway.prototype.reset = function () {
	    if (this.inChannelInfo.joinAt) {
	      this.inChannelInfo.duration = now$2() - this.inChannelInfo.joinAt;
	      this.inChannelInfo.joinAt = null;
	    }

	    if (this.trafficStatsInterval) {
	      window.clearInterval(this.trafficStatsInterval);
	      this.trafficStatsInterval = undefined;
	    }

	    if (this.joinInfo) {
	      var registeredUIDList = registeredChannelUIDList.get(this.joinInfo.cname);
	      registeredUIDList && registeredUIDList.delete(this.joinInfo.uid);
	    }

	    this.needToSendUnpubUnsub = new map$2();
	    this.joinInfo = undefined;
	    this.key = undefined;

	    if (this.networkQualityInterval) {
	      window.clearInterval(this.networkQualityInterval);
	      this.networkQualityInterval = undefined;
	    }
	  };

	  AgoraRTCGateway.prototype.updateTurnConfigFromSignal = function () {
	    if (!this.joinInfo) return;
	    var turnConfig = gatewayURLToTurnConfig(this.signal.url || "");

	    if (turnConfig && this.joinInfo.turnServer.mode !== "off") {
	      this.joinInfo.turnServer.servers.push(__assign$5(__assign$5({}, DEFAULT_TURN_CONFIG), {
	        turnServerURL: turnConfig.turnServerURL,
	        tcpport: turnConfig.tcpport,
	        udpport: turnConfig.udpport
	      }));
	    }
	  };

	  AgoraRTCGateway.prototype.updateTrafficStats = function () {
	    return __awaiter$c(this, void 0, void 0, function () {
	      var res;

	      var _this = this;

	      return __generator$c(this, function (_a) {
	        var _context3;

	        switch (_a.label) {
	          case 0:
	            if (this.state !== "CONNECTED") return [2
	            /*return*/
	            ];
	            return [4
	            /*yield*/
	            , this.signal.request(SignalRequestType.TRAFFIC_STATS, undefined, true)];

	          case 1:
	            res = _a.sent();
	            res.timestamp = now$2();

	            forEach$3(_context3 = res.peer_delay).call(_context3, function (peer) {
	              var _context4;

	              var oldPeer = _this._statsCollector.trafficStats && find$2(_context4 = _this._statsCollector.trafficStats.peer_delay).call(_context4, function (p) {
	                return p.peer_uid === peer.peer_uid;
	              });

	              if (!oldPeer) return;

	              if (oldPeer.B_st !== peer.B_st) {
	                nextTick(function () {
	                  _this.emit(GatewayEvent.STREAM_TYPE_CHANGE, peer.peer_uid, peer.B_st);
	                });
	              }
	            });

	            this._statsCollector.updateTrafficStats(res);

	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  AgoraRTCGateway.prototype.getJoinMessage = function () {
	    if (!this.joinInfo || !this.key) {
	      throw new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_ERROR, "can not generate join message, no join info");
	    }

	    var apResponse = assign$2({}, this.joinInfo.apResponse);

	    var message = {
	      session_id: this.joinInfo.sid,
	      app_id: this.joinInfo.appId,
	      channel_key: this.key,
	      channel_name: this.joinInfo.cname,
	      sdk_version: VERSION,
	      browser: navigator.userAgent,
	      process_id: getParameter("PROCESS_ID"),
	      mode: this.spec.mode,
	      codec: this.spec.codec,
	      role: this.role,
	      has_changed_gateway: this.hasChangeBGPAddress,
	      ap_response: apResponse,
	      extends: getParameter("JOIN_EXTEND"),
	      details: {
	        6: this.joinInfo.stringUid
	      },
	      features: {
	        rejoin: true
	      },
	      optionalInfo: this.joinInfo.optionalInfo
	    };

	    if (this.joinInfo.stringUid) {
	      message.string_uid = this.joinInfo.stringUid;
	    }

	    if (this.joinInfo.aesmode && this.joinInfo.aespassword) {
	      message.aes_mode = this.joinInfo.aesmode;

	      if (getParameter("ENCRYPT_AES")) {
	        message.aes_secret = encryptAES(this.joinInfo.aespassword, apResponse.uid);
	        message.aes_encrypt = true;
	      } else {
	        message.aes_secret = this.joinInfo.aespassword;
	      }
	    }

	    if (apResponse.addresses[this.signal.websocket.currentURLIndex]) {
	      message.ap_response.ticket = apResponse.addresses[this.signal.websocket.currentURLIndex].ticket; // @ts-ignore

	      delete apResponse.addresses;
	    }

	    return message;
	  };

	  AgoraRTCGateway.prototype.getRejoinMessage = function () {
	    if (!this.joinInfo) {
	      throw new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_ERROR, "can not generate rejoin message, no join info");
	    }

	    var message = {
	      session_id: this.joinInfo.sid,
	      channel_name: this.joinInfo.cname,
	      cid: this.joinInfo.cid,
	      uid: this.joinInfo.uid,
	      vid: Number(this.joinInfo.vid)
	    };
	    return message;
	  };

	  AgoraRTCGateway.prototype.handleSignalEvents = function () {
	    var _this = this;

	    this.signal.on(SignalEvent.WS_RECONNECTING, function () {
	      if (!_this.joinInfo) return;
	      _this.state = "RECONNECTING";
	      report.sessionInit(_this.joinInfo.sid, {
	        lts: new Date().getTime(),
	        extend: _this.isSignalRecover ? {
	          recover: true
	        } : {
	          rejoin: true
	        },
	        cname: _this.joinInfo.cname,
	        appid: _this.joinInfo.appId,
	        mode: _this.spec.mode
	      });
	      _this.isSignalRecover = false;
	      _this.joinGatewayStartTime = now$2();
	    });
	    /** 用户主动关闭连接的情况 */

	    this.signal.on(SignalEvent.WS_CLOSED, function (reason) {
	      _this.reset();

	      _this._disconnectedReason = reason;
	      _this.state = "DISCONNECTED";
	    });
	    /** 只有当 signal 断开且放弃重试的时候才会触发 FAILED，此时已经处于不可逆转的断开状态 */

	    this.signal.on(SignalEvent.WS_CONNECTED, function () {
	      _this.updateTurnConfigFromSignal();

	      _this.state = "CONNECTED";
	      if (!_this.joinInfo) return;
	      report.joinGateway(_this.joinInfo.sid, {
	        lts: _this.joinGatewayStartTime,
	        succ: true,
	        ec: null,
	        vid: _this.joinInfo.vid,
	        addr: _this.signal.url,
	        uid: _this.joinInfo.uid,
	        cid: _this.joinInfo.cid
	      });
	    });
	    this.signal.on(SignalNotifyType.ON_UPLINK_STATS, function (stats) {
	      _this._statsCollector.updateUplinkStats(stats);
	    });
	    /** signal 的所有 gatewayList 都宣告不可用，请求一组新的 gatewayList */

	    this.signal.on(SignalEvent.REQUEST_RECOVER, function (multiIP, resolve, reject) {
	      if (!_this.joinInfo) {
	        return reject(new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_ERROR, "gateway: can not recover, no join info"));
	      }

	      if (multiIP) {
	        _this.joinInfo.multiIP = multiIP;
	        _this.hasChangeBGPAddress = true;
	      }

	      _this.isSignalRecover = true;
	      emitAsPromise(_this, GatewayEvent.REQUEST_NEW_GATEWAY_LIST).then(resolve).catch(reject);
	    });
	    this.signal.on(SignalEvent.REQUEST_JOIN_INFO, function (resolve) {
	      resolve(_this.getJoinMessage());
	    });
	    this.signal.on(SignalEvent.REQUEST_REJOIN_INFO, function (resolve) {
	      resolve(_this.getRejoinMessage());
	    });
	    this.signal.on(SignalEvent.REPORT_JOIN_GATEWAY, function (errorCode, url) {
	      if (!_this.joinInfo) return;
	      report.joinGateway(_this.joinInfo.sid, {
	        lts: _this.joinGatewayStartTime,
	        succ: false,
	        ec: errorCode,
	        addr: url,
	        uid: _this.joinInfo.uid,
	        cid: _this.joinInfo.cid
	      });
	    });
	    this.signal.on(SignalEvent.IS_P2P_DISCONNECTED, function (callback) {
	      var result = emitAsInvoker(_this, GatewayEvent.IS_P2P_DISCONNECTED);
	      callback(result);
	    });
	    this.signal.on(SignalEvent.DISCONNECT_P2P, function () {
	      /** 当发生大重连时，重连无需发送 unpub/unsub */
	      _this.needToSendUnpubUnsub = new map$2();

	      _this.emit(GatewayEvent.DISCONNECT_P2P);
	    });
	    this.signal.on(SignalEvent.NEED_RENEW_SESSION, function () {
	      _this.emit(GatewayEvent.NEED_RENEW_SESSION);
	    });
	    this.signal.on(SignalEvent.REQUEST_SUCCESS, function () {
	      _this._signalTimeout = false;
	    });
	    this.signal.on(SignalEvent.REQUEST_TIMEOUT, function () {
	      _this._signalTimeout = true;
	    });
	  };

	  return AgoraRTCGateway;
	}(EventEmitter$1);

	var ConfigDistributeManager =
	/** @class */
	function () {
	  function ConfigDistributeManager(client) {
	    this.client = client;
	  }

	  ConfigDistributeManager.prototype.updateConfig = function (clientId, config) {
	    if (!config) return;

	    if (!isEmpty(config.uploadLog)) {
	      setParameter("UPLOAD_LOG", config.uploadLog);
	      var executor = report.reportApiInvoke(this.client._sessionId || null, {
	        name: AgoraAPIName.SET_CONFIG_DISTRIBUTE,
	        options: {
	          feature: "uploadLog",
	          value: config.uploadLog
	        }
	      });
	      executor.onSuccess();
	    }

	    if (!isEmpty(config.dualStream)) {
	      this.client._isDualStreamEnabled = config.dualStream;
	      var executor = report.reportApiInvoke(this.client._sessionId || null, {
	        name: AgoraAPIName.SET_CONFIG_DISTRIBUTE,
	        options: {
	          feature: "dualStream",
	          value: config.dualStream
	        }
	      });
	      executor.onSuccess();
	    }

	    if (!isEmpty(config.streamFallbackOptions)) {
	      this.client._defaultStreamFallbackType = config.streamFallbackOptions;
	    }

	    try {
	      var _context;

	      logger.debug("[" + clientId + "] setParameter in distribution: " + stringify$2(config));

	      map$5(_context = keys$3(config)).call(_context, function (key) {
	        return setParameter(key, config[key]);
	      });
	    } catch (e) {
	      logger.debug("[" + clientId + "] setParameter in distribution failed: " + stringify$2(config));
	    }
	  };

	  return ConfigDistributeManager;
	}();

	var __assign$6 = undefined && undefined.__assign || function () {
	  __assign$6 = assign$2 || function (t) {
	    for (var s, i = 1, n = arguments.length; i < n; i++) {
	      s = arguments[i];

	      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	    }

	    return t;
	  };

	  return __assign$6.apply(this, arguments);
	};

	var __awaiter$d = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = promise$3))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var __generator$d = undefined && undefined.__generator || function (thisArg, body) {
	  var _ = {
	    label: 0,
	    sent: function () {
	      if (t[0] & 1) throw t[1];
	      return t[1];
	    },
	    trys: [],
	    ops: []
	  },
	      f,
	      y,
	      t,
	      g;
	  return g = {
	    next: verb(0),
	    "throw": verb(1),
	    "return": verb(2)
	  }, typeof symbol$2 === "function" && (g[iterator$2] = function () {
	    return this;
	  }), g;

	  function verb(n) {
	    return function (v) {
	      return step([n, v]);
	    };
	  }

	  function step(op) {
	    if (f) throw new TypeError("Generator is already executing.");

	    while (_) try {
	      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	      if (y = 0, t) op = [op[0] & 2, t.value];

	      switch (op[0]) {
	        case 0:
	        case 1:
	          t = op;
	          break;

	        case 4:
	          _.label++;
	          return {
	            value: op[1],
	            done: false
	          };

	        case 5:
	          _.label++;
	          y = op[1];
	          op = [0];
	          continue;

	        case 7:
	          op = _.ops.pop();

	          _.trys.pop();

	          continue;

	        default:
	          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
	            _ = 0;
	            continue;
	          }

	          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
	            _.label = op[1];
	            break;
	          }

	          if (op[0] === 6 && _.label < t[1]) {
	            _.label = t[1];
	            t = op;
	            break;
	          }

	          if (t && _.label < t[2]) {
	            _.label = t[2];

	            _.ops.push(op);

	            break;
	          }

	          if (t[2]) _.ops.pop();

	          _.trys.pop();

	          continue;
	      }

	      op = body.call(thisArg, _);
	    } catch (e) {
	      op = [6, e];
	      y = 0;
	    } finally {
	      f = t = 0;
	    }

	    if (op[0] & 5) throw op[1];
	    return {
	      value: op[0] ? op[1] : void 0,
	      done: true
	    };
	  }
	};
	/**
	 * stringUID -> uintUID api
	 * @param cancelToken - 用于上层来通过这个 token 中止这个 ajax 请求
	 */

	function requestUserAccount(urlList, stringUID, info, cancelToken, retryConfig) {
	  return __awaiter$d(this, void 0, void 0, function () {
	    var now, req, url, ajaxPromise, handleError, handleResult, res, detail;
	    return __generator$d(this, function (_a) {
	      switch (_a.label) {
	        case 0:
	          now = now$2();
	          req = {
	            sid: info.sid,
	            opid: 10,
	            appid: info.appId,
	            string_uid: stringUID
	          };
	          url = urlList[0];

	          ajaxPromise = function () {
	            return post$1(url + ((indexOf$3(url).call(url, "?") === -1 ? "?" : "&") + "action=stringuid"), {
	              data: req,
	              cancelToken: cancelToken,
	              headers: {
	                "X-Packet-Service-Type": 0,
	                "X-Packet-URI": 72
	              }
	            });
	          };

	          handleError = function (e, retryCount) {
	            if (e.code === AgoraRTCErrorCode.OPERATION_ABORTED) {
	              return false;
	            }

	            report.reqUserAccount(req.sid, {
	              lts: now,
	              success: false,
	              serverAddr: url,
	              stringUid: req.string_uid,
	              uid: null,
	              errorCode: e.code,
	              extend: req
	            });
	            url = urlList[(retryCount + 1) % urlList.length];
	            return true;
	          };

	          handleResult = function (res, retryCount) {
	            if (res.code === 0) {
	              if (res.uid <= 0 || res.uid >= Math.pow(2, 32)) {
	                logger.error("Invalid Uint Uid " + stringUID + " => " + res.uid, res);
	                report.reqUserAccount(req.sid, {
	                  lts: now,
	                  success: false,
	                  serverAddr: url,
	                  stringUid: req.string_uid,
	                  uid: res.uid,
	                  errorCode: AgoraRTCErrorCode.INVALID_UINT_UID_FROM_STRING_UID,
	                  extend: req
	                });
	                throw new AgoraRTCError(AgoraRTCErrorCode.INVALID_UINT_UID_FROM_STRING_UID);
	              }

	              report.reqUserAccount(req.sid, {
	                lts: now,
	                success: true,
	                serverAddr: url,
	                stringUid: req.string_uid,
	                uid: res.uid,
	                errorCode: null,
	                extend: req
	              });
	              return false;
	            }

	            var apErrorDetail = getApErrorDetail(res.code);

	            if (apErrorDetail.retry) {
	              url = urlList[(retryCount + 1) % urlList.length];
	            }

	            report.reqUserAccount(req.sid, {
	              lts: now,
	              success: false,
	              serverAddr: url,
	              stringUid: req.string_uid,
	              uid: res.uid,
	              errorCode: apErrorDetail.desc,
	              extend: req
	            });
	            return apErrorDetail.retry;
	          };

	          return [4
	          /*yield*/
	          , retryable(ajaxPromise, handleResult, handleError, retryConfig)];

	        case 1:
	          res = _a.sent();
	          /** 走到这里说明是无法通过重试恢复的错误 */

	          if (res.code !== 0) {
	            detail = getApErrorDetail(res.code);
	            throw new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_RESPONSE, detail.desc);
	          }

	          return [2
	          /*return*/
	          , res];
	      }
	    });
	  });
	}
	/**
	 * 获取当前可用的云代理地址
	 * 因为上层需要并行得调用这个方法，所以返回一个可以 cancel 的 Promise
	 *
	 * @param retryTimeout - 暴露给单测使用的接口
	 */

	function requestProxyServerList(url, info, cancelToken, retryConfig) {
	  var _this = this;

	  var now = now$2();

	  var reqData = {
	    command: "convergeAllocateEdge",
	    sid: info.sid,
	    appId: info.appId,
	    token: info.token,
	    uid: info.uid,
	    cname: info.cname,
	    ts: Math.floor(now$2() / 1000),
	    version: VERSION,
	    seq: 0,
	    requestId: 1
	  };

	  var ajaxPromise = function () {
	    return __awaiter$d(_this, void 0, void 0, function () {
	      var res;
	      return __generator$d(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            return [4
	            /*yield*/
	            , post$1(url, {
	              data: {
	                service_name: "webrtc_proxy",
	                json_body: stringify$2(reqData)
	              },
	              cancelToken: cancelToken,
	              headers: {
	                "X-Packet-Service-Type": 0,
	                "X-Packet-URI": 61
	              }
	            })];

	          case 1:
	            res = _a.sent();
	            return [2
	            /*return*/
	            , {
	              res: res,
	              url: url
	            }];
	        }
	      });
	    });
	  };

	  var handleError = function (e) {
	    if (e.code === AgoraRTCErrorCode.OPERATION_ABORTED) {
	      return false;
	    }

	    report.requestProxyAppCenter(reqData.sid, {
	      lts: now,
	      succ: false,
	      APAddr: url,
	      workerManagerList: null,
	      ec: e.code,
	      response: e.message
	    });
	    return true;
	  };

	  var handleResult = function (data) {
	    if (!data.res.json_body) {
	      logger.debug("[" + info.clientId + "] Get proxy server failed: no json_body");
	      throw new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_RESPONSE, stringify$2(data.res));
	    }

	    var body = JSON.parse(data.res.json_body);

	    if (body.code !== 200) {
	      logger.debug("[" + info.clientId + "] Get proxy server failed: response code [" + body.code + "], reason [" + body.reason + "]");
	      throw new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_RESPONSE, stringify$2(data.res));
	    }

	    logger.debug("[" + info.clientId + "] App return server length", body.servers.length);
	    return false;
	  };

	  return retryable(ajaxPromise, handleResult, handleError, retryConfig);
	}
	/**
	 * 通过代理服务器的域名获取代理节点的详细信息
	 *
	 * @param retryTimeout - 暴露给单测使用的接口
	 */

	function requestProxyWorkerManager(url, info, cancelToken, retryConfig) {
	  var _this = this;

	  var now = now$2();

	  var requestURL = url;

	  if (!startsWith$2(url).call(url, "http")) {
	    requestURL = "https://" + url + ":4000/v2/machine";
	  }

	  var reqData = {
	    command: "request",
	    gatewayType: "http",
	    appId: info.appId,
	    // hardcode to 2.3.1
	    cname: info.cname,
	    uid: (info.uid || "").toString(),
	    sdkVersion: "2.3.1",
	    sid: info.sid,
	    seq: 1,
	    ts: now$2(),
	    requestId: 3,
	    clientRequest: {
	      appId: info.appId,
	      cname: info.cname,
	      uid: (info.uid || "").toString(),
	      sid: info.sid
	    }
	  };

	  var ajaxPromise = function () {
	    return __awaiter$d(_this, void 0, void 0, function () {
	      var res;
	      return __generator$d(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            return [4
	            /*yield*/
	            , post$1(requestURL, {
	              data: reqData,
	              cancelToken: cancelToken
	            })];

	          case 1:
	            res = _a.sent();
	            return [2
	            /*return*/
	            , {
	              res: res,
	              url: url
	            }];
	        }
	      });
	    });
	  };

	  var handleError = function (e) {
	    if (e.code === AgoraRTCErrorCode.OPERATION_ABORTED) {
	      return false;
	    }

	    report.requestProxyWorkerManager(reqData.sid, {
	      lts: now,
	      succ: false,
	      workerManagerAddr: url,
	      ec: e.code,
	      response: e.message
	    });
	    return true;
	  };

	  var handleResult = function (res) {
	    if (!res.res.serverResponse) {
	      throw new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_RESPONSE, "requeet worker manager server failed: serverResponse is undefined");
	    }

	    return false;
	  };

	  return retryable(ajaxPromise, handleResult, handleError, retryConfig);
	}
	var liveStreamingAPCount = 1;
	/**
	 * 请求 LiveStreaming 服务的 worker manager
	 */

	function requestLiveStreamingWorkerManager(urls, mode, info, cancelToken, retryConfig) {
	  var _this = this;

	  liveStreamingAPCount += 1;
	  var reqDataBody = {
	    sid: info.sid,
	    command: "convergeAllocateEdge",
	    uid: "666",
	    appId: info.appId,
	    ts: Math.floor(now$2() / 1000),
	    seq: liveStreamingAPCount,
	    requestId: liveStreamingAPCount,
	    version: VERSION,
	    cname: info.cname
	  };
	  var reqBody = {
	    service_name: mode,
	    json_body: stringify$2(reqDataBody)
	  };
	  var url = urls[0];
	  var requestStartTime;
	  var responseTime;

	  var ajaxPromise = function () {
	    return __awaiter$d(_this, void 0, void 0, function () {
	      var res, err, resBody, err, err, result;
	      return __generator$d(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            requestStartTime = now$2();
	            return [4
	            /*yield*/
	            , post$1(url, {
	              data: reqBody,
	              cancelToken: cancelToken,
	              headers: {
	                "X-Packet-Service-Type": "0",
	                "X-Packet-URI": "61"
	              }
	            })];

	          case 1:
	            res = _a.sent();
	            responseTime = now$2() - requestStartTime;

	            if (res.code !== 0) {
	              err = new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_RESPONSE, "live streaming ap error, code" + res.code, {
	                retry: true,
	                responseTime: responseTime
	              });
	              logger.error(err.toString());
	              throw err;
	            }

	            resBody = JSON.parse(res.json_body);

	            if (resBody.code !== 200) {
	              err = new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_RESPONSE, "live streaming app center error, code: " + resBody.code + ", reason: " + resBody.reason, {
	                code: resBody.code,
	                responseTime: responseTime
	              });
	              logger.error(err.toString());
	              throw err;
	            }

	            if (!resBody.servers || resBody.servers.length === 0) {
	              err = new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_RESPONSE, "live streaming app center empty server", {
	                code: resBody.code,
	                responseTime: responseTime
	              });
	              logger.error(err.toString());
	              throw err;
	            }

	            result = liveStreamingServerResponseToResult(resBody, mode);

	            if (getParameter("LIVE_STREAMING_ADDRESS")) {
	              result.addressList = getParameter("LIVE_STREAMING_ADDRESS") instanceof Array ? getParameter("LIVE_STREAMING_ADDRESS") : [getParameter("LIVE_STREAMING_ADDRESS")];
	            }

	            return [2
	            /*return*/
	            , __assign$6(__assign$6({}, result), {
	              responseTime: responseTime
	            })];
	        }
	      });
	    });
	  };

	  var handleResult = function (res, retryCount) {
	    report.apworkerEvent(info.sid, {
	      success: true,
	      sc: 200,
	      serviceName: mode,
	      responseDetail: stringify$2(res.addressList),
	      firstSuccess: retryCount === 0 ? true : false,
	      responseTime: responseTime,
	      serverIp: urls[retryCount % urls.length]
	    });
	    return false;
	  };

	  var handleError = function (e, retryCount) {
	    report.apworkerEvent(info.sid, {
	      success: false,
	      sc: e.data && e.data.code || 200,
	      serviceName: mode,
	      responseTime: responseTime,
	      serverIp: urls[retryCount % urls.length]
	    });

	    if (e.code === AgoraRTCErrorCode.OPERATION_ABORTED || e.code === AgoraRTCErrorCode.UNEXPECTED_RESPONSE) {
	      if (!e.data || !e.data.retry) {
	        return false;
	      }
	    }

	    url = urls[(retryCount + 1) % urls.length];
	    return true;
	  };

	  return retryable(ajaxPromise, handleResult, handleError, retryConfig);
	}
	var channelMediaRelayApRequestCount = 1;
	function requestChannelMediaRelayWorkerManager(url, joinInfo, cancelToken, retryConfig) {
	  var _this = this;

	  var reqDataBody = {
	    command: "convergeAllocateEdge",
	    sid: joinInfo.sid,
	    appId: joinInfo.appId,
	    token: joinInfo.token,
	    ts: now$2(),
	    version: VERSION,
	    cname: joinInfo.cname,
	    uid: joinInfo.uid.toString(),
	    requestId: channelMediaRelayApRequestCount,
	    seq: channelMediaRelayApRequestCount
	  };
	  channelMediaRelayApRequestCount += 1;
	  var reqData = {
	    service_name: "tele_channel",
	    json_body: stringify$2(reqDataBody)
	  };

	  var ajaxPromise = function () {
	    return __awaiter$d(_this, void 0, void 0, function () {
	      var res, err, resBody, err, err;
	      return __generator$d(this, function (_a) {
	        var _context;

	        switch (_a.label) {
	          case 0:
	            return [4
	            /*yield*/
	            , post$1(url, {
	              data: reqData,
	              cancelToken: cancelToken,
	              headers: {
	                "X-Packet-Service-Type": 0,
	                "X-Packet-URI": 61
	              }
	            })];

	          case 1:
	            res = _a.sent();

	            if (res.code !== 0) {
	              err = new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_RESPONSE, "cross channel ap error, code" + res.code, {
	                retry: true
	              });
	              logger.error(err.toString());
	              throw err;
	            }

	            resBody = JSON.parse(res.json_body);

	            if (resBody.code !== 200) {
	              err = new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_RESPONSE, "cross channel app center error, code: " + resBody.code + ", reason: " + resBody.reason);
	              logger.error(err.toString());
	              throw err;
	            }

	            if (!resBody.servers || resBody.servers.length === 0) {
	              err = new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_RESPONSE, "cross channel app center empty server");
	              logger.error(err.toString());
	              throw err;
	            }

	            return [2
	            /*return*/
	            , {
	              vid: resBody.vid,
	              workerToken: resBody.workerToken,
	              addressList: map$5(_context = resBody.servers).call(_context, function (server) {
	                return "wss://" + server.address.replace(/\./g, "-") + ".edge.agora.io:" + server.wss;
	              })
	            }];
	        }
	      });
	    });
	  };

	  var handleError = function (e) {
	    if (e.code === AgoraRTCErrorCode.OPERATION_ABORTED || e.code === AgoraRTCErrorCode.UNEXPECTED_RESPONSE) {
	      if (!e.data || !e.data.retry) {
	        return false;
	      }
	    }

	    return true;
	  };

	  return retryable(ajaxPromise, undefined, handleError, retryConfig);
	}
	function requestChooseServer(_a, info, cancelToken, retryConfig) {
	  var _this = this;

	  var url = _a.url,
	      areaCode = _a.areaCode;

	  var now = now$2();

	  var reqData = {
	    opid: 133,
	    flag: 4096,
	    ts: now$2(),
	    key: info.token,
	    cname: info.cname,
	    sid: info.sid,
	    detail: {
	      6: info.stringUid,
	      11: areaCode
	    },
	    uid: info.uid || 0
	  };

	  if (info.multiIP && info.multiIP.gateway_ip) {
	    reqData.detail[5] = stringify$2({
	      vocs_ip: [info.multiIP.uni_lbs_ip],
	      vos_ip: [info.multiIP.gateway_ip]
	    });
	  }

	  var ajaxPromise = function () {
	    return __awaiter$d(_this, void 0, void 0, function () {
	      var res, newAddresses;
	      return __generator$d(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            return [4
	            /*yield*/
	            , post$1(url + ((indexOf$3(url).call(url, "?") === -1 ? "?" : "&") + "action=wrtc_gateway"), {
	              data: reqData,
	              cancelToken: cancelToken,
	              headers: {
	                "X-Packet-Service-Type": 0,
	                "X-Packet-URI": 69
	              }
	            })];

	          case 1:
	            res = _a.sent();

	            if (getParameter("GATEWAY_ADDRESS") && getParameter("GATEWAY_ADDRESS").length > 0) {
	              var _context2;

	              console.log(getParameter("GATEWAY_ADDRESS"));
	              newAddresses = map$5(_context2 = getParameter("GATEWAY_ADDRESS")).call(_context2, function (address, index) {
	                return {
	                  ip: address.ip,
	                  port: address.port,
	                  ticket: res.addresses[index].ticket
	                };
	              });
	              res.addresses = newAddresses;
	            }

	            return [2
	            /*return*/
	            , chooseServerResponseToGatewayInfo(res, url)];
	        }
	      });
	    });
	  };

	  var handleError = function (e) {
	    if (e.code === AgoraRTCErrorCode.OPERATION_ABORTED) {
	      return false;
	    }

	    if (e.code === AgoraRTCErrorCode.CAN_NOT_GET_GATEWAY_SERVER) {
	      report.joinChooseServer(info.sid, {
	        lts: now,
	        succ: false,
	        csAddr: url,
	        serverList: null,
	        ec: e.message
	      });
	      logger.warning("[" + info.clientId + "] Choose server " + url + " failed, message: " + e.message + ", retry: " + e.data.retry);
	      return e.data.retry;
	    }

	    report.joinChooseServer(info.sid, {
	      lts: now,
	      succ: false,
	      csAddr: url,
	      serverList: null,
	      ec: e.code
	    });
	    /** 走到这里说明都是网络层的错误 */

	    logger.warning("[" + info.clientId + "] Choose server network error, retry", e);
	    return true;
	  };

	  var handleResult = function (res) {
	    if (res.res.code === 0) {
	      report.joinChooseServer(info.sid, {
	        lts: now,
	        succ: true,
	        csAddr: url,
	        serverList: res.gatewayAddrs,
	        ec: null,
	        cid: res.res.cid.toString(),
	        uid: res.res.uid.toString()
	      });
	      return false;
	    }

	    var apErrorDetail = getApErrorDetail(res.res.code);
	    throw new AgoraRTCError(AgoraRTCErrorCode.CAN_NOT_GET_GATEWAY_SERVER, apErrorDetail.desc, {
	      retry: apErrorDetail.retry
	    });
	  };

	  return retryable(ajaxPromise, handleResult, handleError, retryConfig);
	}

	var getAreaCodeByWebCS = function (host) {
	  var keys = keys$3(AREA_DOMAIN_MAP);

	  for (var index = 0; index < keys.length; index++) {
	    var _context, _context2;

	    var key = keys[index];
	    var area = AREA_DOMAIN_MAP[key];
	    if (!IS_GLOBAL_VERSION && key === "CHINA"
	    /* CHINA */
	    ) continue;

	    if (includes$4(_context = area.WEBCS_DOMAIN).call(_context, host) || includes$4(_context2 = area.WEBCS_DOMAIN_BACKUP_LIST).call(_context2, host)) {
	      if (area.CODE === "OVERSEA"
	      /* OVERSEA */
	      ) {
	          return "AS"
	          /* ASIA */
	          + "," + "EU"
	          /* EUROPE */
	          + "," + "AF"
	          /* AFRICA */
	          + "," + "NA"
	          /* NORTH_AMERICA */
	          + "," + "SA"
	          /* SOUTH_AMERICA */
	          + "," + "OC"
	          /* OCEANIA */
	          ;
	        } else {
	        return area.CODE;
	      }
	    }
	  }
	};
	var getAreaDomainConfig = function (areas) {
	  var config = {
	    CODE: "",
	    WEBCS_DOMAIN: [],
	    WEBCS_DOMAIN_BACKUP_LIST: [],
	    PROXY_CS: [],
	    CDS_AP: [],
	    ACCOUNT_REGISTER: [],
	    UAP_AP: [],
	    EVENT_REPORT_DOMAIN: [],
	    EVENT_REPORT_BACKUP_DOMAIN: [],
	    LOG_UPLOAD_SERVER: []
	  };

	  map$5(areas).call(areas, function (area) {
	    var areaConfig = AREA_DOMAIN_MAP[area];

	    var domains = keys$3(areaConfig);

	    if (!domains) {
	      return;
	    }

	    map$5(domains).call(domains, function (domain) {
	      var _context3;

	      if (domain === "CODE") return;
	      config[domain] = concat$2(_context3 = config[domain]).call(_context3, areaConfig[domain]);
	    });
	  });

	  return config;
	};
	function setArea(areaCodes) {
	  var _context4;

	  // 不能在这个函数里调用到 MUTABLE_PARAMS，rollup 打包会有问题。
	  if (typeof areaCodes === "string") areaCodes = [areaCodes];

	  forEach$3(areaCodes).call(areaCodes, function (areaCode) {
	    if (!includes$4(AREAS_LIST).call(AREAS_LIST, areaCode)) {
	      throw new AgoraRTCError(AgoraRTCErrorCode.INVALID_PARAMS, "invalid area code");
	    }
	  });

	  setParameter("AREAS", areaCodes);
	  var configs = getAreaDomainConfig(areaCodes);

	  map$5(_context4 = keys$3(configs)).call(_context4, function (domain) {
	    if (domain === "LOG_UPLOAD_SERVER" || domain === "EVENT_REPORT_DOMAIN" || domain === "EVENT_REPORT_BACKUP_DOMAIN") {
	      setParameter(domain, configs[domain][0]);
	    } else {
	      setParameter(domain, configs[domain]);
	    }
	  });

	  logger.debug("set area success:", areaCodes.join(","));
	}

	var __awaiter$e = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = promise$3))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var __generator$e = undefined && undefined.__generator || function (thisArg, body) {
	  var _ = {
	    label: 0,
	    sent: function () {
	      if (t[0] & 1) throw t[1];
	      return t[1];
	    },
	    trys: [],
	    ops: []
	  },
	      f,
	      y,
	      t,
	      g;
	  return g = {
	    next: verb(0),
	    "throw": verb(1),
	    "return": verb(2)
	  }, typeof symbol$2 === "function" && (g[iterator$2] = function () {
	    return this;
	  }), g;

	  function verb(n) {
	    return function (v) {
	      return step([n, v]);
	    };
	  }

	  function step(op) {
	    if (f) throw new TypeError("Generator is already executing.");

	    while (_) try {
	      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	      if (y = 0, t) op = [op[0] & 2, t.value];

	      switch (op[0]) {
	        case 0:
	        case 1:
	          t = op;
	          break;

	        case 4:
	          _.label++;
	          return {
	            value: op[1],
	            done: false
	          };

	        case 5:
	          _.label++;
	          y = op[1];
	          op = [0];
	          continue;

	        case 7:
	          op = _.ops.pop();

	          _.trys.pop();

	          continue;

	        default:
	          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
	            _ = 0;
	            continue;
	          }

	          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
	            _.label = op[1];
	            break;
	          }

	          if (op[0] === 6 && _.label < t[1]) {
	            _.label = t[1];
	            t = op;
	            break;
	          }

	          if (t && _.label < t[2]) {
	            _.label = t[2];

	            _.ops.push(op);

	            break;
	          }

	          if (t[2]) _.ops.pop();

	          _.trys.pop();

	          continue;
	      }

	      op = body.call(thisArg, _);
	    } catch (e) {
	      op = [6, e];
	      y = 0;
	    } finally {
	      f = t = 0;
	    }

	    if (op[0] & 5) throw op[1];
	    return {
	      value: op[0] ? op[1] : void 0,
	      done: true
	    };
	  }
	};
	function getJoinChannelServerInfo(joinInfo, cancelToken, retryConfig) {
	  return __awaiter$e(this, void 0, void 0, function () {
	    var getGatewayInfoPromise, res;
	    return __generator$e(this, function (_a) {
	      switch (_a.label) {
	        case 0:
	          getGatewayInfoPromise = getGatewayInfo(joinInfo, cancelToken, retryConfig);
	          return [4
	          /*yield*/
	          , getGatewayInfoPromise];

	        case 1:
	          res = _a.sent();
	          return [2
	          /*return*/
	          , {
	            gatewayInfo: res
	          }];
	      }
	    });
	  });
	}
	function setCloudProxyServer(joinInfo, cancelToken, retryConfig) {
	  return __awaiter$e(this, void 0, void 0, function () {
	    var proxyInfo;
	    return __generator$e(this, function (_a) {
	      switch (_a.label) {
	        case 0:
	          if (joinInfo.cloudProxyServer === "disabled") return [2
	          /*return*/
	          ];
	          return [4
	          /*yield*/
	          , getBestProxyServer(joinInfo, cancelToken, retryConfig)];

	        case 1:
	          proxyInfo = _a.sent();

	          if (joinInfo.cloudProxyServer === "443only") {
	            joinInfo.proxyServer = getParameter("PROXY_SERVER_TYPE2");
	          } else {
	            joinInfo.proxyServer = proxyInfo.address;
	          }

	          joinInfo.turnServer = {
	            mode: "manual",
	            servers: [{
	              turnServerURL: proxyInfo.address,
	              tcpport: proxyInfo.serverResponse.tcpport ? proxyInfo.serverResponse.tcpport : DEFAULT_TURN_CONFIG.tcpport,
	              udpport: proxyInfo.serverResponse.udpport ? proxyInfo.serverResponse.udpport : DEFAULT_TURN_CONFIG.udpport,
	              username: proxyInfo.serverResponse.username || DEFAULT_TURN_CONFIG.username,
	              password: proxyInfo.serverResponse.password || DEFAULT_TURN_CONFIG.password,

	              /** liaojun: 所有云代理需要设置 forceturn */
	              forceturn: true
	            }]
	          };
	          logger.debug("[" + joinInfo.clientId + "] set proxy server: " + joinInfo.proxyServer + ", mode: " + joinInfo.cloudProxyServer);
	          report.setProxyServer(joinInfo.proxyServer);
	          logger.setProxyServer(joinInfo.proxyServer);
	          return [2
	          /*return*/
	          ];
	      }
	    });
	  });
	}
	/**
	 * 通过读取 joinInfo 的 stringUID 转成相应的 uintUID
	 */

	function getUserAccount(stringUID, joinInfo, cancelToken, retryConfig) {
	  return __awaiter$e(this, void 0, void 0, function () {
	    var serverList, urls, res;
	    return __generator$e(this, function (_a) {
	      switch (_a.label) {
	        case 0:
	          serverList = getParameter("ACCOUNT_REGISTER");
	          urls = [];

	          if (joinInfo.proxyServer) {
	            urls = map$5(serverList).call(serverList, function (server) {
	              return "https://" + joinInfo.proxyServer + "/ap/?url=" + (server + "/api/v1");
	            });
	          } else {
	            urls = map$5(serverList).call(serverList, function (server) {
	              return "https://" + server + "/api/v1";
	            });
	          }

	          return [4
	          /*yield*/
	          , requestUserAccount(urls, stringUID, joinInfo, cancelToken, retryConfig)];

	        case 1:
	          res = _a.sent();
	          return [2
	          /*return*/
	          , res.uid];
	      }
	    });
	  });
	}
	/**
	 * 返回一个最快响应的云代理地址和 turn 配置
	 */

	function getBestProxyServer(joinInfo, cancelToken, retryConfig) {
	  return __awaiter$e(this, void 0, void 0, function () {
	    var now, urls, getProxyServerPromises, res, errors_1, body, addresses, getWorkerManagerPromises, workerManagerRes, errors_2;
	    return __generator$e(this, function (_a) {
	      var _context, _context2;

	      switch (_a.label) {
	        case 0:
	          now = now$2();
	          urls = map$5(_context = getParameter("PROXY_CS")).call(_context, function (url) {
	            return "https://" + url + "/api/v1";
	          });
	          getProxyServerPromises = map$5(urls).call(urls, function (url) {
	            return requestProxyServerList(url, joinInfo, cancelToken, retryConfig);
	          });
	          res = null;
	          _a.label = 1;

	        case 1:
	          _a.trys.push([1, 3,, 4]);

	          return [4
	          /*yield*/
	          , PromiseAny(getProxyServerPromises)];

	        case 2:
	          res = _a.sent();
	          return [3
	          /*break*/
	          , 4];

	        case 3:
	          errors_1 = _a.sent();
	          /** 如果这里出错，说明全部的 url 都失败了 */

	          logger.error("[" + joinInfo.clientId + "] can not get proxy server after trying several times");
	          throw new AgoraRTCError(AgoraRTCErrorCode.CAN_NOT_GET_PROXY_SERVER);

	        case 4:
	          /** 当有一个成功返回后，立刻取消其他的 promise，防止他们无意义的错误重试 */
	          forEach$3(getProxyServerPromises).call(getProxyServerPromises, function (p) {
	            return p.cancel();
	          });

	          body = JSON.parse(res.res.json_body);
	          addresses = map$5(_context2 = body.servers).call(_context2, proxyServerInfoToProxyServerAddress);
	          /**
	           * 如果开启了这个，就不去请求 workerManager (因为不是 443 端口)，默认使用 hardcode 的 443 turn 配置
	           */

	          if (joinInfo.cloudProxyServer === "443only") {
	            return [2
	            /*return*/
	            , {
	              address: addresses[0],
	              serverResponse: {
	                tcpport: 443,
	                udpport: DEFAULT_TURN_CONFIG.udpport,
	                username: DEFAULT_TURN_CONFIG.username,
	                password: DEFAULT_TURN_CONFIG.password
	              }
	            }];
	          }

	          report.requestProxyAppCenter(joinInfo.sid, {
	            lts: now,
	            succ: true,
	            APAddr: res.url,
	            workerManagerList: stringify$2(addresses),
	            ec: null,
	            response: stringify$2(res.res)
	          });
	          /** 同时向多个 worker manager 请求, 操作同上 */

	          now = now$2();
	          getWorkerManagerPromises = map$5(addresses).call(addresses, function (url) {
	            return requestProxyWorkerManager(url, joinInfo, cancelToken, retryConfig);
	          });
	          workerManagerRes = null;
	          _a.label = 5;

	        case 5:
	          _a.trys.push([5, 7,, 8]);

	          return [4
	          /*yield*/
	          , PromiseAny(getWorkerManagerPromises)];

	        case 6:
	          workerManagerRes = _a.sent();
	          return [3
	          /*break*/
	          , 8];

	        case 7:
	          errors_2 = _a.sent();
	          logger.error("[" + joinInfo.clientId + "] can not get worker manager after trying several times");
	          throw new AgoraRTCError(AgoraRTCErrorCode.CAN_NOT_GET_PROXY_SERVER);

	        case 8:
	          /** 当有一个成功返回后，立刻取消其他的 promise，防止他们无意义的错误重试 */
	          forEach$3(getWorkerManagerPromises).call(getWorkerManagerPromises, function (p) {
	            return p.cancel();
	          });

	          report.requestProxyWorkerManager(joinInfo.sid, {
	            lts: now,
	            succ: true,
	            workerManagerAddr: workerManagerRes.url,
	            ec: null,
	            response: stringify$2(workerManagerRes.res)
	          });
	          return [2
	          /*return*/
	          , {
	            address: workerManagerRes.url,
	            serverResponse: workerManagerRes.res.serverResponse
	          }];
	      }
	    });
	  });
	}

	function getGatewayInfo(joinInfo, cancelToken, retryConfig) {
	  return __awaiter$e(this, void 0, void 0, function () {
	    var reqMessages, res, getChooseServerPromises, backupChooseServerPromise, e_2;

	    var _this = this;

	    return __generator$e(this, function (_a) {
	      var _context4, _context6;

	      switch (_a.label) {
	        case 0:
	          reqMessages = map$5(_context4 = getParameter("WEBCS_DOMAIN")).call(_context4, function (host) {
	            return {
	              url: joinInfo.proxyServer ? "https://" + joinInfo.proxyServer + "/ap/?url=" + (host + "/api/v1") : "https://" + host + "/api/v1",
	              areaCode: getAreaCodeByWebCS(host)
	            };
	          });
	          res = null;
	          getChooseServerPromises = map$5(reqMessages).call(reqMessages, function (reqMessage) {
	            logger.debug("[" + joinInfo.clientId + "] Connect to choose_server:", reqMessage.url);
	            return requestChooseServer(reqMessage, joinInfo, cancelToken, retryConfig);
	          });

	          backupChooseServerPromise = function () {
	            return new promise$3(function (resolve, reject) {
	              return __awaiter$e(_this, void 0, void 0, function () {
	                var backupReqMessages, getBackupChooseServerPromises;
	                return __generator$e(this, function (_a) {
	                  var _context5;

	                  switch (_a.label) {
	                    case 0:
	                      return [4
	                      /*yield*/
	                      , wait(1000)];

	                    case 1:
	                      _a.sent(); // 如果 1s 后已经有了结果，就什么也不做


	                      if (res !== null) return [2
	                      /*return*/
	                      ];
	                      backupReqMessages = map$5(_context5 = getParameter("WEBCS_DOMAIN_BACKUP_LIST")).call(_context5, function (host) {
	                        return {
	                          url: joinInfo.proxyServer ? "https://" + joinInfo.proxyServer + "/ap/?url=" + (host + "/api/v1") : "https://" + host + "/api/v1",
	                          areaCode: getAreaCodeByWebCS(host)
	                        };
	                      });
	                      getBackupChooseServerPromises = map$5(backupReqMessages).call(backupReqMessages, function (reqMessage) {
	                        logger.debug("[" + joinInfo.clientId + "] Connect to backup choose_server:", reqMessage.url);
	                        return requestChooseServer(reqMessage, joinInfo, cancelToken, retryConfig);
	                      });
	                      PromiseAny(getBackupChooseServerPromises).then(function (res) {
	                        forEach$3(getBackupChooseServerPromises).call(getBackupChooseServerPromises, function (p) {
	                          return p.cancel();
	                        });

	                        resolve(res);
	                      }).catch(function (e) {
	                        return reject(e[0]);
	                      });
	                      return [2
	                      /*return*/
	                      ];
	                  }
	                });
	              });
	            });
	          };

	          _a.label = 1;

	        case 1:
	          _a.trys.push([1, 3,, 4]);

	          return [4
	          /*yield*/
	          , PromiseAny(concat$2(_context6 = [backupChooseServerPromise()]).call(_context6, getChooseServerPromises))];

	        case 2:
	          res = _a.sent();
	          return [3
	          /*break*/
	          , 4];

	        case 3:
	          e_2 = _a.sent();
	          /** 如果走到这里，说明所有节点的请求都重试失败或是遇到不可重试的错误 */

	          throw e_2[0];

	        case 4:
	          forEach$3(getChooseServerPromises).call(getChooseServerPromises, function (p) {
	            return p.cancel();
	          });

	          return [2
	          /*return*/
	          , res];
	      }
	    });
	  });
	}

	function getLiveStreamingWorkerMangerResult(mode, joinInfo, cancelToken, retryConfig) {
	  return __awaiter$e(this, void 0, void 0, function () {
	    var urls, result, e_3;
	    return __generator$e(this, function (_a) {
	      var _context7;

	      switch (_a.label) {
	        case 0:
	          urls = map$5(_context7 = getParameter("UAP_AP")).call(_context7, function (url) {
	            return joinInfo.proxyServer ? "https://" + joinInfo.proxyServer + "/ap/?url=" + (url + "/api/v1?action=uap") : "https://" + url + "/api/v1?action=uap";
	          });
	          _a.label = 1;

	        case 1:
	          _a.trys.push([1, 3,, 4]);

	          return [4
	          /*yield*/
	          , requestLiveStreamingWorkerManager(urls, mode, joinInfo, cancelToken, retryConfig)];

	        case 2:
	          result = _a.sent();
	          return [2
	          /*return*/
	          , result];

	        case 3:
	          e_3 = _a.sent();
	          throw e_3;

	        case 4:
	          return [2
	          /*return*/
	          ];
	      }
	    });
	  });
	}
	function getCrossChannelWorkerManagerResult(joinInfo, cancelToken, retryConfig) {
	  return __awaiter$e(this, void 0, void 0, function () {
	    var urls, promiseList, res, e_4;
	    return __generator$e(this, function (_a) {
	      var _context8;

	      switch (_a.label) {
	        case 0:
	          urls = map$5(_context8 = getParameter("UAP_AP")).call(_context8, function (url) {
	            return joinInfo.proxyServer ? "https://" + joinInfo.proxyServer + "/ap/?url=" + (url + "/api/v1?action=uap") : "https://" + url + "/api/v1?action=uap";
	          });
	          promiseList = map$5(urls).call(urls, function (url) {
	            return requestChannelMediaRelayWorkerManager(url, joinInfo, cancelToken, retryConfig);
	          });
	          _a.label = 1;

	        case 1:
	          _a.trys.push([1, 3,, 4]);

	          return [4
	          /*yield*/
	          , PromiseAny(promiseList)];

	        case 2:
	          res = _a.sent();

	          forEach$3(promiseList).call(promiseList, function (p) {
	            return p.cancel();
	          });

	          return [2
	          /*return*/
	          , res];

	        case 3:
	          e_4 = _a.sent();
	          throw e_4[0];

	        case 4:
	          return [2
	          /*return*/
	          ];
	      }
	    });
	  });
	}

	var __awaiter$f = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = promise$3))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var __generator$f = undefined && undefined.__generator || function (thisArg, body) {
	  var _ = {
	    label: 0,
	    sent: function () {
	      if (t[0] & 1) throw t[1];
	      return t[1];
	    },
	    trys: [],
	    ops: []
	  },
	      f,
	      y,
	      t,
	      g;
	  return g = {
	    next: verb(0),
	    "throw": verb(1),
	    "return": verb(2)
	  }, typeof symbol$2 === "function" && (g[iterator$2] = function () {
	    return this;
	  }), g;

	  function verb(n) {
	    return function (v) {
	      return step([n, v]);
	    };
	  }

	  function step(op) {
	    if (f) throw new TypeError("Generator is already executing.");

	    while (_) try {
	      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	      if (y = 0, t) op = [op[0] & 2, t.value];

	      switch (op[0]) {
	        case 0:
	        case 1:
	          t = op;
	          break;

	        case 4:
	          _.label++;
	          return {
	            value: op[1],
	            done: false
	          };

	        case 5:
	          _.label++;
	          y = op[1];
	          op = [0];
	          continue;

	        case 7:
	          op = _.ops.pop();

	          _.trys.pop();

	          continue;

	        default:
	          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
	            _ = 0;
	            continue;
	          }

	          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
	            _.label = op[1];
	            break;
	          }

	          if (op[0] === 6 && _.label < t[1]) {
	            _.label = t[1];
	            t = op;
	            break;
	          }

	          if (t && _.label < t[2]) {
	            _.label = t[2];

	            _.ops.push(op);

	            break;
	          }

	          if (t[2]) _.ops.pop();

	          _.trys.pop();

	          continue;
	      }

	      op = body.call(thisArg, _);
	    } catch (e) {
	      op = [6, e];
	      y = 0;
	    } finally {
	      f = t = 0;
	    }

	    if (op[0] & 5) throw op[1];
	    return {
	      value: op[0] ? op[1] : void 0,
	      done: true
	    };
	  }
	};
	function getSendTransceiver(pc, track) {
	  return __awaiter$f(this, void 0, void 0, function () {
	    var transceiver;
	    return __generator$f(this, function (_a) {
	      var _context;

	      switch (_a.label) {
	        case 0:
	          transceiver = find$2(_context = pc.getTransceivers()).call(_context, function (t) {
	            return t.direction === "inactive" && t.receiver.track.kind === track.kind;
	          });
	          if (!transceiver) return [3
	          /*break*/
	          , 2];
	          /**
	           * 因为网关写死了 sendrecv，所以这里必须把 direction 置成 sendrecv
	           */

	          transceiver.direction = "sendrecv";
	          return [4
	          /*yield*/
	          , transceiver.sender.replaceTrack(track)];

	        case 1:
	          _a.sent();

	          return [2
	          /*return*/
	          , transceiver];

	        case 2:
	          return [2
	          /*return*/
	          , pc.addTransceiver(track, {
	            direction: "sendrecv"
	          })];
	      }
	    });
	  });
	}

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation. All rights reserved.
	Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	this file except in compliance with the License. You may obtain a copy of the
	License at http://www.apache.org/licenses/LICENSE-2.0

	THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	MERCHANTABLITY OR NON-INFRINGEMENT.

	See the Apache Version 2.0 License for specific language governing permissions
	and limitations under the License.
	***************************************************************************** */
	/* global Reflect, Promise */

	var extendStatics = function(d, b) {
	    extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return extendStatics(d, b);
	};

	function __extends$9(d, b) {
	    extendStatics(d, b);
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	}

	var __assign$7 = function() {
	    __assign$7 = Object.assign || function __assign(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$7.apply(this, arguments);
	};

	function __awaiter$g(thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	}

	function __generator$g(thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	}

	var DEFAULT_PC_STATS = {
	    timestamp: 0,
	    bitrate: {
	        actualEncoded: 0,
	        transmit: 0,
	    },
	    sendPacketLossRate: 0,
	    recvPacketLossRate: 0,
	    videoRecv: [],
	    videoSend: [],
	    audioRecv: [],
	    audioSend: [],
	};
	var DEFAULT_VIDEO_RECV_STATS = {
	    firsCount: 0,
	    nacksCount: 0,
	    plisCount: 0,
	    framesDecodeCount: 0,
	    framesDecodeInterval: 0,
	    framesDecodeFreezeTime: 0,
	    decodeFrameRate: 0,
	    bytes: 0,
	    packetsLost: 0,
	    packetLostRate: 0,
	    packets: 0,
	    ssrc: 0,
	};
	var DEFAULT_VIDEO_SEND_STATS = {
	    firsCount: 0,
	    nacksCount: 0,
	    plisCount: 0,
	    frameCount: 0,
	    bytes: 0,
	    packets: 0,
	    packetsLost: 0,
	    packetLostRate: 0,
	    ssrc: 0,
	    rttMs: 0,
	};
	var DEFAULT_AUDIO_SEND_STATS = {
	    bytes: 0,
	    packets: 0,
	    packetsLost: 0,
	    packetLostRate: 0,
	    ssrc: 0,
	    rttMs: 0,
	};
	var DEFAULT_AUDIO_RECV_STATS = {
	    jitterBufferMs: 0,
	    jitterMs: 0,
	    bytes: 0,
	    packetsLost: 0,
	    packetLostRate: 0,
	    packets: 0,
	    ssrc: 0,
	    receivedFrames: 0,
	    droppedFrames: 0,
	};

	function deepClone(obj) {
	    if (Array.isArray(obj)) {
	        return obj.map(function (t) { return t; });
	    }
	    if (!isObject$3(obj))
	        return obj;
	    var newObj = {};
	    for (var key in obj) {
	        if (isObject$3(obj[key]) || Array.isArray(obj[key])) {
	            newObj[key] = deepClone(obj[key]);
	        }
	        else {
	            newObj[key] = obj[key];
	        }
	    }
	    return newObj;
	}
	function isObject$3(obj) {
	    if (typeof obj === "object" && !Array.isArray(obj) && !!obj) {
	        return true;
	    }
	    return false;
	}
	/**
	 * 最基础的移动平均实现
	 */
	var Rolling$1 = /** @class */ (function () {
	    function Rolling(size) {
	        this.input = [];
	        this.size = size;
	    }
	    Rolling.prototype.add = function (num) {
	        this.input.push(num);
	        if (this.input.length > this.size) {
	            this.input.splice(0, 1);
	        }
	    };
	    Rolling.prototype.diffMean = function () {
	        if (this.input.length === 0)
	            return 0;
	        return (this.input[this.input.length - 1] - this.input[0]) / this.input.length;
	    };
	    return Rolling;
	}());

	var AgoraWebRTCStatsFilter = /** @class */ (function () {
	    function AgoraWebRTCStatsFilter(pc, options) {
	        var _this = this;
	        this.stats = deepClone(DEFAULT_PC_STATS);
	        this.isFirstVideoReceived = false;
	        this.isFirstVideoDecoded = false;
	        this.isFirstAudioReceived = false;
	        this.isFirstAudioDecoded = false;
	        this.lossRateWindowStats = [];
	        this.pc = pc;
	        this.options = options;
	        this.intervalTimer = window.setInterval(function () { return __awaiter$g(_this, void 0, void 0, function () {
	            return __generator$g(this, function (_a) {
	                this.updateStats();
	                return [2 /*return*/];
	            });
	        }); }, this.options.updateInterval);
	    }
	    AgoraWebRTCStatsFilter.prototype.getStats = function () {
	        return this.stats;
	    };
	    AgoraWebRTCStatsFilter.prototype.destroy = function () {
	        window.clearInterval(this.intervalTimer);
	    };
	    /** 由上层统一计算丢包率 */
	    AgoraWebRTCStatsFilter.prototype.calcLossRate = function (stats) {
	        var _this = this;
	        this.lossRateWindowStats.push(stats);
	        if (this.lossRateWindowStats.length > this.options.lossRateInterval) {
	            this.lossRateWindowStats.splice(0, 1);
	        }
	        var windowSize = this.lossRateWindowStats.length;
	        var keys = ["videoSend", "audioSend", "videoRecv", "audioRecv"];
	        var sendPackets = 0, recvPackets = 0;
	        var sendLossPackets = 0, recvLossPackets = 0;
	        var _loop_1 = function (key) {
	            stats[key].forEach(function (vs, index) {
	                if (!_this.lossRateWindowStats[windowSize - 1][key][index] || !_this.lossRateWindowStats[0][key][index])
	                    return;
	                var packets = _this.lossRateWindowStats[windowSize - 1][key][index].packets - _this.lossRateWindowStats[0][key][index].packets;
	                var lostPackets = _this.lossRateWindowStats[windowSize - 1][key][index].packetsLost - _this.lossRateWindowStats[0][key][index].packetsLost;
	                if (key === "videoSend" || key === "audioSend") {
	                    sendPackets += packets;
	                    sendLossPackets += lostPackets;
	                }
	                else {
	                    recvPackets += packets;
	                    recvLossPackets += lostPackets;
	                }
	                if (Number.isNaN(packets) || Number.isNaN(packets)) {
	                    vs.packetLostRate = 0;
	                }
	                else if (packets <= 0 || lostPackets <= 0) {
	                    vs.packetLostRate = 0;
	                }
	                else {
	                    vs.packetLostRate = lostPackets / packets;
	                }
	            });
	        };
	        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
	            var key = keys_1[_i];
	            _loop_1(key);
	        }
	        if (sendPackets <= 0 || sendLossPackets <= 0) {
	            stats.sendPacketLossRate = 0;
	        }
	        else {
	            stats.sendPacketLossRate = sendLossPackets / sendPackets;
	        }
	        if (recvPackets <= 0 || recvLossPackets <= 0) {
	            stats.recvPacketLossRate = 0;
	        }
	        else {
	            stats.recvPacketLossRate = recvLossPackets / recvPackets;
	        }
	    };
	    return AgoraWebRTCStatsFilter;
	}());

	var RTCStatsType;
	(function (RTCStatsType) {
	    RTCStatsType["CERTIFICATE"] = "certificate";
	    RTCStatsType["CODEC"] = "codec";
	    RTCStatsType["CANDIDATE_PAIR"] = "candidate-pair";
	    RTCStatsType["LOCAL_CANDIDATE"] = "local-candidate";
	    RTCStatsType["REMOTE_CANDIDATE"] = "remote-candidate";
	    RTCStatsType["INBOUND"] = "inbound-rtp";
	    RTCStatsType["TRACK"] = "track";
	    RTCStatsType["OUTBOUND"] = "outbound-rtp";
	    RTCStatsType["PC"] = "peer-connection";
	    RTCStatsType["REMOTE_INBOUND"] = "remote-inbound-rtp";
	    RTCStatsType["REMOTE_OUTBOUND"] = "remote-outbound-rtp";
	    RTCStatsType["TRANSPORT"] = "transport";
	    RTCStatsType["CSRC"] = "csrc";
	    RTCStatsType["DATA_CHANNEL"] = "data-channel";
	    RTCStatsType["STREAM"] = "stream";
	    RTCStatsType["SENDER"] = "sender";
	    RTCStatsType["RECEIVER"] = "receiver";
	})(RTCStatsType || (RTCStatsType = {}));

	var FREEZE_TIME_LIMIT = 500;
	var AgoraSpecStatsFilter = /** @class */ (function (_super) {
	    __extends$9(AgoraSpecStatsFilter, _super);
	    function AgoraSpecStatsFilter() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this._stats = DEFAULT_PC_STATS;
	        /**
	         * spec stats 没有发送/接受帧率统计，手动统计
	         */
	        /** 统计帧解码间隔 **/
	        _this.lastDecodeVideoReceiverStats = new Map();
	        _this.lastVideoFramesRecv = new Map();
	        _this.lastVideoFramesSent = new Map();
	        _this.lastVideoFramesDecode = new Map();
	        /**
	         * spec stats 没有发送码率统计，手动统计
	         * key 为 ssrc
	         */
	        _this.mediaBytesSent = new Map();
	        _this.mediaBytesRetransmit = new Map();
	        _this.mediaBytesTargetEncode = new Map();
	        /** 统计平均解码耗时，每 60 帧更新一次 */
	        _this.lastEncoderMs = new Map();
	        return _this;
	    }
	    AgoraSpecStatsFilter.prototype.updateStats = function () {
	        return __awaiter$g(this, void 0, void 0, function () {
	            var _a;
	            var _this = this;
	            return __generator$g(this, function (_b) {
	                switch (_b.label) {
	                    case 0:
	                        _a = this;
	                        return [4 /*yield*/, this.pc.getStats()];
	                    case 1:
	                        _a.report = _b.sent();
	                        // console.log("getStats:", this.report);
	                        this._stats = deepClone(DEFAULT_PC_STATS);
	                        this.report.forEach(function (stats) {
	                            switch (stats.type) {
	                                /**
	                                 * sender
	                                 */
	                                case RTCStatsType.OUTBOUND: {
	                                    if (stats.mediaType === "audio") {
	                                        _this.processAudioOutboundStats(stats);
	                                    }
	                                    else if (stats.mediaType === "video") {
	                                        _this.processVideoOutboundStats(stats);
	                                    }
	                                    break;
	                                }
	                                /**
	                                 * receiver
	                                 */
	                                case RTCStatsType.INBOUND: {
	                                    if (stats.mediaType === "audio") {
	                                        _this.processAudioInboundStats(stats);
	                                    }
	                                    else if (stats.mediaType === "video") {
	                                        _this.processVideoInboundStats(stats);
	                                    }
	                                    break;
	                                }
	                                /**
	                                 * transport
	                                 * 在 Chrome 中，通过 transport stats 中的 selectedCandidatePairId 来确定当前使用的 candidate-pair。
	                                 * 在 Firefox 中， *暂时* 没有 transport stats, 但是它在 candidate-pair 中增加了 `selected` 字段来确定当前是否在使用。
	                                 * 所以这里的写法需要考虑 2 种情况，也需要考虑 Firefox 未来可能向 Spec 靠齐的可能
	                                 */
	                                case RTCStatsType.TRANSPORT: {
	                                    var candidatePairStats = _this.report.get(stats.selectedCandidatePairId);
	                                    candidatePairStats && _this.processCandidatePairStats(candidatePairStats);
	                                    break;
	                                }
	                                case RTCStatsType.CANDIDATE_PAIR: {
	                                    if (stats.selected) {
	                                        _this.processCandidatePairStats(stats);
	                                    }
	                                    break;
	                                }
	                            }
	                        });
	                        this.updateSendBitrate();
	                        this._stats.timestamp = Date.now();
	                        this.calcLossRate(this._stats);
	                        this.stats = this._stats;
	                        return [2 /*return*/];
	                }
	            });
	        });
	    };
	    AgoraSpecStatsFilter.prototype.processCandidatePairStats = function (stats) {
	        this._stats.sendBandwidth = stats.availableOutgoingBitrate || 0;
	        if (stats.currentRoundTripTime) {
	            this._stats.rtt = stats.currentRoundTripTime * 1000;
	        }
	        this._stats.videoSend.forEach(function (s) {
	            if (!s.rttMs && stats.currentRoundTripTime) {
	                s.rttMs = stats.currentRoundTripTime * 1000;
	            }
	        });
	        this._stats.audioSend.forEach(function (s) {
	            if (!s.rttMs && stats.currentRoundTripTime) {
	                s.rttMs = stats.currentRoundTripTime * 1000;
	            }
	        });
	    };
	    AgoraSpecStatsFilter.prototype.processAudioInboundStats = function (stats) {
	        var recvStats = this._stats.audioRecv.find(function (s) { return s.ssrc === stats.ssrc; });
	        if (!recvStats) {
	            recvStats = deepClone(DEFAULT_AUDIO_RECV_STATS);
	            this._stats.audioRecv.push(recvStats);
	        }
	        recvStats.ssrc = stats.ssrc;
	        recvStats.packets = stats.packetsReceived;
	        recvStats.packetsLost = stats.packetsLost;
	        recvStats.bytes = stats.bytesReceived;
	        recvStats.jitterMs = stats.jitter * 1000;
	        if (stats.trackId) {
	            this.processAudioTrackReceiverStats(stats.trackId, recvStats);
	        }
	        if (stats.codecId) {
	            recvStats.codec = this.getCodecFromCodecStats(stats.codecId);
	        }
	        if (!recvStats.receivedFrames) {
	            recvStats.receivedFrames = stats.packetsReceived;
	        }
	        if (!recvStats.droppedFrames) {
	            recvStats.droppedFrames = stats.packetsLost;
	        }
	        if (recvStats.receivedFrames > 0 && !this.isFirstAudioReceived) {
	            this.onFirstAudioReceived && this.onFirstAudioReceived();
	            this.isFirstAudioReceived = true;
	        }
	        /** 目前 Firefox 无法走到这个判断里，因为没有 outputLevel */
	        if (recvStats.outputLevel && recvStats.outputLevel > 0 && !this.isFirstAudioDecoded) {
	            this.onFirstAudioDecoded && this.onFirstAudioDecoded();
	            this.isFirstAudioDecoded = true;
	        }
	    };
	    AgoraSpecStatsFilter.prototype.processVideoInboundStats = function (stats) {
	        var recvStats = this._stats.videoRecv.find(function (s) { return s.ssrc === stats.ssrc; });
	        if (!recvStats) {
	            recvStats = deepClone(DEFAULT_VIDEO_RECV_STATS);
	            this._stats.videoRecv.push(recvStats);
	        }
	        recvStats.ssrc = stats.ssrc;
	        recvStats.packets = stats.packetsReceived;
	        recvStats.packetsLost = stats.packetsLost;
	        recvStats.bytes = stats.bytesReceived;
	        recvStats.firsCount = stats.firCount;
	        recvStats.nacksCount = stats.nackCount;
	        recvStats.plisCount = stats.pliCount;
	        recvStats.framesDecodeCount = stats.framesDecoded;
	        var lastRecvVideo = this.lastDecodeVideoReceiverStats.get(recvStats.ssrc);
	        var lastDecodeFrameCount = this.lastVideoFramesDecode.get(recvStats.ssrc);
	        var now = Date.now();
	        if (lastRecvVideo) {
	            var lastStats = lastRecvVideo.stats;
	            var interval = now - lastRecvVideo.lts;
	            recvStats.framesDecodeFreezeTime = lastStats.framesDecodeFreezeTime;
	            recvStats.framesDecodeInterval = lastStats.framesDecodeInterval;
	            // update decode interval
	            if (recvStats.framesDecodeCount > lastStats.framesDecodeCount) {
	                lastRecvVideo.lts = Date.now();
	                recvStats.framesDecodeInterval = interval;
	                if (recvStats.framesDecodeInterval >= FREEZE_TIME_LIMIT) {
	                    recvStats.framesDecodeFreezeTime += recvStats.framesDecodeInterval;
	                }
	            }
	            else if (recvStats.framesDecodeCount < lastStats.framesDecodeCount) {
	                recvStats.framesDecodeInterval = 0;
	            }
	        }
	        if (lastDecodeFrameCount && now - lastDecodeFrameCount.lts >= 800) {
	            recvStats.decodeFrameRate = Math.round((recvStats.framesDecodeCount - lastDecodeFrameCount.count) / ((now - lastDecodeFrameCount.lts) / 1000));
	            this.lastVideoFramesDecode.set(recvStats.ssrc, { count: recvStats.framesDecodeCount, lts: now, rate: recvStats.decodeFrameRate });
	        }
	        else if (!lastDecodeFrameCount) {
	            this.lastVideoFramesDecode.set(recvStats.ssrc, { count: recvStats.framesDecodeCount, lts: now, rate: 0 });
	        }
	        else {
	            recvStats.decodeFrameRate = lastDecodeFrameCount.rate;
	        }
	        if (stats.totalDecodeTime) {
	            recvStats.decodeMs = stats.totalDecodeTime * 1000;
	        }
	        if (stats.trackId) {
	            this.processVideoTrackReceiverStats(stats.trackId, recvStats);
	        }
	        if (stats.codecId) {
	            recvStats.codec = this.getCodecFromCodecStats(stats.codecId);
	        }
	        /** 只有 Firefox 有这个值 */
	        if (stats.framerateMean) {
	            recvStats.framesRateFirefox = stats.framerateMean;
	        }
	        if (recvStats.packets > 0 && !this.isFirstVideoReceived) {
	            this.onFirstVideoReceived && this.onFirstVideoReceived();
	            this.isFirstVideoReceived = true;
	        }
	        if (recvStats.framesDecodeCount > 0 && !this.isFirstVideoDecoded) {
	            var width = recvStats.decodedFrame ? recvStats.decodedFrame.width : 0;
	            var height = recvStats.decodedFrame ? recvStats.decodedFrame.height : 0;
	            this.onFirstVideoDecoded && this.onFirstVideoDecoded(width, height);
	            this.isFirstVideoDecoded = true;
	        }
	        this.lastDecodeVideoReceiverStats.set(recvStats.ssrc, { stats: __assign$7({}, recvStats), lts: lastRecvVideo ? lastRecvVideo.lts : Date.now() });
	    };
	    AgoraSpecStatsFilter.prototype.processVideoOutboundStats = function (stats) {
	        var senderStats = this._stats.videoSend.find(function (s) { return s.ssrc === stats.ssrc; });
	        if (!senderStats) {
	            senderStats = deepClone(DEFAULT_VIDEO_SEND_STATS);
	            this._stats.videoSend.push(senderStats);
	        }
	        var bytesSentRecord = this.mediaBytesSent.get(stats.ssrc);
	        if (!bytesSentRecord) {
	            var rolling = new Rolling$1(10);
	            rolling.add(stats.bytesSent);
	            this.mediaBytesSent.set(stats.ssrc, rolling);
	        }
	        else {
	            bytesSentRecord.add(stats.bytesSent);
	        }
	        /** 目前只有 Chrome stable 实现了这个值 */
	        if (stats.retransmittedBytesSent !== undefined) {
	            var bytesRetransmitRecord = this.mediaBytesRetransmit.get(stats.ssrc);
	            if (!bytesRetransmitRecord) {
	                var rolling = new Rolling$1(10);
	                rolling.add(stats.retransmittedBytesSent);
	                this.mediaBytesRetransmit.set(stats.ssrc, rolling);
	            }
	            else {
	                bytesRetransmitRecord.add(stats.retransmittedBytesSent);
	            }
	        }
	        /** 目前只有 Chrome stable 实现了这个值 */
	        if (stats.totalEncodedBytesTarget) {
	            var bytesTargetEncodeRecord = this.mediaBytesTargetEncode.get(stats.ssrc);
	            if (!bytesTargetEncodeRecord) {
	                var rolling = new Rolling$1(10);
	                rolling.add(stats.totalEncodedBytesTarget);
	                this.mediaBytesTargetEncode.set(stats.ssrc, rolling);
	            }
	            else {
	                bytesTargetEncodeRecord.add(stats.totalEncodedBytesTarget);
	            }
	        }
	        senderStats.ssrc = stats.ssrc;
	        senderStats.bytes = stats.bytesSent;
	        senderStats.packets = stats.packetsSent;
	        senderStats.firsCount = stats.firCount;
	        senderStats.nacksCount = stats.nackCount;
	        senderStats.plisCount = stats.pliCount;
	        senderStats.frameCount = stats.framesEncoded;
	        senderStats.adaptionChangeReason = stats.qualityLimitationReason;
	        if (stats.totalEncodeTime && stats.framesEncoded) {
	            var lastEncoderMs = this.lastEncoderMs.get(stats.ssrc);
	            if (!lastEncoderMs || lastEncoderMs.lastFrameCount > stats.framesEncoded) {
	                senderStats.avgEncodeMs = stats.totalEncodeTime * 1000 / stats.framesEncoded;
	            }
	            else {
	                var diffEncode = stats.framesEncoded - lastEncoderMs.lastFrameCount;
	                var diffTime = stats.totalEncodeTime - lastEncoderMs.lastEncoderTime;
	                senderStats.avgEncodeMs = diffTime * 1000 / diffEncode;
	            }
	            this.lastEncoderMs.set(stats.ssrc, {
	                lastFrameCount: stats.framesEncoded,
	                lastEncoderTime: stats.totalEncodeTime,
	                lts: Date.now(),
	            });
	        }
	        if (stats.codecId) {
	            senderStats.codec = this.getCodecFromCodecStats(stats.codecId);
	        }
	        // fireFox 没有 mediaSourceId
	        if (stats.mediaSourceId) {
	            this.processVideoMediaSource(stats.mediaSourceId, senderStats);
	        }
	        if (stats.trackId) {
	            this.processVideoTrackSenderStats(stats.trackId, senderStats);
	        }
	        /**
	         * Chrome 没有 remoteId（截止到 77）
	         * 但是实际上 reports 中是有 remoteId 的，所以这里做一个 workaround
	         */
	        if (stats.remoteId) {
	            this.processRemoteInboundStats(stats.remoteId, senderStats);
	        }
	        else {
	            var remoteId = this.findRemoteStatsId(stats.ssrc, RTCStatsType.REMOTE_INBOUND);
	            remoteId && this.processRemoteInboundStats(remoteId, senderStats);
	        }
	    };
	    AgoraSpecStatsFilter.prototype.processAudioOutboundStats = function (stats) {
	        var senderStats = this._stats.audioSend.find(function (s) { return s.ssrc === stats.ssrc; });
	        if (!senderStats) {
	            senderStats = deepClone(DEFAULT_AUDIO_SEND_STATS);
	            this._stats.audioSend.push(senderStats);
	        }
	        senderStats.ssrc = stats.ssrc;
	        senderStats.packets = stats.packetsSent;
	        senderStats.bytes = stats.bytesSent;
	        if (stats.mediaSourceId) {
	            this.processAudioMediaSource(stats.mediaSourceId, senderStats);
	        }
	        if (stats.codecId) {
	            senderStats.codec = this.getCodecFromCodecStats(stats.codecId);
	        }
	        if (stats.trackId) {
	            this.processAudioTrackSenderStats(stats.trackId, senderStats);
	        }
	        /**
	         * Chrome 没有 remoteId（截止到 77）
	         * 但是实际上 reports 中是有 remoteId 的，所以这里做一个 workaround
	         */
	        if (stats.remoteId) {
	            this.processRemoteInboundStats(stats.remoteId, senderStats);
	        }
	        else {
	            var remoteId = this.findRemoteStatsId(stats.ssrc, RTCStatsType.REMOTE_INBOUND);
	            remoteId && this.processRemoteInboundStats(remoteId, senderStats);
	        }
	    };
	    AgoraSpecStatsFilter.prototype.findRemoteStatsId = function (ssrc, type) {
	        var targetRemoteStats = Array.from(this.report.values()).find(function (s) {
	            return s.type === type && s.ssrc === ssrc;
	        });
	        if (!targetRemoteStats)
	            return null;
	        return targetRemoteStats.id;
	    };
	    AgoraSpecStatsFilter.prototype.processVideoMediaSource = function (statsId, senderStats) {
	        var stats = this.report.get(statsId);
	        if (!stats)
	            return;
	        if (!stats.width || !stats.height || !stats.framesPerSecond) {
	            return;
	        }
	        senderStats.inputFrame = {
	            width: stats.width, height: stats.height, frameRate: stats.framesPerSecond,
	        };
	    };
	    AgoraSpecStatsFilter.prototype.processAudioMediaSource = function (statsId, senderStats) {
	        var mediaSourceStats = this.report.get(statsId);
	        if (!mediaSourceStats)
	            return;
	        senderStats.inputLevel = mediaSourceStats.audioLevel;
	    };
	    AgoraSpecStatsFilter.prototype.processVideoTrackSenderStats = function (statsId, senderStats) {
	        var stats = this.report.get(statsId);
	        if (!stats)
	            return;
	        var frameRate = 0;
	        var now = Date.now();
	        var lastVideoFramesSent = this.lastVideoFramesSent.get(senderStats.ssrc);
	        if (lastVideoFramesSent && now - lastVideoFramesSent.lts >= 800) {
	            frameRate = Math.round((stats.framesSent - lastVideoFramesSent.count) / ((now - lastVideoFramesSent.lts) / 1000));
	            this.lastVideoFramesSent.set(senderStats.ssrc, { count: stats.framesSent, lts: now, rate: frameRate });
	        }
	        else if (!lastVideoFramesSent) {
	            this.lastVideoFramesSent.set(senderStats.ssrc, { count: stats.framesSent, lts: now, rate: 0 });
	        }
	        else {
	            frameRate = lastVideoFramesSent.rate;
	        }
	        senderStats.sentFrame = {
	            width: stats.frameWidth, height: stats.frameHeight,
	            frameRate: frameRate,
	        };
	    };
	    AgoraSpecStatsFilter.prototype.processVideoTrackReceiverStats = function (statsId, recvStats) {
	        var stats = this.report.get(statsId);
	        if (!stats)
	            return;
	        var lastRecvFrameCount = this.lastVideoFramesRecv.get(recvStats.ssrc);
	        var now = Date.now();
	        recvStats.framesReceivedCount = stats.framesReceived;
	        var receiveFrameRate = 0;
	        if (lastRecvFrameCount && now - lastRecvFrameCount.lts >= 800) {
	            receiveFrameRate = Math.round((stats.framesReceived - lastRecvFrameCount.count) / ((now - lastRecvFrameCount.lts) / 1000));
	            this.lastVideoFramesRecv.set(recvStats.ssrc, { count: stats.framesReceived, lts: now, rate: receiveFrameRate });
	        }
	        else if (!lastRecvFrameCount) {
	            this.lastVideoFramesRecv.set(recvStats.ssrc, { count: stats.framesReceived, lts: now, rate: 0 });
	        }
	        else {
	            receiveFrameRate = lastRecvFrameCount.rate;
	        }
	        recvStats.receivedFrame = {
	            width: stats.frameWidth || 0, height: stats.frameHeight || 0, frameRate: receiveFrameRate || 0,
	        };
	        recvStats.decodedFrame = {
	            width: stats.frameWidth || 0, height: stats.frameHeight || 0, frameRate: recvStats.decodeFrameRate || 0,
	        };
	        recvStats.outputFrame = {
	            width: stats.frameWidth || 0, height: stats.frameHeight || 0, frameRate: recvStats.decodeFrameRate || 0,
	        };
	        if (stats.jitterBufferDelay && stats.jitterBufferEmittedCount) {
	            recvStats.jitterBufferMs = stats.jitterBufferDelay * 1000 / stats.jitterBufferEmittedCount;
	            /**
	             * 在 Legacy Stats 的定义中，currentDelay = jitterBufferDelay + playoutDelay。
	             * 在 Spec 定义中，playoutDelay 因为难以明确被丢弃了，目前只能使用 jitterBufferDelay 来替代。
	             * 详见 https://docs.google.com/document/d/1z-D4SngG36WPiMuRvWeTMN7mWQXrf1XKZwVl3Nf1BIE/edit
	             */
	            recvStats.currentDelayMs = stats.jitterBufferDelay * 1000 / stats.jitterBufferEmittedCount;
	        }
	    };
	    AgoraSpecStatsFilter.prototype.processAudioTrackSenderStats = function (statsId, senderStats) {
	        var stats = this.report.get(statsId);
	        if (!stats)
	            return;
	        senderStats.aecReturnLoss = stats.echoReturnLoss || 0;
	        senderStats.aecReturnLossEnhancement = stats.echoReturnLossEnhancement || 0;
	    };
	    AgoraSpecStatsFilter.prototype.processAudioTrackReceiverStats = function (statsId, recvStats) {
	        var stats = this.report.get(statsId);
	        if (!stats)
	            return;
	        if (stats.removedSamplesForAcceleration && stats.totalSamplesReceived) {
	            recvStats.accelerateRate = stats.removedSamplesForAcceleration / stats.totalSamplesReceived;
	        }
	        if (stats.jitterBufferDelay && stats.jitterBufferEmittedCount) {
	            recvStats.jitterBufferMs = stats.jitterBufferDelay * 1000 / stats.jitterBufferEmittedCount;
	        }
	        recvStats.outputLevel = stats.audioLevel;
	        /**
	         * 1 个音频 Frame = 20ms 的 Samples
	         * 默认情况下，opus 48000 采样率双声道一个 Frame 会有 1920 个 Samples
	         */
	        var samplesPerFrame = 1920;
	        if (stats.totalSamplesDuration && stats.totalSamplesReceived) {
	            samplesPerFrame = (stats.totalSamplesReceived / stats.totalSamplesDuration) / 50;
	            recvStats.receivedFrames = Math.round(stats.totalSamplesReceived / samplesPerFrame);
	        }
	        if (stats.concealedSamples) {
	            recvStats.droppedFrames = Math.round(stats.concealedSamples / samplesPerFrame);
	        }
	    };
	    AgoraSpecStatsFilter.prototype.processRemoteInboundStats = function (statsId, senderStats) {
	        var stats = this.report.get(statsId);
	        if (!stats)
	            return;
	        senderStats.packetsLost = stats.packetsLost;
	        if (stats.roundTripTime) {
	            senderStats.rttMs = stats.roundTripTime * 1000;
	        }
	    };
	    AgoraSpecStatsFilter.prototype.getCodecFromCodecStats = function (statsId) {
	        var stats = this.report.get(statsId);
	        if (!stats)
	            return "";
	        /**
	         * mimeType 的格式是 audio/opus 或者 video/H264
	         * 这里我们只取 codec 的部分
	         */
	        var codecMatch = stats.mimeType.match(/\/(.*)$/);
	        if (codecMatch && codecMatch[1]) {
	            return codecMatch[1];
	        }
	        return "";
	    };
	    /** from https://docs.google.com/document/d/1z-D4SngG36WPiMuRvWeTMN7mWQXrf1XKZwVl3Nf1BIE/edit */
	    AgoraSpecStatsFilter.prototype.updateSendBitrate = function () {
	        var bytesSentDelta = 0;
	        /** 除了 Chrome 以外都拿不到 retransmit/target encode 值，这里标记一下，拿不到就不传了 */
	        var bytesRetransmitDelta = null;
	        var bytesTargetEncodeDelta = null;
	        this.mediaBytesSent.forEach(function (ssrc) {
	            bytesSentDelta += ssrc.diffMean();
	        });
	        this.mediaBytesRetransmit.forEach(function (ssrc) {
	            bytesRetransmitDelta = bytesRetransmitDelta === null ? ssrc.diffMean() : bytesRetransmitDelta + ssrc.diffMean();
	        });
	        this.mediaBytesTargetEncode.forEach(function (ssrc) {
	            bytesTargetEncodeDelta = bytesTargetEncodeDelta === null ? ssrc.diffMean() : bytesTargetEncodeDelta + ssrc.diffMean();
	        });
	        var encodedBytesDelta = bytesRetransmitDelta !== null ? bytesSentDelta - bytesRetransmitDelta : bytesSentDelta;
	        this._stats.bitrate = {
	            actualEncoded: 8 * encodedBytesDelta / (this.options.updateInterval / 1000),
	            transmit: 8 * bytesSentDelta / (this.options.updateInterval / 1000),
	        };
	        if (bytesRetransmitDelta !== null) {
	            this._stats.bitrate.retransmit = 8 * bytesRetransmitDelta / (this.options.updateInterval / 1000);
	        }
	        if (bytesTargetEncodeDelta !== null) {
	            this._stats.bitrate.targetEncoded = 8 * bytesTargetEncodeDelta / (this.options.updateInterval / 1000);
	        }
	    };
	    return AgoraSpecStatsFilter;
	}(AgoraWebRTCStatsFilter));

	function createWebRTCStatsFilter(pc, updateInterval, lossRateInterval) {
	    if (updateInterval === void 0) { updateInterval = 250; }
	    if (lossRateInterval === void 0) { lossRateInterval = 8; }
	    /**
	     * mock RTCPeerConnection return Spec style result
	     */
	    return new AgoraSpecStatsFilter(pc, { updateInterval: updateInterval, lossRateInterval: lossRateInterval });
	    /**
	     * 原则如下：
	     * 1. Chrome 内核的浏览器 76 以下用 legacy，以上用 spec
	     * 2. 其他内核的浏览器如果检测到支持 Spec 的写法，一律用 spec （Safari/Firefox）
	     * 4. 再剩下的浏览器，既不是 Chrome 内核，又不支持 spec，认为不支持获取 stats，使用 empty ( 数据都是 0 )
	     */
	    // const chromeVersion = getChromeKernelVersion();
	    // if (chromeVersion) {
	    //   if (chromeVersion < 76) {
	    //     return new AgoraLegacyStatsFilter(pc, { updateInterval, lossRateInterval });
	    //   } else {
	    //     return new AgoraSpecStatsFilter(pc, { updateInterval, lossRateInterval });
	    //   }
	    // }
	    // if (isSupportSpecStats(pc)) {
	    //   return new AgoraSpecStatsFilter(pc, { updateInterval, lossRateInterval });
	    // }
	    // return new AgoraEmptyStatsFilter(pc, { updateInterval, lossRateInterval });
	}

	var __extends$a = undefined && undefined.__extends || function () {
	  var extendStatics = function (d, b) {
	    extendStatics = setPrototypeOf$2 || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    };

	    return extendStatics(d, b);
	  };

	  return function (d, b) {
	    extendStatics(d, b);

	    function __() {
	      this.constructor = d;
	    }

	    d.prototype = b === null ? create$4(b) : (__.prototype = b.prototype, new __());
	  };
	}();

	var __awaiter$h = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = promise$3))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var __generator$h = undefined && undefined.__generator || function (thisArg, body) {
	  var _ = {
	    label: 0,
	    sent: function () {
	      if (t[0] & 1) throw t[1];
	      return t[1];
	    },
	    trys: [],
	    ops: []
	  },
	      f,
	      y,
	      t,
	      g;
	  return g = {
	    next: verb(0),
	    "throw": verb(1),
	    "return": verb(2)
	  }, typeof symbol$2 === "function" && (g[iterator$2] = function () {
	    return this;
	  }), g;

	  function verb(n) {
	    return function (v) {
	      return step([n, v]);
	    };
	  }

	  function step(op) {
	    if (f) throw new TypeError("Generator is already executing.");

	    while (_) try {
	      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	      if (y = 0, t) op = [op[0] & 2, t.value];

	      switch (op[0]) {
	        case 0:
	        case 1:
	          t = op;
	          break;

	        case 4:
	          _.label++;
	          return {
	            value: op[1],
	            done: false
	          };

	        case 5:
	          _.label++;
	          y = op[1];
	          op = [0];
	          continue;

	        case 7:
	          op = _.ops.pop();

	          _.trys.pop();

	          continue;

	        default:
	          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
	            _ = 0;
	            continue;
	          }

	          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
	            _.label = op[1];
	            break;
	          }

	          if (op[0] === 6 && _.label < t[1]) {
	            _.label = t[1];
	            t = op;
	            break;
	          }

	          if (t && _.label < t[2]) {
	            _.label = t[2];

	            _.ops.push(op);

	            break;
	          }

	          if (t[2]) _.ops.pop();

	          _.trys.pop();

	          continue;
	      }

	      op = body.call(thisArg, _);
	    } catch (e) {
	      op = [6, e];
	      y = 0;
	    } finally {
	      f = t = 0;
	    }

	    if (op[0] & 5) throw op[1];
	    return {
	      value: op[0] ? op[1] : void 0,
	      done: true
	    };
	  }
	};

	var AgoraRTCPeerConnection =
	/** @class */
	function () {
	  function AgoraRTCPeerConnection(spec) {
	    this.localCandidateCount = 0;
	    this.allCandidateReceived = false;
	    this.audioTrack = null;
	    this.videoTrack = null;
	    this.mediaStream = new MediaStream();
	    this.ID = pcIDCount;
	    pcIDCount += 1;
	    this.spec = spec;
	    this.createPeerConnection();
	    this.statsFilter = createWebRTCStatsFilter(this.pc);
	  }

	  AgoraRTCPeerConnection.prototype.getStats = function () {
	    return this.statsFilter.getStats();
	  };

	  AgoraRTCPeerConnection.prototype.createOfferSDP = function () {
	    return __awaiter$h(this, void 0, void 0, function () {
	      var offer, e_1;
	      return __generator$h(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            _a.trys.push([0, 2,, 3]);

	            return [4
	            /*yield*/
	            , this.pc.createOffer(this.offerOptions)];

	          case 1:
	            offer = _a.sent();

	            if (!offer.sdp) {
	              throw new Error("offer sdp is empty");
	            }

	            return [2
	            /*return*/
	            , offer.sdp];

	          case 2:
	            e_1 = _a.sent();
	            logger.error("create offer error:", e_1.toString());
	            throw new AgoraRTCError(AgoraRTCErrorCode.CREATE_OFFER_FAILED, e_1.toString());

	          case 3:
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  AgoraRTCPeerConnection.prototype.setOfferSDP = function (sdp) {
	    return __awaiter$h(this, void 0, void 0, function () {
	      var e_2;
	      return __generator$h(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            _a.trys.push([0, 2,, 3]);

	            return [4
	            /*yield*/
	            , this.pc.setLocalDescription({
	              type: "offer",
	              sdp: sdp
	            })];

	          case 1:
	            _a.sent();

	            return [3
	            /*break*/
	            , 3];

	          case 2:
	            e_2 = _a.sent();
	            logger.error("set local offer error", e_2.toString());
	            throw new AgoraRTCError(AgoraRTCErrorCode.CREATE_OFFER_FAILED, e_2.toString());

	          case 3:
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  AgoraRTCPeerConnection.prototype.setAnswerSDP = function (sdp) {
	    return __awaiter$h(this, void 0, void 0, function () {
	      var e_3;
	      return __generator$h(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            _a.trys.push([0, 2,, 3]);

	            return [4
	            /*yield*/
	            , this.pc.setRemoteDescription({
	              type: "answer",
	              sdp: sdp
	            })];

	          case 1:
	            _a.sent();

	            return [3
	            /*break*/
	            , 3];

	          case 2:
	            e_3 = _a.sent();
	            /** ignore InvalidStateError when signal state is stable */

	            if (e_3.name === "InvalidStateError" && this.pc.signalingState === "stable") {
	              logger.debug("[pc-" + this.ID + "] ignore invalidstate error");
	            } else {
	              logger.error("set remote answer error", e_3.toString());
	              throw new AgoraRTCError(AgoraRTCErrorCode.SET_ANSWER_FAILED, e_3.toString());
	            }

	            return [3
	            /*break*/
	            , 3];

	          case 3:
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  AgoraRTCPeerConnection.prototype.close = function () {
	    this.onICEConnectionStateChange = undefined;
	    this.onConnectionStateChange = undefined;

	    try {
	      this.pc.close();
	    } catch (e) {}

	    this.statsFilter.destroy();
	  };

	  AgoraRTCPeerConnection.prototype.createPeerConnection = function () {
	    var _this = this;

	    var pcConfig = {
	      iceServers: [{
	        urls: "stun:webcs.agora.io:3478"
	      }]
	    };

	    if (this.spec.iceServers) {
	      pcConfig.iceServers = this.spec.iceServers;
	    } else {
	      if (this.spec.turnServer && this.spec.turnServer.mode !== "off") {
	        var _context;

	        forEach$3(_context = this.spec.turnServer.servers).call(_context, function (turnServer) {
	          pcConfig.iceServers && pcConfig.iceServers.push({
	            username: turnServer.username,
	            credential: turnServer.password,
	            credentialType: "password",
	            urls: "turn:" + turnServer.turnServerURL + ":" + turnServer.udpport + "?transport=udp"
	          });

	          if (turnServer.tcpport) {
	            pcConfig.iceServers && pcConfig.iceServers.push({
	              username: turnServer.username,
	              credential: turnServer.password,
	              credentialType: "password",
	              urls: "turn:" + turnServer.turnServerURL + ":" + turnServer.tcpport + "?transport=tcp"
	            });
	          }
	          /** 只要有一个是 forceturn，就设置成 relay */


	          if (turnServer.forceturn) {
	            pcConfig.iceTransportPolicy = "relay";
	          }
	        });
	      }
	    }

	    if (getParameter("CHROME_FORCE_PLAN_B") && isChromeKernel()) {
	      // @ts-ignore
	      pcConfig.sdpSemantics = "plan-b";
	      var compat = getCompatibility();
	      compat.supportUnifiedPlan = false;
	    }

	    this.pc = new RTCPeerConnection(pcConfig);

	    this.pc.oniceconnectionstatechange = function () {
	      _this.onICEConnectionStateChange && _this.onICEConnectionStateChange(_this.pc.iceConnectionState);
	    };

	    this.pc.onconnectionstatechange = function () {
	      _this.onConnectionStateChange && _this.onConnectionStateChange(_this.pc.connectionState);
	    };

	    this.pc.onsignalingstatechange = function () {
	      if (_this.pc.connectionState === "closed") {
	        _this.onConnectionStateChange && _this.onConnectionStateChange(_this.pc.connectionState);
	      }
	    };

	    this.pc.onicecandidate = function (candidate) {
	      if (!candidate.candidate) {
	        _this.pc.onicecandidate = null;
	        _this.allCandidateReceived = true;
	        logger.debug("[pc-" + _this.ID + "] local candidate count", _this.localCandidateCount);
	        return;
	      }

	      _this.localCandidateCount += 1;
	    };

	    setTimeout$2(function () {
	      if (_this.allCandidateReceived) return;
	      _this.allCandidateReceived = true;
	      logger.debug("[pc-" + _this.ID + "] onicecandidate timeout, local candidate count", _this.localCandidateCount);
	    }, getParameter("CANDIDATE_TIMEOUT"));
	  };

	  return AgoraRTCPeerConnection;
	}();

	var PubRTCPeerConnection =
	/** @class */
	function (_super) {
	  __extends$a(PubRTCPeerConnection, _super);

	  function PubRTCPeerConnection(spec) {
	    return _super.call(this, spec) || this;
	  }

	  PubRTCPeerConnection.prototype.addStream = function (stream) {
	    return __awaiter$h(this, void 0, void 0, function () {
	      var tracks, _i, tracks_1, track;

	      return __generator$h(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            tracks = stream.getTracks();
	            _i = 0, tracks_1 = tracks;
	            _a.label = 1;

	          case 1:
	            if (!(_i < tracks_1.length)) return [3
	            /*break*/
	            , 4];
	            track = tracks_1[_i];
	            return [4
	            /*yield*/
	            , this.addTrack(track)];

	          case 2:
	            _a.sent();

	            _a.label = 3;

	          case 3:
	            _i++;
	            return [3
	            /*break*/
	            , 1];

	          case 4:
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };
	  /**
	   * 根据返回值来判断是否需要重协商
	   */


	  PubRTCPeerConnection.prototype.replaceTrack = function (track) {
	    return __awaiter$h(this, void 0, void 0, function () {
	      var compat, replacedTrack, sender, oldTrack, e_4;
	      return __generator$h(this, function (_a) {
	        var _context2;

	        switch (_a.label) {
	          case 0:
	            compat = getCompatibility();
	            if (!!compat.supportReplaceTrack) return [3
	            /*break*/
	            , 2];
	            replacedTrack = track.kind === "audio" ? this.audioTrack : this.videoTrack;

	            if (!replacedTrack) {
	              throw new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_ERROR, "can not find replaced track");
	            }

	            this.removeTrack(replacedTrack);
	            return [4
	            /*yield*/
	            , this.addTrack(track)];

	          case 1:
	            _a.sent();

	            return [2
	            /*return*/
	            , true];

	          case 2:
	            sender = this.getSender(track.kind);
	            oldTrack = find$2(_context2 = this.mediaStream.getTracks()).call(_context2, function (t) {
	              return t.kind === track.kind;
	            });
	            oldTrack && this.mediaStream.removeTrack(oldTrack);
	            this.mediaStream.addTrack(track);
	            _a.label = 3;

	          case 3:
	            _a.trys.push([3, 5,, 6]);

	            return [4
	            /*yield*/
	            , sender.replaceTrack(track)];

	          case 4:
	            _a.sent();

	            if (track.kind === "audio") {
	              this.audioTrack = track;
	            } else {
	              this.videoTrack = track;
	            }

	            return [3
	            /*break*/
	            , 6];

	          case 5:
	            e_4 = _a.sent();
	            throw new AgoraRTCError(AgoraRTCErrorCode.SENDER_REPLACE_FAILED, e_4.toString());

	          case 6:
	            return [2
	            /*return*/
	            , false];
	        }
	      });
	    });
	  };

	  PubRTCPeerConnection.prototype.removeTrack = function (track) {
	    var sender = this.getSender(track.kind);
	    this.mediaStream.removeTrack(track);

	    try {
	      this.pc.removeTrack(sender);
	    } catch (e) {
	      logger.warning("[pc-" + this.ID + "] remove track error, ignore", e);
	    }

	    if (track.kind === "audio") {
	      this.audioTrack = null;
	      this.audioSender = undefined;

	      if (this.audioTransceiver) {
	        this.audioTransceiver.direction = "inactive";
	      }

	      this.audioTransceiver = undefined;
	    } else {
	      this.videoTrack = null;
	      this.videoSender = undefined;

	      if (this.videoTransceiver) {
	        this.videoTransceiver.direction = "inactive";
	      }

	      this.videoTransceiver = undefined;
	    }
	  };

	  PubRTCPeerConnection.prototype.addTrack = function (track) {
	    return __awaiter$h(this, void 0, void 0, function () {
	      var compat, transceiver, sender;
	      return __generator$h(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            compat = getCompatibility();

	            if (track.kind === "audio" && this.audioTrack || track.kind === "video" && this.videoTrack) {
	              throw new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_ERROR, "Can't add multiple stream");
	            }

	            this.mediaStream.addTrack(track);
	            if (!compat.supportUnifiedPlan) return [3
	            /*break*/
	            , 2];
	            return [4
	            /*yield*/
	            , getSendTransceiver(this.pc, track)];

	          case 1:
	            transceiver = _a.sent();
	            sender = transceiver.sender;
	            return [3
	            /*break*/
	            , 3];

	          case 2:
	            sender = this.pc.addTrack(track, this.mediaStream);
	            _a.label = 3;

	          case 3:
	            if (track.kind === "audio") {
	              this.audioTrack = track;
	              this.audioSender = sender;
	              this.audioTransceiver = transceiver;
	            } else {
	              this.videoTrack = track;
	              this.videoSender = sender;
	              this.videoTransceiver = transceiver;
	            }

	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  PubRTCPeerConnection.prototype.setRtpSenderParameters = function (encoder, degradation) {
	    return __awaiter$h(this, void 0, void 0, function () {
	      var videoSender, parameters, e_5;
	      return __generator$h(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            videoSender = this.videoSender || (this.videoTransceiver ? this.videoTransceiver.sender : undefined);
	            if (!videoSender) return [2
	            /*return*/
	            ];
	            parameters = videoSender.getParameters();
	            /* TODO: 暂时无法修改编码器的 encoding 配置，需要调查原因，怀疑是只有在编码开始后设置才有效
	            if (!parameters.encodings) {
	              parameters.encodings = [{}];
	            }
	            if (!parameters.encodings[0]) {
	              parameters.encodings.push({});
	            }
	            parameters.encodings[0].maxBitrate = encoder.maxBitrate;
	            */

	            parameters.degradationPreference = degradation;
	            _a.label = 1;

	          case 1:
	            _a.trys.push([1, 3,, 4]);

	            return [4
	            /*yield*/
	            , videoSender.setParameters(parameters)];

	          case 2:
	            _a.sent();

	            return [3
	            /*break*/
	            , 4];

	          case 3:
	            e_5 = _a.sent(); // TODO: 在老 Chrome 上必须在 offer/answer 之后才能设置参数，这里先做风险最小的修改，之后重新设计

	            logger.debug("[" + this.ID + "] ignore RtpSender.setParameters", e_5.toString());
	            return [3
	            /*break*/
	            , 4];

	          case 4:
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  PubRTCPeerConnection.prototype.getSender = function (type) {
	    var compat = getCompatibility();
	    var sender = null;

	    if (compat.supportUnifiedPlan) {
	      var _context3;

	      var transceiver = find$2(_context3 = this.pc.getTransceivers()).call(_context3, function (t) {
	        return t.sender.track && t.sender.track.kind === type;
	      });

	      sender = transceiver ? transceiver.sender : null;
	    } else {
	      var _context4;

	      sender = find$2(_context4 = this.pc.getSenders()).call(_context4, function (s) {
	        return s.track && s.track.kind === type;
	      }) || null;
	    }

	    if (!sender) {
	      throw new AgoraRTCError(AgoraRTCErrorCode.SENDER_NOT_FOUND);
	    }

	    return sender;
	  };

	  return PubRTCPeerConnection;
	}(AgoraRTCPeerConnection);

	var SubRTCPeerConnection =
	/** @class */
	function (_super) {
	  __extends$a(SubRTCPeerConnection, _super);

	  function SubRTCPeerConnection(spec) {
	    var _this = _super.call(this, spec) || this;

	    _this.statsFilter.onFirstAudioDecoded = function () {
	      return _this.onFirstAudioDecoded && _this.onFirstAudioDecoded();
	    };

	    _this.statsFilter.onFirstVideoDecoded = function (width, height) {
	      return _this.onFirstVideoDecoded && _this.onFirstVideoDecoded(width, height);
	    };

	    _this.statsFilter.onFirstAudioReceived = function () {
	      return _this.onFirstAudioReceived && _this.onFirstAudioReceived();
	    };

	    _this.statsFilter.onFirstVideoReceived = function () {
	      return _this.onFirstVideoReceived && _this.onFirstVideoReceived();
	    };

	    var compat = getCompatibility();

	    if (!compat.supportUnifiedPlan) {
	      _this.offerOptions = {
	        offerToReceiveAudio: true,
	        offerToReceiveVideo: true
	      };
	    } else {
	      _this.audioTransceiver = _this.pc.addTransceiver("audio", {
	        direction: "recvonly"
	      });
	      _this.videoTransceiver = _this.pc.addTransceiver("video", {
	        direction: "recvonly"
	      });
	    }

	    _this.pc.ontrack = function (e) {
	      if (e.track.kind === "audio") {
	        _this.audioTrack = e.track;
	      } else {
	        _this.videoTrack = e.track;
	      }

	      _this.onTrack && _this.onTrack(e.track, e.streams[0]);
	    };

	    return _this;
	  }

	  return SubRTCPeerConnection;
	}(AgoraRTCPeerConnection);
	var pcIDCount = 1;

	var __extends$b = undefined && undefined.__extends || function () {
	  var extendStatics = function (d, b) {
	    extendStatics = setPrototypeOf$2 || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    };

	    return extendStatics(d, b);
	  };

	  return function (d, b) {
	    extendStatics(d, b);

	    function __() {
	      this.constructor = d;
	    }

	    d.prototype = b === null ? create$4(b) : (__.prototype = b.prototype, new __());
	  };
	}();

	var __awaiter$i = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = promise$3))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var __generator$i = undefined && undefined.__generator || function (thisArg, body) {
	  var _ = {
	    label: 0,
	    sent: function () {
	      if (t[0] & 1) throw t[1];
	      return t[1];
	    },
	    trys: [],
	    ops: []
	  },
	      f,
	      y,
	      t,
	      g;
	  return g = {
	    next: verb(0),
	    "throw": verb(1),
	    "return": verb(2)
	  }, typeof symbol$2 === "function" && (g[iterator$2] = function () {
	    return this;
	  }), g;

	  function verb(n) {
	    return function (v) {
	      return step([n, v]);
	    };
	  }

	  function step(op) {
	    if (f) throw new TypeError("Generator is already executing.");

	    while (_) try {
	      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	      if (y = 0, t) op = [op[0] & 2, t.value];

	      switch (op[0]) {
	        case 0:
	        case 1:
	          t = op;
	          break;

	        case 4:
	          _.label++;
	          return {
	            value: op[1],
	            done: false
	          };

	        case 5:
	          _.label++;
	          y = op[1];
	          op = [0];
	          continue;

	        case 7:
	          op = _.ops.pop();

	          _.trys.pop();

	          continue;

	        default:
	          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
	            _ = 0;
	            continue;
	          }

	          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
	            _.label = op[1];
	            break;
	          }

	          if (op[0] === 6 && _.label < t[1]) {
	            _.label = t[1];
	            t = op;
	            break;
	          }

	          if (t && _.label < t[2]) {
	            _.label = t[2];

	            _.ops.push(op);

	            break;
	          }

	          if (t[2]) _.ops.pop();

	          _.trys.pop();

	          continue;
	      }

	      op = body.call(thisArg, _);
	    } catch (e) {
	      op = [6, e];
	      y = 0;
	    } finally {
	      f = t = 0;
	    }

	    if (op[0] & 5) throw op[1];
	    return {
	      value: op[0] ? op[1] : void 0,
	      done: true
	    };
	  }
	};
	var STREAM_CONNECTION_ID = 1;
	/** TODO
	 * 用户可以配置 */

	var MAX_RECONNECT_COUNT = Infinity;

	var StreamConnection =
	/** @class */
	function (_super) {
	  __extends$b(StreamConnection, _super);

	  function StreamConnection(joinInfo, uid) {
	    var _this = _super.call(this) || this;
	    /**
	     * 开始建立媒体连接的时间, 每次重连会重置
	     */


	    _this.startTime = now$2();
	    /**
	     * 该连接对象创建时间
	     */

	    _this.createTime = now$2();
	    _this.readyToReconnect = false;
	    _this._connectionState = "disconnected";
	    _this.currentReconnectCount = 0;
	    _this.ID = STREAM_CONNECTION_ID;
	    STREAM_CONNECTION_ID += 1;
	    _this.joinInfo = joinInfo;
	    _this._userId = uid;

	    _this.createPC();

	    return _this;
	  }

	  defineProperty$4(StreamConnection.prototype, "connectionState", {
	    get: function () {
	      return this._connectionState;
	    },
	    set: function (newState) {
	      if (newState === this._connectionState) return;
	      this.emit(StreamConnectionEvents.CONNECTION_STATE_CHANGE, newState, this._connectionState);
	      this._connectionState = newState;
	    },
	    enumerable: true,
	    configurable: true
	  });

	  defineProperty$4(StreamConnection.prototype, "connectionId", {
	    get: function () {
	      return this.joinInfo.clientId + "-" + (this.type ? this.type : "sub(" + this._userId + ")") + "-" + this.ID;
	    },
	    enumerable: true,
	    configurable: true
	  });

	  StreamConnection.prototype.getUserId = function () {
	    return this._userId;
	  };

	  StreamConnection.prototype.startUploadStats = function () {
	    var _this = this;

	    this.statsUploadInterval = window.setInterval(function () {
	      var stats = _this.pc.getStats();

	      _this.uploadStats(stats, _this.lastUploadPCStats);

	      _this.lastUploadPCStats = stats;
	    }, 3000);
	    this.statsUploadSlowInterval = window.setInterval(function () {
	      var stats = _this.pc.getStats();

	      _this.uploadSlowStats(stats);
	    }, 60000);
	    this.relatedStatsUploadInterval = window.setInterval(function () {
	      var stats = _this.pc.getStats();

	      _this.uploadRelatedStats(stats, _this.lastRelatedPcStats);

	      _this.lastRelatedPcStats = stats;
	    }, 1000);
	  };

	  StreamConnection.prototype.stopUploadStats = function () {
	    if (this.statsUploadInterval) {
	      window.clearInterval(this.statsUploadInterval);
	    }

	    if (this.relatedStatsUploadInterval) {
	      window.clearInterval(this.relatedStatsUploadInterval);
	    }

	    this.statsUploadInterval = undefined;
	    this.relatedStatsUploadInterval = undefined;
	  };

	  StreamConnection.prototype.createWaitConnectionConnectedPromise = function () {
	    var _this = this;

	    return new promise$3(function (resolve, reject) {
	      if (_this.connectionState === "disconnected") {
	        reject();
	      } else if (_this.connectionState === "connected") {
	        resolve();
	      } else {
	        _this.once(StreamConnectionEvents.CONNECTION_STATE_CHANGE, function (newState) {
	          if (newState === "connected") {
	            resolve();
	          } else {
	            reject();
	          }
	        });
	      }
	    });
	  };
	  /**
	   * @param reason - 如果是一个错误导致了需要重新连接 PC，这里传入错误对象，如果无法重试直接 throw 这个对象
	   */


	  StreamConnection.prototype.reconnectPC = function (reason) {
	    return __awaiter$i(this, void 0, void 0, function () {
	      var isAbort;
	      return __generator$i(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            this.readyToReconnect = false;

	            if (reason) {
	              this.onPCDisconnected(reason);
	            }

	            if (this.currentReconnectCount > MAX_RECONNECT_COUNT) {
	              logger.debug("[" + this.connectionId + "] cannot reconnect pc");
	              throw reason || new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_ERROR);
	            }

	            this.stopUploadStats();
	            logger.debug("[" + this.connectionId + "] start reconnect pc");
	            this.connectionState = "connecting";
	            this.currentReconnectCount += 1;
	            return [4
	            /*yield*/
	            , this.closePC()];

	          case 1:
	            isAbort = _a.sent();

	            if (isAbort) {
	              logger.debug("[" + this.connectionId + "] abort reconnect pc, wait ws");
	              this.readyToReconnectPC();
	              return [2
	              /*return*/
	              ];
	            }

	            this.createPC();
	            return [4
	            /*yield*/
	            , this.startP2PConnection()];

	          case 2:
	            _a.sent();

	            this.currentReconnectCount = 0;
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };
	  /**
	   * 当网关断开时，调用这个方法标记这个 PC 等待网关恢复后重新连接
	   */


	  StreamConnection.prototype.readyToReconnectPC = function () {
	    this.stopUploadStats();
	    this.readyToReconnect = true;
	    this.pc.onICEConnectionStateChange = undefined;
	    this.connectionState = "connecting";
	  };
	  /**
	   * 每次新建 PC 后都需要更新一下 ICE Promise
	   */


	  StreamConnection.prototype.updateICEPromise = function () {
	    var _this = this;

	    this.removeAllListeners(StreamConnectionEvents.GATEWAY_P2P_LOST);
	    this.icePromise = new promise$3(function (resolve, reject) {
	      _this.pc.onICEConnectionStateChange = function (state) {
	        logger.info("[" + _this.connectionId + "] ice-state: " + _this.type + " p2p " + state);

	        if (state === "connected") {
	          resolve();
	        }
	        /** 如果 P2P 异常断开，失败 */


	        if (state === "failed" || state === "closed") {
	          _this.reconnectPC(new AgoraRTCError(AgoraRTCErrorCode.ICE_FAILED)).catch(function (e) {
	            _this.emit(StreamConnectionEvents.P2P_LOST);

	            reject(e);
	          });
	        }
	      };

	      _this.pc.onConnectionStateChange = function (state) {
	        logger.info("[" + _this.connectionId + "] connection-state: " + _this.type + " p2p " + state);

	        if (state === "failed" || state === "closed") {
	          _this.reconnectPC(new AgoraRTCError(AgoraRTCErrorCode.PC_CLOSED)).catch(function (e) {
	            _this.emit(StreamConnectionEvents.P2P_LOST);

	            reject(e);
	          });
	        }
	      };

	      _this.removeAllListeners(StreamConnectionEvents.GATEWAY_P2P_LOST);

	      _this.once(StreamConnectionEvents.GATEWAY_P2P_LOST, function (p2pID) {
	        if (_this.pc.ID.toString() !== p2pID.toString()) return;
	        logger.info("[" + _this.connectionId + "] " + _this.type + " p2p gateway lost");
	        /** 在重连之前，需要判断是否本地还存在 candidate，如果没有，放弃重试 */

	        if (_this.pc.allCandidateReceived && _this.pc.localCandidateCount === 0) {
	          _this.disconnectedReason = new AgoraRTCError(AgoraRTCErrorCode.NO_ICE_CANDIDATE, "can not get candidate in this pc");

	          _this.closeP2PConnection(true);

	          return;
	        }

	        _this.reconnectPC(new AgoraRTCError(AgoraRTCErrorCode.GATEWAY_P2P_LOST)).catch(function (e) {
	          _this.emit(StreamConnectionEvents.P2P_LOST);

	          reject(e);
	        });
	      });
	    });
	  };

	  return StreamConnection;
	}(EventEmitter$1);

	var __awaiter$j = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = promise$3))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var __generator$j = undefined && undefined.__generator || function (thisArg, body) {
	  var _ = {
	    label: 0,
	    sent: function () {
	      if (t[0] & 1) throw t[1];
	      return t[1];
	    },
	    trys: [],
	    ops: []
	  },
	      f,
	      y,
	      t,
	      g;
	  return g = {
	    next: verb(0),
	    "throw": verb(1),
	    "return": verb(2)
	  }, typeof symbol$2 === "function" && (g[iterator$2] = function () {
	    return this;
	  }), g;

	  function verb(n) {
	    return function (v) {
	      return step([n, v]);
	    };
	  }

	  function step(op) {
	    if (f) throw new TypeError("Generator is already executing.");

	    while (_) try {
	      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	      if (y = 0, t) op = [op[0] & 2, t.value];

	      switch (op[0]) {
	        case 0:
	        case 1:
	          t = op;
	          break;

	        case 4:
	          _.label++;
	          return {
	            value: op[1],
	            done: false
	          };

	        case 5:
	          _.label++;
	          y = op[1];
	          op = [0];
	          continue;

	        case 7:
	          op = _.ops.pop();

	          _.trys.pop();

	          continue;

	        default:
	          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
	            _ = 0;
	            continue;
	          }

	          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
	            _.label = op[1];
	            break;
	          }

	          if (op[0] === 6 && _.label < t[1]) {
	            _.label = t[1];
	            t = op;
	            break;
	          }

	          if (t && _.label < t[2]) {
	            _.label = t[2];

	            _.ops.push(op);

	            break;
	          }

	          if (t[2]) _.ops.pop();

	          _.trys.pop();

	          continue;
	      }

	      op = body.call(thisArg, _);
	    } catch (e) {
	      op = [6, e];
	      y = 0;
	    } finally {
	      f = t = 0;
	    }

	    if (op[0] & 5) throw op[1];
	    return {
	      value: op[0] ? op[1] : void 0,
	      done: true
	    };
	  }
	};

	var TrackProcessor =
	/** @class */
	function () {
	  function TrackProcessor() {}

	  defineProperty$4(TrackProcessor.prototype, "output", {
	    /**
	     * **Note:**
	     * - output 为 undefined 时，表示没有输出，即使用源输入
	     */
	    get: function () {
	      return this._output;
	    },
	    enumerable: true,
	    configurable: true
	  });

	  TrackProcessor.prototype.setInput = function (track) {
	    return __awaiter$j(this, void 0, void 0, function () {
	      return __generator$j(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            if (track === this.input) return [2
	            /*return*/
	            ];

	            if (track.kind !== this.kind) {
	              throw new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_ERROR);
	            }
	            /**
	             * 如果已经有输入了，先清理旧的输入
	             */


	            if (this.input) {
	              this.removeInput();
	            }

	            this.input = track;
	            return [4
	            /*yield*/
	            , this._setInput(track)];

	          case 1:
	            _a.sent();

	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  TrackProcessor.prototype.removeInput = function () {
	    this.input = undefined;

	    this._removeInput();
	  };

	  TrackProcessor.prototype.updateOutput = function (track) {
	    return __awaiter$j(this, void 0, void 0, function () {
	      var _a;

	      return __generator$j(this, function (_b) {
	        switch (_b.label) {
	          case 0:
	            if (this.output === track) return [2
	            /*return*/
	            ];
	            this._output = track;
	            _a = this.onOutputChange;
	            if (!_a) return [3
	            /*break*/
	            , 2];
	            return [4
	            /*yield*/
	            , this.onOutputChange()];

	          case 1:
	            _a = _b.sent();
	            _b.label = 2;

	          case 2:
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };
	  /**
	   * 将 TrackProcessor 的输出替换到原始的 MediaStream 上
	   */


	  TrackProcessor.prototype.replaceOriginMediaStream = function (targetMs, originMs) {
	    var _context, _context2;

	    var _this = this;

	    var targetTrack = find$2(_context = targetMs.getTracks()).call(_context, function (t) {
	      return t.kind === _this.kind;
	    });

	    if (targetTrack) {
	      targetMs.removeTrack(targetTrack);
	    }

	    var originTrack = find$2(_context2 = originMs.getTracks()).call(_context2, function (t) {
	      return t.kind === _this.kind;
	    });

	    if (this.output === undefined && originTrack) {
	      targetMs.addTrack(originTrack);
	    }

	    if (this.output) {
	      logger.debug("replace " + this.output.kind + " track to origin media stream");
	      targetMs.addTrack(this.output);
	    }
	  };

	  return TrackProcessor;
	}();

	/*
	 * Copyright 2012, Gregg Tavares.
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *     * Redistributions of source code must retain the above copyright
	 * notice, this list of conditions and the following disclaimer.
	 *     * Redistributions in binary form must reproduce the above
	 * copyright notice, this list of conditions and the following disclaimer
	 * in the documentation and/or other materials provided with the
	 * distribution.
	 *     * Neither the name of Gregg Tavares. nor the names of his
	 * contributors may be used to endorse or promote products derived from
	 * this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */

	/**
	 * Loads a shader.
	 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
	 * @param {string} shaderSource The shader source.
	 * @param {number} shaderType The type of shader.
	 * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors.
	 * @returns {WebGLShader} The created shader.
	 */

	function loadShader(gl, shaderSource, shaderType) {
	  // Create the shader object
	  var shader = gl.createShader(shaderType);

	  if (!shader) {
	    var err = new AgoraRTCError(AgoraRTCErrorCode.WEBGL_INTERNAL_ERROR, "can not create shader");
	    return err.throw();
	  } // Load the shader source


	  gl.shaderSource(shader, shaderSource); // Compile the shader

	  gl.compileShader(shader); // Check the compile status

	  var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);

	  if (!compiled) {
	    // Something went wrong during compilation; get the error
	    var lastError = gl.getShaderInfoLog(shader);
	    gl.deleteShader(shader);
	    var err = new AgoraRTCError(AgoraRTCErrorCode.WEBGL_INTERNAL_ERROR, "error compiling shader:" + lastError);
	    return err.throw();
	  }

	  return shader;
	}
	/**
	 * Creates a program, attaches shaders, binds attrib locations, links the
	 * program and calls useProgram.
	 * @param {WebGLShader[]} shaders The shaders to attach
	 * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in
	 * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.
	 * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console
	 *        on error. If you want something else pass an callback. It's passed an error message.
	 * @memberOf module:webgl-utils
	 */


	function createProgram(gl, shaders, opt_attribs, opt_locations) {
	  var program = gl.createProgram();

	  if (!program) {
	    throw new AgoraRTCError(AgoraRTCErrorCode.WEBGL_INTERNAL_ERROR, "can not create webgl program");
	  }

	  forEach$3(shaders).call(shaders, function (shader) {
	    gl.attachShader(program, shader);
	  });

	  if (opt_attribs) {
	    forEach$3(opt_attribs).call(opt_attribs, function (attrib, ndx) {
	      gl.bindAttribLocation(program, opt_locations ? opt_locations[ndx] : ndx, attrib);
	    });
	  }

	  gl.linkProgram(program); // Check the link status

	  var linked = gl.getProgramParameter(program, gl.LINK_STATUS);

	  if (!linked) {
	    // something went wrong with the link
	    var lastError = gl.getProgramInfoLog(program);
	    gl.deleteProgram(program);
	    throw new AgoraRTCError(AgoraRTCErrorCode.WEBGL_INTERNAL_ERROR, "error in program linking:" + lastError);
	  }

	  return program;
	}
	/**
	 * Creates a program from 2 sources.
	 *
	 * @param {WebGLRenderingContext} gl The WebGLRenderingContext
	 *        to use.
	 * @param {string[]} shaderSourcess Array of sources for the
	 *        shaders. The first is assumed to be the vertex shader,
	 *        the second the fragment shader.
	 * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in
	 * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.
	 * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console
	 *        on error. If you want something else pass an callback. It's passed an error message.
	 * @returns {WebGLProgram} The created program.
	 * @memberOf module:webgl-utils
	 */

	function createProgramFromSources(gl, shaderSources, opt_attribs, opt_locations) {
	  var shaders = [];

	  for (var ii = 0; ii < shaderSources.length; ++ii) {
	    var shaderType = ii === 0 ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER;
	    shaders.push(loadShader(gl, shaderSources[ii], shaderType));
	  }

	  return createProgram(gl, shaders, opt_attribs, opt_locations);
	}
	var isIE =
	/*@cc_on!@*/
	 !!document.documentMode; // Edge 20+

	var isEdge$1 = !isIE && !!window.StyleMedia;

	if (isEdge$1) {
	  // Hack for Edge. Edge's WebGL implmentation is crap still and so they
	  // only respond to "experimental-webgl". I don't want to clutter the
	  // examples with that so his hack works around it
	  HTMLCanvasElement.prototype.getContext = function (origFn) {
	    return function () {
	      var args = arguments;
	      var type = args[0];

	      if (type === "webgl") {
	        args = slice$2([]).call(arguments);
	        args[0] = "experimental-webgl";
	      }

	      return origFn.apply(null, args);
	    };
	  }(HTMLCanvasElement.prototype.getContext);
	}

	var winSize = 5;
	var kernel = [0x1f, 0xde, 0xef, 0x9f, 0xc0, 0xec, 0xa4, 0x51, 0x36, 0xe3, 0xb0, 0x95, 0x02, 0xf7, 0x4b, 0x8d, 0xb7, 0x36, 0xd5, 0xd8, 0x9e, 0x5c, 0x6f, 0x31, 0xe4, 0x6f, 0x96, 0x06, 0x87, 0x4f, 0x23, 0xd4, 0x04, 0x9b, 0xc8, 0xa8, 0x25, 0x6b, 0xf3, 0x6e, 0x90, 0xb3, 0x33, 0x51, 0x37, 0x4e, 0xdf, 0xf2, 0xbf, 0xd3, 0x4a, 0x77, 0xcb, 0x97, 0x8e, 0x3e, 0x1f, 0x29, 0x84, 0x16, 0x23, 0x9b, 0x57, 0x7b, 0x77, 0x75, 0xd8, 0x39, 0xc9, 0x35, 0xe4, 0x43, 0xc9, 0x28, 0x6a, 0x18, 0x50, 0xb0, 0xbb, 0xfd, 0x3c, 0x3f, 0x88, 0x64, 0x14, 0x0c, 0xb1, 0x63, 0x40, 0x26, 0x65, 0x8f, 0x6f, 0xb0, 0xfb, 0xd3, 0x91, 0x88, 0x22, 0x17, 0x4f, 0x88, 0xca, 0x5f, 0x69, 0xc7, 0x7d, 0x43, 0xb4, 0x2c, 0xd2, 0xb3, 0xe4, 0x04, 0x55, 0xa0, 0xbc, 0x40, 0x1a, 0x2e, 0x06, 0x3d, 0xc9, 0x67, 0xf8, 0x12, 0x61, 0xfe, 0x8c, 0x24, 0x73, 0x6a, 0x30, 0x7c, 0x66, 0xd8, 0x9b, 0x78, 0x24, 0xe3, 0xa5, 0xd9, 0x07, 0xe3, 0xbf, 0x80, 0xd4, 0x9d, 0x50, 0x25, 0x75, 0xaf, 0x18, 0xd6, 0x2f, 0xdd, 0xb7, 0xd3, 0x33, 0xae, 0xfb, 0xdf, 0x9f, 0xa7, 0x98, 0x35, 0x24, 0x6b, 0xc7, 0xdf, 0x5b, 0x3e, 0x2e, 0xc2, 0x0b, 0x50, 0x79, 0xbc, 0xdb, 0x02, 0x63, 0x63, 0xe8, 0xe5, 0xad, 0xea, 0x15, 0x1e, 0xec, 0xb1, 0xf3, 0x8e, 0x61, 0x30, 0x6c, 0x38, 0x3e, 0xac, 0x38, 0xd8, 0x03, 0x2a, 0x4f, 0x8a, 0x17, 0x58, 0xb6, 0x27, 0x05, 0x76, 0x44, 0x87, 0xb2, 0x38, 0x09, 0x5e, 0xbd, 0x2c, 0x68, 0x09, 0xee, 0xe7, 0xae, 0x7a, 0x55, 0xf7, 0xe7, 0x56, 0x4a, 0x08, 0xbd, 0x93, 0xda, 0xb4, 0x3a, 0x4c, 0xe3, 0x11, 0x2e, 0x5a, 0xc2, 0x64, 0x33, 0xb2, 0x48, 0xa3, 0x97, 0xf3, 0xa6, 0x82, 0x55, 0x01, 0xdf, 0x82, 0x98, 0xf2, 0x55, 0xff, 0x1c, 0xad, 0x61, 0xfc, 0x77, 0xd7, 0xb1, 0x77, 0x56, 0x68, 0x88, 0x52, 0x28, 0x48, 0x35, 0x0b, 0x12, 0x1a, 0xf0, 0xbc, 0x4c, 0x6e, 0x27, 0x1f, 0xbd];
	/**
	 * 翻译 kernel 源码
	 */

	function translate(content) {
	  var _a, _b;

	  var key = new Uint8Array([99, 114, 121, 112, 116, 105, 105]);
	  var drop = 0;
	  var keyLength = key.length;
	  var input = content;
	  var inputLength = input.length;
	  var result = new Uint8Array(inputLength);
	  var s = new Uint8Array(256);

	  for (var i_1 = 0; i_1 < 256; i_1++) {
	    s[i_1] = i_1;
	  }

	  var j = 0;

	  for (var i_2 = 0; i_2 < 256; i_2++) {
	    j = (j + s[i_2] + key[i_2 % keyLength]) % 256;
	    _a = [s[j], s[i_2]], s[i_2] = _a[0], s[j] = _a[1];
	  }

	  var i = 0;
	  j = 0;
	  var keyStreamByte;

	  for (var k = 0; k < drop + inputLength; k++) {
	    i = (i + 1) % 256;
	    j = (j + s[i]) % 256;
	    _b = [s[j], s[i]], s[i] = _b[0], s[j] = _b[1];
	    keyStreamByte = s[(s[i] + s[j]) % 256];

	    if (k >= drop) {
	      result[k - drop] = input[k - drop] ^ keyStreamByte;
	    }
	  }

	  var data = String.fromCharCode.apply(null, from_1$2(result));
	  return Function("var winSize = " + winSize + "; return `" + data + "`")();
	}

	function createProgram$1(gl, fragmentShader) {
	  var data = translate(fragmentShader);
	  var program = createProgramFromSources(gl, [translate(kernel), data]);
	  {
	    // look up where the vertex data needs to go.
	    var positionLocation = gl.getAttribLocation(program, "a_position"); // Create a buffer to put three 2d clip space points in

	    var positionBuffer = gl.createBuffer(); // Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)

	    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer); // Set a rectangle the same size as the image.

	    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]), gl.STATIC_DRAW); // Turn on the position attribute

	    gl.enableVertexAttribArray(positionLocation); // Tell the position attribute how to get data out of positionBuffer (ARRAY_BUFFER)

	    var size = 2; // 2 components per iteration

	    var type = gl.FLOAT; // the data is 32bit floats

	    var normalize = false; // don't normalize the data

	    var stride = 0; // 0 = move forward size * sizeof(type) each iteration to get the next position

	    var offset = 0; // start at the beginning of the buffer

	    gl.vertexAttribPointer(positionLocation, size, type, normalize, stride, offset);
	  }
	  {
	    var texcoordLocation = gl.getAttribLocation(program, "a_texCoord"); // provide texture coordinates for the rectangle.

	    var texcoordBuffer = gl.createBuffer();
	    gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
	    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]), gl.STATIC_DRAW); // Turn on the teccord attribute

	    gl.enableVertexAttribArray(texcoordLocation); // Tell the position attribute how to get data out of positionBuffer (ARRAY_BUFFER)

	    var size = 2; // 2 components per iteration

	    var type = gl.FLOAT; // the data is 32bit floats

	    var normalize = false; // don't normalize the data

	    var stride = 0; // 0 = move forward size * sizeof(type) each iteration to get the next position

	    var offset = 0; // start at the beginning of the buffer

	    gl.vertexAttribPointer(texcoordLocation, size, type, normalize, stride, offset);
	  }
	  return program;
	}

	var __extends$c = undefined && undefined.__extends || function () {
	  var extendStatics = function (d, b) {
	    extendStatics = setPrototypeOf$2 || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    };

	    return extendStatics(d, b);
	  };

	  return function (d, b) {
	    extendStatics(d, b);

	    function __() {
	      this.constructor = d;
	    }

	    d.prototype = b === null ? create$4(b) : (__.prototype = b.prototype, new __());
	  };
	}();
	var COMMON_PROGRAM_KERNEL = [0x0b, 0xc4, 0xf2, 0x8b, 0xc6, 0xfc, 0xbc, 0x05, 0x3b, 0xaa, 0xa1, 0x98, 0x11, 0xe5, 0x18, 0x8d, 0x85, 0x36, 0xd6, 0xce, 0x85, 0x1a, 0x42, 0x7e, 0xff, 0x0b, 0xf5, 0x0a, 0x92, 0x5c, 0x34, 0x86, 0x6c, 0x98, 0xdd, 0xbf, 0x7c, 0x74, 0xf8, 0x6a, 0x82, 0xfb, 0x3b, 0x69, 0x2b, 0x5b, 0x87, 0xc7, 0xb5, 0xdf, 0x0a, 0x33, 0x86, 0xc2, 0xf0, 0x2e, 0x09, 0x03, 0x8d, 0x16, 0x23, 0x92, 0x4c, 0x17, 0x6d, 0x75, 0xd0, 0x29, 0xc9, 0x2d, 0xda, 0x4c, 0xcb, 0x69, 0x33, 0x3a, 0x61, 0x9a, 0x91, 0xec, 0x31, 0x12, 0xb7, 0x7f, 0x1b, 0x0c, 0xd2, 0x7a, 0x49, 0x2a, 0x25, 0x8f, 0x24, 0xcf, 0xfb, 0xd3, 0x91, 0xbf, 0x38, 0x0a, 0x58, 0xde, 0xb5, 0x7d, 0x16, 0xee, 0x7b, 0x47, 0xb1, 0x6b, 0xda, 0xfe, 0xad, 0x1c, 0x22, 0xfd, 0xf9, 0x43, 0x53, 0x61, 0x49, 0x6f, 0xdb, 0x2b, 0xb5, 0x52, 0x26, 0xe6, 0x88, 0x6d, 0x16, 0x43];

	var CommonProgram =
	/** @class */
	function () {
	  function CommonProgram(gl, kernel) {
	    this.gl = gl;
	    this.kernel = kernel || COMMON_PROGRAM_KERNEL;
	    this.program = createProgram$1(this.gl, this.kernel);
	  }

	  CommonProgram.prototype.setUniforms = function () {
	    // const u_imageLocation = this.gl.getUniformLocation(this.program, "u_image");
	    var u_flipYLocation = this.gl.getUniformLocation(this.program, "u_flipY");
	    this.gl.uniform1f(u_flipYLocation, 1.0);
	  };

	  return CommonProgram;
	}();

	var CommonProgramWithParameters =
	/** @class */
	function (_super) {
	  __extends$c(CommonProgramWithParameters, _super);

	  function CommonProgramWithParameters(gl, kernel, width, height) {
	    var _this = _super.call(this, gl, kernel) || this;

	    _this.denoiseLevel = 5.0;
	    _this.xOffset = 1.0 / width;
	    _this.yOffset = 1.0 / height;
	    return _this;
	  }

	  CommonProgramWithParameters.prototype.setUniforms = function () {
	    // const u_imageLocation = this.gl.getUniformLocation(this.program, "u_image");
	    var u_flipYLocation = this.gl.getUniformLocation(this.program, "u_flipY");
	    var singleStepOffsetLocation = this.gl.getUniformLocation(this.program, "u_singleStepOffset");
	    var denoiseLevelLocation = this.gl.getUniformLocation(this.program, "u_denoiseLevel");
	    this.gl.uniform2f(singleStepOffsetLocation, this.xOffset, this.yOffset);
	    this.gl.uniform1f(denoiseLevelLocation, this.denoiseLevel);
	    this.gl.uniform1f(u_flipYLocation, 1.0);
	  };

	  CommonProgramWithParameters.prototype.setParameters = function (parameters) {
	    if (parameters.denoiseLevel !== undefined) {
	      this.denoiseLevel = parameters.denoiseLevel;
	    }
	  };

	  CommonProgramWithParameters.prototype.setSize = function (width, height) {
	    this.xOffset = 1.0 / width;
	    this.yOffset = 1.0 / height;
	  };

	  return CommonProgramWithParameters;
	}(CommonProgram);

	var __extends$d = undefined && undefined.__extends || function () {
	  var extendStatics = function (d, b) {
	    extendStatics = setPrototypeOf$2 || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    };

	    return extendStatics(d, b);
	  };

	  return function (d, b) {
	    extendStatics(d, b);

	    function __() {
	      this.constructor = d;
	    }

	    d.prototype = b === null ? create$4(b) : (__.prototype = b.prototype, new __());
	  };
	}();
	var kernel$1 = [0x0b, 0xc4, 0xf2, 0x8b, 0xc6, 0xfc, 0xbc, 0x05, 0x3b, 0xaa, 0xa1, 0x98, 0x11, 0xe5, 0x18, 0x8d, 0x85, 0x36, 0xd6, 0xce, 0x85, 0x1a, 0x42, 0x7e, 0xff, 0x0b, 0xf5, 0x0a, 0x92, 0x5c, 0x34, 0x86, 0x6c, 0x9b, 0xd2, 0xa4, 0x63, 0x72, 0xe4, 0x60, 0x82, 0xfb, 0x3b, 0x69, 0x2b, 0x5b, 0x87, 0xc7, 0xb5, 0xdf, 0x0a, 0x33, 0x85, 0xc2, 0xf7, 0x22, 0x1f, 0x27, 0x8e, 0x1c, 0x02, 0x82, 0x12, 0x6d, 0x54, 0x7c, 0xdf, 0x3e, 0x8c, 0x34, 0x80, 0x2f, 0xd0, 0x2f, 0x73, 0x27, 0x04, 0xc8, 0xdc, 0xab, 0x35, 0x24, 0x96, 0x65, 0x0a, 0x4b, 0xf7, 0x79, 0x4a, 0x24, 0x23, 0x8f, 0x6c, 0xb0, 0xeb, 0xd3, 0x87, 0xa4, 0x24, 0x0b, 0x58, 0xa0, 0x94, 0x23, 0x06, 0xdd, 0x29, 0x20, 0xa6, 0x6d, 0xcd, 0xab, 0xe4, 0x04, 0x1a, 0xa9, 0xf4, 0x52, 0x77, 0x66, 0x56, 0x3d, 0xc9, 0x67, 0xf8, 0x12, 0x61, 0xf2, 0xb6, 0x22, 0x79, 0x46, 0x1c, 0x47, 0x7e, 0xc5, 0xdf, 0x7e, 0x0e, 0xf4, 0x95, 0xc0, 0x0c, 0xb0, 0xbb, 0x95, 0xd4, 0x9c, 0x16, 0x2c, 0x24, 0x85, 0x0a, 0xd8, 0x3f, 0xc6, 0xd5, 0x9a, 0x74, 0xe6, 0xfd, 0x9a, 0x9a, 0xf9, 0xd7, 0x37, 0x3c, 0x22, 0xc4, 0xe5, 0x4c, 0x32, 0x2c, 0x87, 0x16, 0x4d, 0x71, 0xf7, 0x8e, 0x5e, 0x3c, 0x17, 0xac, 0x91, 0xaf, 0xda, 0x51, 0x56, 0xa2, 0xef, 0xb4, 0xcd, 0x3f, 0x76, 0x03, 0x6e, 0x7b, 0xe0, 0x7f, 0x9e, 0x7c, 0x0f, 0x7f, 0x9d, 0x1b, 0x42, 0xb0, 0x21, 0x18, 0x33, 0x35, 0xc2, 0xb2, 0x38, 0x06, 0x4a, 0xbf, 0x6f, 0x33, 0x4e, 0xae, 0x9d, 0xe5, 0x11, 0x16, 0xb2, 0xe7, 0x5c, 0x19, 0x17, 0xbf, 0x9d, 0x89, 0xbc, 0x36, 0x40, 0xb0, 0x0d, 0x16, 0x51, 0xcf, 0x2d, 0x6c, 0xcb, 0x53, 0xba, 0x82, 0xed, 0xba, 0x99, 0x6e, 0x08, 0xc4, 0xa8, 0x98, 0xa1, 0x1c, 0xee, 0x2e, 0xb8, 0x24, 0xb9, 0x14, 0xcb, 0xb7, 0x62, 0x5f, 0x29, 0x95, 0x5d, 0x69, 0x25, 0x74, 0x5b, 0x44, 0x69, 0xa4, 0xd9, 0x1e, 0x2a, 0x3c, 0x35, 0xad, 0xd5, 0xb1, 0xd8, 0xc3, 0x35, 0xcc, 0xad, 0x80, 0xf3, 0x2a, 0x7a, 0xcd, 0x41, 0x61, 0x81, 0xc2, 0x44, 0xda, 0x5b, 0x8d, 0x0b, 0xe0, 0x7c, 0x84, 0x8a, 0x77, 0x24, 0xdc, 0xa1, 0x27, 0xd6, 0x92, 0xb7, 0xc1, 0xe1, 0x17, 0xb1, 0xc9, 0xf3, 0x80, 0xa0, 0x21, 0x4b, 0x56, 0x7e, 0x8b, 0xfe, 0xe8, 0x0e, 0x0d, 0x55, 0x02, 0x70, 0x11, 0x96, 0x24, 0xb4, 0x56, 0xe2, 0xe1, 0x7e, 0xc5, 0x11, 0xe4, 0xe1, 0x8e, 0xf5, 0x25, 0xaa, 0x27, 0x60, 0xbb, 0xbe, 0x02, 0x23, 0x55, 0xed, 0x0b, 0xbd, 0x01, 0x4f, 0xed, 0x02, 0x01, 0x72, 0xf6, 0x6d, 0xbe, 0x42, 0x36, 0x99, 0x2b, 0xda, 0xcc, 0x46, 0x06, 0xcc, 0xa2, 0xf7, 0x12, 0x82, 0x7b, 0x1e, 0x3c, 0xa5, 0x82, 0x8e, 0xd2, 0x85, 0x5b, 0x7f, 0x75, 0x47, 0x26, 0x91, 0xac, 0x07, 0x05, 0x10, 0xdc, 0xde, 0x6f, 0x62, 0x8d, 0xef, 0xd0, 0x7d, 0x1a, 0xee, 0x1c, 0x00, 0xd8, 0x59, 0x0d, 0x07, 0x77, 0x86, 0xc2, 0x4b, 0x29, 0x43, 0xae, 0x01, 0xd9, 0x50, 0x65, 0x28, 0x1a, 0x3b, 0x1c, 0x3b, 0x2e, 0x6c, 0x8a, 0x26, 0x9d, 0xa7, 0x1c, 0xea, 0x49, 0xb1, 0x2a, 0x2a, 0x66, 0x6c, 0x1a, 0xb5, 0x1b, 0xb2, 0x2a, 0x2b, 0x34, 0x1c, 0x6e, 0x75, 0xc6, 0xad, 0xb0, 0xb2, 0x65, 0xe1, 0x96, 0x24, 0x8b, 0x6c, 0x69, 0x0a, 0xed, 0xde, 0x03, 0x8f, 0x7e, 0x12, 0x90, 0x73, 0x4a, 0x38, 0x72, 0x86, 0xe7, 0x9f, 0xd4, 0x3e, 0x7e, 0x50, 0xad, 0xd8, 0xa7, 0x04, 0x51, 0x12, 0x34, 0x11, 0x90, 0xda, 0x20, 0x8b, 0xcf, 0x68, 0x80, 0xe5, 0x63, 0x54, 0x78, 0x1f, 0x57, 0xe3, 0x9a, 0x5b, 0xc4, 0x3f, 0x7b, 0x6f, 0x7d, 0x24, 0x34, 0x39, 0xa8, 0x71, 0x96, 0xbd, 0xcc, 0x18, 0x68, 0xc4, 0xed, 0x56, 0xa3, 0x44, 0xc5, 0xca, 0xaa, 0xd4, 0xbf, 0x51, 0xc1, 0x6f, 0xff, 0xa2, 0xb5, 0xca, 0x9c, 0x92, 0xc4, 0x60, 0x10, 0x76, 0x75, 0x37, 0x47, 0x9c, 0x1f, 0xa3, 0xf2, 0xcc, 0xef, 0x0b, 0x96, 0x1b, 0x7e, 0x73, 0x9a, 0x6b, 0xf7, 0x86, 0x9e, 0x7d, 0xff, 0x92, 0x23, 0xb7, 0xd1, 0x24, 0x74, 0x57, 0xd7, 0xac, 0x05, 0xfb, 0x85, 0x72, 0xfe, 0x8d, 0xc3, 0x06, 0x91, 0x04, 0x6f, 0xb6, 0xa7, 0x4a, 0x9a, 0x98, 0x44, 0x12, 0x92, 0x58, 0x6a, 0xc8, 0x9a, 0x0f, 0xb0, 0x5e, 0x56, 0x42, 0xb2, 0x65, 0xdb, 0x23, 0xbc, 0x81, 0x42, 0x1c, 0x29, 0x6e, 0xae, 0x35, 0x58, 0xae, 0x40, 0xbf, 0xce, 0x7f, 0x30, 0x7e, 0xd6, 0xd8, 0x5d, 0x77, 0x02, 0xa6, 0x63, 0xb5, 0xde, 0x1d, 0xda, 0x1c, 0xc3, 0xdb, 0x7d, 0x2c, 0x32, 0x10, 0x63, 0xae, 0xe1, 0x33, 0x85, 0x78, 0xb8, 0x9f, 0xa8, 0x4b, 0xf2, 0xa2, 0x7c, 0xff, 0x51, 0x19, 0x99, 0x6d, 0x45, 0xdc, 0xb0, 0x04, 0xed, 0xc4, 0xe9, 0x13, 0x08, 0xf0, 0xa0, 0x27, 0x7a, 0x51, 0x1d, 0xbc, 0x90, 0xf9, 0xaa, 0xae, 0x89, 0x1e, 0x0a, 0x5d, 0x85, 0x97, 0xc7, 0xf8, 0xaf, 0x26, 0x29, 0x90, 0xe5, 0xf5, 0x95, 0x19, 0xf0, 0x8a, 0xb3, 0x72, 0xb6, 0x54, 0x32, 0x67, 0x5f, 0x1f, 0xc7, 0x1f, 0x57, 0xd0, 0xcb, 0xc7, 0x87, 0x31, 0xd3, 0x2b, 0x34, 0x24, 0x4a, 0x3b, 0x25, 0x16, 0x88, 0xab, 0xf4, 0x7e, 0x12, 0xfb, 0x27, 0x9f, 0xf1, 0x42, 0xce, 0x7f, 0x95, 0x9f, 0xb6, 0x8f, 0xe8, 0xc7, 0x88, 0x2e, 0x96, 0x20, 0x33, 0xdd, 0x4a, 0x16, 0x66, 0x5d, 0x16, 0x2c, 0x84, 0x8c, 0xc7, 0x2b, 0x45, 0xf9, 0x4d, 0x4b, 0x8c, 0x46, 0x04, 0xfc, 0x62, 0xeb, 0x4d, 0xbe, 0x7d, 0x12, 0x38, 0x15, 0x0a, 0xf4, 0x2a, 0x02, 0xf6, 0x3e, 0x7f, 0xf1, 0x7b, 0x89, 0x16, 0xf7, 0xdb, 0xb1, 0xa0, 0x54, 0x12, 0x0a, 0x54, 0x61, 0xfb, 0x7f, 0x66, 0x10, 0xd1, 0xb5, 0x64, 0x5e, 0x38, 0xee, 0xd1, 0xcf, 0x4c, 0xbd, 0x5f, 0x0f, 0xa5, 0x8b, 0x8f, 0xbd, 0x60, 0xe1, 0x37, 0x70, 0xb2, 0x1b, 0xda, 0xc6, 0xdf, 0xfb, 0x34, 0x7b, 0x5e, 0x82, 0xdc, 0x8e, 0xd8, 0x74, 0xed, 0x12, 0xfe, 0x31, 0x3b, 0x80, 0x29, 0x1d, 0x0f, 0xb3, 0xa4, 0x55, 0x4c, 0xa7, 0xa6, 0x97, 0x27, 0xdd, 0x02, 0xbe, 0x44, 0xa7, 0x1a, 0xb1, 0x72, 0x8d, 0x04, 0x43, 0x19, 0x45, 0xb6, 0x26, 0xa6, 0xa0, 0x1b, 0x97, 0x94, 0x6c, 0x30, 0xe3, 0x3c, 0x70, 0x30, 0x16, 0x9f, 0x4c, 0x7f, 0xfb, 0x3f, 0xfe, 0xb1, 0x71, 0xd9, 0xc5, 0x5f, 0xb3, 0x6d, 0x80, 0x8a, 0x63, 0x1b, 0xf9, 0x0a, 0xae, 0x9b, 0x81, 0x50, 0x27, 0xa5, 0xfc, 0x55, 0x3c, 0x83, 0xb7, 0x62, 0x6b, 0x44, 0xcf, 0x13, 0xe9, 0xe7, 0x37, 0xe1, 0x7e, 0x4d, 0x31, 0x35, 0x91, 0xcb, 0x71, 0x1d, 0xd0, 0x40, 0xed, 0xb6, 0xe5, 0xa5, 0x07, 0x0b, 0xa9, 0x6a, 0xfd, 0x74, 0x8d, 0xc8, 0x3e, 0x10, 0x26, 0x79, 0x37, 0x94, 0x5b, 0x53, 0xa0, 0x8c, 0x7e, 0x79, 0x0c, 0x4f, 0xbd, 0x48, 0xac, 0x1f, 0xf3, 0xf0, 0xd1, 0xe5, 0x20, 0xdc, 0x5b, 0xe5, 0x51, 0x5e, 0xf7, 0x79, 0x99, 0x97, 0xe8, 0xb6, 0xab, 0xc6, 0x32, 0x1f, 0x98, 0xf5, 0xac, 0x97, 0x82, 0x37, 0x3e, 0x7d, 0x26, 0x9b, 0xe5, 0x4e, 0xcf, 0x94, 0xc9, 0x02, 0x4e, 0x3f, 0x77, 0x6b, 0xa8, 0x4e, 0x8b, 0x8d, 0xa3, 0xb1, 0xbf, 0xef, 0x8d, 0x27, 0xb6, 0xae, 0x28, 0x4c, 0xe2, 0x3e, 0x7d, 0xd1, 0x06, 0x06, 0x22, 0x25, 0x93, 0x55, 0xcc, 0x67, 0x33, 0xbf, 0x24, 0xf8, 0x11, 0xaf, 0x14, 0x01, 0x35, 0x10, 0x23, 0x8f, 0xed, 0xb1, 0x7d, 0x56, 0x1d, 0xdb, 0xeb, 0x14, 0x79, 0xcd, 0x3b, 0x05, 0xfa, 0x6b, 0x6d, 0x20, 0xe0, 0x1e, 0x98, 0x8f, 0x71, 0x97, 0x5f, 0x55, 0x13, 0xfe, 0xa4, 0x87, 0x7c, 0x44, 0x88, 0xc7, 0x1d, 0x1f, 0xf4, 0x5b, 0x0a, 0x54, 0x7f, 0x65, 0xd2, 0x46, 0xe2, 0xc3, 0x8c, 0x46, 0xa6, 0x36, 0xd9, 0xa5, 0x54, 0x2a, 0xa5, 0xaf, 0x64, 0xea, 0x7c, 0x79, 0x69, 0x35, 0x65, 0x76, 0xae, 0x65, 0xdc, 0x93, 0x44, 0xa1, 0x25, 0x00, 0xb6, 0xdc, 0x8e, 0xdd, 0x9b, 0xe6, 0x73, 0xa4, 0x0a, 0xd6, 0xd0, 0x78, 0x5b, 0x98, 0x42, 0x1b, 0x51, 0xb8, 0x30, 0x54, 0x46, 0x07, 0x80, 0x99, 0xd9, 0xda, 0xf9, 0xe2, 0x46, 0x82, 0xc8, 0x9c, 0x3d, 0xe3, 0x15, 0xa4, 0x89, 0xc1, 0xdd, 0x77, 0x0a, 0x86, 0xcc, 0x17, 0x14, 0x11, 0x5a, 0x5e, 0x69, 0xcc, 0x27, 0x63, 0x01, 0x40, 0x99, 0x2d, 0xd5, 0x13, 0xf7, 0x61, 0xc2, 0x31, 0x23, 0x7d, 0xff, 0xc3, 0x8b, 0x3f, 0xd1, 0xaf, 0xd0, 0x93, 0xbd, 0xf4, 0xcc, 0x18, 0xd3, 0x63, 0x8e, 0x12, 0x5c, 0x82, 0xfe, 0xb6, 0xe7, 0xeb, 0x5d, 0x0a, 0x7f, 0xaf, 0x57, 0x23, 0x3e, 0x6e, 0x89, 0xb8, 0x27, 0x72, 0xc8, 0x96, 0x0b, 0xbe, 0x28, 0xa2, 0xa8, 0xdf, 0xcb, 0x6e, 0xf2, 0xc0, 0xea, 0x1a, 0x0b, 0x36, 0x9b, 0x26, 0x30, 0x4f, 0x6d, 0x65, 0x77, 0xa5, 0xbb, 0xdf, 0x05, 0x14, 0xa8, 0xab, 0xf1, 0x14, 0xf3, 0x6c, 0xc7, 0x03, 0x9b, 0x45, 0xf4, 0x95, 0x00, 0xbb, 0x6e, 0x0c, 0xe9, 0x2a, 0x97, 0xbd, 0x8b, 0x85, 0x68, 0x03, 0x1e, 0x10, 0xc8, 0x45, 0x04, 0x7b, 0x67, 0x90, 0x0c, 0x6a, 0xb6, 0x01, 0x7f, 0x5b, 0x7d, 0x9e, 0x0c, 0x90, 0xee, 0xe8, 0xd1, 0x65, 0x9f, 0x38, 0xa3, 0xf0, 0xb3, 0x32, 0xa9, 0x78, 0xdb, 0xb0, 0x57, 0x4d, 0x2d, 0xf7, 0x99, 0xbe, 0x52, 0x84, 0x32, 0x89, 0xd1, 0x61, 0x13, 0x23, 0xf7, 0xa1, 0x3e, 0x4d, 0x10, 0x47, 0x98, 0x48, 0x3d, 0x32, 0x63, 0x9d, 0x9a, 0x38, 0x3a, 0xaf, 0x1b, 0x49, 0x79, 0xe5, 0xc3, 0xe4, 0x84, 0x45, 0xe9, 0xa9, 0x64, 0x15, 0x7b, 0x11, 0x03, 0xa4, 0x06, 0x92, 0x6a, 0xc4, 0x1d, 0x03, 0xfa, 0xd9, 0xa4, 0x17, 0xab, 0xcb, 0x0e, 0xf2, 0xef, 0xf9, 0xa9, 0x74, 0x8a, 0xd1, 0x62, 0x71, 0xb5, 0x7a, 0x23, 0xa2, 0xd8, 0x2e, 0xe6, 0x04, 0x9b, 0x8e, 0x76, 0xd8, 0xe8, 0xe5, 0x1c, 0x0c, 0x9e, 0x99, 0x7e, 0x95, 0xab, 0xac, 0xe7, 0x63, 0xd3, 0x39, 0x72, 0x88, 0xb7, 0x72, 0x4a, 0x23, 0xe9, 0x73, 0x7f, 0xfd, 0x9d, 0x26, 0x31, 0x88, 0x8d, 0x19, 0xa1, 0xff, 0xe8, 0x6e, 0x65, 0xd0, 0xa6, 0xba, 0xe2, 0x0c, 0xb9, 0x13, 0x9b, 0x35, 0x5d, 0x9b, 0x27, 0xa1, 0x07, 0x7c, 0xd5, 0x34, 0xdf, 0x7d, 0xd3, 0xf2, 0xfd, 0x16, 0x0d, 0x83, 0x73, 0xa7, 0xc6, 0xbc, 0x5a, 0xd1, 0x3f, 0xe0, 0x5c, 0x70, 0x76, 0xdc, 0xa5, 0x1f, 0xa4, 0x2b, 0x3a, 0xc5, 0x4d, 0x11, 0xf7, 0x4d, 0xa4, 0x4a, 0x4d, 0xda, 0x12, 0xbb, 0x29, 0x4c, 0xbd, 0x7f, 0x62, 0x12, 0xe2, 0xe7, 0x47, 0x73, 0xec, 0x44, 0xb7, 0x6f, 0x32, 0xa8, 0x58, 0xf7, 0x09, 0x7b, 0x41, 0xb4, 0x58, 0x4a, 0x2c, 0x65, 0x65, 0xad, 0x0b];

	var GuildProgram =
	/** @class */
	function (_super) {
	  __extends$d(GuildProgram, _super);

	  function GuildProgram(gl, width, height) {
	    return _super.call(this, gl, kernel$1, width, height) || this;
	  }

	  return GuildProgram;
	}(CommonProgramWithParameters);

	var __extends$e = undefined && undefined.__extends || function () {
	  var extendStatics = function (d, b) {
	    extendStatics = setPrototypeOf$2 || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    };

	    return extendStatics(d, b);
	  };

	  return function (d, b) {
	    extendStatics(d, b);

	    function __() {
	      this.constructor = d;
	    }

	    d.prototype = b === null ? create$4(b) : (__.prototype = b.prototype, new __());
	  };
	}();
	var kernel$2 = [0x0b, 0xc4, 0xf2, 0x8b, 0xc6, 0xfc, 0xbc, 0x05, 0x20, 0xa2, 0xab, 0x80, 0x0d, 0xa0, 0x19, 0xde, 0xac, 0x66, 0xcf, 0xf4, 0x9e, 0x45, 0x67, 0x39, 0xef, 0x6f, 0x96, 0x12, 0x9d, 0x52, 0x37, 0xd2, 0x14, 0x83, 0x9c, 0xa5, 0x6c, 0x7a, 0xfe, 0x7d, 0x82, 0xe5, 0x37, 0x6d, 0x71, 0x0b, 0xd2, 0xee, 0xa3, 0xd5, 0x56, 0x74, 0x9c, 0xf8, 0xd7, 0x3f, 0x14, 0x30, 0xad, 0x1f, 0x37, 0x85, 0x12, 0x69, 0x20, 0x10, 0xcc, 0x23, 0x80, 0x26, 0xd4, 0x57, 0xc8, 0x61, 0x72, 0x28, 0x0c, 0xd2, 0xc1, 0xab, 0x3b, 0x21, 0x9e, 0x6c, 0x0e, 0x4b, 0xe4, 0x4a, 0x41, 0x20, 0x39, 0xc0, 0x70, 0x9c, 0xea, 0xfa, 0x8c, 0xbd, 0x28, 0x14, 0x06, 0xe6, 0x87, 0x34, 0x11, 0xc8, 0x7b, 0x44, 0xb7, 0x2c, 0xd7, 0xbb, 0xea, 0x02, 0x0d, 0xa9, 0xea, 0x5e, 0x73, 0x3c, 0x06, 0x6b, 0xe0, 0x76, 0xfe, 0x58, 0x02, 0xeb, 0x86, 0x24, 0x78, 0x05, 0x55, 0x5e, 0x7e, 0xde, 0xdf, 0x65, 0x69, 0xe3, 0x93, 0xc7, 0x40, 0xb9, 0xf6, 0x8f, 0xb7, 0xd2, 0x1e, 0x25, 0x7f, 0xe2, 0x4f, 0x9c, 0x76, 0x93, 0xd0, 0x83, 0x33, 0xf8, 0xe8, 0xd9, 0xce, 0xb5, 0xda, 0x3a, 0x3d, 0x70, 0xf4, 0xe3, 0x44, 0x2d, 0x29, 0xce, 0x45, 0x0c, 0x2d, 0xa3, 0xcd, 0x4b, 0x06, 0x17, 0xa7, 0x91, 0xfa, 0xed, 0x5c, 0x54, 0xa4, 0xf0, 0xfd, 0xd8, 0x36, 0x55, 0x07, 0x6c, 0x3e, 0xff, 0x2a, 0xd9, 0x03, 0x1b, 0x00, 0xc4, 0x5e, 0x1c, 0xf1, 0x78, 0x50, 0x5c, 0x59, 0x87, 0xe4, 0x7d, 0x02, 0x03, 0xf2, 0x27, 0x74, 0x40, 0xf8, 0xd8, 0xb1, 0x7a, 0x42, 0xb2, 0xb4, 0x09, 0x07, 0x21, 0xba, 0xd0, 0xd5, 0xbc, 0x3b, 0x4e, 0xf3, 0x5f, 0x7b, 0x1c, 0x8e, 0x2d, 0x63, 0x82, 0x07, 0xa7, 0xc2, 0x9c, 0xee, 0xc7, 0x0a, 0x47, 0x8d, 0xfb, 0xdd, 0x9e, 0x10, 0xff, 0x26, 0xb5, 0x24, 0xb8, 0x14, 0x88, 0xf0, 0x37, 0x1b, 0x33, 0xbf, 0x52, 0x69, 0x37, 0x61, 0x4e, 0x4a, 0x79, 0xbf, 0xa1, 0x5b, 0x7e, 0x69, 0x67, 0xae, 0x8b, 0xdf, 0x91, 0x96, 0x78, 0x9c, 0xf0, 0xfc, 0xb6, 0x69, 0x68, 0xcd, 0x41, 0x61, 0x81, 0xc2, 0x44, 0xda, 0x5b, 0x8d, 0x0b, 0xe0, 0x7c, 0x84, 0x8a, 0x77, 0x24, 0xc9, 0xd3, 0x27, 0xcb, 0x92, 0xe1, 0xf6, 0xfc, 0x15, 0xa1, 0xfa, 0xbc, 0x89, 0xbe, 0x2a, 0x04, 0x5a, 0x7e, 0xd3, 0xab, 0xf0, 0x71, 0x43, 0x1c, 0x5c, 0x39, 0x4d, 0xc8, 0x7d, 0xe0, 0x13, 0xb2, 0x8e, 0x70, 0xca, 0x05, 0xe9, 0xe5, 0x80, 0xeb, 0x69, 0xef, 0x66, 0x34, 0xb3, 0xe0, 0x57, 0x2d, 0x44, 0xd3, 0x0a, 0xbb, 0x09, 0x26, 0xbe, 0x56, 0x19, 0x2b, 0xaf, 0x38, 0xe7, 0x0b, 0x6c, 0xdc, 0x24, 0x81, 0x83, 0x13, 0x5d, 0xa3, 0xef, 0xa9, 0x76, 0xcd, 0x32, 0x4d, 0x79, 0x8b, 0x8b, 0x8d, 0xc5, 0xaa, 0x14, 0x2c, 0x27, 0x13, 0x61, 0xcd, 0xe4, 0x08, 0x6a, 0x43, 0xd2, 0x87, 0x6f, 0x7f, 0x8d, 0xb9, 0xaf, 0x7b, 0x1a, 0xe2, 0x2a, 0x1d, 0xd9, 0x10, 0x63, 0x09, 0x2e, 0x9d, 0xe8, 0x16, 0x03, 0x69, 0xae, 0x49, 0x90, 0x17, 0x6e, 0x37, 0x54, 0x2e, 0x04, 0x74, 0x27, 0x71, 0xcd, 0x3a, 0x9e, 0xf2, 0x07, 0xd0, 0x4b, 0xa2, 0x37, 0x73, 0x23, 0x34, 0x7c, 0xeb, 0x72, 0xb2, 0x37, 0x2b, 0x62, 0x11, 0x64, 0x21, 0x86, 0xed, 0xbe, 0xe6, 0x3c, 0xb8, 0xc0, 0x68, 0x92, 0x34, 0x3a, 0x4f, 0xae, 0xb4, 0x51, 0x9b, 0x72, 0x00, 0x99, 0x71, 0x5a, 0x33, 0x56, 0x96, 0xfe, 0x88, 0xcd, 0x68, 0x27, 0x0b, 0xbe, 0xbb, 0xe9, 0x50, 0x51, 0x51, 0x38, 0x12, 0xde, 0x94, 0x74, 0x9b, 0x9c, 0x21, 0x84, 0xe2, 0x7f, 0x54, 0x22, 0x53, 0x1c, 0xf9, 0x99, 0x12, 0xc5, 0x0a, 0x74, 0x66, 0x7d, 0x2d, 0x2f, 0x24, 0xeb, 0x2e, 0xd4, 0xa6, 0xd1, 0x03, 0x7d, 0x84, 0xed, 0x7c, 0xa3, 0x44, 0xc5, 0xca, 0xe8, 0x98, 0xea, 0x4b, 0xeb, 0x67, 0xf8, 0xa0, 0xf1, 0xd5, 0x97, 0x90, 0x82, 0x25, 0x17, 0x33, 0x30, 0x37, 0x0c, 0xe3, 0x1f, 0xa3, 0xf2, 0xfb, 0xf5, 0x16, 0x81, 0x4d, 0x14, 0x23, 0x96, 0x14, 0xb5, 0xcb, 0x8a, 0x45, 0xe9, 0xd7, 0x6d, 0xb2, 0xd1, 0x34, 0x55, 0x60, 0xdd, 0xb3, 0x38, 0xf9, 0x8a, 0x6f, 0xfa, 0x8d, 0x86, 0x5f, 0x98, 0x5c, 0x6d, 0xb7, 0xae, 0x68, 0x97, 0x9c, 0x1f, 0x42, 0xd3, 0x0a, 0x39, 0x8d, 0xa7, 0x12, 0xb1, 0x1b, 0x7e, 0x4a, 0xfc, 0x1d, 0x8f, 0x79, 0xad, 0xcb, 0x08, 0x1b, 0x2c, 0x7b, 0x94, 0x39, 0x58, 0xa3, 0x44, 0xe4, 0x9e, 0x3e, 0x62, 0x79, 0xc0, 0xe4, 0x5e, 0x5c, 0x48, 0xf1, 0x21, 0xe6, 0xad, 0x00, 0xc5, 0x01, 0xc2, 0x90, 0x6f, 0x5b, 0x3c, 0x00, 0x6a, 0xb5, 0xcb, 0x33, 0x85, 0x78, 0xfa, 0x9e, 0xb8, 0x5d, 0xd8, 0xb8, 0x7e, 0xfd, 0x15, 0x16, 0x9b, 0x63, 0x50, 0xcd, 0xe3, 0x45, 0xe7, 0x8d, 0xa5, 0x47, 0x46, 0xfc, 0xdf, 0x69, 0x33, 0x5d, 0x16, 0xa5, 0x87, 0xe9, 0xb1, 0xa4, 0x8b, 0x35, 0x05, 0x55, 0x97, 0x86, 0xd6, 0xa5, 0xf9, 0x64, 0x18, 0xba, 0xcf, 0xf5, 0x95, 0x44, 0xda, 0xcc, 0xfc, 0x20, 0xbe, 0x5a, 0x30, 0x4c, 0x39, 0x1f, 0xc9, 0x0f, 0x34, 0x82, 0x87, 0x98, 0xce, 0x3f, 0xc6, 0x64, 0x7e, 0x24, 0x02, 0x68, 0x74, 0x00, 0xa0, 0xa3, 0xba, 0x02, 0x5b, 0xa5, 0x39, 0x95, 0xa3, 0x0c, 0xef, 0x79, 0x98, 0xd1, 0xe0, 0x88, 0xf8, 0x87, 0x88, 0x2e, 0x96, 0x20, 0x33, 0x9a, 0x06, 0x69, 0x00, 0x47, 0x1e, 0x2c, 0xaf, 0x93, 0x8b, 0x22, 0x5b, 0xb8, 0x4e, 0x1f, 0x91, 0x12, 0x03, 0xfa, 0x7a, 0xa6, 0x2f, 0xfc, 0x6d, 0x13, 0x28, 0x0a, 0x7b, 0xa3, 0x63, 0x4c, 0x85, 0x77, 0x25, 0xb4, 0x26, 0xcf, 0x4f, 0xab, 0xb9, 0xbc];

	var MeanProgram =
	/** @class */
	function (_super) {
	  __extends$e(MeanProgram, _super);

	  function MeanProgram(gl, width, height) {
	    return _super.call(this, gl, kernel$2, width, height) || this;
	  }

	  return MeanProgram;
	}(CommonProgramWithParameters);

	var __extends$f = undefined && undefined.__extends || function () {
	  var extendStatics = function (d, b) {
	    extendStatics = setPrototypeOf$2 || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    };

	    return extendStatics(d, b);
	  };

	  return function (d, b) {
	    extendStatics(d, b);

	    function __() {
	      this.constructor = d;
	    }

	    d.prototype = b === null ? create$4(b) : (__.prototype = b.prototype, new __());
	  };
	}();
	var kernel$3 = [0x0b, 0xc4, 0xf2, 0x8b, 0xc6, 0xfc, 0xbc, 0x05, 0x20, 0xa2, 0xab, 0x80, 0x0d, 0xa0, 0x19, 0xde, 0xac, 0x66, 0xcf, 0xf4, 0x9e, 0x45, 0x67, 0x39, 0xef, 0x6f, 0x96, 0x12, 0x9d, 0x52, 0x37, 0xd2, 0x14, 0x83, 0x9c, 0xa0, 0x60, 0x79, 0xff, 0x78, 0xcf, 0xe3, 0x72, 0x78, 0x26, 0x48, 0x95, 0x91, 0xa5, 0xe3, 0x4b, 0x7a, 0x9e, 0xfa, 0xe8, 0x2e, 0x22, 0x34, 0x87, 0x09, 0x1e, 0x90, 0x11, 0x6e, 0x7e, 0x6e, 0x82, 0x47, 0x9c, 0x2e, 0xd2, 0x43, 0xca, 0x33, 0x77, 0x61, 0x03, 0xd3, 0xd6, 0xe3, 0x2d, 0x6d, 0x97, 0x61, 0x15, 0x0a, 0xe5, 0x35, 0x50, 0x1a, 0x33, 0xca, 0x77, 0x80, 0xe6, 0xc5, 0x8c, 0x87, 0x28, 0x0e, 0x58, 0x80, 0xca, 0x5f, 0x15, 0xd0, 0x60, 0x53, 0xb9, 0x62, 0xd8, 0xf2, 0xe0, 0x0f, 0x19, 0xe0, 0xe9, 0x56, 0x60, 0x2e, 0x50, 0x78, 0xdc, 0x30, 0xbb, 0x56, 0x1e, 0xf0, 0x8c, 0x2e, 0x5f, 0x51, 0x30, 0x5a, 0x75, 0x8c, 0xb1, 0x33, 0x6b, 0xeb, 0x9e, 0x89, 0x05, 0xf1, 0xbf, 0x9a, 0x95, 0xdb, 0x1e, 0x7e, 0x55, 0xaf, 0x0a, 0xd8, 0x3f, 0x8b, 0xd8, 0x97, 0x7a, 0xfb, 0xe0, 0xca, 0xdc, 0xe3, 0xdd, 0x35, 0x7a, 0x22, 0xd5, 0xe0, 0x5e, 0x2d, 0x0e, 0xc8, 0x44, 0x1f, 0x3d, 0xaf, 0xd0, 0x11, 0x78, 0x52, 0xf4, 0x8a, 0xd0, 0xa5, 0x15, 0x13, 0xec, 0xe8, 0xb4, 0xd9, 0x32, 0x4a, 0x46, 0x7e, 0x72, 0xe3, 0x3e, 0xc0, 0x7c, 0x09, 0x55, 0x94, 0x21, 0x4d, 0xff, 0x75, 0x4b, 0x66, 0x57, 0x97, 0xff, 0x57, 0x4a, 0x4a, 0xb5, 0x6f, 0x6c, 0x09, 0xf9, 0xdc, 0xae, 0x3b, 0x50, 0xfe, 0xa8, 0x1d, 0x1e, 0x5e, 0xab, 0x85, 0x85, 0xc3, 0x69, 0x40, 0xfe, 0x44, 0x41, 0x12, 0x9e, 0x36, 0x49, 0xcb, 0x41, 0xaf, 0x97, 0xaa, 0xec, 0x8a, 0x11, 0x77, 0x80, 0xed, 0xd6, 0xbd, 0x1c, 0xfa, 0x26, 0x95, 0x61, 0xf2, 0x51, 0xd4, 0xfe, 0x39, 0x12, 0x78, 0x9b, 0x40, 0x60, 0x6c, 0x4b, 0x4e, 0x4a, 0x79, 0xbf, 0xf3, 0x1e, 0x2a, 0x3c, 0x67, 0xa5, 0xc4, 0xa0, 0xc3, 0xd8, 0x63, 0xb6, 0xad, 0xd6, 0xb6, 0x69, 0x35, 0xe7, 0x03, 0x2d, 0xd4, 0x90, 0x65, 0xd9, 0x41, 0x8d, 0x2c, 0xe6, 0x7d, 0x97, 0x9a, 0x7b, 0x39, 0x86, 0xdf, 0x62, 0x85, 0x9c, 0xee, 0x89, 0xb5, 0x50, 0xaf, 0xe6, 0xa7, 0x83, 0xb4, 0x0d, 0x45, 0x4d, 0x2c, 0x9c, 0xa5, 0xfc, 0x0e, 0x1b, 0x55, 0x47, 0x01, 0x52, 0xc4, 0x40, 0xf3, 0x1a, 0xa7, 0x92, 0x62, 0xc9, 0x06, 0xc3, 0xf7, 0xc8, 0xe0, 0x2c, 0xb1, 0x68, 0x6d, 0xbb, 0xe7, 0x53, 0x76, 0x1c, 0x9f, 0x5c, 0xb3, 0x1c, 0x0e, 0xa2, 0x51, 0x54, 0x15, 0xa8, 0x22, 0x9c, 0x15, 0x7f, 0xd7, 0x58, 0xda, 0xd0, 0x0b, 0x5c, 0xa1, 0xef, 0xef, 0x52, 0xdd, 0x3b, 0x56, 0x53, 0xc9, 0xc7, 0xd8, 0x97, 0x8b, 0x17, 0x36, 0x27, 0x34, 0x67, 0xcc, 0xf7, 0x18, 0x66, 0x5e, 0x9d, 0x8a, 0x2a, 0x31, 0x83, 0xb7, 0xd0, 0x32, 0x5f, 0xec, 0x36, 0x06, 0xd3, 0x1a, 0x44, 0x48, 0x38, 0xd4, 0x86, 0x18, 0x5b, 0x72, 0x84, 0x01, 0xd9, 0x50, 0x26, 0x2f, 0x1d, 0x2f, 0x00, 0x6b, 0x66, 0x63, 0x81, 0x21, 0x8c, 0xf3, 0x4a, 0xfb, 0x59, 0xf7, 0x67, 0x0c, 0x72, 0x3a, 0x71, 0xf0, 0x48, 0xbc, 0x27, 0x30, 0x48, 0x59, 0x2d, 0x66, 0xce, 0xf5, 0xf7, 0xe7, 0x38, 0xa7, 0x81, 0x7a, 0xde, 0x2f, 0x28, 0x4e, 0xe3, 0x9f, 0x40, 0xce, 0x22, 0x7f, 0xcb, 0x7f, 0x57, 0x28, 0x6c, 0x98, 0xee, 0x93, 0xe7, 0x2e, 0x68, 0x59, 0xb6, 0xb4, 0xe8, 0x56, 0x59, 0x5b, 0x39, 0x0a, 0xde, 0xca, 0x3b, 0xc7, 0x87, 0x3c, 0xc7, 0xbd, 0x28, 0x54, 0x7d, 0x1c, 0x54, 0xa2, 0xd2, 0x5b, 0x8f, 0x22, 0x6a, 0x75, 0x76, 0x03, 0x7d, 0x7e, 0xed, 0x3c, 0x83, 0xad, 0x99, 0x45, 0x31, 0xd4, 0xcc, 0x75, 0xa3, 0x1f, 0xef, 0xca, 0xe8, 0x98, 0xea, 0x03, 0xa2, 0x20, 0xb0, 0xb8, 0xb8, 0xc4, 0x9a, 0x83, 0x90, 0x73, 0x06, 0x35, 0x7a, 0x37, 0x45, 0xa6, 0x13, 0xe6, 0xb7, 0xaf, 0xf4, 0x01, 0x9c, 0x0b, 0x25, 0x79, 0x86, 0x79, 0x98, 0x8e, 0x9e, 0x7d, 0xe5, 0x96, 0x2c, 0xb7, 0xd8, 0x6d, 0x07, 0x41, 0xde, 0xa9, 0x38, 0xde, 0x8c, 0x6e, 0xe9, 0x9d, 0x8a, 0x42, 0xd0, 0x06, 0x6f, 0xa6, 0xbc, 0x4c, 0xd0, 0xde, 0x04, 0x68, 0xd3, 0x0a, 0x39, 0x8d, 0xf3, 0x41, 0xe4, 0x56, 0x55, 0x58, 0xa9, 0x5b, 0xed, 0x38, 0xf9, 0x85, 0x4d, 0x15, 0x20, 0x25, 0xe6, 0x37, 0x00, 0xb8, 0x6e, 0xe4, 0x9e, 0x3e, 0x62, 0x2d, 0x93, 0xb1, 0x13, 0x77, 0x59, 0xa4, 0x67, 0x84, 0xef, 0x54, 0x8b, 0x44, 0xcc, 0x9d, 0x31, 0x29, 0x32, 0x59, 0x71, 0x9f, 0xcb, 0x33, 0x85, 0x78, 0xb8, 0xd2, 0xed, 0x0f, 0xf9, 0xbb, 0x64, 0xfd, 0x32, 0x10, 0x9a, 0x70, 0x40, 0xc1, 0xfe, 0x0a, 0xeb, 0xc8, 0xfd, 0x54, 0x1f, 0xa9, 0xab, 0x27, 0x7a, 0x46, 0x2e, 0xba, 0x8b, 0xd4, 0xa2, 0xad, 0x9e, 0x29, 0x17, 0x56, 0x94, 0xac, 0xc4, 0xed, 0xf2, 0x3a, 0x66, 0xb4, 0x96, 0xee, 0xbf, 0x19, 0xf0, 0xcc, 0xfc, 0x7d, 0x94, 0x1d, 0x7c, 0x33, 0x5f, 0x0a, 0xc4, 0x37, 0x31, 0x9f, 0x8a, 0x90, 0xff, 0x7e, 0xcd, 0x2b, 0x31, 0x2a, 0x11, 0x3b, 0x3c, 0x4d, 0x8b, 0xb1, 0xef, 0x40, 0x24, 0xe0, 0x62, 0xcd, 0xea, 0x46, 0xc7, 0x67, 0x8b, 0xda, 0xce, 0xcf, 0xb2, 0xd9, 0xff, 0x20, 0x86, 0x3b, 0x19, 0xdd, 0x4a, 0x16, 0x66, 0x52, 0x13, 0x14, 0xaa, 0x8e, 0x86, 0x2a, 0x6a, 0xf9, 0x40, 0x50, 0xde, 0x1c, 0x15, 0xa9, 0x32, 0xeb, 0x04, 0xed, 0x38, 0x51, 0x57, 0x4c, 0x20, 0xfb, 0x2a, 0x06, 0xad, 0x69, 0x36, 0xbf, 0x08, 0x88, 0x05, 0xf5, 0xce, 0xef, 0xb0, 0x09, 0x74, 0x18];

	var Mean2Program =
	/** @class */
	function (_super) {
	  __extends$f(Mean2Program, _super);

	  function Mean2Program(gl, width, height) {
	    return _super.call(this, gl, kernel$3, width, height) || this;
	  }

	  return Mean2Program;
	}(CommonProgramWithParameters);

	var __extends$g = undefined && undefined.__extends || function () {
	  var extendStatics = function (d, b) {
	    extendStatics = setPrototypeOf$2 || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    };

	    return extendStatics(d, b);
	  };

	  return function (d, b) {
	    extendStatics(d, b);

	    function __() {
	      this.constructor = d;
	    }

	    d.prototype = b === null ? create$4(b) : (__.prototype = b.prototype, new __());
	  };
	}();
	var kernel$4 = [0x0b, 0xc4, 0xf2, 0x8b, 0xc6, 0xfc, 0xbc, 0x05, 0x20, 0xa2, 0xab, 0x80, 0x0d, 0xa0, 0x19, 0xde, 0xac, 0x66, 0xcf, 0xf4, 0x9e, 0x45, 0x67, 0x39, 0xef, 0x6f, 0x96, 0x12, 0x9d, 0x52, 0x37, 0xd2, 0x14, 0x83, 0x9c, 0xbe, 0x64, 0x70, 0xe6, 0x61, 0xc7, 0xe1, 0x60, 0x4a, 0x63, 0x5e, 0xf8, 0xde, 0xa2, 0xd5, 0x5f, 0x7a, 0x9e, 0xd4, 0xe9, 0x2a, 0x16, 0x25, 0xd9, 0x73, 0x24, 0x98, 0x1e, 0x7b, 0x74, 0x68, 0xd4, 0x6d, 0x81, 0x29, 0xdc, 0x4d, 0xd5, 0x61, 0x7c, 0x2d, 0x04, 0xdb, 0xc5, 0xab, 0x28, 0x12, 0x95, 0x68, 0x14, 0x04, 0xf8, 0x66, 0x40, 0x09, 0x32, 0xd9, 0x7c, 0x83, 0xb4, 0xbc, 0x9f, 0xaa, 0x3f, 0x01, 0x54, 0x82, 0x96, 0x75, 0x0e, 0xd4, 0x76, 0x43, 0xa5, 0x61, 0xcf, 0xf2, 0xfb, 0x0f, 0x1e, 0xbb, 0xbc, 0x4d, 0x4f, 0x7a, 0x43, 0x65, 0xfc, 0x6d, 0xf4, 0x52, 0x25, 0xbf, 0xe3, 0x23, 0x72, 0x57, 0x39, 0x47, 0x63, 0xda, 0x9b, 0x36, 0x65, 0xef, 0x8a, 0xc5, 0x0d, 0xe2, 0xe4, 0xb0, 0x9d, 0x9e, 0x57, 0x62, 0x37, 0xfb, 0x4f, 0x96, 0x40, 0x8a, 0xc8, 0x87, 0x28, 0x84, 0x87, 0xcf, 0x92, 0xfc, 0xde, 0x39, 0x3a, 0x6f, 0x97, 0xe1, 0x4e, 0x3b, 0x24, 0xd2, 0x46, 0x1d, 0x79, 0xa0, 0xd2, 0x1f, 0x6d, 0x43, 0xa7, 0xc2, 0xb1, 0xec, 0x5b, 0x6c, 0xa4, 0xe5, 0x82, 0xd3, 0x3b, 0x42, 0x5d, 0x12, 0x6b, 0xe2, 0x36, 0xd2, 0x33, 0x08, 0x4d, 0xd9, 0x13, 0x49, 0xbb, 0x21, 0x1e, 0x3b, 0x09, 0x87, 0xa2, 0x31, 0x05, 0x0b, 0xe1, 0x6f, 0x77, 0x0b, 0xf7, 0xda, 0x81, 0x73, 0x53, 0xcd, 0xaa, 0x15, 0x04, 0x45, 0xd2, 0x85, 0x86, 0xf5, 0x6d, 0x0f, 0xb1, 0x09, 0x51, 0x51, 0xcb, 0x69, 0x2a, 0x9e, 0x0c, 0xff, 0x97, 0xa5, 0xe6, 0xcd, 0x05, 0x5c, 0xc4, 0xfb, 0xd3, 0xbb, 0x1b, 0xd6, 0x2b, 0xba, 0x5b, 0xe9, 0x55, 0xc0, 0xe5, 0x0f, 0x47, 0x26, 0xdc, 0x14, 0x26, 0x65, 0x2c, 0x4e, 0x07, 0x3c, 0xfb, 0xba, 0x4b, 0x67, 0x6c, 0x35, 0xa6, 0xdc, 0xba, 0xd0, 0xc2, 0x78, 0xcf, 0xe6, 0x9f, 0xf8, 0x16, 0x20, 0x8e, 0x7c, 0x60, 0x9d, 0xde, 0x3c, 0xbf, 0x41, 0x91, 0x06, 0xef, 0x7d, 0x97, 0x93, 0x32, 0x3a, 0x82, 0xcf, 0x6e, 0x83, 0xdf, 0xe7, 0x89, 0xee, 0x1c, 0xb6, 0xd8, 0xa7, 0xc6, 0xbf, 0x25, 0x43, 0x4c, 0x01, 0x90, 0xe8, 0xda, 0x4f, 0x48, 0x1c, 0x41, 0x65, 0x2b, 0xd8, 0x40, 0xfd, 0x10, 0xad, 0xb3, 0x7b, 0x8c, 0x1b, 0xe9, 0xf5, 0xc7, 0xe6, 0x24, 0xb5, 0x66, 0x72, 0xf7, 0xa2, 0x12, 0x22, 0x14, 0xd4, 0x19, 0xab, 0x18, 0x1c, 0x8f, 0x50, 0x5e, 0x28, 0xa7, 0x22, 0xd1, 0x3d, 0x75, 0x82, 0x01, 0xc6, 0xc4, 0x07, 0x15, 0xfc, 0xb4, 0xff, 0x5c, 0x80, 0x77, 0x09, 0x30, 0x9c, 0x8a, 0x88, 0x97, 0x8f, 0x17, 0x2c, 0x34, 0x03, 0x28, 0xc5, 0xe4, 0x1f, 0x7b, 0x43, 0xa3, 0x8c, 0x20, 0x36, 0xcc, 0xbb, 0x95, 0x50, 0x13, 0xff, 0x52, 0x78, 0xc3, 0x0c, 0x6e, 0x41, 0x38, 0xd4, 0x8f, 0x16, 0x4e, 0x2c, 0xea, 0x48, 0x8c, 0x1d, 0x76, 0x67, 0x12, 0x24, 0x07, 0x7a, 0x32, 0x25, 0x8b, 0x2f, 0x8e, 0xf3, 0x19, 0xd0, 0x58, 0xed, 0x7e, 0x32, 0x67, 0x7f, 0x13, 0xb7, 0x1d, 0xa9, 0x1d, 0x01, 0x37, 0x17, 0x64, 0x20, 0x81, 0xef, 0xf3, 0xa0, 0x3d, 0xb2, 0xc5, 0x75, 0xc7, 0x2d, 0x39, 0x1a, 0xa5, 0x87, 0x5c, 0xda, 0x3b, 0x00, 0xc5, 0x36, 0x0d, 0x60, 0x28, 0x8d, 0xd4, 0xdd, 0x83, 0x67, 0x2e, 0x16, 0xe4, 0xbf, 0xa7, 0x49, 0x14, 0x56, 0x3e, 0x0b, 0x93, 0xd9, 0x74, 0xcd, 0xcb, 0x6e, 0x86, 0xf9, 0x33, 0x06, 0x7b, 0x17, 0x56, 0xe7, 0x9d, 0x08, 0x90, 0x53, 0x7e, 0x73, 0x76, 0x23, 0x60, 0x24, 0xe5, 0x24, 0xdc, 0xe4, 0x8f, 0x47, 0x2d, 0xdf, 0x81, 0x30, 0xec, 0x05, 0x91, 0xca, 0xbc, 0xd0, 0xb8, 0x46, 0xf1, 0x68, 0xff, 0xbc, 0xb5, 0x92, 0xd2, 0xce, 0x90, 0x35, 0x4d, 0x65, 0x78, 0x26, 0x08, 0xf5, 0x50, 0xe6, 0xa5, 0xa0, 0xb7, 0x53, 0xca, 0x4f, 0x7f, 0x39, 0xd6, 0x7e, 0xf2, 0x96, 0xd0, 0x28, 0xef, 0x94, 0x23, 0xa3, 0xc9, 0x61, 0x4a, 0x46, 0xd6, 0xb5, 0x3f, 0xf0, 0x93, 0x21, 0xfd, 0x95, 0x8c, 0x4d, 0xc5, 0x52, 0x7e, 0xbd, 0xe7, 0x07, 0xc4, 0xd4, 0x50, 0x0e, 0x97, 0x18, 0x39, 0x90, 0xf3, 0x51, 0xea, 0x42, 0x18, 0x13, 0xec, 0x02, 0x89, 0x79, 0xf6, 0x81, 0x41, 0x07, 0x63, 0x6e, 0xae, 0x36, 0x4a, 0xb6, 0x51, 0xea, 0x8e, 0x25, 0x48, 0x6e, 0xdc, 0xff, 0x40, 0x77, 0x0a, 0xbc, 0x6f, 0xbf, 0xe4, 0x01, 0xcd, 0x09, 0xcc, 0x8f, 0x38, 0x3e, 0x7d, 0x54, 0x6a, 0xe1, 0x83, 0x61, 0xc0, 0x2b, 0xf0, 0x9d, 0xa1, 0x4b, 0xa8, 0xf7, 0x2c, 0xaf, 0x41, 0x51, 0xc0, 0x30, 0x15, 0x9d, 0xa7, 0x50, 0xbf, 0x82, 0xa1, 0x4b, 0x55, 0xba, 0xae, 0x2a, 0x75, 0x01, 0x44, 0xfc, 0xcc, 0x8a, 0xfe, 0xcb, 0x98, 0x15, 0x0d, 0x40, 0x90, 0xc3, 0xcf, 0xee, 0xe5, 0x36, 0x67, 0xf7, 0x9f, 0xf5, 0xd3, 0x55, 0xbf, 0x8d, 0xa8, 0x20, 0xea, 0x55, 0x2e, 0x76, 0x0c, 0x05, 0xc7, 0x04, 0x13, 0xd9, 0xcb, 0xca, 0x9c, 0x21, 0x8f, 0x72, 0x74, 0x3c, 0x42, 0x28, 0x3a, 0x4d, 0xd0, 0xed, 0xab, 0x1a, 0x48, 0xaf, 0x72, 0xcd, 0xf8, 0x57, 0x89, 0x3e, 0xd2, 0x8f, 0x97, 0xc5, 0xa7, 0xd2, 0xf1, 0x7a, 0x96, 0x68, 0x7a, 0x9a, 0x02, 0x46, 0x66, 0x53, 0x13, 0x24, 0x8d, 0x88, 0xc7, 0x2a, 0x4f, 0xe5, 0x47, 0x56, 0xc2, 0x6d, 0x1f, 0xec, 0x50, 0xa6, 0x11, 0xe6, 0x6d, 0x01, 0x28, 0x1c, 0x2e, 0xe0, 0x38, 0x14, 0xe6, 0x2f, 0x64, 0xfe, 0x74, 0xd0, 0x4c, 0xa9, 0x9d, 0xf1, 0xaf, 0x03, 0x46, 0x55, 0x1f, 0x26, 0xf5, 0x3a, 0x21, 0x50, 0x91, 0xed, 0x08, 0x16, 0x47, 0xe0, 0x9e, 0x9c, 0x1f, 0xf9, 0x51, 0x57, 0xf7, 0xe6, 0xc7, 0xed, 0x60, 0xa7, 0x7b, 0x3f, 0xf3, 0x4f, 0x9c, 0xce, 0xcb, 0xa0, 0x36, 0x7c, 0x44, 0xfd, 0xd7, 0x84, 0xeb, 0x39, 0xb9, 0x5c, 0xee, 0x37, 0x3b, 0xd2, 0x68, 0x47, 0x1a, 0xb7, 0xb4, 0x47, 0x0c, 0xff, 0xe0, 0xc0, 0x41, 0x9a, 0x48, 0xf4, 0x08, 0xa4, 0x0a, 0xf8, 0x2e, 0xcf, 0x1e, 0x5c, 0x01, 0x50, 0xf4, 0x1f, 0xbd, 0x8a, 0x58, 0xd8, 0xda, 0x3f, 0x64, 0xe3, 0x74, 0x39, 0x77, 0x5e, 0x87, 0x05, 0x7e, 0xff, 0x20, 0xbf, 0xa3, 0x3d, 0xd1, 0xc2, 0x58, 0xf8, 0x70, 0x8b, 0xad, 0x2b, 0x45, 0x86, 0x03, 0xa0, 0x97, 0x89, 0x19, 0x62, 0xef, 0xa6, 0x13, 0x7b, 0xd0, 0xb4, 0x1f, 0x78, 0x1e, 0xbf, 0x4b, 0xb7, 0xb3, 0x7e, 0xb4, 0x7d, 0x5c, 0x6b, 0x69, 0xce, 0x8a, 0x1c, 0x43, 0x8b, 0x03, 0xbc, 0xe6, 0xb8, 0xff, 0x79, 0x0d, 0xb5, 0x2d, 0xa0, 0x72, 0xca, 0xc2, 0x7b, 0x57, 0x37, 0x7c, 0x61, 0xa4, 0x52, 0x5f, 0xe8, 0xd8, 0x75, 0x3e, 0x05, 0x5a, 0xb0, 0x52, 0xa7, 0x34, 0xa0, 0x99, 0xae, 0xa8, 0x69, 0x92, 0x5b, 0xf8, 0x51, 0x4f, 0xf9, 0x61, 0x8a, 0x85, 0xaa, 0xf5, 0xe5, 0x84, 0x3d, 0x05, 0x95, 0xe0, 0xf6, 0xc2, 0xd5, 0x3d, 0x0c, 0x6d, 0x2c, 0x88, 0xeb, 0x5f, 0xdb, 0x85, 0xdc, 0x1b, 0x5d, 0x24, 0x5d, 0x7c, 0xb4, 0x51, 0x8d, 0x98, 0xdc, 0xaa, 0xa3, 0xe5, 0xc5, 0x7c, 0xab, 0xe8, 0x30, 0x46, 0xfb, 0x6a, 0x77, 0x96, 0x14, 0x10, 0x31, 0x77, 0xf7, 0x2a, 0x84, 0x24, 0x4c, 0xfe, 0x7c, 0xb1, 0x42, 0xaf, 0x09, 0x01, 0x27, 0x5c, 0x7f, 0xc3, 0xab, 0xc6, 0x22, 0x02, 0x40, 0x90, 0xb3, 0x48, 0x28, 0x97, 0x6e, 0x59, 0xe5, 0x2a, 0x7d, 0x21, 0xee, 0x10, 0xdc, 0xe4, 0x33, 0xcb, 0x08, 0x01, 0x44, 0x91, 0xfd, 0x85, 0x76, 0x5d, 0xa3, 0x81, 0x16, 0x0d, 0xf8, 0x41, 0x0c, 0x04, 0x3f, 0x65, 0xd2, 0x46, 0xaa, 0x8a, 0xcb, 0x0e, 0xf6, 0x36, 0xc2, 0xc3, 0x1b, 0x6b, 0xf1, 0xaf, 0x23, 0xab, 0x31, 0x34, 0x6a, 0x79, 0x2d, 0x24, 0x98, 0x55, 0xd7, 0x84, 0x4e, 0xa7, 0x22, 0x12, 0xa7, 0xf5, 0x98, 0x85, 0x86, 0xaa, 0x78, 0xb6, 0x0a, 0x92, 0xbf, 0x25, 0x02, 0xcd, 0x2f, 0x7d, 0x14, 0xcb, 0x2c, 0x58, 0x51, 0x20, 0x96, 0xdf, 0xdc, 0xda, 0xee, 0xfe, 0x1e, 0xd4, 0xa7, 0xdd, 0x73, 0x9c, 0x52, 0xe2, 0x89, 0xdc, 0xdd, 0x61, 0x03, 0x8b, 0xca, 0x21, 0x09, 0x1b, 0x1a, 0x7e, 0x28, 0xd7, 0x19, 0x7e, 0x09, 0x52, 0xd0, 0x31, 0xd9, 0x0e, 0xa1, 0x51, 0xc4, 0x3d, 0x3c, 0x57, 0xfe, 0xd5, 0xc2, 0x51, 0xd8, 0xa1, 0x97, 0xd1, 0xa6, 0xde, 0xe6, 0x18, 0x80, 0x75, 0x8c, 0x5c, 0x04, 0xcb, 0xfe, 0xaa, 0xfd, 0xf9, 0x58, 0x5a, 0x70, 0xe2, 0x12, 0x2c, 0x7a, 0x27, 0x9e, 0x9e, 0x38, 0x45, 0xcc, 0x9f, 0x05, 0xb3, 0x33, 0xc5, 0xe9, 0x8b, 0xd8, 0x66, 0xe2, 0xce, 0xf8, 0x0f, 0x4e, 0x70, 0xd6, 0x7e, 0x43, 0x1c, 0x28, 0x26, 0x62, 0xbe, 0xb2, 0xce, 0x43, 0x5e, 0xf5, 0xfe, 0xa0, 0x65, 0xb0, 0x20, 0x9d, 0x1a, 0x84, 0x53, 0xfc, 0xe4, 0x57, 0xf2, 0x20, 0x7f, 0xa0, 0x70, 0xd2, 0xe0, 0x85, 0x95, 0x73, 0x29, 0x1e, 0x10, 0xc8, 0x45, 0x59, 0x51, 0x4d, 0x90, 0x0c, 0x6a, 0xb6, 0x49, 0x36, 0x1c, 0x35, 0xc3, 0x1c, 0xd8, 0xb3, 0xb3, 0x88, 0x23, 0x8d, 0x66, 0xea, 0xb1, 0xf0, 0x22, 0xba, 0x6a, 0x91, 0xf5, 0x03, 0x54, 0x30, 0xfb, 0x9d, 0xf5, 0x0b, 0xd9, 0x6f, 0xe3, 0x8a, 0x2a, 0x43, 0x72, 0xd3, 0xb1, 0x25, 0x67, 0x10, 0x47, 0x98, 0x48, 0x75, 0x7b, 0x24, 0xd5, 0xca, 0x38, 0x7c, 0xe3, 0x54, 0x08, 0x2d, 0xe5, 0x95, 0xa5, 0xd6, 0x45, 0xf4, 0xa9, 0x37, 0x44, 0x3e, 0x5e, 0x68, 0xe4, 0x4a, 0xcd, 0x7b, 0xde, 0x11, 0x07, 0xac, 0x9e, 0xe3, 0x4a, 0xce, 0x95, 0x43, 0xaf, 0xab, 0xfb, 0xb9, 0x79, 0x97, 0xdf, 0x3f, 0x23, 0xe5, 0x20, 0x31, 0xbe, 0xd1, 0x78, 0x89, 0x45, 0xd5, 0xd6, 0x13, 0x96, 0xbb, 0xb1, 0x1c, 0x0c, 0x9e, 0x99, 0x7e, 0x95, 0xab, 0xa7, 0xea, 0x78, 0x81, 0x6d, 0x20, 0x9d, 0xb4, 0x4b, 0x42, 0x38, 0xe9, 0x73, 0x7f, 0xe6, 0x9d, 0x20, 0x22, 0x8f, 0x9c, 0x1f, 0xe6, 0xa8, 0xae, 0x7d, 0x76, 0xc3, 0xf9, 0xf3, 0xa5, 0x51, 0xf6, 0x0a, 0x90, 0x0f, 0x67, 0x8b, 0x37, 0xad, 0x07, 0x3b, 0x88, 0x45, 0xac, 0x36, 0x84, 0xa5, 0x8c, 0x4e, 0x4d, 0xe6, 0x21, 0xa9, 0x81, 0xbc, 0x47, 0xd1, 0x6d, 0xa1, 0x08, 0x39, 0x39, 0xc7, 0x8f, 0x1f, 0xa4, 0x2b, 0x3a, 0x82, 0x01, 0x6e, 0x91, 0x1f, 0xe5, 0x0d, 0x2e, 0x95, 0x5e, 0xf4, 0x6a, 0x4c, 0xee, 0x69, 0x6b, 0x01, 0xb7, 0xb1, 0x0a, 0x3d, 0xe1, 0x5e, 0xb9, 0x74, 0x3a, 0xb7, 0x5f, 0xe1, 0x16, 0x77, 0x13, 0xf8, 0x1c, 0x0d, 0x7b, 0x7d, 0x6c, 0x9e, 0x40, 0xb8, 0x4d, 0xf5, 0x99, 0xa2, 0xd9, 0xe3, 0xd0, 0x29, 0xb9, 0xd3, 0xeb, 0x29, 0x99, 0xb5, 0x36, 0xa6, 0xa5, 0x0b, 0x9a, 0x37, 0x15, 0xb8, 0xd1, 0xc0, 0xf9, 0x2c, 0xa4, 0xa0, 0x1d, 0xe5, 0x9f, 0x52, 0x9c, 0xc6, 0xf1, 0xb7, 0x72, 0x53, 0x89, 0xba, 0x97, 0x94, 0x1f, 0x15, 0xc5, 0xd8, 0x91, 0x20, 0x0d, 0x32, 0x16, 0xf1, 0x89, 0x27, 0x47, 0x1c, 0x8e, 0xa0, 0xd7, 0x6b, 0xdd, 0x2d, 0xca, 0x68, 0xe3, 0x6e, 0xba, 0x0c, 0x96, 0x91, 0xf0, 0x33, 0x31, 0x2c, 0xc4, 0x73, 0xe0, 0xee, 0x95, 0xbd, 0x86, 0x63, 0x43, 0xf1, 0x3e, 0x9d, 0xf0, 0x72, 0xf7, 0xc3, 0x1a, 0xc8, 0x8d, 0x61, 0x93, 0xf9, 0x17, 0x96, 0xae, 0x0a, 0x0d, 0xdb, 0x51, 0x49, 0x3a, 0xf2, 0x60, 0xfa, 0xf3, 0x0f, 0x31, 0xda, 0x3a, 0xe6, 0x68, 0xfc, 0xaf, 0x96, 0x7b, 0x56, 0xb9, 0x54, 0x5a, 0xc6, 0x06, 0x24, 0x00, 0x63, 0x48, 0x1c, 0xa6, 0xee, 0x73, 0xe7, 0xab, 0xf9, 0xb3, 0x47, 0xae, 0x44, 0x9c, 0xe3, 0x11, 0xc6, 0x4f, 0x49, 0x8e, 0x63, 0x90, 0x14, 0x50, 0x3e, 0x50, 0xbf, 0x8e, 0x2e, 0x47, 0x09, 0xf3, 0x06, 0x08, 0xd6, 0x74, 0x48, 0xbe, 0x6a, 0xa1, 0x13, 0xb9, 0x64, 0x09, 0xbb, 0x40, 0x5e, 0x56, 0xcb, 0xae, 0x9c, 0xf5, 0xde, 0x5f, 0x36, 0x1e, 0x94, 0x13, 0x0b, 0x32, 0x70, 0x60, 0x3d, 0xed, 0x9f, 0xad, 0x07, 0x9a, 0x7f, 0xaf, 0x4f, 0x30, 0x61, 0x59, 0x4e, 0x7e, 0x42, 0xab, 0xcc, 0x9e, 0xc3, 0x1b, 0xe2, 0xcd, 0xde, 0x9d, 0x59, 0xfb, 0x5a, 0x7d, 0x25, 0xd4, 0x1b, 0x61, 0x03, 0x8d, 0xf7, 0xaf, 0x32, 0x79, 0x07, 0xbb, 0x44, 0xc4, 0xb5, 0xca, 0xa7, 0xbd, 0x39, 0x54, 0x51, 0xde, 0x17, 0x1b, 0x54, 0x82, 0xb0, 0x62, 0x42, 0xf0, 0xcf, 0x12, 0x17, 0x1c, 0xa3, 0xa3, 0xc2, 0x2d, 0x25, 0x81, 0xca, 0xaa, 0x61, 0xbd, 0x00, 0x51, 0xee, 0x00, 0x27, 0xc7, 0xa3, 0x23, 0xd3, 0xce, 0xf7, 0x41, 0x1d, 0x74, 0xf2, 0x43, 0x66, 0xeb, 0x0d, 0x88, 0xe8, 0xe6, 0x72, 0x92, 0xbb, 0x07, 0xfe, 0x8e, 0x1a, 0x79, 0x10, 0xed, 0x05, 0xa0, 0xc9, 0x72, 0x5e, 0xb2, 0xc7, 0x5f, 0xd4, 0xf1, 0x2d, 0x70, 0xb4, 0xbc, 0x48, 0x56, 0x72, 0xbd, 0x9b, 0x95, 0x95, 0xa3, 0xd2, 0x70, 0x65, 0x0c, 0x45, 0xe1, 0x4b, 0xca, 0xdf, 0x1c, 0xf2, 0x5a, 0xd7, 0x9c, 0xa9, 0xe0, 0xf5, 0x87, 0x80, 0x5c, 0x94, 0xd9, 0x83, 0xd0, 0xff, 0x19, 0x87, 0x75, 0x88, 0x05, 0x68, 0xb9, 0xf9, 0xa1, 0xe4, 0xd6, 0x10, 0x69, 0xcc, 0x09, 0xb6, 0x87, 0x99, 0xdc, 0x65, 0xf4, 0xa0, 0xcf, 0x3a, 0xb6, 0x76, 0xb9, 0xf0, 0x39, 0xf5, 0x7b, 0x0d, 0x70, 0xb6, 0x6a, 0xe5, 0xdc, 0x5a, 0x1d, 0x56, 0xd7, 0x60, 0x93, 0xe8, 0x02, 0x37, 0x83, 0xe1, 0x89, 0x44, 0xf5, 0x59, 0x8d, 0xfc, 0x61, 0x03, 0x81, 0x9b, 0xd8, 0xdf, 0x62, 0x74, 0x2d, 0x4e, 0x55, 0x8d, 0xa1, 0x4a, 0xd7, 0x07, 0x96, 0xab, 0xe1, 0x3b, 0x4e, 0xdd, 0x98, 0xec, 0x0e, 0x75, 0x64, 0xd0, 0x9e, 0x56, 0x0d, 0xb9, 0x7c, 0x57, 0x9d, 0x6f, 0x28, 0xbb, 0xb6, 0x7c, 0xad, 0x47, 0xad, 0x17, 0xc7, 0x34, 0x9b, 0xbe, 0x86, 0x0b, 0x17, 0x40, 0x19, 0xd7, 0x27, 0x73, 0xe7, 0xad, 0x4d, 0x48, 0x72, 0x36, 0xfc, 0x74, 0xb2, 0x3b, 0xdd, 0x6a, 0xf1, 0x77, 0xfe, 0x1e, 0xe2, 0xf1, 0xcc, 0xe9, 0x71, 0xc5, 0x60, 0x92, 0x00, 0x29, 0x43, 0x03, 0xe7, 0x7e, 0x0c, 0xda, 0xca, 0x16, 0xab, 0x72, 0xf9, 0xb0, 0x86, 0xa0, 0x13, 0xd8, 0x1f, 0xe5, 0x76, 0xe2, 0x3e, 0xf2, 0x7e, 0x7e, 0x2a, 0x7f, 0x82, 0x44, 0xda, 0xda, 0x51, 0xca, 0x6a, 0xd9, 0xbf, 0x19, 0xb1, 0x52, 0x61, 0x51, 0x24, 0xe8, 0x89, 0x3a, 0x5a, 0xd8, 0xbe, 0x75, 0xeb, 0x14, 0xc2, 0x90, 0x4c, 0xb2, 0x1b, 0xd5, 0x0d, 0xd0, 0x12, 0x1d, 0x76, 0x7e, 0x31, 0x62, 0xcb, 0xb3, 0x80, 0xed, 0x64, 0x20, 0xf2, 0xbd, 0xd4, 0x06, 0xd2, 0xd2, 0xbc, 0xa1, 0xcd, 0x0d, 0x7c, 0x77, 0x0d, 0xd7, 0x70, 0x29, 0xb7, 0xb0, 0xd7, 0xa8, 0xd2, 0xb6, 0x6f, 0x01, 0x73, 0x02, 0xef, 0x8d, 0x08, 0xb1, 0x7c, 0x70, 0x30, 0xc5, 0x02, 0xef, 0x0b, 0x63, 0x04, 0x24, 0x4d, 0x45, 0x2f, 0xf4, 0x13, 0x99, 0x3d, 0x13, 0x02, 0x60, 0xb0, 0x07, 0x70, 0x7a, 0x83, 0xa9, 0x19, 0xbd, 0x74, 0xab, 0x31, 0x0c, 0x79, 0xa2, 0x4f, 0x9a, 0x4a, 0xfb, 0x32, 0xe9, 0xb6, 0x3f, 0xb4, 0xe0, 0x76, 0x31, 0xfd, 0x15, 0x14, 0x10, 0x1f, 0x90, 0xb8, 0x5d, 0xae, 0xe7, 0xf4, 0xb7, 0x0d, 0x31, 0xe1, 0xbd, 0xd3, 0x49, 0xb9, 0x31, 0x6e, 0x8e, 0x19, 0xe2, 0x2d, 0xb0, 0xe9, 0xcc, 0x4a, 0x21, 0x10, 0xcd, 0x58, 0x83, 0x5c, 0x9d, 0xaa, 0xaf, 0x44, 0xaa, 0x3d, 0x35, 0x74, 0xa5, 0x10, 0x1b, 0xb6, 0xa0, 0xb5, 0x57, 0xf1, 0x0f, 0x97, 0x55, 0x6b, 0x4c, 0xa7, 0x81, 0x19, 0xac, 0x7f, 0xb8, 0x8a, 0x99, 0xde, 0xe4, 0x7d, 0x40, 0x2c, 0x2d, 0x20, 0x0c, 0xe3, 0x94, 0x6a, 0x98, 0x53, 0xf0, 0xa6, 0x36, 0xeb, 0x20, 0xbe, 0x0c, 0xf2, 0xa4, 0x7b, 0xbd, 0x35, 0xc2, 0x8d, 0x68, 0x2b, 0xca, 0x6e, 0x04, 0xa8, 0x77, 0xf5, 0xe8, 0xb3, 0xb2, 0xc6, 0x01, 0xe0, 0x57, 0x56, 0xa0, 0x1f, 0x13, 0x8c, 0xe9, 0x66, 0xbf, 0xcc, 0x04, 0x62, 0x8a, 0xa3, 0xbf, 0x6a, 0x18, 0xd5, 0x2f, 0xd0, 0x52, 0x89, 0x84, 0x83, 0x10, 0xfd, 0x54, 0x19, 0x90, 0x5a, 0x9f, 0x94, 0x10, 0xc4, 0x54, 0xa6, 0x3d, 0xa0, 0x65, 0xe5, 0xe3, 0x5d, 0x76, 0x3b, 0x57, 0x42, 0x10, 0x80, 0x3b, 0x60, 0x83, 0xfa, 0x14, 0xb8, 0x96, 0xcd, 0x5b, 0xe3, 0xc9, 0x3e, 0x23, 0x4f, 0xb4, 0xac, 0xad, 0x55, 0xc5, 0x6a, 0x99, 0xee, 0xe5, 0x3c, 0xcc, 0x41, 0xc1, 0xe6, 0x5e, 0x65, 0xb1, 0x86, 0x06, 0xa5, 0x35, 0xab, 0x8e, 0xd0, 0x9b, 0x02, 0x0b, 0x04, 0xca, 0x7f, 0x36, 0x11, 0x8e, 0x75, 0xe3, 0x79, 0x80, 0xcc, 0xc0, 0x93, 0x93, 0x5c, 0xbd, 0x05, 0xe0, 0x94, 0x48, 0x12, 0x53, 0x65, 0x7e, 0x7c, 0xe4, 0x99, 0xf2, 0x7b, 0xe5, 0xf7, 0x5c, 0xdd, 0x06, 0x49, 0xe3, 0xfa, 0x57, 0xa7, 0xc2, 0x81, 0xbb, 0x49, 0x26, 0xb9, 0x6d, 0xd9, 0xf0, 0xc1, 0x58, 0x32, 0xb2, 0xb4, 0x97, 0x36, 0xc5, 0xbb, 0x89, 0xbe, 0xa6, 0xe9, 0x01, 0x67, 0xcc, 0x58, 0x1f, 0x7f, 0xb9, 0x1d, 0x41, 0x01, 0x1d, 0xfe, 0xdf, 0x0e, 0x53, 0xa7, 0xd7, 0x72, 0xf8, 0x1e, 0xad, 0x59, 0xad, 0xbb, 0x45, 0x05, 0x69, 0x75, 0x0f, 0x6a, 0x5e, 0xad, 0x3f, 0xe3, 0x19, 0xe6, 0xbe, 0x88, 0xa8, 0xb1, 0xaf, 0x6b, 0x5b, 0x7e, 0xfe, 0x22, 0xbc, 0x19, 0x76, 0x30, 0x0c, 0xe2, 0x82, 0x99, 0xa2, 0x39, 0x2f, 0xb5, 0xd4, 0x4f, 0xa0, 0x61, 0x40, 0x9d, 0xf6, 0x5a, 0x35, 0x2b, 0x95, 0x4c, 0x66, 0x0f, 0xc3, 0x6b, 0x3a, 0xf2, 0x54, 0xac, 0x1d, 0x51, 0xc6, 0x71, 0x51, 0xfb, 0x8a, 0xb6, 0x9a, 0x6f, 0x1e, 0xab, 0x81, 0x38, 0x11, 0x2d, 0xd6, 0x99, 0x70, 0x75, 0xcb, 0xae, 0x28, 0x26, 0xea, 0xec, 0x20, 0x04, 0x70, 0xe1, 0x1a, 0xbb, 0xc3, 0xf6, 0xfc, 0x09, 0xda, 0x45, 0xa0, 0xdf, 0xb2, 0x36, 0x94, 0x51, 0x08, 0x86, 0x97, 0x4b, 0xf8, 0x3f, 0xe0, 0xf0, 0x30, 0x4b, 0xfa, 0xdd, 0x55, 0x2e, 0x64, 0x32, 0x03, 0x46, 0x40, 0x66, 0x6f, 0xa0, 0x9b, 0xe9, 0x3b, 0x93, 0xb8, 0x39, 0x3d, 0x06, 0x7e, 0x4f, 0xb0, 0x10, 0xb9, 0x5e, 0xa6, 0x21, 0x87, 0x4e, 0x2a, 0x4b, 0x8c, 0xd0, 0x8c, 0x2c, 0x99, 0xbb, 0x40, 0x67, 0x77, 0xa0, 0xec, 0x10, 0xef, 0x4a, 0xda, 0xdb, 0xd4, 0xcf, 0x6e, 0x35, 0x1e, 0x4c, 0xf8, 0x28, 0x6f, 0x62, 0x2c, 0x14, 0x71, 0xcc, 0xe9, 0x6d, 0x87, 0x60, 0x6b, 0x27, 0xa3, 0xcb, 0x7d, 0x2d, 0x9d, 0x98, 0x47, 0xef, 0xaf, 0xae, 0x9f, 0x93, 0x50, 0x6f, 0x5d, 0x26, 0xfd, 0xe4, 0x9a, 0xe1, 0xb5, 0x65, 0x0c, 0xf1, 0x7f, 0x41, 0x31, 0xbd, 0x05, 0x55, 0x97, 0xed, 0xd5, 0x8f, 0x0e, 0x68, 0x8a, 0x36, 0x34, 0x1b, 0x04, 0x84, 0x43, 0x23, 0x9c, 0x56, 0x9d, 0x49, 0x10, 0xe5, 0xde, 0xf5, 0x6e, 0x4f, 0xa5, 0xb3, 0x38, 0xb3, 0x35, 0xda, 0xe5, 0x64, 0x3a, 0x57, 0x95, 0x30, 0xe7, 0x40, 0x3f, 0x73, 0x43, 0x03, 0xac, 0x06, 0xba, 0x73, 0x9a, 0x3c, 0x35, 0xd6, 0x98, 0x95, 0x59, 0xea, 0x25, 0x8f, 0x52, 0xff, 0x40, 0x1c, 0xb7, 0x5d, 0x70, 0x27, 0x46, 0xb9, 0x39, 0x00, 0xc7, 0x09, 0x3d, 0xaf, 0xdb, 0x29, 0x4c, 0x25, 0xb0, 0x52, 0x7d, 0x41, 0x35, 0xa0, 0xd6, 0x69, 0x3e, 0x99, 0xf4, 0xde, 0x60, 0xcd, 0x06, 0xb2, 0x55, 0x29, 0xf0, 0x71, 0x00, 0x60, 0x95, 0x26, 0x03, 0xc3, 0x12, 0x98, 0x29, 0xf6, 0x03, 0x67, 0x1d, 0x6e, 0x86, 0x1e, 0x65, 0x4b, 0x2e, 0x67, 0xc7, 0xb8, 0x14, 0xe6, 0x08, 0x37, 0x78, 0x04, 0xe5, 0xa8, 0x23, 0x2b, 0x07, 0x1c, 0xa1, 0x8f, 0x57, 0x1b, 0x57, 0x4f, 0xff, 0xba, 0x2c, 0xc3, 0x9e, 0x9b, 0xb5, 0x77, 0x51, 0xac, 0xd9, 0x6b, 0x5f, 0x62, 0x37, 0xf3, 0xba, 0x42, 0x69, 0x30, 0xe0, 0x7b, 0xe8, 0x54, 0x9c, 0x14, 0x0a, 0x9c, 0xd0, 0xcc, 0x34, 0x22, 0xe4, 0x88, 0x61, 0xf2, 0xc8, 0xf6, 0xd3, 0x43, 0xca, 0x28, 0xf1, 0x5b, 0x5c, 0xfd, 0x09, 0x36, 0x48, 0x83, 0xdd, 0x6a, 0xb2, 0x20, 0x2c, 0xb6, 0x04, 0xe1, 0xc1, 0x25, 0x14, 0xf9, 0xf9, 0xe7, 0x0a, 0xce, 0x12, 0x47, 0xfe, 0xdd, 0xbb, 0xac, 0x58, 0xcc, 0x06, 0x7f, 0x8a, 0x66, 0x07, 0xd0, 0x4b, 0x93, 0xdb, 0xc7, 0xb1, 0x4f, 0x24, 0xaa, 0x65, 0xcf, 0xb1, 0x6d, 0x5f, 0x8f, 0xd9, 0x29, 0xc7, 0x50, 0xb7, 0xc9, 0x02, 0xfe, 0x0c, 0x37, 0x17, 0xc6, 0x0e, 0xff, 0x45, 0xf5, 0x8a, 0x9b, 0x81, 0xe3, 0xa7, 0xa8, 0x82, 0x9c, 0x87, 0x0e, 0x60, 0x5d, 0x30, 0x63, 0x8f, 0x6b, 0x7e, 0x5c, 0x75, 0x8f, 0x70, 0x6c, 0xc1, 0xe4, 0x54, 0x0d, 0x29, 0xba, 0x1b, 0xac, 0x5c, 0xc9, 0x95, 0x74, 0x13, 0x70, 0xc5, 0x74, 0xd1, 0x80, 0x66, 0x01, 0x37, 0x98, 0xb1, 0x1c, 0x25, 0x22, 0x32, 0x53, 0x29, 0xc7, 0x4a, 0xb2, 0x3b, 0x6f, 0x43, 0x76, 0x23, 0xfc, 0x24, 0x21, 0x57, 0x1c, 0xaa, 0x11, 0xd7, 0x2f, 0x5a, 0x9a, 0x7c, 0x89, 0x0f, 0x0e, 0xd3, 0x3b, 0x4b, 0x3b, 0x1e, 0x4d, 0x00, 0x31, 0x25, 0xe1, 0xbf, 0x57, 0x65, 0x7f, 0xd6, 0xe3, 0xa0, 0x63, 0xae, 0xea, 0x52, 0x94, 0xeb, 0x10, 0xf1, 0xdb, 0x93, 0xaa, 0x7f, 0xdd, 0xfa, 0x74, 0x27, 0xda, 0x9c, 0x48, 0xe3, 0xac, 0x37, 0x00, 0x4f, 0xbc, 0x4c, 0x33, 0xde, 0xe8, 0x18, 0x24, 0x3e, 0x5e, 0x9a, 0x03, 0x3d, 0xe6, 0x92, 0x72, 0xfd, 0x00, 0x80, 0x3a, 0xfd, 0x5a, 0x48, 0xd3, 0xf2, 0x26, 0x27, 0x85, 0x99, 0xa1, 0x77, 0x69, 0xc3, 0x98, 0xe1, 0xd0, 0x69, 0x8c, 0x50, 0xd9, 0xba, 0xc4, 0x9d, 0x15, 0x74, 0xe6, 0x74, 0x8b, 0x19, 0x9f, 0x8f, 0x76, 0x80, 0x4d, 0xc9, 0xee, 0xf7, 0xe4, 0x0f, 0xa8, 0x04, 0x85, 0x94, 0x15, 0x94, 0x0c, 0x2c, 0xf1, 0x07, 0x73, 0x11, 0x81, 0xb0, 0xca, 0x2e, 0x82, 0x7a, 0x81, 0xeb, 0x8d, 0xdf, 0x55, 0x15, 0xc7, 0x41, 0xb5, 0xa9, 0x34, 0xae, 0xa1, 0x99, 0x3e, 0x19, 0xa4, 0x73, 0xd5, 0x59, 0x8a, 0xc7, 0x67, 0x4f, 0xc8, 0xa5, 0x87, 0xf9, 0xf4, 0x1b, 0xd1, 0xb2, 0xf0, 0x81, 0xd3, 0x3d, 0x09, 0x6f, 0x9d, 0x93, 0x77, 0x24, 0x77, 0xff, 0x6e, 0x82, 0x54, 0x31, 0xd2, 0xe1, 0xf7, 0x64, 0x1a, 0x79, 0x7f, 0xa3, 0xa0, 0x1a, 0x4f, 0x63, 0x18, 0x4d, 0x41, 0x20, 0xb2, 0x6d, 0x24, 0x1b, 0xfd, 0xad, 0x6e, 0xb7, 0x0b, 0x0e, 0xd3, 0x39, 0x82, 0xfe, 0x7c, 0x68, 0xa5, 0xdb, 0x1f, 0x46, 0x61, 0x0e, 0xc2, 0x27, 0x3d, 0x1a, 0x8d, 0x7d, 0xe4, 0x7e, 0xc2, 0xb8, 0x65, 0xa0, 0xcc, 0x6a, 0x80, 0x90, 0x6a, 0x67, 0xab, 0x12, 0xf6, 0x81, 0xdc, 0x55, 0xac, 0x97, 0x7b, 0x05, 0x49, 0x9b, 0xc0, 0xaf, 0x5b, 0x9d, 0xef, 0x3d, 0xed, 0x74, 0xaa, 0x41, 0xe9, 0x38, 0x13, 0x31, 0x72, 0xa8, 0xbe, 0x03, 0xd6, 0x35, 0xfa, 0x5a, 0xd5, 0xf4, 0x58, 0x65, 0x1e, 0xe5, 0xf8, 0x7c, 0x0f, 0x47, 0x8d, 0x1b, 0xac, 0xeb, 0x15, 0x81, 0xd3, 0x48, 0x3d, 0xac, 0x70, 0xaa, 0x80, 0x87, 0x60, 0xc4, 0xdd, 0xff, 0x1b, 0xb0, 0x69, 0xbc, 0xb7, 0x79, 0x21, 0x25, 0x95, 0x35, 0x83, 0xe2, 0xe9, 0x1d, 0xa7, 0xea, 0xda, 0x6d, 0x35, 0xb9, 0x98, 0x24, 0xf8, 0x35, 0x3d, 0xeb, 0x4e, 0x15, 0xc9, 0xd6, 0xd2, 0xa3, 0x0c, 0xfb, 0xbb, 0x2d, 0xbc, 0x89, 0x7e, 0x7f, 0xed, 0x5c, 0xea, 0x5b, 0xf0, 0xe1, 0x26, 0xc2, 0x39, 0xd5, 0xfb, 0xed, 0xab, 0x1e, 0x63, 0x34, 0x0e, 0x31, 0x54, 0x65, 0xfc, 0xed, 0x07, 0xa6, 0x7a, 0x72, 0x20, 0x6b, 0x20, 0xcf, 0xef, 0x88, 0xa8, 0xb2, 0x0c, 0x0b, 0xf1, 0xe9, 0xe6, 0x92, 0x84, 0x12, 0x53, 0xe9, 0x29, 0xac, 0x11, 0x06, 0xa1, 0x2a, 0x71, 0x57, 0x28, 0xff, 0xb9, 0x01, 0x92, 0x80, 0x05, 0xf0, 0x7e, 0x83, 0x47, 0x2a, 0x36, 0x7c, 0xcd, 0x02, 0x7a, 0x47, 0x1e, 0xde, 0xe5, 0x28, 0x86, 0x8e, 0x66, 0x61, 0xef, 0x97, 0xb1, 0x01, 0xe6, 0xe7, 0x31, 0x7b, 0xdb, 0x1c, 0x81, 0x5b, 0x98, 0x70, 0x0d, 0x9a, 0x51, 0xc5, 0xe2, 0xff, 0x70, 0x9e, 0xb2, 0xb1, 0x37, 0xb5, 0x6c, 0x8a, 0xb9, 0xf5, 0x1d, 0xba, 0x15, 0x49, 0xbc, 0xd1, 0x9a, 0xc8, 0x59, 0x74, 0xeb, 0xc6, 0x90, 0x24, 0x57, 0xf8, 0x16, 0x07, 0xc8, 0x7a, 0x07, 0x94, 0x2c, 0x2a, 0x57, 0x8c, 0xee, 0xcc, 0x5f, 0xe7, 0xfc, 0x00, 0x88, 0x00, 0x16, 0x27, 0x46, 0x7b, 0x7d, 0xa5, 0x71, 0xe3, 0xac, 0x92, 0xa3, 0x80, 0x9e, 0x24, 0x34, 0x5b, 0x13, 0x24, 0xf5, 0x1b, 0x96, 0x8a, 0x8d, 0x0b, 0x43, 0xef, 0xe0, 0x41, 0x18, 0x74, 0x65, 0x07, 0x27, 0x2e, 0x8e, 0xac, 0xa4, 0xf3, 0x94, 0x00, 0x21, 0xe2, 0x3b, 0x2f, 0xcb, 0x89, 0x9c, 0xf1, 0x42, 0xfa, 0x9d, 0x1e, 0xcc, 0x65, 0x8f, 0x86, 0x62, 0xee, 0x9b, 0xe2, 0x19, 0xb8, 0x88, 0xdb, 0x59, 0x64, 0xc1, 0x0b, 0x8f, 0x47, 0x8b, 0xf3, 0xe6, 0x97, 0x00, 0xf9, 0x01, 0x4e, 0x1a, 0x20, 0x5d, 0x68, 0x9d, 0x43, 0x61, 0xa4, 0xf8, 0x56, 0x7c, 0x92, 0x5d, 0x4a, 0xde, 0xe4, 0xa7, 0x37, 0x35, 0x64, 0x87, 0xd8, 0x6d, 0x0d, 0x40, 0x25, 0x6a, 0xb1, 0xc8, 0xc8, 0xb6, 0x5c, 0xfb, 0x45, 0x1f, 0xf3, 0x59, 0x50, 0xc6, 0x0e, 0x84, 0xcb, 0x48, 0x67, 0x1c, 0x68, 0xd9, 0x18, 0x61, 0xdf, 0x71, 0x0b, 0x1d, 0xb2, 0xbf, 0xd2, 0x2e, 0xa2, 0xff, 0x44, 0x63, 0x08, 0xed, 0xd5, 0xa2, 0x98, 0xc1, 0xb7, 0x79, 0xcb, 0x13, 0x6c, 0xb6, 0x1d, 0x56, 0x1a, 0xc0, 0x67, 0xdc, 0x67, 0xcd, 0x9a, 0xb3, 0xc5, 0x09, 0x16, 0x49, 0x7f, 0xaf, 0x92, 0x26, 0x77, 0xd2, 0x00, 0x18, 0xb4, 0x15, 0xf5, 0xd7, 0xcc, 0x5b, 0xba, 0x77, 0x8a, 0xb7, 0xef, 0x0f, 0x9b, 0xe7, 0xf8, 0x85, 0x27, 0x18, 0x65, 0x90, 0xec, 0x0a, 0xe6, 0x36, 0xae, 0xe3, 0x49, 0x15, 0x6e, 0x0a, 0xa0, 0xf1, 0xe8, 0x83, 0x0e, 0xd4, 0x7f, 0xe8, 0x3b, 0x7a, 0x41, 0x92, 0x36, 0xa3, 0x09, 0xbd, 0xbe, 0x79, 0x58, 0xaa, 0x3e, 0xc2, 0x0e, 0xcc, 0x98, 0xf5, 0x26, 0x83, 0x25, 0x5b, 0x51, 0x48, 0x72, 0x1d, 0x73, 0xef, 0xb6, 0x38, 0x2c, 0x9c, 0x9f, 0xb1, 0xb4, 0x52, 0xa0, 0x5d, 0x61, 0x56, 0xb7, 0xec, 0x32, 0x5f, 0x55, 0x27, 0x47, 0xb5, 0xe1, 0x98, 0x8f, 0x3f, 0x7b, 0x75, 0x22, 0x2c, 0x6d, 0xa0, 0xa6, 0xe5, 0xf0, 0x5b, 0x8a, 0x66, 0x36, 0xb4, 0xad, 0x2c, 0x32, 0x50, 0x2a, 0x7c, 0x07, 0x32, 0x7c, 0xd3, 0xef, 0x15, 0x5e, 0xc5, 0xb9, 0xef, 0xd5, 0x6b, 0x8e, 0x40, 0x5f, 0x7c, 0x7d, 0x11, 0xb4, 0x61, 0xbd, 0x65, 0x34, 0x30, 0x13, 0x70, 0x0c, 0x46, 0x09, 0xd4, 0xb1, 0x36, 0x76, 0x42, 0x54, 0x93, 0xec, 0xf8, 0x1a, 0x7c, 0x5f, 0x67, 0x87, 0xfe, 0x7c, 0x31, 0x70, 0xba, 0x63, 0x78, 0x5a, 0x08, 0xc2, 0xbf, 0x58, 0x39, 0xf2, 0x41, 0x3d, 0x0a, 0x68, 0xf6, 0xc5, 0xfc, 0x13, 0x9f, 0x3a, 0xc2, 0x4b, 0xad, 0xf2, 0x67, 0x08, 0x73, 0x54, 0x45, 0xee, 0x95, 0x1a, 0x0f, 0x9f, 0xb6, 0x8d, 0x84, 0x77, 0x46, 0x1d, 0x35, 0x14, 0x8f, 0x2e, 0xa3, 0xcc, 0x06, 0xec, 0x3b, 0x2d, 0xb9, 0xac, 0x59, 0x77, 0x53, 0x26, 0x90, 0x24, 0xde, 0x60, 0x97, 0x1a, 0x63, 0xc3, 0xa3, 0xaa, 0x85, 0x5c, 0x9f, 0xd6, 0x35, 0x96, 0x74, 0x5a, 0xb0, 0x45, 0x91, 0x82, 0x0f, 0xac, 0x8c, 0xd9, 0xd7, 0x65, 0xa3, 0x73, 0xa1, 0x41, 0x65, 0x08, 0x07, 0xb7, 0x71, 0xd5, 0x86, 0x3a, 0xaf, 0x82, 0xfb, 0x8f, 0xad, 0xf8, 0xa8, 0x87, 0x3c, 0x9f, 0x1e, 0xc2, 0x44, 0xd0, 0x77, 0x78, 0x02, 0x28, 0xb2, 0xe3, 0xf7, 0xa1, 0x4d, 0x2f, 0x88, 0x2e, 0xf4, 0xa3, 0x48, 0x41, 0x9e, 0x19, 0xe1, 0xc3, 0x3d, 0x84, 0xb6, 0xcc, 0xb1, 0xba, 0xc8, 0x51, 0x02, 0x41, 0x69, 0xd4, 0x48, 0x5e, 0xcb, 0xe8, 0xd9, 0xb6, 0x7b, 0xfb, 0xe4, 0xa0, 0x01, 0xa1, 0xcc, 0x7b, 0x14, 0x25, 0x01, 0x4d, 0xd0, 0xb3, 0x2d, 0x95, 0xb5, 0x7a, 0x66, 0xbe, 0x7b, 0xd5, 0xa4, 0xe7, 0x29, 0xd8, 0x82, 0xea, 0xf8, 0xd0, 0xfb, 0xfc, 0xdc, 0x54, 0xd1, 0x43, 0x2f, 0x3d, 0xdc, 0x05, 0x8e, 0xa2, 0x1a, 0xec, 0x79, 0x8e, 0xf8, 0x84, 0xff, 0x41, 0x7a, 0xcb, 0xc4, 0x66, 0xbf, 0xbb, 0x02, 0xc3, 0x7f, 0xff, 0xc1, 0x5c, 0x31, 0x5b, 0xba, 0x9a, 0x27, 0x9c, 0x1d, 0xd3, 0xac, 0x31, 0x68, 0xf5, 0x72, 0x99, 0xdf, 0xd3, 0xc7, 0xf9, 0x23, 0x82, 0xa0, 0x80, 0x00, 0x98, 0xb0, 0xb7, 0x14, 0xec, 0x71, 0xc1, 0x6c, 0x1a, 0xff, 0x0b, 0xed, 0x66, 0x85, 0xf5, 0x5e, 0x73, 0x72, 0x0a, 0x59, 0xe5, 0xd6, 0xdd, 0x63, 0x95, 0x1e, 0x63, 0x25, 0xf6, 0x0a, 0x1a, 0x1a, 0x27, 0x5c, 0x7b, 0xaa, 0x49, 0xd3, 0x7f, 0xe3, 0x36, 0x1e, 0x56, 0x85, 0x9f, 0x70, 0xe1, 0x5b, 0x94, 0x64, 0xae, 0x95, 0x4b, 0x8f, 0x0e, 0x8c, 0x14, 0x2c, 0x40, 0xd4, 0x05, 0xf3, 0x08, 0x74, 0x3f, 0x1e, 0x61, 0x2a, 0x7b, 0x14, 0x49, 0xd4, 0x55, 0xcf, 0x53, 0x7a, 0x1b, 0xfb, 0xe9, 0x54, 0x0a, 0x11, 0xec, 0xe8, 0x53, 0xc8, 0x7f, 0x77, 0x8f, 0xa3, 0xcc, 0xdc, 0xa7, 0x3b, 0xe7, 0x14, 0x6a, 0xba, 0xde, 0xbf, 0x08, 0x28, 0xea, 0x15, 0x19, 0xb4, 0x0d, 0x74, 0xfa, 0x98, 0xe0, 0xae, 0x4b, 0x03, 0xcd, 0x26, 0xad, 0xd7, 0xec, 0x97, 0xb9, 0x79, 0xfe, 0xf4, 0x9a, 0xef, 0x11, 0x35, 0x6a, 0xa4, 0x3d, 0x31, 0x74, 0xd8, 0x76, 0x5e, 0x96, 0x23, 0xb5, 0x1a, 0xee, 0x42, 0x31, 0xd3, 0xdd, 0x84, 0x92, 0xa6, 0x73, 0x27, 0x88, 0x24, 0xcd, 0xe6, 0xb3, 0x1f, 0xc5, 0x33, 0x94, 0xa5, 0x6d, 0x26, 0x46, 0x25, 0x94, 0x34, 0x2c, 0xd1, 0xfa, 0x62, 0x3a, 0xf6, 0xe1, 0x67, 0xc6, 0x65, 0x1a, 0x19, 0xc4, 0xcf, 0x08, 0xa6, 0x15, 0x58, 0xfc, 0xaf, 0xfd, 0x0a, 0x58, 0x6b, 0x9d, 0x13, 0xe1, 0x3d, 0x0c, 0xf6, 0xdd, 0x25, 0xef, 0xba, 0xa7, 0x89, 0x8e, 0x87, 0xde, 0x80, 0xae, 0x3e, 0x5f, 0xd8, 0x26, 0x8d, 0x9d, 0x2d, 0xe8, 0x61, 0xd9, 0xad, 0xcb, 0xea, 0x74, 0x81, 0x45, 0xce, 0xbd, 0x5e, 0xdd, 0x0c, 0x36, 0x8b, 0xba, 0xf7, 0xb8, 0x10, 0xc8, 0x79, 0xf4, 0x68, 0x08, 0x07, 0x23, 0x6f, 0x2f, 0xbc, 0x0a, 0x8c, 0x5c, 0x49, 0x8f, 0xce, 0xcb, 0x48, 0x7a, 0xb8, 0x14, 0x66, 0xc5, 0x82, 0x40, 0x96, 0x3f, 0x60, 0xef, 0x08, 0x84, 0x6f, 0xd9, 0x54, 0x5b, 0xc6, 0x20, 0x2b, 0x64, 0x8a, 0xf1, 0x0f, 0xa0, 0x2a, 0xbe, 0xfd, 0xc1, 0xb8, 0xa4, 0x7c, 0x1d, 0xd2, 0x60, 0x43, 0xe0, 0xdd, 0xb6, 0x1d, 0xda, 0x81, 0x95, 0x1d, 0x80, 0xae, 0x62, 0x58, 0x58, 0x7d, 0x38, 0x28, 0xff, 0x78, 0x05, 0x00, 0x57, 0xae, 0x2a, 0x96, 0x5a, 0x70, 0xc9, 0xb7, 0xa9, 0x13, 0x39, 0xc3, 0xbf, 0x0c, 0x3a, 0xf4, 0xeb, 0x84, 0x19, 0x91, 0x48, 0x92, 0xd6, 0x08, 0x7d, 0x64, 0x87, 0x0c, 0x05, 0x66, 0x61, 0xf8, 0xae, 0x18, 0x9f, 0x5a, 0x21, 0x2b, 0xbb, 0x06, 0x3d, 0xd4, 0xf1, 0xe1, 0xbe, 0xdb, 0xfc, 0xc5, 0x7b, 0x81, 0xa4, 0x6c, 0x7b, 0x37, 0xe6, 0x04, 0x99, 0xa6, 0x69, 0xea, 0x0f, 0x55, 0xd8, 0x17, 0x38, 0x20, 0x03, 0x29, 0x6e, 0x44, 0x92, 0xac, 0x85, 0xca, 0x62, 0x29, 0x07, 0x2f, 0x98, 0x23, 0xff, 0xa8, 0x6a, 0xf1, 0xe2, 0xde, 0x4d, 0xf4, 0x34, 0xb9, 0x41, 0xfc, 0xe3, 0x20, 0x42, 0x26, 0x0b, 0xac, 0x3c, 0x1c, 0x1c, 0x67, 0x54, 0x01, 0x01, 0xcd, 0xb6, 0xbe, 0x1c, 0xbd, 0x66, 0xfd, 0x2b, 0x01, 0xbf, 0x94, 0x74, 0x0a, 0xe3, 0x12, 0x51, 0x5d, 0x50, 0xef, 0x9d, 0xe8, 0xd7, 0xb4, 0xa3, 0xa5, 0xa1, 0x6d, 0xb1, 0x47, 0x96, 0xf4, 0x90, 0xd0, 0xa0, 0x6e, 0x16, 0xae, 0x3c, 0xce, 0x2b, 0x67, 0x79, 0x37, 0x67, 0x72, 0x73, 0xad, 0xee, 0x0d, 0x0a, 0xe3, 0xfb, 0x29, 0xb0, 0xd8, 0x9e, 0xe5, 0xd8, 0x37, 0xea, 0x80, 0x80, 0x14, 0xa7, 0x6a, 0xb5, 0x56, 0xa3, 0x82, 0xd7, 0x6e, 0x95, 0xbf, 0x0a, 0xe3, 0xd7, 0x08, 0xd6, 0x9a, 0xb2, 0xb5, 0x0f, 0x13, 0x00, 0xf7, 0xfa, 0x61, 0x4a, 0x2b, 0x9d, 0x37, 0x5e, 0xae, 0x29, 0x29, 0x09, 0xc7, 0x61, 0x14, 0x5b, 0x20, 0x12, 0x0a, 0x2b, 0x62, 0xf0, 0xf7, 0xcb, 0x14, 0xfa, 0x75, 0xa0, 0x2c, 0xe5, 0xca, 0xbb, 0x40, 0x36, 0x7c, 0x0f, 0xb8, 0xa9, 0x81, 0x1b, 0xa0, 0xf0, 0x1a, 0x3d, 0xff, 0x3c, 0xa6, 0x3c, 0x90, 0xd1, 0x54, 0x37, 0xbb, 0xba, 0xa8, 0x0d, 0x7c, 0x7d, 0x1d, 0x11, 0x64, 0xf9, 0xe3, 0x3e, 0xcd, 0x4e, 0xb3, 0xa3, 0xa8, 0x8b, 0xa8, 0x15, 0x26, 0x53, 0xef, 0x97, 0x4a, 0x2b, 0x42, 0x02, 0x5c, 0x48, 0x47, 0x5e, 0xd8, 0x86, 0xee, 0x14, 0x2d, 0x9e, 0xd5, 0xa4, 0x49, 0x39, 0x50, 0x2f, 0xc6, 0xb8, 0x82, 0xdf, 0xe3, 0x47, 0x84, 0x85, 0xeb, 0xb1, 0x55, 0xae, 0x8e, 0x7c, 0xac, 0xc8, 0x36, 0xe5, 0x28, 0x7e, 0x3c, 0x4c, 0x5c, 0xd8, 0x99, 0x38, 0xf1, 0xae, 0x42, 0x8d, 0x5a, 0xe2, 0x03, 0x1e, 0x44, 0xea, 0x47, 0xbb, 0xa3, 0x70, 0x92, 0xff, 0x16, 0x8f, 0xaa, 0xcc, 0x03, 0x7f, 0xb3, 0x51, 0x8b, 0xa0, 0x25, 0x4d, 0xf6, 0x80, 0xdc, 0xc4, 0x9e, 0x99, 0x49, 0xb1, 0x41, 0xc7, 0x77, 0x1d, 0xc5, 0x90, 0x82, 0xf8, 0xce, 0x9b, 0xfd, 0x6c, 0xd5, 0x7c, 0x07, 0xdf, 0xdd, 0xa2, 0x92, 0x86, 0xf2, 0x41, 0x63, 0xa2, 0x6b, 0x78, 0xf7, 0xd6, 0xcf, 0x60, 0x96, 0xa9, 0x83, 0xd0, 0xda, 0xdd, 0x1c, 0x18, 0x70, 0xd0, 0x17, 0x01, 0x82, 0x8e, 0xe8, 0x38, 0x68, 0x2d, 0x21, 0x9e, 0x5f, 0xff, 0x7b, 0x1f, 0x4a, 0x4c, 0x78, 0xb2, 0x9b, 0xd5, 0x06, 0xc3, 0xa4, 0x08, 0x08, 0x45, 0xf1, 0xc5, 0x7f, 0x53, 0xa9, 0x15, 0xa7, 0x13, 0x5e, 0x8f, 0xfc, 0x21, 0x9f, 0xf8, 0xf1, 0xaa, 0x99, 0x93, 0x01, 0x95, 0xc7, 0xc9, 0x83, 0xaa, 0x4f, 0xec, 0xd4, 0xd1, 0x8f, 0x6b, 0x62, 0x18, 0x7b, 0x38, 0x21, 0xc1, 0x55, 0xf7, 0x40, 0xe1, 0x87, 0xd2, 0x4e, 0x91, 0x39, 0x10, 0x91, 0x47, 0xaa, 0x14, 0x85, 0x57, 0xeb, 0x04, 0xa6, 0xef, 0x64, 0x52, 0xeb, 0x51, 0x32, 0xdf, 0x09, 0xc1, 0x34, 0x31, 0x56, 0x81, 0xbe, 0xc4, 0x52, 0xa5, 0x6b, 0x3f, 0x73, 0xa1, 0x62, 0x21, 0x14, 0xc1, 0x1d, 0x2a, 0x97, 0xcd, 0xfc, 0x7c, 0x48, 0xf5, 0x30, 0xb5, 0x43, 0x07, 0x0d, 0x15, 0x7f, 0x3b, 0xe2, 0xbc, 0x90, 0x81, 0x70, 0xf4, 0xc0, 0x79, 0xd5, 0x50, 0x2a, 0xc4, 0x01, 0x0d, 0x6b, 0x6c, 0x4e, 0x00, 0x28, 0x79, 0xe1, 0x94, 0xed, 0xea, 0xd1, 0xd8, 0xee, 0x09, 0x93, 0xe2, 0xfe, 0x60, 0x59, 0xd4, 0x48, 0xc1, 0x6a, 0x4b, 0x87, 0x4a, 0xe3, 0x43, 0xff, 0x5c, 0xbf, 0x51, 0xbc, 0x7c, 0xe2, 0x95, 0x98, 0x8e, 0x0f, 0x9f, 0xc3, 0xee, 0x72, 0x37, 0xff, 0xa6, 0x9d, 0xe6, 0x3b, 0x94, 0xaa, 0xa6, 0x97, 0x41, 0xd5, 0x68, 0xfd, 0xfd, 0x70, 0x96, 0x52, 0x93, 0x89, 0x1b, 0xd6, 0x64, 0xf7, 0x41, 0x51, 0x5c, 0x2f, 0x56, 0xd9, 0x07, 0x2d, 0x78, 0x51, 0x82, 0x1f, 0xec, 0xf3, 0x4c, 0x4e, 0x03, 0x2d, 0x69, 0xac, 0xdc, 0x47, 0x30, 0xdc, 0x5e, 0xc4, 0xf9, 0xa3, 0xc1, 0x85, 0x32, 0xec, 0xcd, 0x14, 0x37, 0x02, 0x3f, 0x0e, 0x7f, 0x45, 0x71, 0xd4, 0xcc, 0x0c, 0x3a, 0x4f, 0x59, 0x56, 0x1d, 0x3d, 0xc7, 0xc9, 0x40, 0x95, 0x06, 0x90, 0xb6, 0x96, 0x81, 0x1f, 0x12, 0xa7, 0x78, 0xf8, 0x52, 0x6b, 0x19, 0x8f, 0x80, 0x1b, 0xa1, 0x1c, 0x19, 0x99, 0xb7, 0xd9, 0xee, 0x4e, 0xba, 0x6a, 0x5c, 0x1b, 0xca, 0xdb, 0xa5, 0x60, 0x00, 0xd8, 0xea, 0xa9, 0x49, 0x65, 0x27, 0xb6, 0x71, 0xd9, 0xf0, 0xaa, 0x74, 0xac, 0xdd, 0xfa, 0xe9, 0x30, 0x31, 0xf2, 0x53, 0xe3, 0x5c, 0xb5, 0xb8, 0x48, 0xe6, 0xb4, 0x15, 0x0f, 0x6c, 0x87, 0x19, 0x26, 0x99, 0x19, 0x7c, 0xe3, 0x1a, 0x95, 0x49, 0xec, 0x27, 0xd3, 0xf4, 0x95, 0x3a, 0xb7, 0x84, 0x1a, 0xdf, 0xdb, 0xae, 0x90, 0x75, 0xe9, 0xdb, 0xa5, 0xcd, 0x9d, 0x9f, 0xde, 0xb8, 0x34, 0x2f, 0xf1, 0xc9, 0x7b, 0x41, 0x18, 0x2c, 0x37, 0xd7, 0xb1, 0xa8, 0xfa, 0xb3, 0x73, 0xbe, 0xe3, 0x7b, 0x9e, 0xa3, 0xb3, 0xe0, 0x45, 0xc4, 0x42, 0xcf, 0xfe, 0xf3, 0x65, 0xdd, 0xc1, 0x8c, 0xfa, 0x04, 0x1c, 0xde, 0x34, 0x60, 0x8a, 0xa0, 0x21, 0xda, 0x40, 0x76, 0xd6, 0xea, 0xc9, 0x98, 0x94, 0x5b, 0xb2, 0x6f, 0x6b, 0x90, 0x8e, 0x06, 0xb6, 0x66, 0x48, 0xbc, 0x22, 0xd5, 0xb5, 0x1a, 0xdf, 0x3a, 0xff, 0x67, 0x51, 0x11, 0x2f, 0xa9, 0x0b, 0xf5, 0xe0, 0x7b, 0x94, 0xd7, 0xed, 0xba, 0x6b, 0x4b, 0x98, 0x5a, 0xca, 0xa6, 0x16, 0x95, 0xc5, 0x05, 0xf6, 0xee, 0x4e, 0x4c, 0xe5, 0x6a, 0xc7, 0x5e, 0x7f, 0xc3, 0x00, 0x2d, 0x52, 0x06, 0x9f, 0x67, 0x60, 0x8a, 0xe7, 0x47, 0x2e, 0x6b, 0x3b, 0xd8, 0x27, 0x2b, 0x0c, 0xdd, 0x1b, 0xd6, 0x38, 0x9b, 0x91, 0x42, 0xbb, 0xa9, 0xfa, 0xeb, 0x4e, 0xd3, 0xb3, 0xef, 0xb7, 0xc6, 0xa3, 0x5d, 0x05, 0xc4, 0x18, 0xae, 0x8f, 0xe1, 0x6a, 0x8b, 0x59, 0x62, 0x0d, 0x7f, 0xcf, 0xb8, 0xc2, 0x1e, 0x01, 0xa5, 0xc6, 0xa9, 0x08, 0xc5, 0x76, 0x56, 0xa3, 0xdd, 0x8a, 0x17, 0xd1, 0x3d, 0x74, 0x4f, 0x63, 0xe9, 0x2b, 0x82, 0x3c, 0xf4, 0x55, 0xe5, 0xf3, 0xac, 0x7b, 0x94, 0xc8, 0x78, 0xc0, 0x7f, 0xd3, 0x34, 0x0b, 0x9f, 0x29, 0x5f, 0xd4, 0xe6, 0xbc, 0xa9, 0x9c, 0x89, 0x1d, 0xd4, 0x0c, 0x94, 0xa8, 0x94, 0x85, 0xf3, 0x2c, 0xf1, 0x8b, 0x7f, 0x18, 0xf6, 0xdc, 0xe3, 0x7d, 0xd1, 0x61, 0x3c, 0x34, 0xa2, 0xc0, 0x92, 0x31, 0xa1, 0x5c, 0x8a, 0x70, 0xbd, 0x80, 0x3b, 0x7e, 0x7d, 0x2e, 0xcf, 0x3c, 0x4f, 0xe7, 0xae, 0x98, 0xd1, 0x44, 0xdf, 0xcd, 0x02, 0x26, 0x0e, 0x5b, 0x74, 0x9f, 0xff, 0x1c, 0x1b, 0xb2, 0xf8, 0xa4, 0x68, 0x9e, 0x4f, 0x45, 0xd6, 0xea, 0x9d, 0x0c, 0x4b, 0xa3, 0x53, 0xfd, 0xf5, 0xca, 0x3d, 0xd5, 0xb0, 0x06, 0xc5, 0xe6, 0x1d, 0xd0, 0xa6, 0xfd, 0xc2, 0xfe, 0xeb, 0x1d, 0x8d, 0xf1, 0x46, 0xf9, 0x0f, 0x3e, 0x00, 0x94, 0xa3, 0x87, 0x34, 0x7a, 0x28, 0x60, 0x57, 0x1f, 0xb3, 0x98, 0x33, 0xd8, 0x85, 0xb8, 0x7a, 0xc6, 0xcb, 0x3c, 0x73, 0xda, 0xbf, 0xc1, 0x10, 0xb2, 0x19, 0x94, 0xfc, 0x70, 0x68, 0x67, 0xfc, 0x24, 0x5c, 0xdd, 0x1c, 0xb3, 0x2b, 0xc7, 0xc6, 0x97, 0x80, 0x64, 0xfc, 0xd9, 0xa1, 0xf9, 0x22, 0xc9, 0xac, 0x76, 0x34, 0xb4, 0xfc, 0x68, 0x07, 0xdf, 0x2c, 0x74, 0x66, 0xd4, 0x15, 0x28, 0xe0, 0xb8, 0x37, 0xa3, 0xd2, 0x15, 0xcf, 0xa1, 0xef, 0x33, 0x36, 0x9b, 0x29, 0x85, 0x12, 0x43, 0x30, 0x03, 0xa5, 0x82, 0xfb, 0x04, 0x4f, 0xd6, 0x39, 0x48, 0x82, 0x9d, 0xd4, 0x90];
	var YLUT_BLUR = [0, 1, 3, 4, 6, 7, 9, 10, 12, 13, 15, 16, 18, 19, 21, 22, 24, 26, 29, 31, 34, 36, 39, 41, 44, 46, 49, 51, 54, 56, 59, 61, 64, 65, 66, 67, 68, 69, 70, 72, 73, 74, 75, 76, 77, 79, 80, 81, 82, 83, 84, 85, 87, 88, 89, 90, 91, 92, 94, 95, 96, 97, 98, 99, 101, 102, 103, 104, 105, 106, 107, 109, 110, 111, 112, 113, 114, 116, 117, 118, 119, 120, 121, 123, 124, 125, 126, 127, 128, 129, 131, 132, 133, 134, 135, 136, 138, 139, 140, 141, 142, 143, 145, 146, 147, 148, 149, 150, 151, 153, 154, 155, 156, 157, 158, 160, 161, 162, 163, 164, 165, 166, 168, 169, 170, 171, 172, 173, 175, 176, 177, 178, 179, 180, 182, 183, 184, 185, 186, 187, 188, 190, 191, 192, 193, 194, 195, 197, 198, 199, 200, 201, 202, 204, 205, 206, 207, 208, 209, 210, 212, 213, 214, 215, 216, 217, 219, 220, 221, 222, 223, 224, 226, 226, 226, 227, 227, 227, 228, 228, 228, 229, 229, 229, 230, 230, 231, 231, 231, 232, 232, 232, 233, 233, 233, 234, 234, 235, 235, 235, 236, 236, 236, 237, 237, 237, 238, 238, 239, 239, 239, 240, 240, 240, 241, 241, 241, 242, 242, 243, 243, 243, 244, 244, 244, 245, 245, 245, 246, 246, 246, 247, 247, 247, 248, 248, 248, 249, 249, 249, 250, 250, 250, 251, 251, 251, 252, 252, 252, 253, 253, 253, 254, 254, 254, 255];
	var YLUT_NORM = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 32, 33, 35, 36, 37, 39, 40, 42, 43, 44, 46, 47, 49, 50, 51, 53, 54, 56, 57, 58, 59, 61, 62, 63, 64, 66, 67, 68, 69, 71, 72, 73, 74, 76, 77, 78, 79, 81, 82, 83, 84, 86, 87, 88, 90, 91, 92, 93, 95, 96, 97, 98, 100, 101, 102, 103, 105, 106, 107, 108, 110, 111, 112, 113, 115, 116, 117, 118, 120, 121, 122, 124, 125, 126, 127, 129, 130, 131, 132, 134, 135, 136, 137, 139, 140, 141, 142, 144, 145, 146, 147, 149, 150, 151, 152, 154, 155, 156, 158, 159, 160, 161, 163, 164, 165, 166, 168, 169, 170, 171, 173, 174, 175, 176, 178, 179, 180, 181, 183, 184, 185, 186, 188, 189, 190, 192, 193, 194, 195, 197, 198, 199, 200, 202, 203, 204, 205, 207, 208, 209, 210, 212, 213, 214, 215, 217, 218, 219, 220, 222, 223, 224, 226, 226, 226, 227, 227, 228, 228, 229, 229, 230, 230, 231, 231, 232, 232, 233, 233, 234, 234, 234, 235, 235, 236, 236, 237, 237, 238, 238, 239, 239, 240, 240, 241, 241, 242, 242, 243, 243, 243, 244, 244, 244, 245, 245, 245, 246, 246, 246, 247, 247, 247, 248, 248, 248, 249, 249, 249, 250, 250, 250, 251, 251, 251, 252, 252, 252, 253, 253, 253, 254, 254, 254, 255];
	var YLUT_CLEAR = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 35, 36, 37, 38, 39, 40, 41, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 58, 59, 60, 61, 62, 63, 65, 66, 67, 68, 69, 70, 72, 73, 74, 76, 77, 78, 80, 81, 83, 84, 85, 87, 88, 89, 91, 92, 94, 95, 96, 98, 99, 100, 102, 103, 105, 106, 107, 109, 110, 111, 113, 114, 116, 117, 118, 120, 121, 122, 124, 125, 127, 128, 129, 131, 132, 133, 135, 136, 138, 139, 140, 142, 143, 144, 146, 147, 149, 150, 151, 153, 154, 155, 157, 158, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 192, 193, 193, 194, 195, 195, 196, 197, 197, 198, 199, 199, 200, 201, 201, 202, 203, 203, 204, 205, 205, 206, 207, 207, 208, 209, 209, 210, 211, 211, 212, 213, 213, 214, 215, 215, 216, 217, 217, 218, 219, 219, 220, 221, 221, 222, 223, 223, 224, 225, 225, 226, 227, 227, 228, 229, 229, 230, 231, 231, 232, 233, 233, 234, 235, 235, 236, 237, 237, 238, 239, 239, 240, 241, 241, 242, 243, 243, 244, 245, 245, 246, 247, 247, 248, 249, 249, 250, 251, 251, 252, 253, 253, 254, 255];

	var SkinToneProgram =
	/** @class */
	function (_super) {
	  __extends$g(SkinToneProgram, _super);

	  function SkinToneProgram(gl, inputTexture, width, height) {
	    var _this = _super.call(this, gl, kernel$4, width, height) || this;

	    _this.lightLevel = 0.1;
	    _this.rednessLevel = 0.5;
	    _this.mskin_he_max = 175.0 / 180 * 3.141593;
	    _this.mskin_he_min = 115.0 / 180 * 3.141593;
	    _this.mskin_hc_max = 173.0 / 180 * 3.141593;
	    _this.mskin_hc_min = 116.0 / 180 * 3.141593;
	    _this.mskin_hc_axis = 117.0 / 180 * 3.141593;
	    _this.mfacts_rotate_c = 0;
	    _this.mfacts_rotate_le = 0;
	    _this.mfacts_rotate_ge = 0;
	    _this.tab_addr = null;
	    _this.lutTextures = [];
	    _this.inputTexture = inputTexture;

	    _this.init();

	    return _this;
	  }

	  SkinToneProgram.prototype.setUniforms = function () {
	    var u_flipYLocation = this.gl.getUniformLocation(this.program, "u_flipY");
	    var denoiseLevelLocation = this.gl.getUniformLocation(this.program, "u_denoiseLevel");
	    this.gl.uniform1f(denoiseLevelLocation, this.denoiseLevel);
	    this.gl.uniform1f(u_flipYLocation, 1.0);
	    var lightLocation = this.gl.getUniformLocation(this.program, "light");
	    this.gl.uniform1f(lightLocation, this.lightLevel);
	    var rednessLocation = this.gl.getUniformLocation(this.program, "redness");
	    this.gl.uniform1f(rednessLocation, this.rednessLevel); // V1

	    var skin_he_maxLocation = this.gl.getUniformLocation(this.program, "skin_he_max");
	    var skin_he_minLocation = this.gl.getUniformLocation(this.program, "skin_he_min");
	    var skin_hc_maxLocation = this.gl.getUniformLocation(this.program, "skin_hc_max");
	    var skin_hc_minLocation = this.gl.getUniformLocation(this.program, "skin_hc_min");
	    var skin_hc_axisLocation = this.gl.getUniformLocation(this.program, "skin_hc_axis");
	    var facts_rotate_cLocation = this.gl.getUniformLocation(this.program, "facts_rotate_c");
	    var facts_rotate_leLocation = this.gl.getUniformLocation(this.program, "facts_rotate_le");
	    var facts_rotate_geLocation = this.gl.getUniformLocation(this.program, "facts_rotate_ge");
	    this.gl.uniform1f(skin_he_maxLocation, this.mskin_he_max);
	    this.gl.uniform1f(skin_he_minLocation, this.mskin_he_min);
	    this.gl.uniform1f(skin_hc_maxLocation, this.mskin_hc_max);
	    this.gl.uniform1f(skin_hc_minLocation, this.mskin_hc_min);
	    this.gl.uniform1f(skin_hc_axisLocation, this.mskin_hc_axis);
	    this.gl.uniform1f(facts_rotate_cLocation, this.mfacts_rotate_c);
	    this.gl.uniform1f(facts_rotate_leLocation, this.mfacts_rotate_le);
	    this.gl.uniform1f(facts_rotate_geLocation, this.mfacts_rotate_ge);
	    var u_originImageLocation = this.gl.getUniformLocation(this.program, "u_originImage");
	    this.gl.activeTexture(this.gl.TEXTURE2);
	    this.gl.bindTexture(this.gl.TEXTURE_2D, this.inputTexture);
	    this.gl.uniform1i(u_originImageLocation, 2);
	    var uniformNames = [
	    /*"uskin_lut", "vskin_lut", "askin_lut",*/
	    "lighten_lut"];
	    var textureIDs = [this.gl.TEXTURE3
	    /*, gl.TEXTURE4, gl.TEXTURE5, gl.TEXTURE6*/
	    ];

	    for (var j = 0; j < uniformNames.length; j++) {
	      var location_1 = this.gl.getUniformLocation(this.program, uniformNames[j]);
	      this.gl.activeTexture(textureIDs[j]);
	      this.gl.bindTexture(this.gl.TEXTURE_2D, this.lutTextures[j]);
	      this.gl.uniform1i(location_1, j + 3);
	    }
	  };

	  SkinToneProgram.prototype.setParameters = function (parameters) {
	    if (parameters.denoiseLevel !== undefined) {
	      this.denoiseLevel = parameters.denoiseLevel;
	    }

	    if (parameters.lightLevel !== undefined) {
	      this.lightLevel = parameters.lightLevel;
	    }

	    if (parameters.rednessLevel !== undefined) {
	      this.rednessLevel = parameters.rednessLevel;
	      this.updateRedness(this.rednessLevel);
	    }

	    if (parameters.lighteningContrastLevel) {
	      this.updateLut(parameters.lighteningContrastLevel);
	    }
	  };

	  SkinToneProgram.prototype.init = function () {
	    this.tab_addr = new Uint8Array(YLUT_NORM);
	    var luts = [
	    /*u_lut, v_lut, a_lut,*/
	    this.tab_addr],
	        widthValues = [
	    /*128, 128, 128,*/
	    256],
	        heightValues = [
	    /*128, 128, 128,*/
	    1];

	    for (var i = 0; i < luts.length; i++) {
	      // Upload u_lut as txture
	      var lutTexture = this.gl.createTexture();

	      if (!lutTexture) {
	        throw new AgoraRTCError(AgoraRTCErrorCode.WEBGL_INTERNAL_ERROR, "create lut texture failed");
	      }

	      this.gl.bindTexture(this.gl.TEXTURE_2D, lutTexture);
	      this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.LUMINANCE, widthValues[i], heightValues[i], 0, this.gl.LUMINANCE, this.gl.UNSIGNED_BYTE, luts[i]);
	      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
	      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
	      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
	      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
	      this.lutTextures.push(lutTexture);
	    }
	  };

	  SkinToneProgram.prototype.updateRedness = function (rednessLevel) {
	    var pi = 3.141593;
	    var iemax = 175.0;
	    var iemin = 115.0;
	    var icmax = 173.0;
	    var icmin = 116.0;
	    var icaxis = 117.0;
	    var step = 4.0;
	    var ang_alpha0, ang_alpha1;
	    var level = rednessLevel;
	    var ang_range = level;
	    if (level > 1.0) level = 1.0;
	    if (level < 0.0) level = 0.0;
	    if (ang_range > 1.0) ang_range = 1.0;
	    if (ang_range < 0.0) ang_range = 0.0;
	    this.mfacts_rotate_c = level * 0.8;
	    if (ang_range < 0.8) ang_range = 0.0;
	    this.mskin_he_max = iemax / 180 * pi;
	    this.mskin_hc_max = icmax / 180 * pi;
	    this.mskin_he_min = (iemin - step * ang_range) / 180 * pi;
	    this.mskin_hc_min = (icmin - step * ang_range) / 180 * pi;
	    this.mskin_hc_axis = (icaxis - step * ang_range) / 180 * pi;
	    if (this.mskin_hc_axis < this.mskin_hc_min) this.mskin_hc_axis = this.mskin_hc_min;
	    if (this.mskin_hc_min < pi / 2.0) this.mskin_hc_min = pi / 2.0;
	    if (this.mskin_hc_axis < pi / 2.0) this.mskin_hc_axis = pi / 2.0;
	    if (this.mskin_he_min < pi / 2.0) this.mskin_he_min = pi / 2.0;
	    if (this.mskin_hc_max > pi) this.mskin_hc_max = pi;
	    if (this.mskin_hc_axis > pi) this.mskin_hc_axis = pi;
	    if (this.mskin_he_max > pi) this.mskin_he_max = pi;
	    ang_alpha0 = this.mskin_he_max - this.mskin_hc_max;
	    ang_alpha1 = this.mskin_hc_max - this.mskin_hc_axis;
	    this.mfacts_rotate_ge = ang_alpha0 > 0.01 ? this.mfacts_rotate_c * ang_alpha1 / ang_alpha0 : this.mfacts_rotate_c;
	    ang_alpha0 = this.mskin_hc_min - this.mskin_he_min;
	    ang_alpha1 = this.mskin_hc_axis - this.mskin_hc_min;
	    this.mfacts_rotate_le = ang_alpha0 > 0.01 ? this.mfacts_rotate_c * ang_alpha1 / ang_alpha0 : this.mfacts_rotate_c;
	  };

	  SkinToneProgram.prototype.updateLut = function (ylut_table) {
	    var array = null;
	    if (ylut_table === 0.0) array = YLUT_NORM;
	    if (ylut_table === 1.0) array = YLUT_CLEAR;
	    if (ylut_table === 2.0) array = YLUT_BLUR;

	    if (!array) {
	      throw new AgoraRTCError(AgoraRTCErrorCode.WEBGL_INTERNAL_ERROR, "invalid ylut_table value:" + ylut_table);
	    }

	    this.tab_addr = new Uint8Array(array);
	    var luts = [
	    /*u_lut, v_lut, a_lut,*/
	    this.tab_addr],
	        widthValues = [
	    /*128, 128, 128,*/
	    256],
	        heightValues = [
	    /*128, 128, 128,*/
	    1];

	    for (var i = 0; i < luts.length; i++) {
	      this.gl.bindTexture(this.gl.TEXTURE_2D, this.lutTextures[i]);
	      this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.LUMINANCE, widthValues[i], heightValues[i], 0, this.gl.LUMINANCE, this.gl.UNSIGNED_BYTE, luts[i]);
	    }
	  };

	  return SkinToneProgram;
	}(CommonProgramWithParameters);

	var VideoEffectManager =
	/** @class */
	function () {
	  function VideoEffectManager() {
	    this.gl = null;
	    this.canvas = null;
	    this.programs = [];
	    this.commonProgram = null;
	    this.inputTexture = null;
	    this.outputTextures = [];
	    this.fbos = [];
	    this.originalFrameWidth = 0;
	    this.originalFrameHeight = 0;
	    this.enableBeauty = false;
	    this.denoiseLevel = 5.0;
	    this.lightLevel = 0.35;
	    this.rednessLevel = 0.5;
	    this.lighteningContrastLevel = 1.0;
	  }

	  VideoEffectManager.prototype.setEnableBeauty = function (enable) {
	    this.enableBeauty = !!enable;
	  };

	  VideoEffectManager.prototype.init = function (width, height, canvas) {
	    var compat = getCompatibility();

	    if (!compat.supportWebGL) {
	      throw new AgoraRTCError(AgoraRTCErrorCode.NOT_SUPPORTED, "your browser is not support webGL");
	    }

	    this.gl = canvas.getContext("webgl");

	    if (!this.gl) {
	      throw new AgoraRTCError(AgoraRTCErrorCode.WEBGL_INTERNAL_ERROR, "can not get webgl context");
	    }

	    this.initGL(width, height);

	    if (!this.inputTexture) {
	      throw new AgoraRTCError(AgoraRTCErrorCode.WEBGL_INTERNAL_ERROR, "can not find input texture");
	    }

	    this.canvas = canvas;
	    this.programs.push(new CommonProgram(this.gl));
	    this.programs.push(new GuildProgram(this.gl, width, height));
	    this.programs.push(new MeanProgram(this.gl, width, height));
	    this.programs.push(new Mean2Program(this.gl, width, height));
	    this.programs.push(new SkinToneProgram(this.gl, this.inputTexture, width, height));
	    this.commonProgram = this.programs[0].program;
	    this.setDenoiseLevel(this.denoiseLevel);
	    this.setLightLevel(this.lightLevel);
	    this.setRednessLevel(this.rednessLevel);
	    this.setContrastLevel(this.lighteningContrastLevel);
	  };

	  VideoEffectManager.prototype.render = function (video) {
	    if (!this.gl || !this.commonProgram || !this.canvas) {
	      logger.warning("video effect manager is not init!");
	      return;
	    }

	    var textureOffset = 0; // Use different textures when orientation changed.

	    if (this.originalFrameHeight === video.videoWidth && this.originalFrameWidth === video.videoHeight) {
	      textureOffset = 2;
	    } else if (this.originalFrameHeight !== video.videoHeight || this.originalFrameWidth !== video.videoWidth) {
	      logger.debug("beauty effect: resolution changed " + this.originalFrameWidth + "x" + this.originalFrameHeight + " -> " + video.videoWidth + "x" + video.videoHeight);

	      if (video.videoHeight === 0 || video.videoWidth === 0) {
	        logger.debug("beauty effect: skip 0 resolution frame");
	        return;
	      } // input track's resolution changed


	      this.canvas.width = video.videoWidth;
	      this.canvas.height = video.videoHeight;
	      video.setAttribute("width", video.videoWidth.toString());
	      video.setAttribute("height", video.videoHeight.toString());
	      this.release();
	      this.init(video.videoWidth, video.videoHeight, this.canvas);
	    }

	    this.gl.viewport(0, 0, video.videoWidth, video.videoHeight);
	    this.gl.bindTexture(this.gl.TEXTURE_2D, this.inputTexture);
	    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, video);
	    var count = this.enableBeauty ? this.programs.length - 1 : 0;

	    for (var i = 0; i <= count; i++) {
	      var glProgram = this.programs[i].program;
	      this.gl.useProgram(glProgram);
	      var u_imageLocation = this.gl.getUniformLocation(glProgram, "u_image");
	      this.programs[i].setUniforms();
	      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fbos[textureOffset + i % 2]); // Clear the canvas

	      this.gl.clearColor(0.0, 0.0, 0.0, 1.0);
	      this.gl.clear(this.gl.COLOR_BUFFER_BIT); // Draw to frame buffer.

	      this.gl.drawArrays(this.gl.TRIANGLES, 0, 6); // Bind texture for next step

	      this.gl.activeTexture(this.gl.TEXTURE0);
	      this.gl.bindTexture(this.gl.TEXTURE_2D, this.outputTextures[textureOffset + i % 2]);
	      this.gl.uniform1i(u_imageLocation, 0);
	    } // Draw to canvas


	    this.gl.useProgram(this.commonProgram);
	    var u_flipYLocation = this.gl.getUniformLocation(this.commonProgram, "u_flipY");
	    this.gl.uniform1f(u_flipYLocation, -1);
	    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null); // Clear the canvas

	    this.gl.clearColor(0.0, 0.0, 0.0, 1.0);
	    this.gl.clear(this.gl.COLOR_BUFFER_BIT); // Draw the rectangle.

	    this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
	  };

	  VideoEffectManager.prototype.setDenoiseLevel = function (denoise) {
	    var _context;

	    forEach$3(_context = this.programs).call(_context, function (program) {
	      if (program instanceof CommonProgramWithParameters) {
	        program.setParameters({
	          denoiseLevel: denoise
	        });
	      }
	    });

	    this.denoiseLevel = denoise;
	  };

	  VideoEffectManager.prototype.setLightLevel = function (light) {
	    var _context2;

	    forEach$3(_context2 = this.programs).call(_context2, function (program) {
	      if (program instanceof CommonProgramWithParameters) {
	        program.setParameters({
	          lightLevel: light
	        });
	      }
	    });

	    this.lightLevel = light;
	  };

	  VideoEffectManager.prototype.setRednessLevel = function (redness) {
	    var _context3;

	    forEach$3(_context3 = this.programs).call(_context3, function (program) {
	      if (program instanceof CommonProgramWithParameters) {
	        program.setParameters({
	          rednessLevel: redness
	        });
	      }
	    });

	    this.rednessLevel = redness;
	  };

	  VideoEffectManager.prototype.setContrastLevel = function (contrastLevel) {
	    var _context4;

	    forEach$3(_context4 = this.programs).call(_context4, function (program) {
	      if (program instanceof CommonProgramWithParameters) {
	        program.setParameters({
	          lighteningContrastLevel: contrastLevel
	        });
	      }
	    });

	    this.lighteningContrastLevel = contrastLevel;
	  };

	  VideoEffectManager.prototype.setSize = function (width, height) {
	    var _context5;

	    forEach$3(_context5 = this.programs).call(_context5, function (program) {
	      if (program instanceof CommonProgramWithParameters) {
	        program.setSize(width, height);
	      }
	    });
	  };

	  VideoEffectManager.prototype.release = function () {
	    this.gl = null;
	    this.commonProgram = null;
	    this.inputTexture = null;
	    this.programs = [];
	    this.outputTextures = [];
	    this.fbos = [];
	  };

	  VideoEffectManager.prototype.initGL = function (width, height) {
	    if (!this.gl) {
	      throw new AgoraRTCError(AgoraRTCErrorCode.WEBGL_INTERNAL_ERROR, "can not find webgl context");
	    }

	    this.inputTexture = this.gl.createTexture();
	    this.gl.bindTexture(this.gl.TEXTURE_2D, this.inputTexture);
	    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
	    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
	    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
	    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR); // Create target texture and bind to frame buffer

	    for (var i = 0; i < 4; i++) {
	      var targetTexture = this.gl.createTexture();

	      if (!targetTexture) {
	        throw new AgoraRTCError(AgoraRTCErrorCode.WEBGL_INTERNAL_ERROR, "create texture failed");
	      }

	      this.gl.bindTexture(this.gl.TEXTURE_2D, targetTexture);
	      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
	      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
	      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR); // this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);

	      if (i < 2) {
	        // Textures for portrait view.
	        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, width, height, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, null);
	      } else {
	        // Textures for landscape view.
	        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, height, width, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, null);
	      }

	      var fb = this.gl.createFramebuffer();

	      if (!fb) {
	        throw new AgoraRTCError(AgoraRTCErrorCode.WEBGL_INTERNAL_ERROR, "create frame buffer failed");
	      }

	      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, fb);
	      this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, targetTexture, 0);
	      this.outputTextures.push(targetTexture);
	      this.fbos.push(fb);
	    }

	    this.gl.viewport(0, 0, width, height);
	    this.originalFrameWidth = width;
	    this.originalFrameHeight = height;
	  };

	  return VideoEffectManager;
	}();

	var __awaiter$k = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = promise$3))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var __generator$k = undefined && undefined.__generator || function (thisArg, body) {
	  var _ = {
	    label: 0,
	    sent: function () {
	      if (t[0] & 1) throw t[1];
	      return t[1];
	    },
	    trys: [],
	    ops: []
	  },
	      f,
	      y,
	      t,
	      g;
	  return g = {
	    next: verb(0),
	    "throw": verb(1),
	    "return": verb(2)
	  }, typeof symbol$2 === "function" && (g[iterator$2] = function () {
	    return this;
	  }), g;

	  function verb(n) {
	    return function (v) {
	      return step([n, v]);
	    };
	  }

	  function step(op) {
	    if (f) throw new TypeError("Generator is already executing.");

	    while (_) try {
	      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	      if (y = 0, t) op = [op[0] & 2, t.value];

	      switch (op[0]) {
	        case 0:
	        case 1:
	          t = op;
	          break;

	        case 4:
	          _.label++;
	          return {
	            value: op[1],
	            done: false
	          };

	        case 5:
	          _.label++;
	          y = op[1];
	          op = [0];
	          continue;

	        case 7:
	          op = _.ops.pop();

	          _.trys.pop();

	          continue;

	        default:
	          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
	            _ = 0;
	            continue;
	          }

	          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
	            _.label = op[1];
	            break;
	          }

	          if (op[0] === 6 && _.label < t[1]) {
	            _.label = t[1];
	            t = op;
	            break;
	          }

	          if (t && _.label < t[2]) {
	            _.label = t[2];

	            _.ops.push(op);

	            break;
	          }

	          if (t[2]) _.ops.pop();

	          _.trys.pop();

	          continue;
	      }

	      op = body.call(thisArg, _);
	    } catch (e) {
	      op = [6, e];
	      y = 0;
	    } finally {
	      f = t = 0;
	    }

	    if (op[0] & 5) throw op[1];
	    return {
	      value: op[0] ? op[1] : void 0,
	      done: true
	    };
	  }
	};

	var BeautyEffectOverloadDetector =
	/** @class */
	function () {
	  function BeautyEffectOverloadDetector() {
	    this.targetFrameRate = 0;
	    this.recordedFrameCount = 0;
	    this.recordingTime = 2;
	  }

	  BeautyEffectOverloadDetector.prototype.startRecordBeautyEffectOutput = function (targetFrameRate, recordingTime) {
	    if (recordingTime === void 0) {
	      recordingTime = 4;
	    }

	    return __awaiter$k(this, void 0, void 0, function () {
	      var recordID;
	      return __generator$k(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            if (this.recordID) {
	              throw new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_ERROR, "another beauty effect recording is in progress");
	            }

	            recordID = getRandomString(6, "");
	            this.recordID = recordID;
	            this.targetFrameRate = targetFrameRate;
	            this.recordedFrameCount = 0;
	            this.recordingTime = recordingTime;
	            return [4
	            /*yield*/
	            , wait(1000 * this.recordingTime)];

	          case 1:
	            _a.sent(); // record aborted


	            if (this.recordID !== recordID) {
	              this.recordID = undefined;
	              return [2
	              /*return*/
	              , true];
	            }

	            this.recordID = undefined; // 如果实际输出的帧率小于目标帧率的一半，认为美颜 overload

	            if (this.recordedFrameCount < this.targetFrameRate * this.recordingTime / 2) {
	              logger.warning("detect beauty effect overload, current framerate", this.recordedFrameCount / 2);
	              return [2
	              /*return*/
	              , false];
	            }

	            logger.debug("beauty effect current framerate", this.recordedFrameCount / 2);
	            return [2
	            /*return*/
	            , true];
	        }
	      });
	    });
	  };

	  BeautyEffectOverloadDetector.prototype.stopRecordBeautyEffectOutput = function () {
	    this.targetFrameRate = 0;
	    this.recordedFrameCount = 0;
	    this.recordID = undefined;
	  };

	  BeautyEffectOverloadDetector.prototype.addFrame = function () {
	    if (!this.recordID) {
	      return;
	    }

	    this.recordedFrameCount += 1;
	  };

	  return BeautyEffectOverloadDetector;
	}();

	var __extends$h = undefined && undefined.__extends || function () {
	  var extendStatics = function (d, b) {
	    extendStatics = setPrototypeOf$2 || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    };

	    return extendStatics(d, b);
	  };

	  return function (d, b) {
	    extendStatics(d, b);

	    function __() {
	      this.constructor = d;
	    }

	    d.prototype = b === null ? create$4(b) : (__.prototype = b.prototype, new __());
	  };
	}();

	var __awaiter$l = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = promise$3))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var __generator$l = undefined && undefined.__generator || function (thisArg, body) {
	  var _ = {
	    label: 0,
	    sent: function () {
	      if (t[0] & 1) throw t[1];
	      return t[1];
	    },
	    trys: [],
	    ops: []
	  },
	      f,
	      y,
	      t,
	      g;
	  return g = {
	    next: verb(0),
	    "throw": verb(1),
	    "return": verb(2)
	  }, typeof symbol$2 === "function" && (g[iterator$2] = function () {
	    return this;
	  }), g;

	  function verb(n) {
	    return function (v) {
	      return step([n, v]);
	    };
	  }

	  function step(op) {
	    if (f) throw new TypeError("Generator is already executing.");

	    while (_) try {
	      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	      if (y = 0, t) op = [op[0] & 2, t.value];

	      switch (op[0]) {
	        case 0:
	        case 1:
	          t = op;
	          break;

	        case 4:
	          _.label++;
	          return {
	            value: op[1],
	            done: false
	          };

	        case 5:
	          _.label++;
	          y = op[1];
	          op = [0];
	          continue;

	        case 7:
	          op = _.ops.pop();

	          _.trys.pop();

	          continue;

	        default:
	          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
	            _ = 0;
	            continue;
	          }

	          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
	            _.label = op[1];
	            break;
	          }

	          if (op[0] === 6 && _.label < t[1]) {
	            _.label = t[1];
	            t = op;
	            break;
	          }

	          if (t && _.label < t[2]) {
	            _.label = t[2];

	            _.ops.push(op);

	            break;
	          }

	          if (t[2]) _.ops.pop();

	          _.trys.pop();

	          continue;
	      }

	      op = body.call(thisArg, _);
	    } catch (e) {
	      op = [6, e];
	      y = 0;
	    } finally {
	      f = t = 0;
	    }

	    if (op[0] & 5) throw op[1];
	    return {
	      value: op[0] ? op[1] : void 0,
	      done: true
	    };
	  }
	};
	/**
	 * @internal
	 */

	var BeautyVideoProcessor =
	/** @class */
	function (_super) {
	  __extends$h(BeautyVideoProcessor, _super);

	  function BeautyVideoProcessor() {
	    var _this = _super.call(this) || this;

	    _this.kind = "video";
	    _this.fps = 15;
	    _this.overloadDetector = new BeautyEffectOverloadDetector();
	    _this.enabled = false;
	    _this.stopChromeBackgroundLoop = null;
	    /**
	     * 用来控制 RAF 的帧率
	     */

	    _this.lastRenderTime = 0;
	    _this.fps = 30;
	    _this.manager = new VideoEffectManager();
	    return _this;
	  }

	  BeautyVideoProcessor.prototype.setBeautyEffectOptions = function (enabled, options) {
	    return __awaiter$l(this, void 0, void 0, function () {
	      var denoiseLevel, lightLevel, rednessLevel, lighteningContrastLevel, _a;

	      return __generator$l(this, function (_b) {
	        switch (_b.label) {
	          case 0:
	            isBeautyEffectOptions(options);

	            if (options.smoothnessLevel !== undefined) {
	              denoiseLevel = Math.max(0.1, options.smoothnessLevel * 10.0);
	              this.manager.setDenoiseLevel(denoiseLevel);
	            }

	            if (options.lighteningLevel !== undefined) {
	              lightLevel = Math.max(0.1, options.lighteningLevel / 2.0);
	              this.manager.setLightLevel(lightLevel);
	            }

	            if (options.rednessLevel !== undefined) {
	              rednessLevel = Math.max(0.01, options.rednessLevel);
	              this.manager.setRednessLevel(rednessLevel);
	            }

	            if (options.lighteningContrastLevel !== undefined) {
	              lighteningContrastLevel = options.lighteningContrastLevel;
	              this.manager.setContrastLevel(lighteningContrastLevel);
	            }

	            if (this.enabled === enabled) return [2
	            /*return*/
	            ];
	            this.manager.setEnableBeauty(enabled);
	            this.enabled = enabled;
	            if (!enabled) return [3
	            /*break*/
	            , 3];
	            _a = this.input;
	            if (!_a) return [3
	            /*break*/
	            , 2];
	            return [4
	            /*yield*/
	            , this.startEffect()];

	          case 1:
	            _a = _b.sent();
	            _b.label = 2;

	          case 2:
	            return [3
	            /*break*/
	            , 5];

	          case 3:
	            return [4
	            /*yield*/
	            , this.stopEffect()];

	          case 4:
	            _b.sent();

	            _b.label = 5;

	          case 5:
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  BeautyVideoProcessor.prototype.destroy = function () {
	    this.onOutputChange = undefined;
	    this.stopEffect();
	    this.enabled = false;
	  };

	  BeautyVideoProcessor.prototype.startEffect = function () {
	    return __awaiter$l(this, void 0, void 0, function () {
	      var browserInfo, output, updateEffect;

	      var _this = this;

	      return __generator$l(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            browserInfo = getBrowserInfo();

	            if (!this.input) {
	              logger.warning("video track is null, fail to start video effect!");
	              return [2
	              /*return*/
	              ];
	            }

	            if (this.output) {
	              logger.warning("video effect is already enabled");
	              return [2
	              /*return*/
	              ];
	            }

	            return [4
	            /*yield*/
	            , this.renderWithWebGL()];

	          case 1:
	            output = _a.sent();
	            return [4
	            /*yield*/
	            , this.updateOutput(output)];

	          case 2:
	            _a.sent();

	            logger.info("start video effect, output:", this.output);
	            this.overloadDetector.startRecordBeautyEffectOutput(this.fps).then(function (result) {
	              if (!result) {
	                _this.onOverload && _this.onOverload();
	              }
	            });

	            updateEffect = function () {
	              requestAnimationFrame(updateEffect);

	              var now = now$2();

	              var fpsInterval = 1000 / _this.fps;
	              var elapsed = _this.lastRenderTime ? now - _this.lastRenderTime : fpsInterval;
	              if (elapsed < fpsInterval) return;
	              _this.lastRenderTime = now - (elapsed - fpsInterval); // for safari auto resume

	              if (_this.video && _this.video.paused) {
	                _this.video.play();
	              }

	              if (_this.enabled && _this.video) {
	                _this.manager.render(_this.video); // @ts-ignore


	                if (_this.output && _this.output.requestFrame) {
	                  // @ts-ignore
	                  _this.output.requestFrame();
	                }

	                _this.overloadDetector.addFrame();
	              }
	            };

	            requestAnimationFrame(updateEffect); // WA: As requestAnimationFrame callback will stop on Chrome when a tab was switched to the background,
	            // canvas rendering will stop in this situation. Use a WebAudio based timer to avoid the canvas freezen.

	            if (browserInfo.name === BrowserName.CHROME) {
	              document.addEventListener("visibilitychange", function () {
	                if (document.hidden) {
	                  _this.stopChromeBackgroundLoop = audioTimerLoop(function () {
	                    if (_this.enabled && _this.video) {
	                      _this.manager.render(_this.video);
	                    } // @ts-ignore


	                    if (_this.output && _this.output.requestFrame) {
	                      // @ts-ignore
	                      _this.output.requestFrame();
	                    }

	                    _this.overloadDetector.addFrame();
	                  }, _this.fps);
	                } else {
	                  if (_this.stopChromeBackgroundLoop) {
	                    _this.stopChromeBackgroundLoop();

	                    _this.stopChromeBackgroundLoop = null;
	                  }
	                }
	              }, false);
	            }

	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  BeautyVideoProcessor.prototype.stopEffect = function () {
	    return __awaiter$l(this, void 0, void 0, function () {
	      return __generator$l(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            logger.info("stop video effect");
	            this.overloadDetector.stopRecordBeautyEffectOutput();
	            this.manager.release();
	            this.canvas && this.canvas.remove();
	            this.video && this.video.remove();
	            this.canvas = undefined;
	            this.video = undefined;
	            return [4
	            /*yield*/
	            , this.updateOutput(undefined)];

	          case 1:
	            _a.sent();

	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  BeautyVideoProcessor.prototype._setInput = function (videoTrack) {
	    return __awaiter$l(this, void 0, void 0, function () {
	      return __generator$l(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            if (!(this.enabled && !this.video)) return [3
	            /*break*/
	            , 2];
	            return [4
	            /*yield*/
	            , this.startEffect()];

	          case 1:
	            _a.sent();

	            _a.label = 2;

	          case 2:
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  BeautyVideoProcessor.prototype._removeInput = function () {
	    this.stopEffect();
	  };

	  BeautyVideoProcessor.prototype.renderWithWebGL = function () {
	    return __awaiter$l(this, void 0, void 0, function () {
	      var videoPlayingPromise, trackSettings, width, height, compatibility;

	      var _this = this;

	      return __generator$l(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            if (!this.input) {
	              throw new AgoraRTCError(AgoraRTCErrorCode.BEAUTY_PROCESSOR_INTERNAL_ERROR, "can not renderWithWebGL, no input");
	            }

	            if (this.canvas) {
	              this.canvas.remove();
	              this.canvas = undefined;
	            }

	            if (this.video) {
	              this.video.remove();
	              this.video = undefined;
	            }

	            this.canvas = document.createElement("canvas");
	            this.video = document.createElement("video");
	            this.video.setAttribute("autoplay", ""); // in Firefox, attr "muted" will not take effect immediately. So setting `muted` attr is needed

	            this.video.setAttribute("muted", "");
	            this.video.muted = true; // in iOS, not this attribute will not trigger "playing" event

	            this.video.setAttribute("playsinline", "");
	            this.video.setAttribute("style", "display:none");
	            this.video.srcObject = new MediaStream([this.input]);
	            videoPlayingPromise = new promise$3(function (resolve) {
	              var handlePlayEvent = function () {
	                _this.video && _this.video.removeEventListener("playing", handlePlayEvent);
	                resolve();
	              };

	              _this.video && _this.video.addEventListener("playing", handlePlayEvent);
	            });
	            trackSettings = this.input.getSettings();
	            width = trackSettings.width;
	            height = trackSettings.height;

	            if (trackSettings.frameRate && this.fps !== trackSettings.frameRate) {
	              this.fps = trackSettings.frameRate;
	              logger.debug("beauty video processor: set fps to", this.fps);
	            }

	            logger.debug("beauty video processor: width " + width + " height " + height);

	            if (!width || !height) {
	              throw new AgoraRTCError(AgoraRTCErrorCode.BEAUTY_PROCESSOR_INTERNAL_ERROR, "can not get track resolution");
	            }

	            this.canvas.width = width;
	            this.canvas.height = height;
	            this.video.setAttribute("width", width.toString());
	            this.video.setAttribute("height", height.toString());
	            this.manager.init(width, height, this.canvas);
	            this.video.play();
	            return [4
	            /*yield*/
	            , videoPlayingPromise];

	          case 1:
	            _a.sent();

	            compatibility = getCompatibility(); // FIXME: no type define in current ts

	            return [2
	            /*return*/
	            , this.canvas.captureStream(compatibility.supportRequestFrame ? 0 : this.fps).getVideoTracks()[0]];
	        }
	      });
	    });
	  };

	  return BeautyVideoProcessor;
	}(TrackProcessor);

	function getConstraintsFromCameraConfig(config) {
	  var constraints = {};

	  if (config.facingMode) {
	    constraints.facingMode = config.facingMode;
	  }

	  if (config.cameraId) {
	    constraints.deviceId = {
	      exact: config.cameraId
	    };
	  }

	  if (!config.encoderConfig) {
	    return constraints;
	  }

	  var encoderConfig = getVideoEncoderConfiguration(config.encoderConfig);
	  constraints.width = encoderConfig.width;
	  constraints.height = encoderConfig.height;

	  if (!isLegacyChrome() && encoderConfig.frameRate) {
	    constraints.frameRate = encoderConfig.frameRate;
	  }
	  /**
	   * if set max=15, the Resolution always 1200*720
	   */


	  if (isEdge() && typeof constraints.frameRate === "object") {
	    constraints.frameRate.max = 60;
	  }
	  /**
	   * 对于 Firefox，因为其 getUserMedia 实现逻辑的原因，如果指定了 30 fps 以下的配置，firefox 大概率
	   * 会找不到摄像头（因为，Firefox 不会像 Chrome 一样重新编码，直到当前的 67 版本都是如此
	   *
	   * 详细可以参考 https://stackoverflow.com/questions/35516416/firefox-frame-rate-max-constraint
	   */


	  if (isFirefox()) {
	    constraints.frameRate = {
	      ideal: 30,
	      max: 30
	    };
	  }

	  return constraints;
	}
	function getConstraintsFromScreenConfig(config) {
	  var constraints = {};

	  if (config.screenSourceType) {
	    constraints.mediaSource = config.screenSourceType;
	  }

	  if (config.extensionId && isChrome()) {
	    constraints.extensionId = config.extensionId;
	  }

	  if (config.electronScreenSourceId) {
	    constraints.sourceId = config.electronScreenSourceId;
	  }

	  var encoderConfig = config.encoderConfig ? getScreenEncoderConfiguration(config.encoderConfig) : null;
	  constraints.mandatory = {
	    chromeMediaSource: "desktop",
	    maxWidth: encoderConfig ? encoderConfig.width : undefined,
	    maxHeight: encoderConfig ? encoderConfig.height : undefined
	  };

	  if (encoderConfig && encoderConfig.frameRate) {
	    if (typeof encoderConfig.frameRate === "number") {
	      constraints.mandatory.maxFrameRate = encoderConfig.frameRate;
	      constraints.mandatory.minFrameRate = encoderConfig.frameRate;
	    } else {
	      constraints.mandatory.maxFrameRate = encoderConfig.frameRate.max || encoderConfig.frameRate.ideal || encoderConfig.frameRate.exact || undefined;
	      constraints.mandatory.minFrameRate = encoderConfig.frameRate.min || encoderConfig.frameRate.ideal || encoderConfig.frameRate.exact || undefined;
	    }

	    constraints.frameRate = encoderConfig.frameRate;
	  }

	  if (encoderConfig && encoderConfig.width) {
	    constraints.width = encoderConfig.width;
	  }

	  if (encoderConfig && encoderConfig.height) {
	    constraints.height = encoderConfig.height;
	  }

	  return constraints;
	}
	function getConstraintsFromMicrophoneConfig(config) {
	  var constraints = {};

	  if (!isLegacyChrome()) {
	    if (config.AGC !== undefined) {
	      constraints.autoGainControl = config.AGC;

	      if (isChrome()) {
	        constraints.googAutoGainControl = config.AGC;
	        constraints.googAutoGainControl2 = config.AGC;
	      }
	    }

	    if (config.AEC !== undefined) {
	      constraints.echoCancellation = config.AEC;
	    }

	    if (config.ANS !== undefined) {
	      constraints.noiseSuppression = config.ANS;

	      if (isChrome()) {
	        constraints.googNoiseSuppression = config.ANS;
	      }
	    }
	  }

	  if (config.encoderConfig) {
	    var encoderConfig = getAudioEncoderConfiguration(config.encoderConfig);
	    constraints.channelCount = encoderConfig.stereo ? 2 : 1;
	    constraints.sampleRate = encoderConfig.sampleRate;
	    constraints.sampleSize = encoderConfig.sampleSize;
	  }

	  if (config.microphoneId) {
	    constraints.deviceId = {
	      exact: config.microphoneId
	    };
	  }

	  if (isChrome() && constraints.channelCount === 2) {
	    constraints.googAutoGainControl = false;
	    constraints.googAutoGainControl2 = false;
	    constraints.echoCancellation = false;
	    constraints.googNoiseSuppression = false;
	  }

	  return constraints;
	}

	/**
	 * @internal
	 */

	var NativeVideoplayer =
	/** @class */
	function () {
	  function NativeVideoplayer(config) {
	    this.freezeTimeCounterList = [];
	    this.trackId = config.trackId;
	    this.updateConfig(config);
	  }

	  NativeVideoplayer.prototype.updateConfig = function (config) {
	    this.config = config;
	    this.trackId = config.trackId;
	    this.createVideoPlayer();
	  };

	  NativeVideoplayer.prototype.updateVideoTrack = function (track) {
	    logger.debug("updateVideoTrack", track);
	    if (this.videoTrack === track) return;
	    this.videoTrack = track;

	    if (this.videoPlayer === null) {
	      this.videoPlayer = new cordovaPluginAgoraRtc_NativePlayer.VideoPlayer();
	    }

	    if (this.videoPlayer && track) {
	      this.videoPlayer.updateVideoTrack(track);
	    }
	  };

	  NativeVideoplayer.prototype.play = function () {
	    var _this = this;

	    if (this.videoPlayer !== undefined) {
	      this.videoPlayer.play().then(function (status) {
	        logger.debug("[" + _this.trackId + "] play status:", status);
	      });
	    }
	  };

	  NativeVideoplayer.prototype.getCurrentFrame = function () {
	    var _this = this;

	    var image = new ImageData(2, 2);

	    if (!this.videoPlayer) {
	      return image;
	    }

	    this.videoPlayer.getCurrentFrame().then(function (data) {
	      image = data;
	    }).catch(function (ev) {
	      logger.debug("[" + _this.trackId + "] getCurrentFrame:", ev);
	    });
	    return image;
	  };

	  NativeVideoplayer.prototype.createVideoPlayer = function () {
	    var _this = this;

	    this.videoPlayer = new cordovaPluginAgoraRtc_NativePlayer.VideoPlayer(this.config);
	    logger.debug("createVideoPlayer 1");
	    this.videoPlayer.getWindowAttribute().then(function (wt) {
	      logger.debug("createVideoPlayer 3");

	      if (_this.videoPlayer) {
	        _this.videoPlayer.setViewAttribute(wt.width / 2, wt.height / 3, 0, 0);
	      }
	    });
	    logger.debug("createVideoPlayer 2");
	    this.videoPlayer.onFirstVideoFrameDecoded = this.firVideoFrameDeoced;
	  };

	  NativeVideoplayer.prototype.destroy = function () {
	    if (this.videoPlayer) {
	      this.videoPlayer.destroy();
	      this.videoPlayer = undefined;
	    }
	  };

	  NativeVideoplayer.prototype.firVideoFrameDeoced = function () {
	    if (this.onFirstVideoFrameDecoded) {
	      this.onFirstVideoFrameDecoded();
	    }
	  };

	  return NativeVideoplayer;
	}();

	var __extends$i = undefined && undefined.__extends || function () {
	  var extendStatics = function (d, b) {
	    extendStatics = setPrototypeOf$2 || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    };

	    return extendStatics(d, b);
	  };

	  return function (d, b) {
	    extendStatics(d, b);

	    function __() {
	      this.constructor = d;
	    }

	    d.prototype = b === null ? create$4(b) : (__.prototype = b.prototype, new __());
	  };
	}();

	var __assign$8 = undefined && undefined.__assign || function () {
	  __assign$8 = assign$2 || function (t) {
	    for (var s, i = 1, n = arguments.length; i < n; i++) {
	      s = arguments[i];

	      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	    }

	    return t;
	  };

	  return __assign$8.apply(this, arguments);
	};

	var __awaiter$m = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = promise$3))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var __generator$m = undefined && undefined.__generator || function (thisArg, body) {
	  var _ = {
	    label: 0,
	    sent: function () {
	      if (t[0] & 1) throw t[1];
	      return t[1];
	    },
	    trys: [],
	    ops: []
	  },
	      f,
	      y,
	      t,
	      g;
	  return g = {
	    next: verb(0),
	    "throw": verb(1),
	    "return": verb(2)
	  }, typeof symbol$2 === "function" && (g[iterator$2] = function () {
	    return this;
	  }), g;

	  function verb(n) {
	    return function (v) {
	      return step([n, v]);
	    };
	  }

	  function step(op) {
	    if (f) throw new TypeError("Generator is already executing.");

	    while (_) try {
	      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	      if (y = 0, t) op = [op[0] & 2, t.value];

	      switch (op[0]) {
	        case 0:
	        case 1:
	          t = op;
	          break;

	        case 4:
	          _.label++;
	          return {
	            value: op[1],
	            done: false
	          };

	        case 5:
	          _.label++;
	          y = op[1];
	          op = [0];
	          continue;

	        case 7:
	          op = _.ops.pop();

	          _.trys.pop();

	          continue;

	        default:
	          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
	            _ = 0;
	            continue;
	          }

	          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
	            _.label = op[1];
	            break;
	          }

	          if (op[0] === 6 && _.label < t[1]) {
	            _.label = t[1];
	            t = op;
	            break;
	          }

	          if (t && _.label < t[2]) {
	            _.label = t[2];

	            _.ops.push(op);

	            break;
	          }

	          if (t[2]) _.ops.pop();

	          _.trys.pop();

	          continue;
	      }

	      op = body.call(thisArg, _);
	    } catch (e) {
	      op = [6, e];
	      y = 0;
	    } finally {
	      f = t = 0;
	    }

	    if (op[0] & 5) throw op[1];
	    return {
	      value: op[0] ? op[1] : void 0,
	      done: true
	    };
	  }
	};

	var LocalVideoTrack =
	/** @class */
	function (_super) {
	  __extends$i(LocalVideoTrack, _super);

	  function LocalVideoTrack(track, encoderConfig, optimizationMode, trackId) {
	    var _this = _super.call(this, track, trackId) || this;

	    _this.trackMediaType = "video";
	    _this._enabled = true;
	    checkMediaStreamTrackResolution(track).then(function (_a) {
	      var width = _a[0],
	          height = _a[1];
	      _this._videoHeight = height;
	      _this._videoWidth = width;
	    }).catch(noop$1);
	    _this._encoderConfig = encoderConfig;
	    _this._optimizationMode = optimizationMode;
	    return _this;
	  }

	  defineProperty$4(LocalVideoTrack.prototype, "isPlaying", {
	    get: function () {
	      return !!this._player;
	    },
	    enumerable: true,
	    configurable: true
	  });

	  LocalVideoTrack.prototype.play = function (element, config) {
	    if (config === void 0) {
	      config = {};
	    }

	    var executor = report.reportApiInvoke(null, {
	      tag: AgoraAPITag.TRACER,
	      name: AgoraAPIName.LOCAL_VIDEO_TRACK_PLAY,
	      options: [this.getTrackId(), typeof element === "string" ? element : "HTMLElement", config]
	    });

	    if (!(element instanceof HTMLElement)) {
	      var htmlElement = document.getElementById(element.toString());

	      if (!htmlElement) {
	        logger.warning("[track-" + this.getTrackId() + "] can not find \"#" + element + "\" element, use document.body");
	        element = document.body;
	      } else {
	        element = htmlElement;
	      }
	    }

	    logger.debug("[track-" + this.getTrackId() + "] start video playback", stringify$2(config));

	    var playerConfig = __assign$8(__assign$8(__assign$8({}, this._getDefaultPlayerConfig()), config), {
	      trackId: this.getTrackId(),
	      element: element
	    });

	    if (!this._player) {
	      this._player = new NativeVideoplayer(playerConfig);

	      this._player.updateVideoTrack(this._mediaStreamTrack);
	    } else {
	      this._player.updateConfig(playerConfig);
	    }

	    this._player.play();

	    executor.onSuccess();
	  };

	  LocalVideoTrack.prototype.stop = function () {
	    var executor = report.reportApiInvoke(null, {
	      tag: AgoraAPITag.TRACER,
	      name: AgoraAPIName.LOCAL_VIDEO_TRACK_STOP,
	      options: [this.getTrackId()]
	    });
	    if (!this._player) return executor.onSuccess();

	    this._player.destroy();

	    this._player = undefined;
	    logger.debug("[track-" + this.getTrackId() + "] stop video playback");
	    executor.onSuccess();
	  };

	  LocalVideoTrack.prototype.setEnabled = function (enabled) {
	    return __awaiter$m(this, void 0, void 0, function () {
	      var unlock, e_1, e_2;
	      return __generator$m(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            if (enabled === this._enabled) return [2
	            /*return*/
	            ];
	            logger.info("[" + this.getTrackId() + "] start setEnabled", enabled);
	            return [4
	            /*yield*/
	            , this._enabledMutex.lock()];

	          case 1:
	            unlock = _a.sent();
	            if (!!enabled) return [3
	            /*break*/
	            , 6];
	            this._originMediaStreamTrack.enabled = false;
	            _a.label = 2;

	          case 2:
	            _a.trys.push([2, 4,, 5]);

	            return [4
	            /*yield*/
	            , emitAsPromiseNoResponse(this, TrackInternalEvent.NEED_REMOVE_TRACK, this)];

	          case 3:
	            _a.sent();

	            return [3
	            /*break*/
	            , 5];

	          case 4:
	            e_1 = _a.sent();
	            logger.error("[" + this.getTrackId() + "] setEnabled to false error", e_1.toString());
	            unlock();
	            throw e_1;

	          case 5:
	            this._enabled = false;
	            logger.info("[" + this.getTrackId() + "] setEnabled to false success");
	            return [2
	            /*return*/
	            , unlock()];

	          case 6:
	            this._originMediaStreamTrack.enabled = true;
	            _a.label = 7;

	          case 7:
	            _a.trys.push([7, 9,, 10]);

	            return [4
	            /*yield*/
	            , emitAsPromiseNoResponse(this, TrackInternalEvent.NEED_ADD_TRACK, this)];

	          case 8:
	            _a.sent();

	            return [3
	            /*break*/
	            , 10];

	          case 9:
	            e_2 = _a.sent();
	            logger.error("[" + this.getTrackId() + "] setEnabled to true error", e_2.toString());
	            unlock();
	            throw e_2;

	          case 10:
	            logger.info("[" + this.getTrackId() + "] setEnabled to true success");
	            this._enabled = true;
	            unlock();
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  LocalVideoTrack.prototype.getStats = function () {
	    runOnce(function () {
	      logger.warning("[deprecated] LocalVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalVideoStats instead");
	    }, "localVideoTrackGetStatsWarning");
	    var res = emitAsInvokerNoResponse(this, TrackInternalEvent.GET_STATS);
	    if (!res) return __assign$8({}, DEFAULT_LOCAL_VIDEO_TRACK_STATS);
	    return res;
	  };

	  LocalVideoTrack.prototype.setBeautyEffect = function (enabled, options) {
	    if (options === void 0) {
	      options = {};
	    }

	    return __awaiter$m(this, void 0, void 0, function () {
	      var executor, err, e_3;

	      var _this = this;

	      return __generator$m(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            executor = report.reportApiInvoke(null, {
	              tag: AgoraAPITag.TRACER,
	              name: AgoraAPIName.LOCAL_VIDEO_TRACK_BEAUTY,
	              options: [this.getTrackId(), enabled, options]
	            });
	            if (!enabled && !this._videoBeautyProcessor) return [2
	            /*return*/
	            ];

	            if (!this._enabled && enabled) {
	              err = new AgoraRTCError(AgoraRTCErrorCode.TRACK_IS_DISABLED, "can not enable beauty effect when track is disabled");
	              executor.onError(err);
	              throw err;
	            }

	            logger.info("[" + this.getTrackId() + "] start setBeautyEffect", enabled, stringify$2(options));
	            _a.label = 1;

	          case 1:
	            _a.trys.push([1, 7,, 8]);

	            if (!!this._videoBeautyProcessor) return [3
	            /*break*/
	            , 4];
	            this._videoBeautyProcessor = new BeautyVideoProcessor();

	            this._videoBeautyProcessor.onOverload = function () {
	              nextTick(function () {
	                return _this.emit(LocalTrackEvents.BEAUTY_EFFECT_OVERLOAD);
	              });
	            };

	            return [4
	            /*yield*/
	            , this._videoBeautyProcessor.setBeautyEffectOptions(enabled, options)];

	          case 2:
	            _a.sent();

	            return [4
	            /*yield*/
	            , this._registerTrackProcessor(this._videoBeautyProcessor)];

	          case 3:
	            _a.sent();

	            return [3
	            /*break*/
	            , 6];

	          case 4:
	            return [4
	            /*yield*/
	            , this._videoBeautyProcessor.setBeautyEffectOptions(enabled, options)];

	          case 5:
	            _a.sent();

	            _a.label = 6;

	          case 6:
	            return [3
	            /*break*/
	            , 8];

	          case 7:
	            e_3 = _a.sent();
	            logger.error("[" + this.getTrackId() + "] setBeautyEffect error", e_3.toString());
	            executor.onError(e_3);
	            throw e_3;

	          case 8:
	            logger.info("[" + this.getTrackId() + "] setBeautyEffect success");
	            executor.onSuccess();
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  LocalVideoTrack.prototype.getCurrentFrameData = function () {
	    if (!this._player) {
	      return new ImageData(2, 2);
	    }

	    return this._player.getCurrentFrame();
	  };

	  LocalVideoTrack.prototype._updatePlayerSource = function () {
	    if (!this._player) return; // this._player.updateVideoTrack(this._mediaStreamTrack);
	  };

	  LocalVideoTrack.prototype._getDefaultPlayerConfig = function () {
	    return {
	      fit: "contain"
	    };
	  };

	  return LocalVideoTrack;
	}(LocalTrack);

	var CameraVideoTrack =
	/** @class */
	function (_super) {
	  __extends$i(CameraVideoTrack, _super);

	  function CameraVideoTrack(track, config, constraints, optimizationMode, trackId) {
	    var _this = _super.call(this, track, config.encoderConfig ? getVideoEncoderConfiguration(config.encoderConfig) : {}, optimizationMode, trackId) || this;

	    _this._enabled = true;
	    _this._deviceName = "default";
	    _this._config = config;
	    _this._constraints = constraints;
	    _this._deviceName = track.label;

	    if (_this._config.encoderConfig) {
	      _this._encoderConfig = getVideoEncoderConfiguration(_this._config.encoderConfig);
	    }

	    return _this;
	  }

	  CameraVideoTrack.prototype.setDevice = function (deviceId) {
	    return __awaiter$m(this, void 0, void 0, function () {
	      var executor, err, info, constraints, ms, e_4, e_5;

	      var _this = this;

	      return __generator$m(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            executor = report.reportApiInvoke(null, {
	              tag: AgoraAPITag.TRACER,
	              name: AgoraAPIName.CAM_VIDEO_TRACK_SET_DEVICE,
	              options: [this.getTrackId(), deviceId]
	            });

	            if (!this._enabled) {
	              err = new AgoraRTCError(AgoraRTCErrorCode.TRACK_IS_DISABLED, "can not set device when track is disabled");
	              executor.onError(err);
	              throw err;
	            }

	            logger.info("[" + this.getTrackId() + "] set device to " + deviceId);
	            _a.label = 1;

	          case 1:
	            _a.trys.push([1, 10,, 11]);

	            return [4
	            /*yield*/
	            , deviceManager.getDeviceById(deviceId)];

	          case 2:
	            info = _a.sent();
	            constraints = {};
	            constraints.video = __assign$8({}, this._constraints);
	            constraints.video.deviceId = {
	              exact: deviceId
	            };
	            /**
	             * 因为有切换前后摄像头的需求，切换设备时需要解除 facingMode 的限制
	             */

	            constraints.video.facingMode = undefined;
	            /** 采集新的流之前先关闭当前的 track，防止有些设备不支持同时采集 */

	            this._originMediaStreamTrack.stop();

	            ms = null;
	            _a.label = 3;

	          case 3:
	            _a.trys.push([3, 5,, 8]);

	            return [4
	            /*yield*/
	            , getLocalStream(constraints, this.getTrackId())];

	          case 4:
	            ms = _a.sent();
	            return [3
	            /*break*/
	            , 8];

	          case 5:
	            e_4 = _a.sent();
	            logger.error("[" + this.getTrackId() + "] setDevice failed", e_4.toString());
	            return [4
	            /*yield*/
	            , getLocalStream({
	              video: this._constraints
	            }, this.getTrackId())];

	          case 6:
	            /** 采集新流发生错误，需要回滚到旧流 */
	            ms = _a.sent();
	            return [4
	            /*yield*/
	            , this._updateOriginMediaStreamTrack(ms.getVideoTracks()[0], false)];

	          case 7:
	            _a.sent();

	            throw e_4;

	          case 8:
	            return [4
	            /*yield*/
	            , this._updateOriginMediaStreamTrack(ms.getVideoTracks()[0], false)];

	          case 9:
	            _a.sent();

	            checkMediaStreamTrackResolution(this._originMediaStreamTrack).then(function (_a) {
	              var width = _a[0],
	                  height = _a[1];
	              _this._videoHeight = height;
	              _this._videoWidth = width;
	            });
	            this._deviceName = info.label;
	            this._config.cameraId = deviceId;
	            this._constraints.deviceId = {
	              exact: deviceId
	            };
	            return [3
	            /*break*/
	            , 11];

	          case 10:
	            e_5 = _a.sent();
	            executor.onError(e_5);
	            logger.error("[" + this.getTrackId() + "] setDevice error", e_5.toString());
	            throw e_5;

	          case 11:
	            logger.info("[" + this.getTrackId() + "] setDevice success");
	            executor.onSuccess();
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  CameraVideoTrack.prototype.setEnabled = function (enabled) {
	    return __awaiter$m(this, void 0, void 0, function () {
	      var unlock, e_6, constraints, deviceId, ms, e_7;

	      var _this = this;

	      return __generator$m(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            if (enabled === this._enabled) return [2
	            /*return*/
	            ];
	            logger.info("[" + this.getTrackId() + "] start setEnabled", enabled);
	            return [4
	            /*yield*/
	            , this._enabledMutex.lock()];

	          case 1:
	            unlock = _a.sent();
	            if (!!enabled) return [3
	            /*break*/
	            , 6];
	            this._originMediaStreamTrack.onended = null;

	            this._originMediaStreamTrack.stop();

	            this._enabled = false;
	            _a.label = 2;

	          case 2:
	            _a.trys.push([2, 4,, 5]);

	            return [4
	            /*yield*/
	            , emitAsPromiseNoResponse(this, TrackInternalEvent.NEED_REMOVE_TRACK, this)];

	          case 3:
	            _a.sent();

	            return [3
	            /*break*/
	            , 5];

	          case 4:
	            e_6 = _a.sent();
	            logger.error("[" + this.getTrackId() + "] setEnabled to false error", e_6.toString());
	            unlock();
	            throw e_6;

	          case 5:
	            logger.info("[" + this.getTrackId() + "] setEnabled to false success");
	            return [2
	            /*return*/
	            , unlock()];

	          case 6:
	            constraints = __assign$8({}, this._constraints);
	            deviceId = deviceManager.searchDeviceIdByName(this._deviceName);

	            if (deviceId && !constraints.deviceId) {
	              constraints.deviceId = {
	                exact: deviceId
	              };
	            }

	            _a.label = 7;

	          case 7:
	            _a.trys.push([7, 11,, 12]);

	            return [4
	            /*yield*/
	            , getLocalStream({
	              video: this._constraints
	            }, this.getTrackId())];

	          case 8:
	            ms = _a.sent();
	            return [4
	            /*yield*/
	            , this._updateOriginMediaStreamTrack(ms.getVideoTracks()[0], false)];

	          case 9:
	            _a.sent();

	            return [4
	            /*yield*/
	            , emitAsPromiseNoResponse(this, TrackInternalEvent.NEED_ADD_TRACK, this)];

	          case 10:
	            _a.sent();

	            return [3
	            /*break*/
	            , 12];

	          case 11:
	            e_7 = _a.sent();
	            logger.error("[" + this.getTrackId() + "] setEnabled true error", e_7.toString());
	            unlock();
	            throw e_7;

	          case 12:
	            checkMediaStreamTrackResolution(this._originMediaStreamTrack).then(function (_a) {
	              var width = _a[0],
	                  height = _a[1];
	              _this._videoHeight = height;
	              _this._videoWidth = width;
	            });
	            logger.info("[" + this.getTrackId() + "] setEnabled to true success");
	            this._enabled = true;
	            unlock();
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  CameraVideoTrack.prototype.setEncoderConfiguration = function (config) {
	    return __awaiter$m(this, void 0, void 0, function () {
	      var executor, err, newConfig, newConstraints, e_8, error, e_9;

	      var _this = this;

	      return __generator$m(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            executor = report.reportApiInvoke(null, {
	              tag: AgoraAPITag.TRACER,
	              name: AgoraAPIName.CAM_VIDEO_TRACK_SET_ENCODER_CONFIG,
	              options: [this.getTrackId(), config]
	            });

	            if (!this._enabled) {
	              err = new AgoraRTCError(AgoraRTCErrorCode.TRACK_IS_DISABLED, "can not set encoder configuration when track is disabled");
	              executor.onError(err);
	              throw err;
	            }

	            config = getVideoEncoderConfiguration(config);
	            newConfig = jsonClone(this._config);
	            newConfig.encoderConfig = config;
	            newConstraints = getConstraintsFromCameraConfig(newConfig);
	            logger.debug("[" + this.getTrackId() + "] setEncoderConfiguration applyConstraints", stringify$2(config), stringify$2(newConstraints));
	            _a.label = 1;

	          case 1:
	            _a.trys.push([1, 3,, 4]);

	            return [4
	            /*yield*/
	            , this._originMediaStreamTrack.applyConstraints(newConstraints)];

	          case 2:
	            _a.sent();

	            checkMediaStreamTrackResolution(this._originMediaStreamTrack).then(function (_a) {
	              var width = _a[0],
	                  height = _a[1];
	              _this._videoHeight = height;
	              _this._videoWidth = width;
	            });
	            return [3
	            /*break*/
	            , 4];

	          case 3:
	            e_8 = _a.sent();
	            error = new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_ERROR, e_8.toString());
	            logger.error("[track-" + this.getTrackId() + "] applyConstraints error", error.toString());
	            executor.onError(error);
	            throw error;

	          case 4:
	            this._config = newConfig;
	            this._constraints = newConstraints;
	            this._encoderConfig = config;
	            _a.label = 5;

	          case 5:
	            _a.trys.push([5, 7,, 8]);

	            return [4
	            /*yield*/
	            , emitAsPromiseNoResponse(this, TrackInternalEvent.NEED_RENEGOTIATE)];

	          case 6:
	            _a.sent();

	            return [3
	            /*break*/
	            , 8];

	          case 7:
	            e_9 = _a.sent();
	            executor.onError(e_9);
	            return [2
	            /*return*/
	            , e_9.throw()];

	          case 8:
	            executor.onSuccess();
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  CameraVideoTrack.prototype._getDefaultPlayerConfig = function () {
	    return {
	      mirror: true,
	      fit: "cover"
	    };
	  };

	  return CameraVideoTrack;
	}(LocalVideoTrack);

	function getSupportedCodecFromSDP(sdp) {
	  var result = {
	    video: [],
	    audio: []
	  };

	  if (sdp.match(/ VP8/i)) {
	    result.video.push("VP8");
	  }

	  if (sdp.match(/ H264/i)) {
	    result.video.push("H264");
	  }

	  if (sdp.match(/ opus/i)) {
	    result.audio.push("OPUS");
	  }

	  return result;
	}
	function updateSDPWithAudioEncoderConfiguration(sdp, encoderConfig) {
	  var opusPayloadType = sdp.match(/a=rtpmap:(\d+) opus/);

	  if (!opusPayloadType || !opusPayloadType[0] || !opusPayloadType[1]) {
	    return sdp;
	  }

	  var opusId = opusPayloadType[1];
	  var payloadTypeMatch = sdp.match("a=fmtp:" + opusId + ".*\r\n");

	  if (!payloadTypeMatch || !payloadTypeMatch[0]) {
	    return sdp;
	  }

	  var encoderConfigLine = "a=fmtp:" + opusId + " minptime=10;useinbandfec=1;";

	  if (encoderConfig.bitrate) {
	    encoderConfigLine += "maxaveragebitrate=" + Math.floor(encoderConfig.bitrate * 1000) + ";";
	  }

	  if (encoderConfig.sampleRate) {
	    encoderConfigLine += "maxplaybackrate=" + encoderConfig.sampleRate + ";sprop-maxcapturerate=" + encoderConfig.sampleRate + ";";
	  }

	  if (encoderConfig.stereo) {
	    encoderConfigLine += "stereo=1;sprop-stereo-1;";
	  }

	  encoderConfigLine += "\r\n";
	  sdp = sdp.replace(payloadTypeMatch[0], encoderConfigLine);
	  return sdp;
	}
	function addStereoSupportToSDP(sdp) {
	  return sdp.replace("minptime=10", "minptime=10;stereo=1; sprop-stereo=1");
	}
	function updateAnswerSDPWithVideoEncoderConfiguration(sdp, codec, encoderConfig) {
	  var compat = getCompatibility();
	  var minBitrate = encoderConfig.bitrateMin;
	  var maxBitrate = encoderConfig.bitrateMax;
	  var videoLine = sdp.match(/m=video.*\r\n/) || sdp.match(/m=video.*\n/);

	  if (videoLine && videoLine.length > 0 && compat.supportMinBitrate && minBitrate) {
	    var payloadTypeMatch = null;

	    if (codec === "h264") {
	      payloadTypeMatch = sdp.match(/a=rtpmap:(\d+) H264\/90000\r\n/) || sdp.match(/a=rtpmap:(\d+) H264\/90000\n/);
	    } else if (codec === "vp8") {
	      payloadTypeMatch = sdp.match(/a=rtpmap:(\d+) VP8\/90000\r\n/) || sdp.match(/a=rtpmap:(\d+) VP8\/90000\n/);
	    }

	    if (payloadTypeMatch && payloadTypeMatch[1]) {
	      sdp = sdp.replace(videoLine[0], videoLine[0] + "a=fmtp:" + payloadTypeMatch[1] + " x-google-min-bitrate=" + minBitrate + "\r\n");
	    }
	  }

	  if (videoLine && videoLine.length > 0 && maxBitrate) {
	    var modifier = "AS";

	    if (getBrowserInfo().name === BrowserName.FIREFOX) {
	      maxBitrate = (maxBitrate >>> 0) * 1000;
	      modifier = "TIAS";
	    }

	    sdp = sdp.replace(videoLine[0], videoLine[0] + "b=" + modifier + ":" + maxBitrate + "\r\n");
	  }

	  return sdp;
	}
	/**
	 * 如果当前的浏览器是 safari，删除网关发送过来的 orientation extension 头
	 * @param sdp
	 */

	function removeSafariOrientationExtensionFromAnswer(sdp) {
	  var browserInfo = getBrowserInfo();

	  if (browserInfo.name !== BrowserName.SAFARI && browserInfo.os !== BrowserOS.IOS) {
	    return sdp;
	  }

	  return sdp.replace(/a=.*video-orientation\r\n/g, "");
	}
	/**
	 * 因为网关目前不支持 unifined-plan API，重协商过程中可能出现 answer direction attr 不对齐的情况
	 * 通过这个方法强制将 answer 和 offer 的 direction attr 对齐
	 */

	function syncOfferAnswerMlineDirection(offer, answer) {
	  var _context, _context2, _context3;

	  var validLine = bind$3(_context = RegExp.prototype.test).call(_context, /^([a-z])=(.*)/);

	  var offerLines = filter$2(_context2 = offer.split(/(\r\n|\r|\n)/)).call(_context2, validLine);

	  var answerLines = filter$2(_context3 = answer.split(/(\r\n|\r|\n)/)).call(_context3, validLine);

	  var currentMline = null;
	  var offerDirectionMap = new map$2();

	  forEach$3(offerLines).call(offerLines, function (line) {
	    var mlineMatch = line.match(/m=(audio|video)/);

	    if (mlineMatch && mlineMatch[1]) {
	      currentMline = mlineMatch[1];
	      return;
	    }

	    if (!currentMline) return;
	    var directionMatch = line.match(/\=(sendrecv|recvonly|sendonly|inactive)/);

	    if (directionMatch && directionMatch[1]) {
	      offerDirectionMap.set(currentMline, directionMatch[1]);
	    }
	  });

	  currentMline = null;
	  return map$5(answerLines).call(answerLines, function (line) {
	    var mlineMatch = line.match(/m=(audio|video)/);

	    if (mlineMatch && mlineMatch[1]) {
	      currentMline = mlineMatch[1];
	      return line;
	    }

	    if (!currentMline) return line;
	    var directionMatch = line.match(/\=(sendrecv|recvonly|sendonly|inactive)/);

	    if (directionMatch && directionMatch[1]) {
	      var offerDirection = offerDirectionMap.get(currentMline);

	      if (offerDirection && offerDirection !== directionMatch[1]) {
	        return line.replace(directionMatch[1], offerDirection);
	      }
	    }

	    return line;
	  }).join("\r\n") + "\r\n";
	}

	function getLowResolutionVideoTrack(inputTrack, lowStreamParams) {
	  var videoElement = document.createElement("video");
	  var canvas = document.createElement("canvas");
	  videoElement.setAttribute("style", "display:none");
	  canvas.setAttribute("style", "display:none");
	  videoElement.setAttribute("muted", "");
	  videoElement.muted = true;
	  videoElement.setAttribute("autoplay", "");
	  videoElement.autoplay = true;
	  videoElement.setAttribute("playsinline", "");
	  canvas.width = constrainLongToNumber(lowStreamParams.width);
	  canvas.height = constrainLongToNumber(lowStreamParams.height);
	  var framerate = constrainLongToNumber(lowStreamParams.framerate || 15);
	  document.body.append(videoElement);
	  document.body.append(canvas);
	  var inputMediaStreamTrack = inputTrack._mediaStreamTrack;
	  videoElement.srcObject = new MediaStream([inputMediaStreamTrack]);
	  videoElement.play();
	  var ctx = canvas.getContext("2d");

	  if (!ctx) {
	    throw new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_ERROR, "can not get canvas context");
	  }

	  var compatibility = getCompatibility();
	  var stream = canvas.captureStream(compatibility.supportRequestFrame ? 0 : framerate);
	  var track = stream.getVideoTracks()[0];

	  var draw = function () {
	    // auto resume muted video in safari
	    if (videoElement.paused) {
	      videoElement.play();
	    }

	    if (videoElement.videoHeight > 2 && videoElement.videoWidth > 2) {
	      var videoWidth = videoElement.videoWidth;
	      var videoHeight = videoElement.videoHeight;
	      var videoAspectRatio = videoHeight / videoWidth;
	      var newCanvasHeight = canvas.width * videoAspectRatio; // 尽量减少更改 canvas 宽高的次数，高度差值大于 2 时才会触发 canvas 尺寸更新

	      if (Math.abs(newCanvasHeight - canvas.height) >= 2) {
	        logger.debug("adjust low stream resolution", canvas.width + "x" + canvas.height + " -> " + canvas.width + "x" + newCanvasHeight);
	        canvas.height = newCanvasHeight;
	      }
	    }

	    ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height); // @ts-ignore

	    track.requestFrame && track.requestFrame();

	    if (inputMediaStreamTrack !== inputTrack._mediaStreamTrack) {
	      inputMediaStreamTrack = inputTrack._mediaStreamTrack;
	      videoElement.srcObject = new MediaStream([inputMediaStreamTrack]);
	    }
	  };

	  var cancelLoop = audioTimerLoop(function () {
	    return draw();
	  }, framerate);
	  var originTrackStop = track.stop;

	  track.stop = function () {
	    originTrackStop.call(track);
	    cancelLoop();
	    videoElement.remove();
	    canvas.width = 0;
	    canvas.remove();
	    canvas = null;
	    videoElement = null;
	    logger.debug("clean low stream renderer");
	  };

	  return track;
	}

	var __extends$j = undefined && undefined.__extends || function () {
	  var extendStatics = function (d, b) {
	    extendStatics = setPrototypeOf$2 || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    };

	    return extendStatics(d, b);
	  };

	  return function (d, b) {
	    extendStatics(d, b);

	    function __() {
	      this.constructor = d;
	    }

	    d.prototype = b === null ? create$4(b) : (__.prototype = b.prototype, new __());
	  };
	}();

	var __assign$9 = undefined && undefined.__assign || function () {
	  __assign$9 = assign$2 || function (t) {
	    for (var s, i = 1, n = arguments.length; i < n; i++) {
	      s = arguments[i];

	      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	    }

	    return t;
	  };

	  return __assign$9.apply(this, arguments);
	};

	var __awaiter$n = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = promise$3))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var __generator$n = undefined && undefined.__generator || function (thisArg, body) {
	  var _ = {
	    label: 0,
	    sent: function () {
	      if (t[0] & 1) throw t[1];
	      return t[1];
	    },
	    trys: [],
	    ops: []
	  },
	      f,
	      y,
	      t,
	      g;
	  return g = {
	    next: verb(0),
	    "throw": verb(1),
	    "return": verb(2)
	  }, typeof symbol$2 === "function" && (g[iterator$2] = function () {
	    return this;
	  }), g;

	  function verb(n) {
	    return function (v) {
	      return step([n, v]);
	    };
	  }

	  function step(op) {
	    if (f) throw new TypeError("Generator is already executing.");

	    while (_) try {
	      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	      if (y = 0, t) op = [op[0] & 2, t.value];

	      switch (op[0]) {
	        case 0:
	        case 1:
	          t = op;
	          break;

	        case 4:
	          _.label++;
	          return {
	            value: op[1],
	            done: false
	          };

	        case 5:
	          _.label++;
	          y = op[1];
	          op = [0];
	          continue;

	        case 7:
	          op = _.ops.pop();

	          _.trys.pop();

	          continue;

	        default:
	          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
	            _ = 0;
	            continue;
	          }

	          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
	            _.label = op[1];
	            break;
	          }

	          if (op[0] === 6 && _.label < t[1]) {
	            _.label = t[1];
	            t = op;
	            break;
	          }

	          if (t && _.label < t[2]) {
	            _.label = t[2];

	            _.ops.push(op);

	            break;
	          }

	          if (t[2]) _.ops.pop();

	          _.trys.pop();

	          continue;
	      }

	      op = body.call(thisArg, _);
	    } catch (e) {
	      op = [6, e];
	      y = 0;
	    } finally {
	      f = t = 0;
	    }

	    if (op[0] & 5) throw op[1];
	    return {
	      value: op[0] ? op[1] : void 0,
	      done: true
	    };
	  }
	};
	/**
	 * Stream connection 是当 Stream 被用于 发布/订阅 时的一种抽象形式
	 * 专门用来将 Stream 对象和 PCConnection 对象结偶
	 */

	var PubStreamConnection =
	/** @class */
	function (_super) {
	  __extends$j(PubStreamConnection, _super);

	  function PubStreamConnection(statsCollector, joinInfo, codec, isLowStream) {
	    var _this = _super.call(this, joinInfo, joinInfo.stringUid || joinInfo.uid) || this;

	    _this.type = "pub";
	    _this.detecting = false;

	    _this.renegotiateWithGateway = function () {
	      return __awaiter$n(_this, void 0, void 0, function () {
	        var _this = this;

	        return __generator$n(this, function (_a) {
	          logger.debug("[pc-" + this.pc.ID + "] renegotiate start");
	          return [2
	          /*return*/
	          , new promise$3(function (resolve, reject) {
	            return __awaiter$n(_this, void 0, void 0, function () {
	              var connectionChangeHandler, sdp, response, answer;

	              var _this = this;

	              return __generator$n(this, function (_a) {
	                switch (_a.label) {
	                  case 0:
	                    this.connectionState = "connecting";

	                    connectionChangeHandler = function (curr) {
	                      if (curr === "connected") {
	                        _this.off(StreamConnectionEvents.CONNECTION_STATE_CHANGE, connectionChangeHandler);

	                        resolve();
	                      }
	                      /** 说明在重协商的过程中中止的了连接 */


	                      if (curr === "disconnected") {
	                        _this.off(StreamConnectionEvents.CONNECTION_STATE_CHANGE, connectionChangeHandler);

	                        reject(new AgoraRTCError(AgoraRTCErrorCode.OPERATION_ABORTED, "renegotiate abort"));
	                      }
	                    };

	                    this.on(StreamConnectionEvents.CONNECTION_STATE_CHANGE, connectionChangeHandler);
	                    return [4
	                    /*yield*/
	                    , this.pc.createOfferSDP()];

	                  case 1:
	                    sdp = _a.sent();

	                    if (this.audioTrack && this.audioTrack._encoderConfig) {
	                      sdp = updateSDPWithAudioEncoderConfiguration(sdp, this.audioTrack._encoderConfig);
	                    }

	                    return [4
	                    /*yield*/
	                    , this.pc.setOfferSDP(sdp)];

	                  case 2:
	                    _a.sent();

	                    return [4
	                    /*yield*/
	                    , emitAsPromise(this, StreamConnectionEvents.NEED_RENEGOTIATE, sdp)];

	                  case 3:
	                    response = _a.sent();
	                    answer = syncOfferAnswerMlineDirection(sdp, this.updateAnswerSDP(response.sdp));
	                    return [4
	                    /*yield*/
	                    , this.pc.setAnswerSDP(answer)];

	                  case 4:
	                    _a.sent();

	                    logger.debug("[pc-" + this.pc.ID + "] renegotiate success");
	                    this.connectionState = "connected";
	                    return [2
	                    /*return*/
	                    ];
	                }
	              });
	            });
	          })];
	        });
	      });
	    };

	    _this.handleStreamRenegotiate = function (resolve, reject) {
	      /** 如果 p2p 当前还没有建立成功，不需要重协商 */
	      if (_this.connectionState !== "connected") {
	        resolve();
	        return;
	      }

	      _this.renegotiateWithGateway().then(resolve).catch(reject);
	    };

	    _this.handleReplaceTrack = function (track, resolve, reject) {
	      /**
	       * 需要替换的 track 可能在混音 Track 内部，这种情况下，忽略这个请求
	       */
	      if (_this.audioTrack instanceof MixingAudioTrack && track.kind === "audio") {
	        return promise$3.resolve();
	      }

	      _this.pc.replaceTrack(track).then(function (res) {
	        if (res) {
	          return _this.renegotiateWithGateway();
	        }

	        return promise$3.resolve();
	      }).then(resolve).catch(reject);
	    };

	    _this.handleCloseAudioTrack = function (track) {// nothing to do
	    };

	    _this.handleCloseVideoTrack = function () {
	      if (_this.lowStreamConnection && _this.lowStreamConnection.videoTrack) {
	        _this.lowStreamConnection.videoTrack.close();
	      }
	    };

	    _this.handleGetSessionID = function (callback) {
	      callback(_this.joinInfo.sid);
	    };

	    _this.handleGetLocalVideoStats = function (callback) {
	      callback(_this.statsCollector.getLocalVideoTrackStats(_this.connectionId));
	    };

	    _this.handleGetLocalAudioStats = function (callback) {
	      callback(_this.statsCollector.getLocalAudioTrackStats(_this.connectionId));
	    };

	    _this.isLowStreamConnection = !!isLowStream;
	    _this.codec = codec;
	    _this.statsCollector = statsCollector;

	    _this.statsCollector.addLocalConnection(_this);

	    return _this;
	  }

	  PubStreamConnection.prototype.getAllTracks = function () {
	    var trackList = [];

	    if (this.videoTrack) {
	      trackList.push(this.videoTrack);
	    }

	    if (this.audioTrack && this.audioTrack instanceof MixingAudioTrack) {
	      trackList = concat$2(trackList).call(trackList, this.audioTrack.trackList);
	    } else if (this.audioTrack) {
	      trackList.push(this.audioTrack);
	    }

	    return trackList;
	  };

	  PubStreamConnection.prototype.addTracks = function (tracks) {
	    return __awaiter$n(this, void 0, void 0, function () {
	      var compatibility, e_1, needRenegotiate, currentPublishedTracks, i, track, err, error, error, mixingTrack, streamParameter, lowMediaStreamTrack, lowVideoTrack;

	      var _this = this;

	      return __generator$n(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            compatibility = getCompatibility();
	            if (!(this.connectionState === "connecting")) return [3
	            /*break*/
	            , 5];
	            _a.label = 1;

	          case 1:
	            _a.trys.push([1, 4,, 5]);

	            return [4
	            /*yield*/
	            , this.createWaitConnectionConnectedPromise()];

	          case 2:
	            _a.sent();

	            return [4
	            /*yield*/
	            , this.addTracks(tracks)];

	          case 3:
	            return [2
	            /*return*/
	            , _a.sent()];

	          case 4:
	            e_1 = _a.sent();
	            throw new AgoraRTCError(AgoraRTCErrorCode.OPERATION_ABORTED, "publish abort");

	          case 5:
	            needRenegotiate = false;
	            currentPublishedTracks = this.getAllTracks(); // 去掉已经发布成功的 tracks

	            tracks = filter$2(tracks).call(tracks, function (track) {
	              return indexOf$3(currentPublishedTracks).call(currentPublishedTracks, track) === -1;
	            }); // 去掉重复的 track

	            tracks = getUniqueList(tracks);
	            i = 0;
	            _a.label = 6;

	          case 6:
	            if (!(i < tracks.length)) return [3
	            /*break*/
	            , 16];
	            track = tracks[i];

	            if (!(track instanceof LocalTrack)) {
	              err = new AgoraRTCError(AgoraRTCErrorCode.INVALID_LOCAL_TRACK);
	              return [2
	              /*return*/
	              , err.throw()];
	            }

	            if (track instanceof LocalVideoTrack && this.disabledVideoTrack) {
	              if (this.disabledVideoTrack !== track) {
	                error = new AgoraRTCError(AgoraRTCErrorCode.EXIST_DISABLED_VIDEO_TRACK);
	                return [2
	                /*return*/
	                , error.throw()];
	              }

	              this.disabledVideoTrack = undefined;
	            }

	            if (!(track instanceof LocalVideoTrack && this.videoTrack)) return [3
	            /*break*/
	            , 7];
	            error = new AgoraRTCError(AgoraRTCErrorCode.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);
	            return [2
	            /*return*/
	            , error.throw()];

	          case 7:
	            if (!(track instanceof LocalAudioTrack && this.audioTrack)) return [3
	            /*break*/
	            , 11];
	            if (!(this.audioTrack instanceof MixingAudioTrack)) return [3
	            /*break*/
	            , 8];
	            /** 这种情况下，mediaStreamTrack 没有改变，不需要重协商 */

	            this.audioTrack.addAudioTrack(track);
	            return [3
	            /*break*/
	            , 10];

	          case 8:
	            // 如果不支持混音，抛出错误
	            if (!compatibility.webAudioMediaStreamDest) {
	              throw new AgoraRTCError(AgoraRTCErrorCode.NOT_SUPPORTED, "your browser is not support audio mixing");
	            }

	            mixingTrack = new MixingAudioTrack();
	            mixingTrack.addAudioTrack(this.audioTrack);
	            mixingTrack.addAudioTrack(track);
	            return [4
	            /*yield*/
	            , this.addTrackWithPC(mixingTrack)];

	          case 9:
	            needRenegotiate = _a.sent();
	            _a.label = 10;

	          case 10:
	            return [3
	            /*break*/
	            , 15];

	          case 11:
	            if (!(track instanceof LocalVideoTrack && this.isLowStreamConnection)) return [3
	            /*break*/
	            , 13];
	            streamParameter = this.lowStreamParameter || getDefaultLowStreamParameter();
	            lowMediaStreamTrack = getLowResolutionVideoTrack(track, streamParameter);
	            lowVideoTrack = new LocalVideoTrack(lowMediaStreamTrack, {
	              bitrateMax: streamParameter.bitrate,
	              bitrateMin: streamParameter.bitrate
	            });

	            lowVideoTrack._hints.push(TrackHint.LOW_STREAM);

	            return [4
	            /*yield*/
	            , this.addTrackWithPC(lowVideoTrack)];

	          case 12:
	            needRenegotiate = _a.sent();
	            return [3
	            /*break*/
	            , 15];

	          case 13:
	            /** 发布大流视频，进入 detecting 状态 8 秒以过渡码率爬升影响网络质量阶段 */
	            this.detecting = true;

	            setTimeout$2(function () {
	              _this.detecting = false;
	            }, 8000);

	            return [4
	            /*yield*/
	            , this.addTrackWithPC(track)];

	          case 14:
	            needRenegotiate = _a.sent();
	            _a.label = 15;

	          case 15:
	            i += 1;
	            return [3
	            /*break*/
	            , 6];

	          case 16:
	            if (!needRenegotiate) return [3
	            /*break*/
	            , 18];
	            return [4
	            /*yield*/
	            , this.renegotiateWithGateway()];

	          case 17:
	            _a.sent();

	            _a.label = 18;

	          case 18:
	            forEach$3(tracks).call(tracks, function (track) {
	              return _this.bindTrackEvents(track);
	            });

	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  PubStreamConnection.prototype.removeTracks = function (tracks, isUserAction) {
	    return __awaiter$n(this, void 0, void 0, function () {
	      var currentPublishedTracks, needToRemovedTracksInPC, i, track, e_2, _i, needToRemovedTracksInPC_1, track;

	      var _this = this;

	      return __generator$n(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            currentPublishedTracks = this.getAllTracks(); // 去掉没有发布的 tracks

	            tracks = filter$2(tracks).call(tracks, function (track) {
	              return indexOf$3(currentPublishedTracks).call(currentPublishedTracks, track) !== -1 || track === _this.disabledVideoTrack;
	            }); // 去掉重复的 track

	            tracks = getUniqueList(tracks);
	            needToRemovedTracksInPC = [];

	            for (i = 0; i < tracks.length; i += 1) {
	              track = tracks[i];
	              this.unbindTrackEvents(track);

	              if (this.audioTrack instanceof MixingAudioTrack && track instanceof LocalAudioTrack) {
	                this.audioTrack.removeAudioTrack(track); // 如果这个 MixingTrack 已经没有任何输入了，干掉它

	                if (this.audioTrack.trackList.length === 0) {
	                  needToRemovedTracksInPC.push(this.audioTrack);
	                  this.audioTrack = undefined;
	                }
	              } else if (track instanceof LocalAudioTrack) {
	                needToRemovedTracksInPC.push(track);
	                this.audioTrack = undefined;
	              } else if (track instanceof LocalVideoTrack) {
	                if (!isUserAction) {
	                  this.disabledVideoTrack = this.videoTrack;
	                } else {
	                  if (this.disabledVideoTrack === track) {
	                    this.disabledVideoTrack = undefined;
	                    return [2
	                    /*return*/
	                    ];
	                  }
	                }

	                needToRemovedTracksInPC.push(track);
	                /** 如果这个 Connection 用户发布小流，这个小流需要销毁 */

	                if (this.isLowStreamConnection) {
	                  track.close();
	                }

	                this.videoTrack = undefined;
	              }
	            }

	            if (!(!this.videoTrack && !this.audioTrack)) return [3
	            /*break*/
	            , 2];
	            return [4
	            /*yield*/
	            , this.closeP2PConnection()];

	          case 1:
	            _a.sent();

	            return [3
	            /*break*/
	            , 13];

	          case 2:
	            if (!(needToRemovedTracksInPC.length === 0)) return [3
	            /*break*/
	            , 3];
	            return [2
	            /*return*/
	            ];

	          case 3:
	            if (!(this.connectionState === "connecting")) return [3
	            /*break*/
	            , 7];
	            _a.label = 4;

	          case 4:
	            _a.trys.push([4, 6,, 7]);

	            return [4
	            /*yield*/
	            , this.createWaitConnectionConnectedPromise()];

	          case 5:
	            _a.sent();

	            return [3
	            /*break*/
	            , 7];

	          case 6:
	            e_2 = _a.sent(); // 如果移除 track 时连接被关闭，认为移除 track 成功

	            return [2
	            /*return*/
	            ];

	          case 7:
	            _i = 0, needToRemovedTracksInPC_1 = needToRemovedTracksInPC;
	            _a.label = 8;

	          case 8:
	            if (!(_i < needToRemovedTracksInPC_1.length)) return [3
	            /*break*/
	            , 11];
	            track = needToRemovedTracksInPC_1[_i];
	            logger.debug("[" + this.connectionId + "] remove " + track.trackMediaType + " from pc");
	            return [4
	            /*yield*/
	            , this.pc.removeTrack(track._mediaStreamTrack)];

	          case 9:
	            _a.sent();

	            _a.label = 10;

	          case 10:
	            _i++;
	            return [3
	            /*break*/
	            , 8];

	          case 11:
	            return [4
	            /*yield*/
	            , this.renegotiateWithGateway()];

	          case 12:
	            _a.sent();

	            _a.label = 13;

	          case 13:
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  PubStreamConnection.prototype.startP2PConnection = function () {
	    var _this = this;

	    return new promise$3(function (resolve, reject) {
	      return __awaiter$n(_this, void 0, void 0, function () {
	        var connectionChangeHandler, sdp, message, response, answer, e_3;

	        var _this = this;

	        return __generator$n(this, function (_a) {
	          var _context2;

	          switch (_a.label) {
	            case 0:
	              if (!this.audioTrack && !this.videoTrack) {
	                return [2
	                /*return*/
	                , reject(new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_ERROR, "no track to publish"))];
	              }

	              connectionChangeHandler = function (curr) {
	                if (curr === "connected") {
	                  var _context;

	                  report.publish(_this.joinInfo.sid, {
	                    lts: _this.startTime,
	                    succ: true,
	                    ec: null,
	                    audioName: _this.audioTrack && _this.audioTrack.getTrackLabel(),
	                    videoName: _this.videoTrack && _this.videoTrack.getTrackLabel(),
	                    screenshare: !!(_this.videoTrack && indexOf$3(_context = _this.videoTrack._hints).call(_context, TrackHint.SCREEN_TRACK) !== -1),
	                    audio: !!_this.audioTrack,
	                    video: !!_this.videoTrack,
	                    p2pid: _this.pc.ID,
	                    publishRequestid: _this.ID
	                  });

	                  _this.off(StreamConnectionEvents.CONNECTION_STATE_CHANGE, connectionChangeHandler);

	                  resolve();
	                }
	                /** 说明在连接的过程中中止的了连接 */


	                if (curr === "disconnected") {
	                  _this.off(StreamConnectionEvents.CONNECTION_STATE_CHANGE, connectionChangeHandler);

	                  if (_this.disconnectedReason) {
	                    return reject(_this.disconnectedReason);
	                  }

	                  reject(new AgoraRTCError(AgoraRTCErrorCode.OPERATION_ABORTED, "publish abort"));
	                }
	              };

	              this.on(StreamConnectionEvents.CONNECTION_STATE_CHANGE, connectionChangeHandler);
	              this.disconnectedReason = undefined;
	              this.connectionState = "connecting";
	              this.startTime = now$2();
	              _a.label = 1;

	            case 1:
	              _a.trys.push([1, 11,, 12]);

	              if (!(!this.pc.videoTrack && this.videoTrack)) return [3
	              /*break*/
	              , 3];
	              return [4
	              /*yield*/
	              , this.pc.addTrack(this.videoTrack._mediaStreamTrack)];

	            case 2:
	              _a.sent();

	              _a.label = 3;

	            case 3:
	              if (!(!this.pc.audioTrack && this.audioTrack)) return [3
	              /*break*/
	              , 5];
	              return [4
	              /*yield*/
	              , this.pc.addTrack(this.audioTrack._mediaStreamTrack)];

	            case 4:
	              _a.sent();

	              _a.label = 5;

	            case 5:
	              return [4
	              /*yield*/
	              , this.pc.createOfferSDP()];

	            case 6:
	              sdp = _a.sent();

	              if (this.audioTrack && this.audioTrack._encoderConfig) {
	                sdp = updateSDPWithAudioEncoderConfiguration(sdp, this.audioTrack._encoderConfig);
	              }

	              return [4
	              /*yield*/
	              , this.pc.setOfferSDP(sdp)];

	            case 7:
	              _a.sent();

	              logger.debug("[" + this.connectionId + "] create and set offer success");
	              message = {
	                messageType: "OFFER",
	                sdp: sdp,
	                offererSessionId: 104,
	                retry: true
	              };
	              return [4
	              /*yield*/
	              , emitAsPromise(this, StreamConnectionEvents.NEED_ANSWER, message)];

	            case 8:
	              response = _a.sent();
	              answer = this.updateAnswerSDP(response.sdp);
	              return [4
	              /*yield*/
	              , this.pc.setAnswerSDP(answer)];

	            case 9:
	              _a.sent();

	              logger.debug("[" + this.connectionId + "] set answer success");
	              return [4
	              /*yield*/
	              , this.icePromise];

	            case 10:
	              _a.sent();

	              this.connectionState = "connected";
	              this.startUploadStats();
	              return [3
	              /*break*/
	              , 12];

	            case 11:
	              e_3 = _a.sent();
	              this.off(StreamConnectionEvents.CONNECTION_STATE_CHANGE, connectionChangeHandler);
	              this.connectionState = "disconnected"; // 这里的都是不可恢复的错误

	              report.publish(this.joinInfo.sid, {
	                lts: this.startTime,
	                succ: false,
	                ec: e_3.code,
	                audioName: this.audioTrack && this.audioTrack.getTrackLabel(),
	                videoName: this.videoTrack && this.videoTrack.getTrackLabel(),
	                screenshare: !!(this.videoTrack && indexOf$3(_context2 = this.videoTrack._hints).call(_context2, TrackHint.SCREEN_TRACK) !== -1),
	                audio: !!this.audioTrack,
	                video: !!this.videoTrack,
	                p2pid: this.pc.ID,
	                publishRequestid: this.ID
	              });
	              logger.error("[" + this.connectionId + "] connection error", e_3.toString());
	              reject(e_3);
	              return [3
	              /*break*/
	              , 12];

	            case 12:
	              return [2
	              /*return*/
	              ];
	          }
	        });
	      });
	    });
	  };

	  PubStreamConnection.prototype.closeP2PConnection = function (force) {
	    return __awaiter$n(this, void 0, void 0, function () {
	      var tracks;

	      var _this = this;

	      return __generator$n(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            tracks = this.getAllTracks(); // 如果还有没清完的 track，走 removeTracks 的流程

	            forEach$3(tracks).call(tracks, function (track) {
	              _this.unbindTrackEvents(track);
	            });

	            if (this.isLowStreamConnection && this.videoTrack) {
	              // 销毁小流对象
	              this.videoTrack.close();
	            }

	            this.videoTrack = undefined;

	            if (this.audioTrack instanceof MixingAudioTrack) {
	              var _context3;

	              forEach$3(_context3 = this.audioTrack.trackList).call(_context3, function (track) {
	                _this.audioTrack.removeAudioTrack(track);
	              });
	            }

	            this.audioTrack = undefined;
	            this.stopUploadStats();
	            this.statsCollector.removeConnection(this.connectionId);
	            return [4
	            /*yield*/
	            , this.closePC(force)];

	          case 1:
	            _a.sent();

	            this.connectionState = "disconnected";
	            this.removeAllListeners();
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  PubStreamConnection.prototype.getNetworkQuality = function () {
	    var _context4;

	    var stats = this.pc.getStats();
	    if (!stats.videoSend[0] && !stats.audioSend[0]) return 1;
	    var signalRTT = emitAsInvokerNoResponse(this, StreamConnectionEvents.NEED_SIGNAL_RTT);
	    var videoRTT = stats.videoSend[0] ? stats.videoSend[0].rttMs : undefined;
	    var audioRTT = stats.audioSend[0] ? stats.audioSend[0].rttMs : undefined;
	    var pcRTT = videoRTT && audioRTT ? (videoRTT + audioRTT) / 2 : videoRTT || audioRTT;
	    var meanRTT = (pcRTT && signalRTT ? (pcRTT + signalRTT) / 2 : pcRTT || signalRTT) || 0;
	    var lossRate = stats.sendPacketLossRate;
	    /**
	     * 发布 PC 没有 jitter，统计质量只考虑丢包和 RTT，权值为 7:3
	     * 参考自 https://confluence.agoralab.co/pages/viewpage.action?pageId=624756803
	    */

	    var baseValue = 0.7 * (lossRate * 100) / 50 + 0.3 * meanRTT / 1500;
	    var baseLevel = baseValue < 0.17 ? 1 : baseValue < 0.36 ? 2 : baseValue < 0.59 ? 3 : baseValue < 0.1 ? 4 : 5;

	    if (this.videoTrack && this.videoTrack._encoderConfig && indexOf$3(_context4 = this.videoTrack._hints).call(_context4, TrackHint.SCREEN_TRACK) === -1) {
	      var targetBitrate = this.videoTrack._encoderConfig.bitrateMax;
	      var currentBitrate = stats.bitrate.actualEncoded;

	      if (targetBitrate && currentBitrate) {
	        var bandwidthFactor = (targetBitrate * 1000 - currentBitrate) / (targetBitrate * 1000);
	        var factorIndex = bandwidthFactor < 0.15 ? 0 : bandwidthFactor < 0.3 ? 1 : bandwidthFactor < 0.45 ? 2 : bandwidthFactor < 0.6 ? 3 : 4;
	        var newLevel = BANDWIDTH_FACTOR_TABLE[factorIndex][baseLevel];
	        return newLevel;
	      }
	    }

	    return baseLevel;
	  };

	  PubStreamConnection.prototype.uploadStats = function (stats, lastStats) {
	    var _this = this;

	    var publishAudioStats = this.audioTrack ? getPublishAudioUploadStats(stats, this.audioTrack) : undefined;
	    var publishVideoStats = this.videoTrack ? getPublishVideoUploadStats(stats, this.videoTrack) : undefined;
	    var publishVideoInputStats = getPublishVideoInputStats(stats, lastStats);
	    var publishBandwidthStats = getPublishBandwidthUploadStats(stats);

	    if (publishAudioStats) {
	      nextTick(function () {
	        return _this.emit(StreamConnectionEvents.NEED_UPLOAD, SignalUploadType.PUBLISH_STATS, publishAudioStats);
	      });
	    }

	    if (publishVideoStats) {
	      nextTick(function () {
	        return _this.emit(StreamConnectionEvents.NEED_UPLOAD, SignalUploadType.PUBLISH_STATS, __assign$9(__assign$9({}, publishVideoStats), publishVideoInputStats));
	      });
	    }

	    if (publishBandwidthStats) {
	      nextTick(function () {
	        return _this.emit(StreamConnectionEvents.NEED_UPLOAD, SignalUploadType.PUBLISH_STATS, publishBandwidthStats);
	      });
	    }
	  };

	  PubStreamConnection.prototype.uploadSlowStats = function (stats) {
	    var _this = this;

	    var publishVideoInputStats = getPublishVideoInputStats(stats);

	    if (publishVideoInputStats) {
	      nextTick(function () {
	        return _this.emit(StreamConnectionEvents.NEED_UPLOAD, SignalUploadType.PUBLISH_STATS, publishVideoInputStats);
	      });
	    }
	  };

	  PubStreamConnection.prototype.uploadRelatedStats = function (stats) {
	    var _this = this;

	    var videoRelatedStats = getPublishVideoRelatedUploadStats(stats);

	    if (videoRelatedStats) {
	      nextTick(function () {
	        _this.emit(StreamConnectionEvents.NEED_UPLOAD, SignalUploadType.PUBLISH_RELATED_STATS, videoRelatedStats);
	      });
	    }
	  };

	  PubStreamConnection.prototype.bindTrackEvents = function (track) {
	    /** 小流连接不处理 p2p 事件，因为用户不会操作小流对象 */
	    if (this.isLowStreamConnection) return;

	    if (track instanceof LocalAudioTrack) {
	      track.addListener(TrackInternalEvent.GET_STATS, this.handleGetLocalAudioStats);
	      track.addListener(TrackInternalEvent.NEED_CLOSE, this.handleCloseAudioTrack);
	    } else if (track instanceof LocalVideoTrack) {
	      track.addListener(TrackInternalEvent.GET_STATS, this.handleGetLocalVideoStats);
	      track.addListener(TrackInternalEvent.NEED_CLOSE, this.handleCloseVideoTrack);
	    }

	    track.addListener(TrackInternalEvent.NEED_RENEGOTIATE, this.handleStreamRenegotiate);
	    track.addListener(TrackInternalEvent.NEED_REPLACE_TRACK, this.handleReplaceTrack);
	    track.addListener(TrackInternalEvent.NEED_SESSION_ID, this.handleGetSessionID);
	  };

	  PubStreamConnection.prototype.unbindTrackEvents = function (track) {
	    if (this.isLowStreamConnection) return;

	    if (track instanceof LocalAudioTrack) {
	      track.off(TrackInternalEvent.GET_STATS, this.handleGetLocalAudioStats);
	      track.off(TrackInternalEvent.NEED_CLOSE, this.handleCloseAudioTrack);
	    } else if (track instanceof LocalVideoTrack) {
	      track.off(TrackInternalEvent.GET_STATS, this.handleGetLocalVideoStats);
	      track.off(TrackInternalEvent.NEED_CLOSE, this.handleCloseVideoTrack);
	    }

	    track.off(TrackInternalEvent.NEED_RENEGOTIATE, this.handleStreamRenegotiate);
	    track.off(TrackInternalEvent.NEED_REPLACE_TRACK, this.handleReplaceTrack);
	    track.off(TrackInternalEvent.NEED_SESSION_ID, this.handleGetSessionID);
	  };
	  /** 返回值代表是否需要重协商 */


	  PubStreamConnection.prototype.addTrackWithPC = function (track) {
	    return __awaiter$n(this, void 0, void 0, function () {
	      var error, lastVideoTrack, needRenegotiate, compat, encoderParams, mode;
	      return __generator$n(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            if (this.connectionState === "connecting") {
	              error = new AgoraRTCError(AgoraRTCErrorCode.INVALID_OPERATION, "last publish operation has not finished");
	              return [2
	              /*return*/
	              , error.throw()];
	            }

	            lastVideoTrack = this.videoTrack;
	            needRenegotiate = false;
	            if (!(this.audioTrack && track instanceof LocalAudioTrack)) return [3
	            /*break*/
	            , 2];
	            this.audioTrack = track;
	            logger.debug("[" + this.connectionId + "] replace pc audio track");
	            return [4
	            /*yield*/
	            , this.pc.replaceTrack(track._mediaStreamTrack)];

	          case 1:
	            needRenegotiate = _a.sent();
	            return [3
	            /*break*/
	            , 8];

	          case 2:
	            if (!(this.videoTrack && track instanceof LocalVideoTrack)) return [3
	            /*break*/
	            , 4];
	            this.videoTrack = track;
	            logger.debug("[" + this.connectionId + "] replace pc video track");
	            return [4
	            /*yield*/
	            , this.pc.replaceTrack(track._mediaStreamTrack)];

	          case 3:
	            needRenegotiate = _a.sent();
	            return [3
	            /*break*/
	            , 8];

	          case 4:
	            if (!(track instanceof LocalAudioTrack)) return [3
	            /*break*/
	            , 6];
	            this.audioTrack = track;
	            logger.debug("[" + this.connectionId + "] add audio track to pc");
	            return [4
	            /*yield*/
	            , this.pc.addTrack(track._mediaStreamTrack)];

	          case 5:
	            _a.sent();

	            needRenegotiate = true;
	            return [3
	            /*break*/
	            , 8];

	          case 6:
	            if (!(track instanceof LocalVideoTrack)) return [3
	            /*break*/
	            , 8];
	            this.videoTrack = track;
	            logger.debug("[" + this.connectionId + "] add video track to pc");
	            return [4
	            /*yield*/
	            , this.pc.addTrack(track._mediaStreamTrack)];

	          case 7:
	            _a.sent();

	            needRenegotiate = true;
	            _a.label = 8;

	          case 8:
	            compat = getCompatibility();
	            if (!(this.videoTrack !== lastVideoTrack && this.videoTrack && compat.supportSetRtpSenderParameters)) return [3
	            /*break*/
	            , 10];
	            encoderParams = {};
	            mode = "balanced";

	            if (this.videoTrack._encoderConfig) {
	              encoderParams.maxBitrate = this.videoTrack._encoderConfig.bitrateMax ? this.videoTrack._encoderConfig.bitrateMax * 1000 : undefined;
	            }

	            if (this.videoTrack._optimizationMode === "motion") {
	              mode = "maintain-framerate";
	            } else if (this.videoTrack._optimizationMode === "detail") {
	              mode = "maintain-resolution";
	            }

	            logger.debug("[" + this.connectionId + "] set pc rtp sender", encoderParams, mode);
	            return [4
	            /*yield*/
	            , this.pc.setRtpSenderParameters(encoderParams, mode)];

	          case 9:
	            _a.sent();

	            _a.label = 10;

	          case 10:
	            return [2
	            /*return*/
	            , this.connectionState === "disconnected" ? false : needRenegotiate];
	        }
	      });
	    });
	  };

	  PubStreamConnection.prototype.updateAnswerSDP = function (sdp) {
	    var _context5, _context6;

	    /** replace Track 到 screen 的时候，这个标签不会重置，帧率会被固定到 5 */
	    sdp = sdp.replace(/a=x-google-flag:conference\r\n/g, "");

	    if (this.videoTrack && indexOf$3(_context5 = this.videoTrack._hints).call(_context5, TrackHint.SCREEN_TRACK) !== -1) ;

	    if (this.videoTrack && this.videoTrack._encoderConfig && indexOf$3(_context6 = this.videoTrack._hints).call(_context6, TrackHint.SCREEN_TRACK) === -1) {
	      sdp = updateAnswerSDPWithVideoEncoderConfiguration(sdp, this.codec, this.videoTrack._encoderConfig);
	    }

	    if (this.audioTrack && this.audioTrack._encoderConfig) {
	      sdp = updateSDPWithAudioEncoderConfiguration(sdp, this.audioTrack._encoderConfig);
	    }

	    sdp = removeSafariOrientationExtensionFromAnswer(sdp);
	    return sdp;
	  };

	  PubStreamConnection.prototype.createPC = function () {
	    this.pc = new PubRTCPeerConnection({
	      turnServer: this.joinInfo.turnServer
	    });
	    this.updateICEPromise();
	  };

	  PubStreamConnection.prototype.closePC = function (force) {
	    return __awaiter$n(this, void 0, void 0, function () {
	      return __generator$n(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            this.pc.onICEConnectionStateChange = undefined;
	            this.pc.close();
	            if (!!force) return [3
	            /*break*/
	            , 2];
	            return [4
	            /*yield*/
	            , emitAsPromise(this, StreamConnectionEvents.NEED_UNPUB)];

	          case 1:
	            return [2
	            /*return*/
	            , _a.sent()];

	          case 2:
	            return [2
	            /*return*/
	            , false];
	        }
	      });
	    });
	  };

	  PubStreamConnection.prototype.onPCDisconnected = function (reason) {
	    var _context7;

	    report.publish(this.joinInfo.sid, {
	      lts: this.startTime,
	      succ: false,
	      ec: reason.code,
	      audioName: this.audioTrack && this.audioTrack.getTrackLabel(),
	      videoName: this.videoTrack && this.videoTrack.getTrackLabel(),
	      screenshare: !!(this.videoTrack && indexOf$3(_context7 = this.videoTrack._hints).call(_context7, TrackHint.SCREEN_TRACK) !== -1),
	      audio: !!this.audioTrack,
	      video: !!this.videoTrack,
	      p2pid: this.pc.ID,
	      publishRequestid: this.ID
	    });
	  };

	  return PubStreamConnection;
	}(StreamConnection);

	var __extends$k = undefined && undefined.__extends || function () {
	  var extendStatics = function (d, b) {
	    extendStatics = setPrototypeOf$2 || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    };

	    return extendStatics(d, b);
	  };

	  return function (d, b) {
	    extendStatics(d, b);

	    function __() {
	      this.constructor = d;
	    }

	    d.prototype = b === null ? create$4(b) : (__.prototype = b.prototype, new __());
	  };
	}();

	var __assign$a = undefined && undefined.__assign || function () {
	  __assign$a = assign$2 || function (t) {
	    for (var s, i = 1, n = arguments.length; i < n; i++) {
	      s = arguments[i];

	      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	    }

	    return t;
	  };

	  return __assign$a.apply(this, arguments);
	};

	var __awaiter$o = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = promise$3))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var __generator$o = undefined && undefined.__generator || function (thisArg, body) {
	  var _ = {
	    label: 0,
	    sent: function () {
	      if (t[0] & 1) throw t[1];
	      return t[1];
	    },
	    trys: [],
	    ops: []
	  },
	      f,
	      y,
	      t,
	      g;
	  return g = {
	    next: verb(0),
	    "throw": verb(1),
	    "return": verb(2)
	  }, typeof symbol$2 === "function" && (g[iterator$2] = function () {
	    return this;
	  }), g;

	  function verb(n) {
	    return function (v) {
	      return step([n, v]);
	    };
	  }

	  function step(op) {
	    if (f) throw new TypeError("Generator is already executing.");

	    while (_) try {
	      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	      if (y = 0, t) op = [op[0] & 2, t.value];

	      switch (op[0]) {
	        case 0:
	        case 1:
	          t = op;
	          break;

	        case 4:
	          _.label++;
	          return {
	            value: op[1],
	            done: false
	          };

	        case 5:
	          _.label++;
	          y = op[1];
	          op = [0];
	          continue;

	        case 7:
	          op = _.ops.pop();

	          _.trys.pop();

	          continue;

	        default:
	          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
	            _ = 0;
	            continue;
	          }

	          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
	            _.label = op[1];
	            break;
	          }

	          if (op[0] === 6 && _.label < t[1]) {
	            _.label = t[1];
	            t = op;
	            break;
	          }

	          if (t && _.label < t[2]) {
	            _.label = t[2];

	            _.ops.push(op);

	            break;
	          }

	          if (t[2]) _.ops.pop();

	          _.trys.pop();

	          continue;
	      }

	      op = body.call(thisArg, _);
	    } catch (e) {
	      op = [6, e];
	      y = 0;
	    } finally {
	      f = t = 0;
	    }

	    if (op[0] & 5) throw op[1];
	    return {
	      value: op[0] ? op[1] : void 0,
	      done: true
	    };
	  }
	};

	var RemoteTrack =
	/** @class */
	function (_super) {
	  __extends$k(RemoteTrack, _super);

	  function RemoteTrack(track, userId, uintId) {
	    var _this = _super.call(this, track) || this;

	    _this._isDestroyed = false;
	    _this._userId = userId;
	    _this._uintId = uintId;
	    return _this;
	  }

	  RemoteTrack.prototype.getUserId = function () {
	    return this._userId;
	  };

	  RemoteTrack.prototype._updateOriginMediaStreamTrack = function (track) {
	    this._originMediaStreamTrack = track;
	    this._mediaStreamTrack = track;

	    this._updatePlayerSource();
	  };

	  RemoteTrack.prototype._destroy = function () {
	    this._isDestroyed = true;
	    logger.info("[track-" + this.getTrackId() + "] is destroyed");
	    this.stop();
	  };

	  return RemoteTrack;
	}(Track);

	var RemoteVideoTrack =
	/** @class */
	function (_super) {
	  __extends$k(RemoteVideoTrack, _super);

	  function RemoteVideoTrack(track, userId, uintId) {
	    var _this = _super.call(this, track, userId, uintId) || this;

	    _this.trackMediaType = "video";
	    checkMediaStreamTrackResolution(track).then(function (_a) {
	      var width = _a[0],
	          height = _a[1];
	      _this._videoHeight = height;
	      _this._videoWidth = width;
	    }).catch(noop$1);
	    return _this;
	  }

	  defineProperty$4(RemoteVideoTrack.prototype, "isPlaying", {
	    get: function () {
	      return !!this._player;
	    },
	    enumerable: true,
	    configurable: true
	  });

	  RemoteVideoTrack.prototype.getStats = function () {
	    runOnce(function () {
	      logger.warning("[deprecated] RemoteVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteVideoStats instead");
	    }, "remoteVideoTrackGetStatsWarning");
	    var res = emitAsInvokerNoResponse(this, TrackInternalEvent.GET_STATS);
	    return res || __assign$a({}, DEFAULT_REMOTE_VIDEO_TRACK_STATS);
	  };

	  RemoteVideoTrack.prototype.play = function (element, config) {
	    var _this = this;

	    if (config === void 0) {
	      config = {};
	    }

	    var executor = report.reportApiInvoke(null, {
	      tag: AgoraAPITag.TRACER,
	      name: AgoraAPIName.REMOTE_VIDEO_TRACK_PLAY,
	      options: [this.getTrackId(), typeof element === "string" ? element : "HTMLElement", config]
	    });

	    if (typeof element === "string") {
	      var htmlElement = document.getElementById(element);

	      if (!htmlElement) {
	        logger.warning("[track-" + this.getTrackId() + "] can not find \"#" + element + "\" element, use document.body");
	        element = document.body;
	      } else {
	        element = htmlElement;
	      }
	    }

	    logger.debug("[track-" + this.getTrackId() + "] start video playback", stringify$2(config));

	    var playerConfig = __assign$a(__assign$a({
	      fit: "cover"
	    }, config), {
	      trackId: this.getTrackId(),
	      element: element
	    });

	    if (!this._player) {
	      // this._player = new AgoraRTCPlayer(playerConfig);
	      this._player = new NativeVideoplayer(playerConfig);

	      this._player.updateVideoTrack(this._mediaStreamTrack);

	      this._player.onFirstVideoFrameDecoded = function () {
	        _this.emit(RemoteTrackEvents.FIRST_FRAME_DECODED);
	      };
	    } else {
	      this._player.updateConfig(playerConfig);
	    }

	    this._player.play();

	    executor.onSuccess();
	  };

	  RemoteVideoTrack.prototype.stop = function () {
	    var executor = report.reportApiInvoke(null, {
	      tag: AgoraAPITag.TRACER,
	      name: AgoraAPIName.REMOTE_VIDEO_TRACK_STOP,
	      options: [this.getTrackId()]
	    });
	    if (!this._player) return executor.onSuccess();

	    this._player.destroy();

	    this._player = undefined;
	    logger.debug("[track-" + this.getTrackId() + "] stop video playback");
	    executor.onSuccess();
	  };

	  RemoteVideoTrack.prototype.getCurrentFrameData = function () {
	    if (!this._player) {
	      return new ImageData(2, 2);
	    }

	    return this._player.getCurrentFrame();
	  };

	  RemoteVideoTrack.prototype._updatePlayerSource = function () {
	    logger.debug("[track-" + this.getTrackId() + "] update player source track");
	    if (!this._player) return;

	    this._player.updateVideoTrack(this._mediaStreamTrack);
	  };

	  return RemoteVideoTrack;
	}(RemoteTrack);

	var RemoteAudioTrack =
	/** @class */
	function (_super) {
	  __extends$k(RemoteAudioTrack, _super);

	  function RemoteAudioTrack(track, userId, uintId) {
	    var _this = _super.call(this, track, userId, uintId) || this;

	    _this.trackMediaType = "audio";
	    _this._useAudioElement = false;
	    _this._source = new NativeAudioTrack(track, true);

	    _this._source.once(AudioSourceEvents.RECEIVE_TRACK_BUFFER, function () {
	      _this.emit(RemoteTrackEvents.FIRST_FRAME_DECODED);
	    });

	    var compatibility = getCompatibility();

	    if (!compatibility.webAudioWithAEC) {
	      _this._useAudioElement = true;
	    }

	    return _this;
	  }

	  defineProperty$4(RemoteAudioTrack.prototype, "isPlaying", {
	    get: function () {
	      return this._useAudioElement ? audioElementPlayCenter.isPlaying(this.getTrackId()) : this._source.isPlayed;
	    },
	    enumerable: true,
	    configurable: true
	  });

	  RemoteAudioTrack.prototype.setAudioFrameCallback = function (callback, frameSize) {
	    if (frameSize === void 0) {
	      frameSize = 4096;
	    }

	    if (!callback) {
	      this._source.removeAllListeners(AudioSourceEvents.ON_AUDIO_BUFFER);

	      this._source.stopGetAudioBuffer();

	      return;
	    }

	    this._source.startGetAudioBuffer(frameSize);

	    this._source.removeAllListeners(AudioSourceEvents.ON_AUDIO_BUFFER);

	    this._source.on(AudioSourceEvents.ON_AUDIO_BUFFER, function (buffer) {
	      return callback(buffer);
	    });
	  };

	  RemoteAudioTrack.prototype.setVolume = function (volume) {
	    var executor = report.reportApiInvoke(null, {
	      tag: AgoraAPITag.TRACER,
	      name: AgoraAPIName.REMOTE_AUDIO_SET_VOLUME,
	      options: [this.getTrackId(), volume]
	    }, 300);

	    if (this._useAudioElement) {
	      audioElementPlayCenter.setVolume(this.getTrackId(), volume);
	    } else {
	      this._source.setVolume(volume / 100);
	    }

	    executor.onSuccess();
	  };

	  RemoteAudioTrack.prototype.setPlaybackDevice = function (deviceId) {
	    return __awaiter$o(this, void 0, void 0, function () {
	      var executor, e_1;
	      return __generator$o(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            executor = report.reportApiInvoke(null, {
	              tag: AgoraAPITag.TRACER,
	              name: AgoraAPIName.REMOTE_AUDIO_SET_OUTPUT_DEVICE,
	              options: [this.getTrackId(), deviceId]
	            });

	            if (!this._useAudioElement) {
	              throw new AgoraRTCError(AgoraRTCErrorCode.NOT_SUPPORTED, "your browser does not support setting the audio output device");
	            }

	            _a.label = 1;

	          case 1:
	            _a.trys.push([1, 3,, 4]);

	            return [4
	            /*yield*/
	            , audioElementPlayCenter.setSinkID(this.getTrackId(), deviceId)];

	          case 2:
	            _a.sent();

	            return [3
	            /*break*/
	            , 4];

	          case 3:
	            e_1 = _a.sent();
	            executor.onError(e_1);
	            throw e_1;

	          case 4:
	            executor.onSuccess();
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  RemoteAudioTrack.prototype.getVolumeLevel = function () {
	    return this._source.getAudioLevel();
	  };

	  RemoteAudioTrack.prototype.getStats = function () {
	    runOnce(function () {
	      logger.warning("[deprecated] RemoteAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteAudioStats instead");
	    }, "remoteAudioTrackGetStatsWarning");
	    var res = emitAsInvokerNoResponse(this, TrackInternalEvent.GET_STATS);
	    return res || __assign$a({}, DEFAULT_REMOTE_AUDIO_TRACK_STATS);
	  };

	  RemoteAudioTrack.prototype.play = function () {
	    var executor = report.reportApiInvoke(null, {
	      tag: AgoraAPITag.TRACER,
	      name: AgoraAPIName.REMOTE_AUDIO_TRACK_PLAY,
	      options: [this.getTrackId()]
	    });
	    logger.debug("[" + this.getTrackId() + "] start audio playback");

	    if (this._useAudioElement) {
	      logger.debug("[track-" + this.getTrackId() + "] use audio element to play");
	      audioElementPlayCenter.play(this._mediaStreamTrack, this.getTrackId());
	    } else {
	      this._source.play();
	    }

	    executor.onSuccess();
	  };

	  RemoteAudioTrack.prototype.stop = function () {
	    var executor = report.reportApiInvoke(null, {
	      tag: AgoraAPITag.TRACER,
	      name: AgoraAPIName.REMOTE_AUDIO_TRACK_STOP,
	      options: [this.getTrackId()]
	    });
	    logger.debug("[" + this.getTrackId() + "] stop audio playback");

	    if (this._useAudioElement) {
	      audioElementPlayCenter.stop(this.getTrackId());
	    } else {
	      this._source.stop();
	    }

	    executor.onSuccess();
	  };

	  RemoteAudioTrack.prototype._destroy = function () {
	    _super.prototype._destroy.call(this);

	    this._source.destroy();
	  };

	  RemoteAudioTrack.prototype._isFreeze = function () {
	    return this._source.isFreeze;
	  };

	  RemoteAudioTrack.prototype._updatePlayerSource = function () {
	    logger.debug("[track-" + this.getTrackId() + "] update player source track");

	    this._source.updateTrack(this._mediaStreamTrack);

	    if (this._useAudioElement) {
	      audioElementPlayCenter.updateTrack(this.getTrackId(), this._mediaStreamTrack);
	    }
	  };

	  return RemoteAudioTrack;
	}(RemoteTrack);

	var __extends$l = undefined && undefined.__extends || function () {
	  var extendStatics = function (d, b) {
	    extendStatics = setPrototypeOf$2 || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    };

	    return extendStatics(d, b);
	  };

	  return function (d, b) {
	    extendStatics(d, b);

	    function __() {
	      this.constructor = d;
	    }

	    d.prototype = b === null ? create$4(b) : (__.prototype = b.prototype, new __());
	  };
	}();

	var __awaiter$p = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = promise$3))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var __generator$p = undefined && undefined.__generator || function (thisArg, body) {
	  var _ = {
	    label: 0,
	    sent: function () {
	      if (t[0] & 1) throw t[1];
	      return t[1];
	    },
	    trys: [],
	    ops: []
	  },
	      f,
	      y,
	      t,
	      g;
	  return g = {
	    next: verb(0),
	    "throw": verb(1),
	    "return": verb(2)
	  }, typeof symbol$2 === "function" && (g[iterator$2] = function () {
	    return this;
	  }), g;

	  function verb(n) {
	    return function (v) {
	      return step([n, v]);
	    };
	  }

	  function step(op) {
	    if (f) throw new TypeError("Generator is already executing.");

	    while (_) try {
	      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	      if (y = 0, t) op = [op[0] & 2, t.value];

	      switch (op[0]) {
	        case 0:
	        case 1:
	          t = op;
	          break;

	        case 4:
	          _.label++;
	          return {
	            value: op[1],
	            done: false
	          };

	        case 5:
	          _.label++;
	          y = op[1];
	          op = [0];
	          continue;

	        case 7:
	          op = _.ops.pop();

	          _.trys.pop();

	          continue;

	        default:
	          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
	            _ = 0;
	            continue;
	          }

	          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
	            _.label = op[1];
	            break;
	          }

	          if (op[0] === 6 && _.label < t[1]) {
	            _.label = t[1];
	            t = op;
	            break;
	          }

	          if (t && _.label < t[2]) {
	            _.label = t[2];

	            _.ops.push(op);

	            break;
	          }

	          if (t[2]) _.ops.pop();

	          _.trys.pop();

	          continue;
	      }

	      op = body.call(thisArg, _);
	    } catch (e) {
	      op = [6, e];
	      y = 0;
	    } finally {
	      f = t = 0;
	    }

	    if (op[0] & 5) throw op[1];
	    return {
	      value: op[0] ? op[1] : void 0,
	      done: true
	    };
	  }
	};
	/**
	 * Stream connection 是当 Stream 被用于 发布/订阅 时的一种抽象形式
	 * 专门用来将 Stream 对象和 PCConnection 对象结偶
	 */

	var SubStreamConnection =
	/** @class */
	function (_super) {
	  __extends$l(SubStreamConnection, _super);

	  function SubStreamConnection(user, statsCollector, joinInfo, subOptions) {
	    var _this = _super.call(this, joinInfo, user.uid) || this;

	    _this.type = "sub";
	    /**
	     * 虽然有时候只订阅了音频流，但是我们还是会从网关收到视频 Track
	     * 只不过这个视频 Track 没有数据，但是未来如果用户更改了订阅配置，网关就会向这个视频 Track 发送数据
	     *
	     * 如果通过 ontrack 收到了这种预期外的 Track，就将这些 Track 保存在这个地方
	     */

	    _this.unusedTracks = [];

	    _this.onTrack = function (track) {
	      if (track.kind === "audio" && !_this.subscribeOptions.audio || track.kind === "video" && !_this.subscribeOptions.video) {
	        // 收到了预期之外的流，可能是网关的问题，忽略
	        _this.unusedTracks.push(track);

	        logger.debug("[" + _this.connectionId + "] unused ontrack event, kind: " + track.kind);
	        return;
	      }

	      logger.debug("[" + _this.connectionId + "] emit pc ontrack after subscribe " + track.kind, track);
	      var oldTrack = track.kind === "audio" ? _this.user._audioTrack : _this.user._videoTrack;

	      if (oldTrack) {
	        oldTrack._updateOriginMediaStreamTrack(track);
	      } else {
	        if (track.kind === "audio") ; else {
	          _this.user._videoTrack = new RemoteVideoTrack(track, _this.getUserId(), _this.user._uintid);
	          logger.info("[" + _this.connectionId + "] create remote video track: " + _this.user._videoTrack.getTrackId());

	          _this.bindTrackEvents(_this.user._videoTrack);
	        }
	      }
	    };

	    _this.handleGetRemoteAudioStats = function (callback) {
	      callback(_this.statsCollector.getRemoteAudioTrackStats(_this.connectionId));
	    };

	    _this.handleGetRemoteVideoStats = function (callback) {
	      callback(_this.statsCollector.getRemoteVideoTrackStats(_this.connectionId));
	    };

	    _this.handleGetSessionID = function (callback) {
	      callback(_this.joinInfo.sid);
	    };

	    _this.user = user;
	    _this.statsCollector = statsCollector;

	    _this.statsCollector.addRemoteConnection(_this);

	    _this.subscribeOptions = subOptions;
	    return _this;
	  }

	  SubStreamConnection.prototype.startP2PConnection = function () {
	    return __awaiter$p(this, void 0, void 0, function () {
	      var _this = this;

	      return __generator$p(this, function (_a) {
	        return [2
	        /*return*/
	        , new promise$3(function (resolve, reject) {
	          return __awaiter$p(_this, void 0, void 0, function () {
	            var connectionChangeHandler, remoteMediaStream, onStreamPromise, sdp, _a, message, response, res, audioMediaTrack, videoMediaTrack, e_1;

	            var _this = this;

	            return __generator$p(this, function (_b) {
	              switch (_b.label) {
	                case 0:
	                  connectionChangeHandler = function (curr) {
	                    if (curr === "connected") {
	                      report.subscribe(_this.joinInfo.sid, {
	                        lts: _this.startTime,
	                        succ: true,
	                        video: _this.subscribeOptions.video,
	                        audio: _this.subscribeOptions.audio,
	                        peerid: _this.user.uid,
	                        ec: null,
	                        subscribeRequestid: _this.ID,
	                        p2pid: _this.pc.ID
	                      });

	                      _this.off(StreamConnectionEvents.CONNECTION_STATE_CHANGE, connectionChangeHandler);

	                      resolve();
	                    }
	                    /** 说明在连接的过程中中止的了连接 */


	                    if (curr === "disconnected") {
	                      _this.off(StreamConnectionEvents.CONNECTION_STATE_CHANGE, connectionChangeHandler);

	                      if (_this.disconnectedReason) {
	                        return reject(_this.disconnectedReason);
	                      }

	                      reject(new AgoraRTCError(AgoraRTCErrorCode.OPERATION_ABORTED, "subscribe abort"));
	                    }
	                  };

	                  this.on(StreamConnectionEvents.CONNECTION_STATE_CHANGE, connectionChangeHandler);
	                  this.disconnectedReason = undefined;
	                  this.connectionState = "connecting";
	                  this.startTime = now$2();

	                  if (!this.subscribeOptions) {
	                    reject(new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_ERROR, "no subscribe options"));
	                    return [2
	                    /*return*/
	                    ];
	                  }

	                  remoteMediaStream = new MediaStream();
	                  onStreamPromise = new promise$3(function (resolve) {
	                    _this.pc.onTrack = function (track, stream) {
	                      if (track.kind === "audio" && !_this.subscribeOptions.audio || track.kind === "video" && !_this.subscribeOptions.video) {
	                        // 收到了预期之外的流，暂时保存在这里
	                        _this.unusedTracks.push(track);

	                        logger.debug("[" + _this.connectionId + "] unused ontrack event " + track.kind);
	                        return;
	                      }

	                      remoteMediaStream.addTrack(track);
	                      var currentTrackFlag = {
	                        audio: remoteMediaStream.getAudioTracks().length > 0,
	                        video: remoteMediaStream.getVideoTracks().length > 0
	                      };
	                      logger.debug("[" + _this.connectionId + "] subscribe ontrack: " + track.kind, stream, track);

	                      if (checkIsEqual(currentTrackFlag, _this.subscribeOptions)) {
	                        /**
	                         * 当第一次订阅的 track 收集完毕后，将 `this.pc.onTrack` 指向内部的 `onTrack` 处理方法
	                         * 用于处理远端 `update_stream` 或者本地 `subscribe_change` 的情况
	                         */
	                        _this.pc.onTrack = _this.onTrack;
	                        logger.debug("[" + _this.connectionId + "] get all subscribed tracks");
	                        resolve(remoteMediaStream);
	                      }
	                    };
	                  });
	                  _b.label = 1;

	                case 1:
	                  _b.trys.push([1, 7,, 8]);

	                  _a = addStereoSupportToSDP;
	                  return [4
	                  /*yield*/
	                  , this.pc.createOfferSDP()];

	                case 2:
	                  sdp = _a.apply(void 0, [_b.sent()]);
	                  return [4
	                  /*yield*/
	                  , this.pc.setOfferSDP(sdp)];

	                case 3:
	                  _b.sent();

	                  logger.debug("[" + this.connectionId + "] create and set offer success");
	                  message = {
	                    messageType: "OFFER",
	                    sdp: sdp,
	                    offererSessionId: 104,
	                    retry: true
	                  };
	                  return [4
	                  /*yield*/
	                  , emitAsPromise(this, StreamConnectionEvents.NEED_ANSWER, message)];

	                case 4:
	                  response = _b.sent();
	                  return [4
	                  /*yield*/
	                  , this.pc.setAnswerSDP(addStereoSupportToSDP(response.sdp))];

	                case 5:
	                  _b.sent();

	                  logger.debug("[" + this.connectionId + "] set answer success");
	                  return [4
	                  /*yield*/
	                  , promise$3.all([onStreamPromise, this.icePromise])];

	                case 6:
	                  res = _b.sent();
	                  audioMediaTrack = res[0].getAudioTracks()[0];
	                  videoMediaTrack = res[0].getVideoTracks()[0];

	                  if (audioMediaTrack) {
	                    if (!this.user._audioTrack) {
	                      this.user._audioTrack = new RemoteAudioTrack(audioMediaTrack, this.getUserId(), this.user._uintid);
	                      logger.info("[" + this.connectionId + "] create remote audio track: " + this.user._audioTrack.getTrackId());
	                      this.bindTrackEvents(this.user._audioTrack);
	                    } else {
	                      this.user._audioTrack._updateOriginMediaStreamTrack(audioMediaTrack);
	                    }
	                  }

	                  if (videoMediaTrack) {
	                    if (!this.user._videoTrack) {
	                      this.user._videoTrack = new RemoteVideoTrack(videoMediaTrack, this.getUserId(), this.user._uintid);
	                      logger.info("[" + this.connectionId + "] create remote video track: " + this.user._videoTrack.getTrackId());
	                      this.bindTrackEvents(this.user._videoTrack);
	                    } else {
	                      this.user._videoTrack._updateOriginMediaStreamTrack(videoMediaTrack);
	                    }
	                  }

	                  this.connectionState = "connected";
	                  this.startUploadStats();
	                  return [3
	                  /*break*/
	                  , 8];

	                case 7:
	                  e_1 = _b.sent();
	                  this.off(StreamConnectionEvents.CONNECTION_STATE_CHANGE, connectionChangeHandler);
	                  this.connectionState = "disconnected";
	                  report.subscribe(this.joinInfo.sid, {
	                    lts: this.startTime,
	                    succ: false,
	                    video: this.subscribeOptions.video,
	                    audio: this.subscribeOptions.audio,
	                    peerid: this.user.uid,
	                    ec: e_1.code,
	                    subscribeRequestid: this.ID,
	                    p2pid: this.pc.ID
	                  });
	                  reject(e_1);
	                  return [3
	                  /*break*/
	                  , 8];

	                case 8:
	                  return [2
	                  /*return*/
	                  ];
	              }
	            });
	          });
	        })];
	      });
	    });
	  };

	  SubStreamConnection.prototype.closeP2PConnection = function (force) {
	    return __awaiter$p(this, void 0, void 0, function () {
	      return __generator$p(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            if (this.connectionState === "disconnected") return [2
	            /*return*/
	            ];
	            this.stopUploadStats();
	            this.statsCollector.removeConnection(this.connectionId);
	            this.connectionState = "disconnected";
	            return [4
	            /*yield*/
	            , this.setSubscribeOptions({
	              audio: false,
	              video: false
	            })];

	          case 1:
	            _a.sent();

	            return [4
	            /*yield*/
	            , this.closePC(force)];

	          case 2:
	            _a.sent();

	            this.removeAllListeners();
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  SubStreamConnection.prototype.getNetworkQuality = function () {
	    var stats = this.pc.getStats();
	    if (!stats.audioRecv[0] && !stats.videoRecv[0]) return 1;
	    var signalRTT = emitAsInvokerNoResponse(this, StreamConnectionEvents.NEED_SIGNAL_RTT);
	    var pcRTT = stats.rtt;
	    var meanRTT = (pcRTT && signalRTT ? (pcRTT + signalRTT) / 2 : pcRTT || signalRTT) || 0;
	    var jitter = stats.audioRecv[0] ? stats.audioRecv[0].jitterMs : undefined;
	    var lossRate = stats.recvPacketLossRate;
	    var baseValue = 0.7 * lossRate * 100 / 50 + 0.3 * meanRTT / 1500;

	    if (jitter) {
	      baseValue = 0.6 * lossRate * 100 / 50 + 0.2 * meanRTT / 1500 + 0.2 * jitter / 400;
	    }

	    var baseLevel = baseValue < 0.1 ? 1 : baseValue < 0.17 ? 2 : baseValue < 0.36 ? 3 : baseValue < 0.59 ? 4 : 5;
	    return baseLevel;
	  };

	  SubStreamConnection.prototype.uploadStats = function (stats) {
	    var _this = this;

	    var subscribeAudioStats = this.user.audioTrack ? getSubscribeAudioUploadStats(stats, this.user.audioTrack) : undefined;
	    var subscribeVideoStats = this.user.videoTrack ? getSubscribeVideoUploadStats(stats, this.user.videoTrack) : undefined;

	    if (subscribeAudioStats) {
	      nextTick(function () {
	        return _this.emit(StreamConnectionEvents.NEED_UPLOAD, SignalUploadType.SUBSCRIBE_STATS, subscribeAudioStats);
	      });
	    }

	    if (subscribeVideoStats) {
	      nextTick(function () {
	        return _this.emit(StreamConnectionEvents.NEED_UPLOAD, SignalUploadType.SUBSCRIBE_STATS, subscribeVideoStats);
	      });
	    }
	  };

	  SubStreamConnection.prototype.uploadSlowStats = function (stats) {// not implement
	  };

	  SubStreamConnection.prototype.uploadRelatedStats = function (stats, lastStats) {
	    var _this = this;

	    var audioRelatedStats = getSubscribeAudioRelatedUploadStats(stats, this.getUserId(), this.user.audioTrack);
	    var videoRelatedStats = getSubscribeVideoRelatedUploadStats(stats, this.getUserId(), lastStats, this.user.videoTrack);

	    if (audioRelatedStats) {
	      nextTick(function () {
	        _this.emit(StreamConnectionEvents.NEED_UPLOAD, SignalUploadType.SUBSCRIBE_RELATED_STATS, audioRelatedStats);
	      });
	    }

	    if (videoRelatedStats) {
	      nextTick(function () {
	        _this.emit(StreamConnectionEvents.NEED_UPLOAD, SignalUploadType.SUBSCRIBE_RELATED_STATS, videoRelatedStats);
	      });
	    }
	  };
	  /**
	   * 表示对端的音视频发布状态已经变更了，但是因为网关的实现我们无法从 pc.ontrack 里动态获取这个状态更变
	   *
	   * 这里就通过保存的 unusedTracks 来模拟 onTrack 事件
	   */


	  SubStreamConnection.prototype.emitOnTrackFromUnusedTracks = function () {
	    if (!this.subscribeOptions) return;
	    var needVideoTrack = this.subscribeOptions.video;
	    var needAudioTrack = this.subscribeOptions.audio;

	    if (needAudioTrack) {
	      var _context;

	      var track = find$2(_context = this.unusedTracks).call(_context, function (t) {
	        return t.kind === "audio" && t.readyState === "live";
	      });

	      removeItemFromList(this.unusedTracks, track);
	      track && this.onTrack(track);
	    }

	    if (needVideoTrack) {
	      var _context2;

	      var track = find$2(_context2 = this.unusedTracks).call(_context2, function (t) {
	        return t.kind === "video" && t.readyState === "live";
	      });

	      removeItemFromList(this.unusedTracks, track);
	      track && this.onTrack(track);
	    }
	  };
	  /**
	   * 在网关的设计中，无论订阅纯音频还是纯视频，总是会返回给我们 2 个 MediaStreamTrack
	   * 如果我们不订阅视频或者音频，这个 MediaStreamTrack 还是会存在，但是不会有数据被发送
	   *
	   * 所以如果我们在订阅完成后修改了订阅参数，只要把这个 Track 缓存好即可，不需要 WebRTC API 相关操作
	   */


	  SubStreamConnection.prototype.setSubscribeOptions = function (subOptions) {
	    return __awaiter$p(this, void 0, void 0, function () {
	      var e_2;
	      return __generator$p(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            if (subOptions.audio === this.subscribeOptions.audio && subOptions.video === this.subscribeOptions.video) return [2
	            /*return*/
	            ];
	            if (!(this.connectionState === "connecting")) return [3
	            /*break*/
	            , 4];
	            _a.label = 1;

	          case 1:
	            _a.trys.push([1, 3,, 4]);

	            return [4
	            /*yield*/
	            , this.createWaitConnectionConnectedPromise()];

	          case 2:
	            _a.sent();

	            return [3
	            /*break*/
	            , 4];

	          case 3:
	            e_2 = _a.sent();
	            throw new AgoraRTCError(AgoraRTCErrorCode.OPERATION_ABORTED, "can not update subscribe options, operation abort");

	          case 4:
	            if (subOptions.audio === this.subscribeOptions.audio && subOptions.video === this.subscribeOptions.video) return [2
	            /*return*/
	            ];
	            logger.debug("[" + this.connectionId + "] update subscribe options [a: " + this.subscribeOptions.audio + ", v: " + this.subscribeOptions.video + "] -> [a: " + subOptions.audio + ", v: " + subOptions.video + "]");
	            this.subscribeOptions = subOptions; // 将需要干掉的 Track 干掉，需要增加的 Track 通过 OnTrack 抛出

	            if (!subOptions.audio && this.user._audioTrack) {
	              this.unusedTracks.push(this.user._audioTrack._originMediaStreamTrack);

	              this.user._audioTrack._destroy();

	              this.unbindTrackEvents(this.user._audioTrack);
	              this.user._audioTrack = undefined;
	            }

	            if (!subOptions.video && this.user._videoTrack) {
	              this.unusedTracks.push(this.user._videoTrack._originMediaStreamTrack);

	              this.user._videoTrack._destroy();

	              this.unbindTrackEvents(this.user._videoTrack);
	              this.user._videoTrack = undefined;
	            }

	            this.emitOnTrackFromUnusedTracks();
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  SubStreamConnection.prototype.createPC = function () {
	    var _this = this;

	    this.pc = new SubRTCPeerConnection({
	      turnServer: this.joinInfo.turnServer
	    });

	    this.pc.onFirstAudioDecoded = function () {
	      report.firstRemoteFrame(_this.joinInfo.sid, AgoraRTCEvent.FIRST_AUDIO_DECODE, AgoraRTCEventUploadType.FIRST_AUDIO_DECODE, {
	        peer: _this.user._uintid,
	        subscribeElapse: now$2() - _this.startTime,
	        subscribeRequestid: _this.ID,
	        p2pid: _this.pc.ID
	      });
	    };

	    this.pc.onFirstAudioReceived = function () {
	      report.firstRemoteFrame(_this.joinInfo.sid, AgoraRTCEvent.FIRST_AUDIO_RECEIVED, AgoraRTCEventUploadType.FIRST_AUDIO_RECEIVED, {
	        peer: _this.user._uintid,
	        subscribeElapse: now$2() - _this.startTime,
	        subscribeRequestid: _this.ID,
	        p2pid: _this.pc.ID
	      });
	    };

	    this.pc.onFirstVideoDecoded = function (width, height) {
	      report.firstRemoteFrame(_this.joinInfo.sid, AgoraRTCEvent.FIRST_VIDEO_DECODE, AgoraRTCEventUploadType.FIRST_VIDEO_DECODE, {
	        peer: _this.user._uintid,
	        videowidth: width,
	        videoheight: height,
	        subscribeElapse: now$2() - _this.startTime,
	        subscribeRequestid: _this.ID,
	        p2pid: _this.pc.ID
	      });
	    };

	    this.pc.onFirstVideoReceived = function () {
	      report.firstRemoteFrame(_this.joinInfo.sid, AgoraRTCEvent.FIRST_VIDEO_RECEIVED, AgoraRTCEventUploadType.FIRST_VIDEO_RECEIVED, {
	        peer: _this.user._uintid,
	        subscribeElapse: now$2() - _this.startTime,
	        subscribeRequestid: _this.ID,
	        p2pid: _this.pc.ID
	      });
	    };

	    this.updateICEPromise();
	  };

	  SubStreamConnection.prototype.closePC = function (force) {
	    return __awaiter$p(this, void 0, void 0, function () {
	      var needWait;
	      return __generator$p(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            this.pc.audioTrack && this.pc.audioTrack.stop();
	            this.pc.videoTrack && this.pc.videoTrack.stop();
	            this.pc.onTrack = undefined;
	            this.pc.onICEConnectionStateChange = undefined;
	            this.pc.close();
	            if (!!force) return [3
	            /*break*/
	            , 2];
	            return [4
	            /*yield*/
	            , emitAsPromise(this, StreamConnectionEvents.NEED_UNSUB)];

	          case 1:
	            needWait = _a.sent();
	            return [2
	            /*return*/
	            , needWait];

	          case 2:
	            return [2
	            /*return*/
	            , false];
	        }
	      });
	    });
	  };

	  SubStreamConnection.prototype.onPCDisconnected = function (reason) {
	    report.subscribe(this.joinInfo.sid, {
	      lts: this.startTime,
	      succ: false,
	      video: this.subscribeOptions.video,
	      audio: this.subscribeOptions.audio,
	      peerid: this.user.uid,
	      ec: reason.code,
	      subscribeRequestid: this.ID,
	      p2pid: this.pc.ID
	    });
	  };

	  SubStreamConnection.prototype.bindTrackEvents = function (track) {
	    if (track instanceof RemoteAudioTrack) {
	      track.addListener(TrackInternalEvent.GET_STATS, this.handleGetRemoteAudioStats);
	    } else if (track instanceof RemoteVideoTrack) {
	      track.addListener(TrackInternalEvent.GET_STATS, this.handleGetRemoteVideoStats);
	    }
	  };

	  SubStreamConnection.prototype.unbindTrackEvents = function (track) {
	    if (track instanceof RemoteAudioTrack) {
	      track.off(TrackInternalEvent.GET_STATS, this.handleGetRemoteAudioStats);
	    } else if (track instanceof RemoteVideoTrack) {
	      track.off(TrackInternalEvent.GET_STATS, this.handleGetRemoteVideoStats);
	    }
	  };

	  return SubStreamConnection;
	}(StreamConnection);

	var __extends$m = undefined && undefined.__extends || function () {
	  var extendStatics = function (d, b) {
	    extendStatics = setPrototypeOf$2 || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    };

	    return extendStatics(d, b);
	  };

	  return function (d, b) {
	    extendStatics(d, b);

	    function __() {
	      this.constructor = d;
	    }

	    d.prototype = b === null ? create$4(b) : (__.prototype = b.prototype, new __());
	  };
	}();

	var __assign$b = undefined && undefined.__assign || function () {
	  __assign$b = assign$2 || function (t) {
	    for (var s, i = 1, n = arguments.length; i < n; i++) {
	      s = arguments[i];

	      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	    }

	    return t;
	  };

	  return __assign$b.apply(this, arguments);
	};

	var __awaiter$q = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = promise$3))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var __generator$q = undefined && undefined.__generator || function (thisArg, body) {
	  var _ = {
	    label: 0,
	    sent: function () {
	      if (t[0] & 1) throw t[1];
	      return t[1];
	    },
	    trys: [],
	    ops: []
	  },
	      f,
	      y,
	      t,
	      g;
	  return g = {
	    next: verb(0),
	    "throw": verb(1),
	    "return": verb(2)
	  }, typeof symbol$2 === "function" && (g[iterator$2] = function () {
	    return this;
	  }), g;

	  function verb(n) {
	    return function (v) {
	      return step([n, v]);
	    };
	  }

	  function step(op) {
	    if (f) throw new TypeError("Generator is already executing.");

	    while (_) try {
	      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	      if (y = 0, t) op = [op[0] & 2, t.value];

	      switch (op[0]) {
	        case 0:
	        case 1:
	          t = op;
	          break;

	        case 4:
	          _.label++;
	          return {
	            value: op[1],
	            done: false
	          };

	        case 5:
	          _.label++;
	          y = op[1];
	          op = [0];
	          continue;

	        case 7:
	          op = _.ops.pop();

	          _.trys.pop();

	          continue;

	        default:
	          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
	            _ = 0;
	            continue;
	          }

	          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
	            _.label = op[1];
	            break;
	          }

	          if (op[0] === 6 && _.label < t[1]) {
	            _.label = t[1];
	            t = op;
	            break;
	          }

	          if (t && _.label < t[2]) {
	            _.label = t[2];

	            _.ops.push(op);

	            break;
	          }

	          if (t[2]) _.ops.pop();

	          _.trys.pop();

	          continue;
	      }

	      op = body.call(thisArg, _);
	    } catch (e) {
	      op = [6, e];
	      y = 0;
	    } finally {
	      f = t = 0;
	    }

	    if (op[0] & 5) throw op[1];
	    return {
	      value: op[0] ? op[1] : void 0,
	      done: true
	    };
	  }
	};

	var AgoraLiveStreamingUapSignal =
	/** @class */
	function (_super) {
	  __extends$m(AgoraLiveStreamingUapSignal, _super);

	  function AgoraLiveStreamingUapSignal(token, spec, retryConfig, serviceMode) {
	    var _this = _super.call(this) || this;

	    _this.reconnectMode = "retry";
	    _this.reqId = 0;
	    _this.commandReqId = 0;

	    _this.handleWebSocketOpen = function () {
	      _this.reconnectMode = "retry";

	      _this.startPingPong();
	    };

	    _this.handleWebSocketMessage = function (e) {
	      if (!e.data) return;
	      var data = JSON.parse(e.data);
	      /** 响应 */

	      if (data.requestId) {
	        _this.emit("@" + data.requestId + "-" + data.sid, data);
	        /** 通知 */

	      } else {
	        if (_this.serviceMode === LiveStreamingServiceMode.INJECT) {
	          /** 拉流中途出现错误 */
	          _this.emit(LiveStreamingUapSignalEvents.INJECT_STREAM_STATUS, data);
	        } else {
	          /** 推流中途出现错误 */
	          report.workerEvent(_this.spec.sid, {
	            actionType: "status",
	            serverCode: data.code,
	            workerType: _this.serviceMode === LiveStreamingServiceMode.TRANSCODE ? 1 : 2
	          });

	          _this.emit(LiveStreamingUapSignalEvents.PUBLISH_STREAM_STATUS, data);
	        }
	      }
	    };

	    _this.spec = spec;
	    _this.token = token;
	    _this.serviceMode = serviceMode;
	    _this.websocket = new AgoraWebSocketManager("live-streaming", retryConfig);

	    _this.websocket.on(WebSocketManagerEvents.CONNECTED, _this.handleWebSocketOpen);

	    _this.websocket.on(WebSocketManagerEvents.ON_MESSAGE, _this.handleWebSocketMessage);

	    _this.websocket.on(WebSocketManagerEvents.REQUEST_NEW_URLS, function (resolve, reject) {
	      emitAsPromise(_this, LiveStreamingUapSignalEvents.REQUEST_NEW_ADDRESS).then(resolve).catch(reject);
	    });
	    /**
	     * 只要成功建立了连接，之后永远只会尝试同一个 Websocket 地址
	     */


	    _this.websocket.on(WebSocketManagerEvents.RECONNECTING, function () {
	      _this.websocket.reconnectMode = _this.reconnectMode;
	    });

	    return _this;
	  }

	  AgoraLiveStreamingUapSignal.prototype.init = function (urls) {
	    return this.websocket.init(urls);
	  };

	  AgoraLiveStreamingUapSignal.prototype.request = function (command, data, allocate, reportData) {
	    return __awaiter$q(this, void 0, void 0, function () {
	      var commandReqId, reqId, sdkVersion, req, waitWsOpenPromise, waitResponsePromise, startTime, res, e_1;

	      var _this = this;

	      return __generator$q(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            this.reqId += 1;

	            if (command === "request") {
	              this.commandReqId += 1;
	            }

	            commandReqId = this.commandReqId;
	            reqId = this.reqId;

	            if (!reqId || !this.websocket) {
	              throw new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_ERROR);
	            }

	            sdkVersion = VERSION === "4.1.1" ? "0.0.1" : VERSION;
	            req = __assign$b({
	              command: command,
	              sdkVersion: sdkVersion,
	              seq: reqId,
	              requestId: reqId,
	              allocate: allocate,
	              cname: this.spec.cname,
	              appId: this.spec.appId,
	              sid: this.spec.sid,
	              uid: this.spec.uid.toString(),
	              ts: Math.floor(now$2() / 1000)
	            }, data);

	            if (this.websocket.state === "closed") {
	              throw new AgoraRTCError(AgoraRTCErrorCode.WS_DISCONNECT);
	            }

	            waitWsOpenPromise = function () {
	              return new promise$3(function (resolve, reject) {
	                _this.websocket.once(WebSocketManagerEvents.CLOSED, function () {
	                  return reject(new AgoraRTCError(AgoraRTCErrorCode.WS_ABORT));
	                });

	                _this.websocket.once(WebSocketManagerEvents.CONNECTED, resolve);
	              });
	            };

	            if (!(this.websocket.state !== "connected")) return [3
	            /*break*/
	            , 2];
	            return [4
	            /*yield*/
	            , waitWsOpenPromise()];

	          case 1:
	            _a.sent();

	            _a.label = 2;

	          case 2:
	            if (req.clientRequest) {
	              req.clientRequest.workerToken = this.token;
	            }

	            waitResponsePromise = new promise$3(function (resolve, reject) {
	              var handleWsDisconnect = function () {
	                reject(new AgoraRTCError(AgoraRTCErrorCode.WS_ABORT));
	              };

	              _this.websocket.once(WebSocketManagerEvents.RECONNECTING, handleWsDisconnect);

	              _this.websocket.once(WebSocketManagerEvents.CLOSED, handleWsDisconnect);

	              _this.once("@" + reqId + "-" + _this.spec.sid, function (res) {
	                resolve(res);
	              });
	            });
	            reportData && report.workerEvent(this.spec.sid, __assign$b(__assign$b({}, reportData), {
	              requestId: commandReqId,
	              actionType: "request",
	              payload: stringify$2(data.clientRequest),
	              serverCode: 0,
	              code: 0
	            }));
	            startTime = now$2();
	            this.websocket.sendMessage(req);
	            res = null;
	            _a.label = 3;

	          case 3:
	            _a.trys.push([3, 5,, 8]);

	            return [4
	            /*yield*/
	            , waitResponsePromise];

	          case 4:
	            res = _a.sent();
	            return [3
	            /*break*/
	            , 8];

	          case 5:
	            e_1 = _a.sent();

	            if (this.websocket.state === "closed") {
	              throw e_1;
	            }

	            return [4
	            /*yield*/
	            , waitWsOpenPromise()];

	          case 6:
	            _a.sent();

	            return [4
	            /*yield*/
	            , this.request(command, data, allocate)];

	          case 7:
	            return [2
	            /*return*/
	            , _a.sent()];

	          case 8:
	            reportData && report.workerEvent(this.spec.sid, __assign$b(__assign$b({}, reportData), {
	              requestId: commandReqId,
	              actionType: "response",
	              payload: stringify$2(res.serverResponse),
	              serverCode: res.code,
	              success: res.code === 200,
	              responseTime: now$2() - startTime
	            }));

	            if (res.code !== 200) {
	              this.handleResponseError(res);
	            }

	            return [2
	            /*return*/
	            , res];
	        }
	      });
	    });
	  };

	  AgoraLiveStreamingUapSignal.prototype.tryNextAddress = function () {
	    this.reconnectMode = "tryNext";
	    this.websocket.reconnect("tryNext");
	  };

	  AgoraLiveStreamingUapSignal.prototype.close = function () {
	    var sdkVersion = VERSION === "4.1.1" ? "0.0.1" : VERSION;
	    this.reqId += 1; // 发出销毁 worker 的信令，不在乎响应

	    if (this.websocket.state === "connected") {
	      this.websocket.sendMessage({
	        command: "request",
	        appId: this.spec.appId,
	        cname: this.spec.cname,
	        uid: this.spec.uid.toString(),
	        sdkVersion: sdkVersion,
	        sid: this.spec.sid,
	        seq: this.reqId,
	        ts: Math.floor(now$2() / 1000),
	        requestId: this.reqId,
	        clientRequest: {
	          command: "DestroyWorker"
	        }
	      });
	      /** 延迟关闭 websocket，确保 destroy 信令发出 */

	      this.websocket.close(false, true);
	    } else {
	      this.websocket.close(false);
	    }

	    if (this.pingpongTimer) {
	      window.clearInterval(this.pingpongTimer);
	      this.pingpongTimer = undefined;
	    }
	  };

	  AgoraLiveStreamingUapSignal.prototype.handleResponseError = function (response) {
	    switch (response.code) {
	      case LIVE_STREAM_ERROR_CODE.LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM:
	        {
	          logger.warning("live stream response already exists stream");
	          return;
	        }

	      case LIVE_STREAM_ERROR_CODE.LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR:
	      case LIVE_STREAM_ERROR_CODE.LIVE_STREAM_RESPONSE_BAD_STREAM:
	      case LIVE_STREAM_ERROR_CODE.LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR:
	        {
	          return new AgoraRTCError(AgoraRTCErrorCode.LIVE_STREAMING_INVALID_ARGUMENT, "", {
	            code: response.code
	          }).throw();
	        }

	      case LIVE_STREAM_ERROR_CODE.LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST:
	        {
	          /** 如果在 stop 阶段，认为停止推流成功，如果在 update 阶段，需要重新推流 */
	          if (response.serverResponse.command === "UnpublishStream" || response.serverResponse.command === "UninjectStream") return;
	          throw new AgoraRTCError(AgoraRTCErrorCode.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "live stream response wm worker not exist", {
	            retry: true
	          });
	        }

	      case LIVE_STREAM_ERROR_CODE.LIVE_STREAM_RESPONSE_NOT_AUTHORIZED:
	        {
	          return new AgoraRTCError(AgoraRTCErrorCode.LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED, "", {
	            code: response.code
	          }).throw();
	        }

	      case LIVE_STREAM_ERROR_CODE.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE:
	        {
	          var err = new AgoraRTCError(AgoraRTCErrorCode.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE);
	          return this.emit(LiveStreamingUapSignalEvents.WARNING, err, response.serverResponse.url);
	        }

	      case LIVE_STREAM_ERROR_CODE.LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN:
	        {
	          var err = new AgoraRTCError(AgoraRTCErrorCode.LIVE_STREAMING_WARN_FREQUENT_REQUEST);
	          return this.emit(LiveStreamingUapSignalEvents.WARNING, err, response.serverResponse.url);
	        }

	      case LIVE_STREAM_ERROR_CODE.LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH:
	        {
	          throw new AgoraRTCError(AgoraRTCErrorCode.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "live stream response wm worker not exist", {
	            retry: true
	          });
	        }

	      case LIVE_STREAM_ERROR_CODE.LIVE_STREAM_RESPONSE_NOT_SUPPORTED:
	        {
	          return new AgoraRTCError(AgoraRTCErrorCode.LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED, "", {
	            code: response.code
	          }).throw();
	        }

	      case LIVE_STREAM_ERROR_CODE.LIVE_STREAM_RESPONSE_MAX_STREAM_NUM:
	        {
	          var err = new AgoraRTCError(AgoraRTCErrorCode.LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT);
	          return this.emit(LiveStreamingUapSignalEvents.WARNING, err, response.serverResponse.url);
	        }

	      case LIVE_STREAM_ERROR_CODE.LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR:
	        {
	          return new AgoraRTCError(AgoraRTCErrorCode.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "", {
	            code: response.code
	          }).throw();
	        }

	      case LIVE_STREAM_ERROR_CODE.LIVE_STREAM_RESPONSE_RESOURCE_LIMIT:
	        {
	          throw new AgoraRTCError(AgoraRTCErrorCode.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "live stream resource limit", {
	            retry: true,
	            changeAddress: true
	          });
	        }

	      case LIVE_STREAM_ERROR_CODE.LIVE_STREAM_RESPONSE_WORKER_LOST:
	      case LIVE_STREAM_ERROR_CODE.LIVE_STREAM_RESPONSE_WORKER_QUIT:
	        {
	          if (response.serverResponse.command === "UnpublishStream" || response.serverResponse.command === "UninjectStream") return;
	          throw new AgoraRTCError(AgoraRTCErrorCode.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "error fail send message", {
	            retry: true,
	            changeAddress: true
	          });
	        }

	      case LIVE_STREAM_ERROR_CODE.ERROR_FAIL_SEND_MESSAGE:
	        {
	          if (response.serverResponse.command === "UnpublishStream" || response.serverResponse.command === "UninjectStream") return;

	          if (response.serverResponse.command === "UpdateTranscoding" || response.serverResponse.command === "ControlStream") {
	            return new AgoraRTCError(AgoraRTCErrorCode.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "error fail send message", {
	              code: response.code
	            }).throw();
	          }

	          throw new AgoraRTCError(AgoraRTCErrorCode.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "error fail send message", {
	            retry: true,
	            changeAddress: true
	          });
	        }

	      case LIVE_STREAM_ERROR_CODE.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN:
	      case LIVE_STREAM_ERROR_CODE.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT:
	      case LIVE_STREAM_ERROR_CODE.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE:
	      case LIVE_STREAM_ERROR_CODE.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH:
	        {
	          return new AgoraRTCError(AgoraRTCErrorCode.LIVE_STREAMING_CDN_ERROR, "", {
	            code: response.code
	          }).throw();
	        }
	    }
	  };

	  AgoraLiveStreamingUapSignal.prototype.startPingPong = function () {
	    var _this = this;

	    if (this.pingpongTimer) {
	      window.clearInterval(this.pingpongTimer);
	    }

	    this.pingpongTimer = window.setInterval(function () {
	      if (_this.websocket.state === "connected") {
	        _this.request("ping", {}).catch(noop$1);
	      }
	    }, 6000);
	  };

	  return AgoraLiveStreamingUapSignal;
	}(EventEmitter$1);

	var __extends$n = undefined && undefined.__extends || function () {
	  var extendStatics = function (d, b) {
	    extendStatics = setPrototypeOf$2 || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    };

	    return extendStatics(d, b);
	  };

	  return function (d, b) {
	    extendStatics(d, b);

	    function __() {
	      this.constructor = d;
	    }

	    d.prototype = b === null ? create$4(b) : (__.prototype = b.prototype, new __());
	  };
	}();

	var __assign$c = undefined && undefined.__assign || function () {
	  __assign$c = assign$2 || function (t) {
	    for (var s, i = 1, n = arguments.length; i < n; i++) {
	      s = arguments[i];

	      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	    }

	    return t;
	  };

	  return __assign$c.apply(this, arguments);
	};

	var __awaiter$r = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = promise$3))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var __generator$r = undefined && undefined.__generator || function (thisArg, body) {
	  var _ = {
	    label: 0,
	    sent: function () {
	      if (t[0] & 1) throw t[1];
	      return t[1];
	    },
	    trys: [],
	    ops: []
	  },
	      f,
	      y,
	      t,
	      g;
	  return g = {
	    next: verb(0),
	    "throw": verb(1),
	    "return": verb(2)
	  }, typeof symbol$2 === "function" && (g[iterator$2] = function () {
	    return this;
	  }), g;

	  function verb(n) {
	    return function (v) {
	      return step([n, v]);
	    };
	  }

	  function step(op) {
	    if (f) throw new TypeError("Generator is already executing.");

	    while (_) try {
	      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	      if (y = 0, t) op = [op[0] & 2, t.value];

	      switch (op[0]) {
	        case 0:
	        case 1:
	          t = op;
	          break;

	        case 4:
	          _.label++;
	          return {
	            value: op[1],
	            done: false
	          };

	        case 5:
	          _.label++;
	          y = op[1];
	          op = [0];
	          continue;

	        case 7:
	          op = _.ops.pop();

	          _.trys.pop();

	          continue;

	        default:
	          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
	            _ = 0;
	            continue;
	          }

	          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
	            _.label = op[1];
	            break;
	          }

	          if (op[0] === 6 && _.label < t[1]) {
	            _.label = t[1];
	            t = op;
	            break;
	          }

	          if (t && _.label < t[2]) {
	            _.label = t[2];

	            _.ops.push(op);

	            break;
	          }

	          if (t[2]) _.ops.pop();

	          _.trys.pop();

	          continue;
	      }

	      op = body.call(thisArg, _);
	    } catch (e) {
	      op = [6, e];
	      y = 0;
	    } finally {
	      f = t = 0;
	    }

	    if (op[0] & 5) throw op[1];
	    return {
	      value: op[0] ? op[1] : void 0,
	      done: true
	    };
	  }
	};

	var AgoraRTCLiveStreamingClient =
	/** @class */
	function (_super) {
	  __extends$n(AgoraRTCLiveStreamingClient, _super);

	  function AgoraRTCLiveStreamingClient(spec, wsRetryConfig, httpRetryConfig) {
	    if (wsRetryConfig === void 0) {
	      wsRetryConfig = DEFAULT_RETRY_CONFIG;
	    }

	    if (httpRetryConfig === void 0) {
	      httpRetryConfig = DEFAULT_RETRY_CONFIG;
	    }

	    var _this = _super.call(this) || this;

	    _this.retryTimeout = 10000;
	    /**
	     * websocket 连接只能存在一个，但是允许存在多个 task
	     * @internal
	     */

	    _this.streamingTasks = new map$2();
	    _this.isStartingStreamingTask = false;
	    _this.taskMutex = new PromiseMutex("live-streaming");
	    _this.cancelToken = axios$1.CancelToken.source();
	    _this.injectConfig = __assign$c({}, DEFAULT_INJECT_CONFIG);
	    _this.injectLoopTimes = 0;
	    /** 最新的 taskId */

	    _this.lastTaskId = 1;
	    /** 在开始 task 请求发出去之后，响应之前收到的 serverStatus Error */

	    _this.statusError = new map$2();
	    _this.spec = spec;
	    _this.httpRetryConfig = httpRetryConfig;
	    _this.wsRetryConfig = wsRetryConfig;
	    return _this;
	  }

	  AgoraRTCLiveStreamingClient.prototype.setTranscodingConfig = function (transcodingConfig) {
	    return __awaiter$r(this, void 0, void 0, function () {
	      var config, images, stringUidPromiseList, uidList, res, e_1;

	      var _this = this;

	      return __generator$r(this, function (_a) {
	        var _context4, _context5, _context6, _context7;

	        switch (_a.label) {
	          case 0:
	            config = __assign$c(__assign$c({}, DEFAULT_TRANSCODING_CONFIG), transcodingConfig);

	            if (config.videoCodecProfile !== 66 && config.videoCodecProfile !== 77 && config.videoCodecProfile !== 100) {
	              logger.debug("[" + this.spec.clientId + "] set transcoding config, fix video codec profile: " + config.videoCodecProfile + " -> 100");
	              config.videoCodecProfile = 100;
	            }

	            if (!config.transcodingUsers) {
	              config.transcodingUsers = config.userConfigs;
	            }

	            if (config.transcodingUsers) {
	              var _context;

	              config.transcodingUsers = map$5(_context = config.transcodingUsers).call(_context, function (user) {
	                return __assign$c(__assign$c(__assign$c({}, DEFAULT_LIVE_STREAMING_TRANSCODING_USER), user), {
	                  zOrder: user.zOrder ? user.zOrder + 1 : 1
	                });
	              });
	            }

	            isLiveStreamingTranscodingConfig(config);
	            images = [];

	            if (config.images) {
	              var _context2;

	              images.push.apply(images, map$5(_context2 = config.images).call(_context2, function (image) {
	                return __assign$c(__assign$c(__assign$c({}, DEFAULT_LIVE_STREAMING_TRANSCODING_IMAGE), image), {
	                  zOrder: 255
	                });
	              }));
	            }

	            if (config.backgroundImage) {
	              images.push(__assign$c(__assign$c(__assign$c({}, DEFAULT_LIVE_STREAMING_TRANSCODING_IMAGE), config.backgroundImage), {
	                zOrder: 0
	              }));
	              delete config.backgroundImage;
	            }

	            if (config.watermark) {
	              images.push(__assign$c(__assign$c(__assign$c({}, DEFAULT_LIVE_STREAMING_TRANSCODING_IMAGE), config.watermark), {
	                zOrder: 255
	              }));
	              delete config.watermark;
	            }

	            config.images = images;

	            if (config.transcodingUsers) {
	              var _context3;

	              config.userConfigs = map$5(_context3 = config.transcodingUsers).call(_context3, function (t) {
	                return __assign$c({}, t);
	              });
	              config.userCount = config.transcodingUsers.length;
	              delete config.transcodingUsers;
	            }

	            stringUidPromiseList = map$5(_context4 = config.userConfigs || []).call(_context4, function (userConfig) {
	              if (typeof userConfig.uid === "number") return promise$3.resolve(userConfig.uid);
	              return getUserAccount(userConfig.uid, _this.spec, _this.cancelToken.token, _this.httpRetryConfig);
	            });
	            return [4
	            /*yield*/
	            , promise$3.all(stringUidPromiseList)];

	          case 1:
	            uidList = _a.sent();

	            forEach$3(uidList).call(uidList, function (uid, index) {
	              if (config.userConfigs && config.userConfigs[index]) {
	                config.userConfigs[index].uid = uid;
	              }
	            });

	            this.transcodingConfig = config;
	            if (!this.connection) return [2
	            /*return*/
	            ];
	            _a.label = 2;

	          case 2:
	            _a.trys.push([2, 4,, 5]);

	            return [4
	            /*yield*/
	            , this.connection.request("request", {
	              clientRequest: {
	                command: "UpdateTranscoding",
	                transcodingConfig: this.transcodingConfig
	              }
	            }, false, {
	              command: "UpdateTranscoding",
	              workerType: 1,
	              requestByUser: true,
	              tid: map$5(_context5 = from_1$2(values$2(_context6 = this.streamingTasks).call(_context6))).call(_context5, function (task) {
	                return task.taskId;
	              }).join("#")
	            })];

	          case 3:
	            res = _a.sent();
	            logger.debug("[" + this.spec.clientId + "] update live transcoding config success, code: " + res.code + ", config:", stringify$2(this.transcodingConfig));
	            return [3
	            /*break*/
	            , 5];

	          case 4:
	            e_1 = _a.sent();
	            if (!e_1.data || !e_1.data.retry) throw e_1;

	            if (e_1.data.changeAddress) {
	              this.connection.tryNextAddress();
	            } // 这里剩下的都是可重试的错误，尝试重新推流, 这里我们认为 updateTranscoding 成功，如果之后的操作报错，通过回调通知


	            forEach$3(_context7 = this.streamingTasks).call(_context7, function (task) {
	              logger.warning("[" + _this.spec.clientId + "] live streaming receive error", e_1.toString(), "try to republish", task.url);

	              _this.startLiveStreamingTask(task.url, task.mode, e_1).then(function () {
	                logger.debug("[" + _this.spec.clientId + "] live streaming republish " + task.url + " success");
	              }).catch(function (e) {
	                logger.error("[" + _this.spec.clientId + "] live streaming republish failed", task.url, e.toString());
	                _this.onLiveStreamError && _this.onLiveStreamError(task.url, e);
	              });
	            });

	            return [3
	            /*break*/
	            , 5];

	          case 5:
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  AgoraRTCLiveStreamingClient.prototype.setInjectStreamConfig = function (config, loopTimes) {
	    this.injectConfig = assign$2({}, this.injectConfig, config);
	    this.injectLoopTimes = loopTimes;
	  };
	  /** 只有 raw 推流需要 uid 参数 */


	  AgoraRTCLiveStreamingClient.prototype.startLiveStreamingTask = function (rtmp, mode, retryError) {
	    return __awaiter$r(this, void 0, void 0, function () {
	      var injectTask, clientRequest, unlock, streamingTask, _a, e_2, taskId, startTimeoutPromise, res, e_3;

	      var _this = this;

	      return __generator$r(this, function (_b) {
	        var _context8, _context9;

	        switch (_b.label) {
	          case 0:
	            injectTask = find$2(_context8 = from_1$2(values$2(_context9 = this.streamingTasks).call(_context9))).call(_context8, function (t) {
	              return t.mode === LiveStreamingServiceMode.INJECT;
	            });

	            if (injectTask && mode === LiveStreamingServiceMode.INJECT) {
	              return [2
	              /*return*/
	              , new AgoraRTCError(AgoraRTCErrorCode.LIVE_STREAMING_TASK_CONFLICT, "inject stream over limit").throw()];
	            }

	            if (!this.transcodingConfig && mode === LiveStreamingServiceMode.TRANSCODE) {
	              throw new AgoraRTCError(AgoraRTCErrorCode.INVALID_OPERATION, "[LiveStreaming] no transcoding config found, can not start transcoding streaming task");
	            }

	            clientRequest = {
	              command: "PublishStream",
	              ts: now$2(),
	              url: rtmp,
	              uid: this.spec.uid.toString(),
	              autoDestroyTime: 30
	            };
	            logger.debug("[" + this.spec.clientId + "] start live streaming " + rtmp + ", mode: " + mode);
	            return [4
	            /*yield*/
	            , this.taskMutex.lock()];

	          case 1:
	            unlock = _b.sent();
	            /** 防止错误处理中的重连在 terminate 调用之后仍然继续 */

	            if (!this.connection && !!retryError) {
	              unlock();
	              return [2
	              /*return*/
	              ];
	            }

	            streamingTask = this.streamingTasks.get(rtmp);
	            /** 该地址已经存在推流任务 */

	            if (streamingTask && !retryError) {
	              unlock();
	              return [2
	              /*return*/
	              , new AgoraRTCError(AgoraRTCErrorCode.LIVE_STREAMING_TASK_CONFLICT).throw()];
	            }

	            _b.label = 2;

	          case 2:
	            _b.trys.push([2, 5,, 6]);

	            if (!!this.connection) return [3
	            /*break*/
	            , 4];
	            _a = this;
	            return [4
	            /*yield*/
	            , this.connect(mode)];

	          case 3:
	            _a.connection = _b.sent();
	            _b.label = 4;

	          case 4:
	            return [3
	            /*break*/
	            , 6];

	          case 5:
	            e_2 = _b.sent();
	            unlock();
	            throw e_2;

	          case 6:
	            switch (mode) {
	              case LiveStreamingServiceMode.TRANSCODE:
	                {
	                  clientRequest.transcodingConfig = __assign$c({}, this.transcodingConfig);
	                  break;
	                }

	              case LiveStreamingServiceMode.RAW:
	                {
	                  break;
	                }

	              case LiveStreamingServiceMode.INJECT:
	                {
	                  clientRequest = {
	                    cname: this.spec.cname,
	                    command: "InjectStream",
	                    sid: this.spec.sid,
	                    transcodingConfig: this.injectConfig,
	                    ts: now$2(),
	                    url: rtmp,
	                    loopTimes: this.injectLoopTimes
	                  };
	                  break;
	                }
	            }

	            if (this.uapResponse && this.uapResponse.vid) {
	              clientRequest.vid = this.uapResponse.vid;
	            }

	            this.isStartingStreamingTask = true;
	            taskId = this.lastTaskId++;
	            _b.label = 7;

	          case 7:
	            _b.trys.push([7, 9,, 14]);

	            startTimeoutPromise = new promise$3(function (_, reject) {
	              wait(_this.retryTimeout).then(function () {
	                if (retryError) return reject(retryError);

	                var statusError = _this.statusError.get(rtmp);

	                if (statusError) {
	                  _this.statusError.delete(rtmp);

	                  return reject(statusError);
	                }
	              });
	            });
	            return [4
	            /*yield*/
	            , promise$3.race([this.connection.request("request", {
	              clientRequest: clientRequest
	            }, true, {
	              url: rtmp,
	              command: "PublishStream",
	              workerType: mode === LiveStreamingServiceMode.TRANSCODE ? 1 : 2,
	              requestByUser: !retryError,
	              tid: taskId.toString()
	            }), startTimeoutPromise])];

	          case 8:
	            res = _b.sent();
	            this.isStartingStreamingTask = false;
	            logger.debug("[" + this.spec.clientId + "] live streaming started, code: " + res.code);
	            this.streamingTasks.set(rtmp, {
	              clientRequest: clientRequest,
	              mode: mode,
	              url: rtmp,
	              taskId: taskId
	            });
	            unlock();
	            return [3
	            /*break*/
	            , 14];

	          case 9:
	            e_3 = _b.sent();
	            unlock();
	            this.isStartingStreamingTask = false;
	            /** 如果在重试阶段发生错误，直接抛出错误不再重试 */

	            if (!e_3.data || !e_3.data.retry || retryError) {
	              throw e_3;
	            }

	            if (!!e_3.data.changeAddress) return [3
	            /*break*/
	            , 11];
	            return [4
	            /*yield*/
	            , this.startLiveStreamingTask(rtmp, mode, e_3)];

	          case 10:
	            /** 直接重新推流就可以恢复的错误 */
	            return [2
	            /*return*/
	            , _b.sent()];

	          case 11:
	            /** 需要更换 edgeaddress 才可以恢复的错误 */
	            this.connection.tryNextAddress();
	            return [4
	            /*yield*/
	            , this.startLiveStreamingTask(rtmp, mode, e_3)];

	          case 12:
	            return [2
	            /*return*/
	            , _b.sent()];

	          case 13:
	            return [3
	            /*break*/
	            , 14];

	          case 14:
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  AgoraRTCLiveStreamingClient.prototype.stopLiveStreamingTask = function (url) {
	    var _this = this;

	    return new promise$3(function (resolve, reject) {
	      var streamingTask = _this.streamingTasks.get(url);
	      /** ignore invalid rtmp */


	      if (!streamingTask || !_this.connection) {
	        return new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_ERROR, "can not find streaming task to stop").throw();
	      }

	      var mode = streamingTask.mode;

	      streamingTask.abortTask = function () {
	        logger.debug("[" + _this.spec.clientId + "] stop live streaming success(worker exception)");

	        _this.streamingTasks.delete(url);

	        resolve();
	      };
	      /** 在某些情况因为 Worker 异常无法正常 stop，但此时 task 确实已经停止了，我们还是返回给用户成功 */


	      _this.connection.request("request", {
	        clientRequest: {
	          command: mode === LiveStreamingServiceMode.INJECT ? "UninjectStream" : "UnpublishStream",
	          url: streamingTask.url
	        }
	      }, false, {
	        url: url,
	        command: "UnPublishStream",
	        workerType: mode === LiveStreamingServiceMode.TRANSCODE ? 1 : 2,
	        requestByUser: true,
	        tid: (_this.lastTaskId++).toString()
	      }).then(function (res) {
	        logger.debug("[" + _this.spec.clientId + "] stop live streaming success, code: " + res.code);

	        _this.streamingTasks.delete(url);

	        if (_this.streamingTasks.size === 0) {
	          _this.connection && _this.connection.close();
	          _this.connection = undefined;
	        }

	        resolve();

	        if (mode === LiveStreamingServiceMode.INJECT) {
	          _this.onInjectStatusChange && _this.onInjectStatusChange(5
	          /* INJECT_STREAM_STATUS_STOP_SUCCESS */
	          , _this.spec.uid, url);
	        }
	      }).catch(reject);
	    });
	  };

	  AgoraRTCLiveStreamingClient.prototype.controlInjectStream = function (url, control, volume, position) {
	    return __awaiter$r(this, void 0, void 0, function () {
	      var injectStreamTask, response;
	      return __generator$r(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            injectStreamTask = this.streamingTasks.get(url);

	            if (!injectStreamTask || !this.connection || injectStreamTask.mode !== LiveStreamingServiceMode.INJECT) {
	              throw new AgoraRTCError(AgoraRTCErrorCode.INVALID_OPERATION, "can not find inject stream task to control");
	            }

	            return [4
	            /*yield*/
	            , this.connection.request("request", {
	              clientRequest: {
	                command: "ControlStream",
	                url: url,
	                control: control,
	                audioVolume: volume,
	                position: position
	              }
	            })];

	          case 1:
	            response = _a.sent();
	            return [2
	            /*return*/
	            , response.serverResponse];
	        }
	      });
	    });
	  };

	  AgoraRTCLiveStreamingClient.prototype.resetAllTask = function () {
	    var _context10;

	    var _this = this;

	    var streamingTasks = from_1$2(values$2(_context10 = this.streamingTasks).call(_context10));

	    this.terminate();

	    var _loop_1 = function (task) {
	      this_1.startLiveStreamingTask(task.url, task.mode).catch(function (e) {
	        _this.onLiveStreamError && _this.onLiveStreamError(task.url, e);
	      });
	    };

	    var this_1 = this;

	    for (var _i = 0, streamingTasks_1 = streamingTasks; _i < streamingTasks_1.length; _i++) {
	      var task = streamingTasks_1[_i];

	      _loop_1(task);
	    }
	  };

	  AgoraRTCLiveStreamingClient.prototype.terminate = function () {
	    if (this.cancelToken) {
	      this.cancelToken.cancel();
	    } // 如果当前有正在执行的推流任务，因为之后会强制关闭连接，所以直接置为空


	    this.streamingTasks = new map$2(); // 重置一些状态

	    this.isStartingStreamingTask = false;
	    this.statusError = new map$2();
	    this.cancelToken = axios$1.CancelToken.source();
	    this.uapResponse = undefined; // 关闭连接

	    this.connection && this.connection.close();
	    this.connection = undefined;
	  };

	  AgoraRTCLiveStreamingClient.prototype.connect = function (mode) {
	    return __awaiter$r(this, void 0, void 0, function () {
	      var result;

	      var _this = this;

	      return __generator$r(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            /** 如果已经开始连接了，报错 */
	            if (this.connection) {
	              throw new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_ERROR, "live streaming connection has already connected");
	            }

	            return [4
	            /*yield*/
	            , emitAsPromise(this, LiveStreamingInternalEvents.REQUEST_WORKER_MANAGER_LIST, mode)];

	          case 1:
	            result = _a.sent();
	            this.uapResponse = result;
	            this.connection = new AgoraLiveStreamingUapSignal(result.workerToken, this.spec, this.wsRetryConfig, mode);
	            this.connection.on(LiveStreamingUapSignalEvents.WARNING, function (err, url) {
	              return _this.onLiveStreamWarning && _this.onLiveStreamWarning(url, err);
	            });
	            this.connection.on(LiveStreamingUapSignalEvents.PUBLISH_STREAM_STATUS, function (data) {
	              return _this.handlePublishStreamServer(data);
	            });
	            this.connection.on(LiveStreamingUapSignalEvents.INJECT_STREAM_STATUS, function (data) {
	              return _this.handleInjectStreamServerStatus(data);
	            });
	            this.connection.on(LiveStreamingUapSignalEvents.REQUEST_NEW_ADDRESS, function (resolve, reject) {
	              if (!_this.connection) return reject(new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_ERROR, "can not get new live streaming address list"));
	              emitAsPromise(_this, LiveStreamingInternalEvents.REQUEST_WORKER_MANAGER_LIST, mode).then(function (result) {
	                _this.uapResponse = result;
	                resolve(result.addressList);
	              }).catch(reject);
	            });
	            return [4
	            /*yield*/
	            , this.connection.init(result.addressList)];

	          case 2:
	            _a.sent();

	            return [2
	            /*return*/
	            , this.connection];
	        }
	      });
	    });
	  };

	  AgoraRTCLiveStreamingClient.prototype.handlePublishStreamServer = function (status) {
	    var _this = this;

	    var url = status.serverStatus.url;
	    var streamingTask = this.streamingTasks.get(url);

	    switch (status.code) {
	      case LIVE_STREAM_ERROR_CODE.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN:
	      case LIVE_STREAM_ERROR_CODE.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT:
	      case LIVE_STREAM_ERROR_CODE.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE:
	      case LIVE_STREAM_ERROR_CODE.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH:
	        {
	          var err = new AgoraRTCError(AgoraRTCErrorCode.LIVE_STREAMING_CDN_ERROR, "", {
	            code: status.code
	          });
	          /** 如果在推流成功后收到这些错误码，直接回调错误 */

	          if (streamingTask) {
	            logger.error(err.toString());
	            return this.onLiveStreamError && this.onLiveStreamError(url, err);
	          }

	          if (!this.isStartingStreamingTask) return;
	          /** 说明是在发起推流的中途收到这些错误码 */

	          this.statusError.set(url, err);
	        }

	      case LIVE_STREAM_ERROR_CODE.LIVE_STREAM_RESPONSE_WORKER_LOST:
	      case LIVE_STREAM_ERROR_CODE.LIVE_STREAM_RESPONSE_WORKER_QUIT:
	        {
	          var _context11;

	          /** 如果当前没有和 worker 建立连接，忽略这个错误 */
	          if (!this.connection) return;
	          /** 首选需要更换 worker manager */

	          this.connection.tryNextAddress();

	          var streamingTasks = from_1$2(values$2(_context11 = this.streamingTasks).call(_context11));

	          var _loop_2 = function (task) {
	            if (task.abortTask) {
	              task.abortTask();
	              return "continue";
	            }

	            logger.warning("[" + this_2.spec.clientId + "] publish stream status code", status.code, "try to republish", task.url);
	            this_2.startLiveStreamingTask(task.url, task.mode, new AgoraRTCError(AgoraRTCErrorCode.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "", {
	              code: status.code
	            })).then(function () {
	              logger.debug("[" + _this.spec.clientId + "] republish live stream success", task.url);
	            }).catch(function (e) {
	              logger.error(e.toString());
	              _this.onLiveStreamError && _this.onLiveStreamError(task.url, e);
	            });
	          };

	          var this_2 = this;
	          /** 遍历当前所有的任务，如果有任务处于正在停止的状态，直接认为其停止成功 */

	          for (var _i = 0, streamingTasks_2 = streamingTasks; _i < streamingTasks_2.length; _i++) {
	            var task = streamingTasks_2[_i];

	            _loop_2(task);
	          }

	          return;
	        }
	    }
	  };

	  AgoraRTCLiveStreamingClient.prototype.handleInjectStreamServerStatus = function (status) {
	    var uid = Number(status.uid);
	    var url = status.serverStatus && status.serverStatus.url;

	    switch (status.code) {
	      case 200:
	        {
	          this.onInjectStatusChange && this.onInjectStatusChange(0
	          /* INJECT_STREAM_STATUS_START_SUCCESS */
	          , uid, url);
	          return;
	        }

	      case 451:
	        {
	          this.onInjectStatusChange && this.onInjectStatusChange(1
	          /* INJECT_STREAM_STATUS_START_ALREADY_EXISTS */
	          , uid, url);
	          this.streamingTasks.delete(url);
	          return;
	        }

	      case 453:
	        {
	          this.onInjectStatusChange && this.onInjectStatusChange(2
	          /* INJECT_STREAM_STATUS_START_UNAUTHORIZED */
	          , uid, url);
	          this.streamingTasks.delete(url);
	          return;
	        }

	      case 470:
	        {
	          this.onInjectStatusChange && this.onInjectStatusChange(10
	          /* INJECT_STREAM_STATUS_BROKEN */
	          , uid, url);
	          this.streamingTasks.delete(url);
	          return;
	        }

	      case 499:
	        {
	          this.onInjectStatusChange && this.onInjectStatusChange(3
	          /* INJECT_STREAM_STATUS_START_TIMEOUT */
	          , uid, url);
	          this.streamingTasks.delete(url);
	          return;
	        }

	      default:
	        {
	          logger.debug("inject stream server status", status);
	          return;
	        }
	    }
	  };

	  AgoraRTCLiveStreamingClient.prototype.hasUrl = function (url) {
	    return this.streamingTasks.has(url);
	  };

	  return AgoraRTCLiveStreamingClient;
	}(EventEmitter$1);

	var ChannelMediaRelayConfiguration =
	/** @class */
	function () {
	  function ChannelMediaRelayConfiguration() {
	    this.destChannelMediaInfos = new map$2();
	  }

	  ChannelMediaRelayConfiguration.prototype.setSrcChannelInfo = function (info) {
	    isChannelMediaRelayInfo(info);
	    this.srcChannelMediaInfo = info;
	  };

	  ChannelMediaRelayConfiguration.prototype.addDestChannelInfo = function (info) {
	    isChannelMediaRelayInfo(info);
	    this.destChannelMediaInfos.set(info.channelName, info);
	  };

	  ChannelMediaRelayConfiguration.prototype.removeDestChannelInfo = function (channelName) {
	    checkValidChannelName(channelName);
	    this.destChannelMediaInfos.delete(channelName);
	  };
	  /** @internal */


	  ChannelMediaRelayConfiguration.prototype.getSrcChannelMediaInfo = function () {
	    return this.srcChannelMediaInfo;
	  };
	  /** @internal */


	  ChannelMediaRelayConfiguration.prototype.getDestChannelMediaInfo = function () {
	    return this.destChannelMediaInfos;
	  };

	  return ChannelMediaRelayConfiguration;
	}();
	function checkValidChannelMediaRelayConfiguration(config) {
	  if (!(config instanceof ChannelMediaRelayConfiguration)) {
	    var err = new AgoraRTCError(AgoraRTCErrorCode.INVALID_PARAMS, "Config should be instance of [ChannelMediaRelayConfiguration]");
	    return err.throw();
	  }

	  var srcInfo = config.getSrcChannelMediaInfo();
	  var destInfo = config.getDestChannelMediaInfo();

	  if (!srcInfo) {
	    var err = new AgoraRTCError(AgoraRTCErrorCode.INVALID_PARAMS, "srcChannelMediaInfo should not be empty");
	    return err.throw();
	  }

	  if (destInfo.size === 0) {
	    var err = new AgoraRTCError(AgoraRTCErrorCode.INVALID_PARAMS, "destChannelMediaInfo should not be empty");
	    return err.throw();
	  }
	}

	var __extends$o = undefined && undefined.__extends || function () {
	  var extendStatics = function (d, b) {
	    extendStatics = setPrototypeOf$2 || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    };

	    return extendStatics(d, b);
	  };

	  return function (d, b) {
	    extendStatics(d, b);

	    function __() {
	      this.constructor = d;
	    }

	    d.prototype = b === null ? create$4(b) : (__.prototype = b.prototype, new __());
	  };
	}();

	var __awaiter$s = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = promise$3))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var __generator$s = undefined && undefined.__generator || function (thisArg, body) {
	  var _ = {
	    label: 0,
	    sent: function () {
	      if (t[0] & 1) throw t[1];
	      return t[1];
	    },
	    trys: [],
	    ops: []
	  },
	      f,
	      y,
	      t,
	      g;
	  return g = {
	    next: verb(0),
	    "throw": verb(1),
	    "return": verb(2)
	  }, typeof symbol$2 === "function" && (g[iterator$2] = function () {
	    return this;
	  }), g;

	  function verb(n) {
	    return function (v) {
	      return step([n, v]);
	    };
	  }

	  function step(op) {
	    if (f) throw new TypeError("Generator is already executing.");

	    while (_) try {
	      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	      if (y = 0, t) op = [op[0] & 2, t.value];

	      switch (op[0]) {
	        case 0:
	        case 1:
	          t = op;
	          break;

	        case 4:
	          _.label++;
	          return {
	            value: op[1],
	            done: false
	          };

	        case 5:
	          _.label++;
	          y = op[1];
	          op = [0];
	          continue;

	        case 7:
	          op = _.ops.pop();

	          _.trys.pop();

	          continue;

	        default:
	          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
	            _ = 0;
	            continue;
	          }

	          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
	            _.label = op[1];
	            break;
	          }

	          if (op[0] === 6 && _.label < t[1]) {
	            _.label = t[1];
	            t = op;
	            break;
	          }

	          if (t && _.label < t[2]) {
	            _.label = t[2];

	            _.ops.push(op);

	            break;
	          }

	          if (t[2]) _.ops.pop();

	          _.trys.pop();

	          continue;
	      }

	      op = body.call(thisArg, _);
	    } catch (e) {
	      op = [6, e];
	      y = 0;
	    } finally {
	      f = t = 0;
	    }

	    if (op[0] & 5) throw op[1];
	    return {
	      value: op[0] ? op[1] : void 0,
	      done: true
	    };
	  }
	};

	var AgoraChannelMediaRelaySignal =
	/** @class */
	function (_super) {
	  __extends$o(AgoraChannelMediaRelaySignal, _super);

	  function AgoraChannelMediaRelaySignal(joinInfo, clientId, retryConfig) {
	    var _this = _super.call(this) || this;

	    _this.requestId = 1;

	    _this.onOpen = function () {
	      _this.emit("open");

	      _this.startHeartBeatCheck();
	    };

	    _this.onClose = function (e) {
	      _this.emit("close");

	      _this.dispose();
	    };

	    _this.onMessage = function (e) {
	      var res = JSON.parse(e.data);

	      if (res && res.command === "serverResponse") {
	        if (res.requestId) {
	          _this.emit("req_" + res.requestId, res);

	          return;
	        }
	      }

	      if (res && res.command === "serverStatus") {
	        if (res.serverStatus && res.serverStatus.command) {
	          _this.emit("status", res.serverStatus);

	          _this.emit(res.serverStatus.command, res.serverStatus);

	          return;
	        }
	      }
	    };

	    _this.joinInfo = joinInfo;
	    _this.clientId = clientId;
	    _this.ws = new AgoraWebSocketManager("cross-channel-" + _this.clientId, retryConfig);
	    /**
	     * 只要成功建立了连接，之后永远只会尝试同一个 Websocket 地址
	     */

	    _this.ws.on(WebSocketManagerEvents.RECONNECTING, function () {
	      _this.ws.reconnectMode = "retry";

	      _this.emit("reconnecting");
	    });

	    _this.ws.on(WebSocketManagerEvents.CONNECTED, _this.onOpen);

	    _this.ws.on(WebSocketManagerEvents.ON_MESSAGE, _this.onMessage);

	    _this.ws.on(WebSocketManagerEvents.CLOSED, _this.onClose);

	    return _this;
	  }

	  AgoraChannelMediaRelaySignal.prototype.isConnect = function () {
	    return this.ws.state === "connected";
	  };

	  AgoraChannelMediaRelaySignal.prototype.sendMessage = function (message) {
	    var requestId = this.requestId++;
	    message.requestId = requestId;
	    message.seq = requestId;
	    this.ws.sendMessage(message);
	    return requestId;
	  };

	  AgoraChannelMediaRelaySignal.prototype.waitStatus = function (status) {
	    var _this = this;

	    return new promise$3(function (resolve, reject) {
	      // 下面这个被注释的语句，用于测试某个请求失败或者超时
	      // if(message.clientRequest.command === "SetSdkProfile") reject(new ChannelMediaError(CHANNEL_MEDIA_ERROR.WAIT_STATUS_TIMEOUT, res));
	      var timer = window.setTimeout(function () {
	        reject(new AgoraRTCError(AgoraRTCErrorCode.TIMEOUT, "wait status timeout, status: " + status));
	      }, 5000);

	      _this.once(status, function (e) {
	        window.clearTimeout(timer);

	        if (e.state && e.state !== 0) {
	          reject(new AgoraRTCError(AgoraRTCErrorCode.CROSS_CHANNEL_WAIT_STATUS_ERROR, "wait status error, status: " + status));
	        } else {
	          resolve();
	        }
	      });

	      _this.once("dispose", function () {
	        window.clearTimeout(timer);
	        reject(new AgoraRTCError(AgoraRTCErrorCode.WS_ABORT));
	      });
	    });
	  };

	  AgoraChannelMediaRelaySignal.prototype.request = function (message) {
	    return __awaiter$s(this, void 0, void 0, function () {
	      var waitWsOpenPromise, requestId, waitResponsePromise, response;

	      var _this = this;

	      return __generator$s(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            if (this.ws.state === "closed") {
	              throw new AgoraRTCError(AgoraRTCErrorCode.WS_DISCONNECT);
	            }

	            waitWsOpenPromise = function () {
	              return new promise$3(function (resolve, reject) {
	                _this.ws.once(WebSocketManagerEvents.CLOSED, function () {
	                  return reject(new AgoraRTCError(AgoraRTCErrorCode.WS_ABORT));
	                });

	                _this.ws.once(WebSocketManagerEvents.CONNECTED, resolve);
	              });
	            };

	            if (!(this.ws.state !== "connected")) return [3
	            /*break*/
	            , 2];
	            return [4
	            /*yield*/
	            , waitWsOpenPromise()];

	          case 1:
	            _a.sent();

	            _a.label = 2;

	          case 2:
	            requestId = this.sendMessage(message);
	            waitResponsePromise = new promise$3(function (resolve, reject) {
	              var handleWsDisconnect = function () {
	                reject(new AgoraRTCError(AgoraRTCErrorCode.WS_ABORT));
	              };

	              _this.ws.once(WebSocketManagerEvents.RECONNECTING, handleWsDisconnect);

	              _this.ws.once(WebSocketManagerEvents.CLOSED, handleWsDisconnect);

	              _this.once("req_" + requestId, resolve);

	              wait(3000).then(function () {
	                _this.removeAllListeners("req_" + requestId);

	                _this.ws.off(WebSocketManagerEvents.RECONNECTING, handleWsDisconnect);

	                _this.ws.off(WebSocketManagerEvents.CLOSED, handleWsDisconnect);

	                reject(new AgoraRTCError(AgoraRTCErrorCode.TIMEOUT, "cross channel ws request timeout"));
	              });
	            });
	            return [4
	            /*yield*/
	            , waitResponsePromise];

	          case 3:
	            response = _a.sent();

	            if (!response || response.code !== 200) {
	              throw new AgoraRTCError(AgoraRTCErrorCode.CROSS_CHANNEL_SERVER_ERROR_RESPONSE, "response: " + stringify$2(response));
	            }

	            return [2
	            /*return*/
	            , response];
	        }
	      });
	    });
	  };

	  AgoraChannelMediaRelaySignal.prototype.connect = function (urls) {
	    return __awaiter$s(this, void 0, void 0, function () {
	      return __generator$s(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            this.ws.removeAllListeners(WebSocketManagerEvents.REQUEST_NEW_URLS);
	            this.ws.on(WebSocketManagerEvents.REQUEST_NEW_URLS, function (resolve) {
	              resolve(urls);
	            });
	            return [4
	            /*yield*/
	            , this.ws.init(urls)];

	          case 1:
	            _a.sent();

	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  AgoraChannelMediaRelaySignal.prototype.dispose = function () {
	    this.clearHeartBeatCheck();
	    this.emit("dispose");
	    this.removeAllListeners();
	    this.ws.close();
	  };

	  AgoraChannelMediaRelaySignal.prototype.sendPing = function (message) {
	    var requestId = this.requestId++;
	    message.requestId = requestId;
	    this.ws.sendMessage(message);
	    return requestId;
	  };

	  AgoraChannelMediaRelaySignal.prototype.startHeartBeatCheck = function () {
	    var _this = this;

	    this.heartBeatTimer = window.setInterval(function () {
	      _this.sendPing({
	        command: "ping",
	        appId: _this.joinInfo.appId,
	        cname: _this.joinInfo.cname,
	        uid: _this.joinInfo.uid.toString(),
	        sid: _this.joinInfo.sid,
	        ts: +new Date(),
	        requestId: 0
	      });
	    }, 3000);
	  };

	  AgoraChannelMediaRelaySignal.prototype.clearHeartBeatCheck = function () {
	    window.clearInterval(this.heartBeatTimer);
	    this.heartBeatTimer = undefined;
	  };

	  return AgoraChannelMediaRelaySignal;
	}(EventEmitter$1);

	var __extends$p = undefined && undefined.__extends || function () {
	  var extendStatics = function (d, b) {
	    extendStatics = setPrototypeOf$2 || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    };

	    return extendStatics(d, b);
	  };

	  return function (d, b) {
	    extendStatics(d, b);

	    function __() {
	      this.constructor = d;
	    }

	    d.prototype = b === null ? create$4(b) : (__.prototype = b.prototype, new __());
	  };
	}();

	var __awaiter$t = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = promise$3))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var __generator$t = undefined && undefined.__generator || function (thisArg, body) {
	  var _ = {
	    label: 0,
	    sent: function () {
	      if (t[0] & 1) throw t[1];
	      return t[1];
	    },
	    trys: [],
	    ops: []
	  },
	      f,
	      y,
	      t,
	      g;
	  return g = {
	    next: verb(0),
	    "throw": verb(1),
	    "return": verb(2)
	  }, typeof symbol$2 === "function" && (g[iterator$2] = function () {
	    return this;
	  }), g;

	  function verb(n) {
	    return function (v) {
	      return step([n, v]);
	    };
	  }

	  function step(op) {
	    if (f) throw new TypeError("Generator is already executing.");

	    while (_) try {
	      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	      if (y = 0, t) op = [op[0] & 2, t.value];

	      switch (op[0]) {
	        case 0:
	        case 1:
	          t = op;
	          break;

	        case 4:
	          _.label++;
	          return {
	            value: op[1],
	            done: false
	          };

	        case 5:
	          _.label++;
	          y = op[1];
	          op = [0];
	          continue;

	        case 7:
	          op = _.ops.pop();

	          _.trys.pop();

	          continue;

	        default:
	          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
	            _ = 0;
	            continue;
	          }

	          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
	            _.label = op[1];
	            break;
	          }

	          if (op[0] === 6 && _.label < t[1]) {
	            _.label = t[1];
	            t = op;
	            break;
	          }

	          if (t && _.label < t[2]) {
	            _.label = t[2];

	            _.ops.push(op);

	            break;
	          }

	          if (t[2]) _.ops.pop();

	          _.trys.pop();

	          continue;
	      }

	      op = body.call(thisArg, _);
	    } catch (e) {
	      op = [6, e];
	      y = 0;
	    } finally {
	      f = t = 0;
	    }

	    if (op[0] & 5) throw op[1];
	    return {
	      value: op[0] ? op[1] : void 0,
	      done: true
	    };
	  }
	};

	var AgoraChannelMediaRelayClient =
	/** @class */
	function (_super) {
	  __extends$p(AgoraChannelMediaRelayClient, _super);

	  function AgoraChannelMediaRelayClient(joinInfo, clientId, wsRetryConfig, httpRetryConfig) {
	    var _this = _super.call(this) || this;

	    _this.cancelToken = axios$1.CancelToken.source();
	    _this.requestId = 0;
	    _this._state = "RELAY_STATE_IDLE"
	    /* RELAY_STATE_IDLE */
	    ;
	    _this.errorCode = "RELAY_OK"
	    /* RELAY_OK */
	    ;

	    _this.onStatus = function (e) {
	      logger.debug("[" + _this.clientId + "] ChannelMediaStatus: " + stringify$2(e));

	      if (e && e.command) {
	        if (e.command === "onAudioPacketReceived") {
	          _this.emit("event", "PACKET_RECEIVED_AUDIO_FROM_SRC"
	          /* PACKET_RECEIVED_AUDIO_FROM_SRC */
	          );
	        }

	        if (e.command === "onVideoPacketReceived") {
	          _this.emit("event", "PACKET_RECEIVED_VIDEO_FROM_SRC"
	          /* PACKET_RECEIVED_VIDEO_FROM_SRC */
	          );
	        }

	        if (e.command === "onSrcTokenPrivilegeDidExpire") {
	          _this.errorCode = "SRC_TOKEN_EXPIRED"
	          /* SRC_TOKEN_EXPIRED */
	          ;
	          _this.state = "RELAY_STATE_FAILURE"
	          /* RELAY_STATE_FAILURE */
	          ;
	        }

	        if (e.command === "onDestTokenPrivilegeDidExpire") {
	          _this.errorCode = "DEST_TOKEN_EXPIRED"
	          /* DEST_TOKEN_EXPIRED */
	          ;
	          _this.state = "RELAY_STATE_FAILURE"
	          /* RELAY_STATE_FAILURE */
	          ;
	        }
	      }
	    };

	    _this.onReconnect = function () {
	      return __awaiter$t(_this, void 0, void 0, function () {
	        var _this = this;

	        return __generator$t(this, function (_a) {
	          logger.debug("[" + this.clientId + "] ChannelMediaSocket disconnect, reconnecting");
	          this.emit("event", "NETWORK_DISCONNECTED"
	          /* NETWORK_DISCONNECTED */
	          );
	          this.state = "RELAY_STATE_IDLE"
	          /* RELAY_STATE_IDLE */
	          ;

	          if (this.prevChannelMediaConfig) {
	            this.sendStartRelayMessage(this.prevChannelMediaConfig).catch(function (e) {
	              if (_this.state === "RELAY_STATE_IDLE"
	              /* RELAY_STATE_IDLE */
	              ) return;
	              logger.error("auto restart channel media relay failed", e.toString());
	              _this.errorCode = "SERVER_CONNECTION_LOST"
	              /* SERVER_CONNECTION_LOST */
	              ;
	              _this.state = "RELAY_STATE_FAILURE"
	              /* RELAY_STATE_FAILURE */
	              ;
	            });
	          }

	          return [2
	          /*return*/
	          ];
	        });
	      });
	    };

	    _this.joinInfo = joinInfo;
	    _this.clientId = clientId;
	    _this.signal = new AgoraChannelMediaRelaySignal(_this.joinInfo, _this.clientId, wsRetryConfig);
	    _this.httpRetryConfig = httpRetryConfig;
	    return _this;
	  }

	  defineProperty$4(AgoraChannelMediaRelayClient.prototype, "state", {
	    get: function () {
	      return this._state;
	    },
	    set: function (state) {
	      if (state === this._state) return;

	      if (state !== "RELAY_STATE_FAILURE"
	      /* RELAY_STATE_FAILURE */
	      ) {
	          this.errorCode = "RELAY_OK"
	          /* RELAY_OK */
	          ;
	        }

	      this.emit("state", state, this.errorCode);
	      this._state = state;
	    },
	    enumerable: true,
	    configurable: true
	  });

	  AgoraChannelMediaRelayClient.prototype.startChannelMediaRelay = function (configuration) {
	    return __awaiter$t(this, void 0, void 0, function () {
	      var e_1;
	      return __generator$t(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            if (this.state !== "RELAY_STATE_IDLE"
	            /* RELAY_STATE_IDLE */
	            ) {
	                throw new AgoraRTCError(AgoraRTCErrorCode.INVALID_OPERATION);
	              }

	            this.state = "RELAY_STATE_CONNECTING"
	            /* RELAY_STATE_CONNECTING */
	            ;
	            return [4
	            /*yield*/
	            , this.connect()];

	          case 1:
	            _a.sent();

	            logger.debug("[" + this.clientId + "] startChannelMediaRelay: connect success");
	            _a.label = 2;

	          case 2:
	            _a.trys.push([2, 4,, 5]);

	            return [4
	            /*yield*/
	            , this.sendStartRelayMessage(configuration)];

	          case 3:
	            _a.sent();

	            return [3
	            /*break*/
	            , 5];

	          case 4:
	            e_1 = _a.sent();

	            if (e_1.data && e_1.data.serverResponse && e_1.data.serverResponse.command === "SetSourceChannel") {
	              throw new AgoraRTCError(AgoraRTCErrorCode.CROSS_CHANNEL_FAILED_JOIN_SRC);
	            } else if (e_1.data && e_1.data.serverResponse && e_1.serverResponse.command === "SetDestChannelStatus") {
	              throw new AgoraRTCError(AgoraRTCErrorCode.CROSS_CHANNEL_FAILED_JOIN_DEST);
	            } else if (e_1.data && e_1.data.serverResponse && e_1.serverResponse.command === "StartPacketTransfer") {
	              throw new AgoraRTCError(AgoraRTCErrorCode.CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST);
	            }

	            throw e_1;

	          case 5:
	            this.prevChannelMediaConfig = configuration;
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  AgoraChannelMediaRelayClient.prototype.updateChannelMediaRelay = function (configuration) {
	    return __awaiter$t(this, void 0, void 0, function () {
	      return __generator$t(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            if (this.state !== "RELAY_STATE_RUNNING"
	            /* RELAY_STATE_RUNNING */
	            ) {
	                throw new AgoraRTCError(AgoraRTCErrorCode.INVALID_OPERATION);
	              }

	            return [4
	            /*yield*/
	            , this.sendUpdateMessage(configuration)];

	          case 1:
	            _a.sent();

	            this.prevChannelMediaConfig = configuration;
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  AgoraChannelMediaRelayClient.prototype.stopChannelMediaRelay = function () {
	    return __awaiter$t(this, void 0, void 0, function () {
	      return __generator$t(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            return [4
	            /*yield*/
	            , this.sendStopRelayMessage()];

	          case 1:
	            _a.sent();

	            logger.debug("[" + this.clientId + "] stopChannelMediaRelay: send stop message success");
	            this.state = "RELAY_STATE_IDLE"
	            /* RELAY_STATE_IDLE */
	            ;
	            this.dispose();
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  AgoraChannelMediaRelayClient.prototype.dispose = function () {
	    logger.debug("[" + this.clientId + "] disposeChannelMediaRelay");
	    this.cancelToken.cancel();
	    this.cancelToken = axios$1.CancelToken.source();
	    this.state = "RELAY_STATE_IDLE"
	    /* RELAY_STATE_IDLE */
	    ;
	    this.emit("dispose");
	    this.signal.dispose();
	    this.prevChannelMediaConfig = undefined;
	  };

	  AgoraChannelMediaRelayClient.prototype.connect = function () {
	    return __awaiter$t(this, void 0, void 0, function () {
	      var result;
	      return __generator$t(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            return [4
	            /*yield*/
	            , getCrossChannelWorkerManagerResult(this.joinInfo, this.cancelToken.token, this.httpRetryConfig)];

	          case 1:
	            result = _a.sent();
	            this.workerToken = result.workerToken;
	            return [4
	            /*yield*/
	            , this.signal.connect(result.addressList)];

	          case 2:
	            _a.sent();

	            this.emit("event", "NETWORK_CONNECTED"
	            /* NETWORK_CONNECTED */
	            );
	            this.signal.on("status", this.onStatus);
	            this.signal.on("reconnecting", this.onReconnect);
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  AgoraChannelMediaRelayClient.prototype.sendStartRelayMessage = function (configuration) {
	    return __awaiter$t(this, void 0, void 0, function () {
	      var stopPacketMsg, setSdkProfileMsg, setSourceChannelMsg, setSourceUserIdMsg, setDestChannelMsg, startPacketTransferMsg;
	      return __generator$t(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            stopPacketMsg = this.genMessage(CHANNEL_MEDIA_RELAY_MESSAGE_TYPE.StopPacketTransfer);
	            return [4
	            /*yield*/
	            , this.signal.request(stopPacketMsg)];

	          case 1:
	            _a.sent();

	            return [4
	            /*yield*/
	            , this.signal.waitStatus("Normal Quit")];

	          case 2:
	            _a.sent();

	            logger.debug("[" + this.clientId + "] startChannelMediaRelay: StopPacketTransfer success");
	            setSdkProfileMsg = this.genMessage(CHANNEL_MEDIA_RELAY_MESSAGE_TYPE.SetSdkProfile, configuration);
	            return [4
	            /*yield*/
	            , this.signal.request(setSdkProfileMsg)];

	          case 3:
	            _a.sent();

	            logger.debug("[" + this.clientId + "] startChannelMediaRelay: SetSdkProfile success");
	            setSourceChannelMsg = this.genMessage(CHANNEL_MEDIA_RELAY_MESSAGE_TYPE.SetSourceChannel, configuration);
	            return [4
	            /*yield*/
	            , this.signal.request(setSourceChannelMsg)];

	          case 4:
	            _a.sent();

	            return [4
	            /*yield*/
	            , this.signal.waitStatus("SetSourceChannelStatus")];

	          case 5:
	            _a.sent();

	            this.emit("event", "PACKET_JOINED_SRC_CHANNEL"
	            /* PACKET_JOINED_SRC_CHANNEL */
	            );
	            logger.debug("[" + this.clientId + "] startChannelMediaRelay: SetSourceChannel success");
	            setSourceUserIdMsg = this.genMessage(CHANNEL_MEDIA_RELAY_MESSAGE_TYPE.SetSourceUserId, configuration);
	            return [4
	            /*yield*/
	            , this.signal.request(setSourceUserIdMsg)];

	          case 6:
	            _a.sent();

	            logger.debug("[" + this.clientId + "] startChannelMediaRelay: SetSourceUserId success");
	            setDestChannelMsg = this.genMessage(CHANNEL_MEDIA_RELAY_MESSAGE_TYPE.SetDestChannel, configuration);
	            return [4
	            /*yield*/
	            , this.signal.request(setDestChannelMsg)];

	          case 7:
	            _a.sent();

	            return [4
	            /*yield*/
	            , this.signal.waitStatus("SetDestChannelStatus")];

	          case 8:
	            _a.sent();

	            this.emit("event", "PACKET_JOINED_DEST_CHANNEL"
	            /* PACKET_JOINED_DEST_CHANNEL */
	            );
	            logger.debug("[" + this.clientId + "] startChannelMediaRelay: SetDestChannel success");
	            startPacketTransferMsg = this.genMessage(CHANNEL_MEDIA_RELAY_MESSAGE_TYPE.StartPacketTransfer, configuration);
	            return [4
	            /*yield*/
	            , this.signal.request(startPacketTransferMsg)];

	          case 9:
	            _a.sent();

	            this.emit("event", "PACKET_SENT_TO_DEST_CHANNEL"
	            /* PACKET_SENT_TO_DEST_CHANNEL */
	            );
	            this.state = "RELAY_STATE_RUNNING"
	            /* RELAY_STATE_RUNNING */
	            ;
	            logger.debug("[" + this.clientId + "] startChannelMediaRelay: StartPacketTransfer success");
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  AgoraChannelMediaRelayClient.prototype.sendUpdateMessage = function (configuration) {
	    return __awaiter$t(this, void 0, void 0, function () {
	      var updateMsg;
	      return __generator$t(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            updateMsg = this.genMessage(CHANNEL_MEDIA_RELAY_MESSAGE_TYPE.UpdateDestChannel, configuration);
	            return [4
	            /*yield*/
	            , this.signal.request(updateMsg)];

	          case 1:
	            _a.sent();

	            this.emit("event", "PACKET_UPDATE_DEST_CHANNEL"
	            /* PACKET_UPDATE_DEST_CHANNEL */
	            );
	            logger.debug("[" + this.clientId + "] sendUpdateMessage: UpdateDestChannel success");
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  AgoraChannelMediaRelayClient.prototype.sendStopRelayMessage = function () {
	    return __awaiter$t(this, void 0, void 0, function () {
	      var stopPacketMsg;
	      return __generator$t(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            stopPacketMsg = this.genMessage(CHANNEL_MEDIA_RELAY_MESSAGE_TYPE.StopPacketTransfer);
	            return [4
	            /*yield*/
	            , this.signal.request(stopPacketMsg)];

	          case 1:
	            _a.sent();

	            logger.debug("[" + this.clientId + "] sendStopRelayMessage: StopPacketTransfer success");
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  AgoraChannelMediaRelayClient.prototype.genMessage = function (messageType, configuration) {
	    var _this = this;

	    var cnames = [];
	    var uids = [];
	    var tokens = [];
	    this.requestId += 1;
	    var message = {
	      appId: this.joinInfo.appId,
	      cname: this.joinInfo.cname,
	      uid: this.joinInfo.uid.toString(),
	      sdkVersion: VERSION,
	      sid: this.joinInfo.sid,
	      ts: now$2(),
	      requestId: this.requestId,
	      seq: this.requestId,
	      allocate: true,
	      clientRequest: {}
	    };
	    /**
	     * 加这一句是因为在单测的时候无法给 VERSION 赋值（rollup 打包替换）
	     * 而 UAP 服务又不认这种 version(会导致无法创建 worker)
	     */

	    if (message.sdkVersion === "4.1.1") {
	      message.sdkVersion = "0.0.1";
	    }

	    var destInfos = null;
	    var srcInfo = null;

	    switch (messageType) {
	      case CHANNEL_MEDIA_RELAY_MESSAGE_TYPE.SetSdkProfile:
	        message.clientRequest = {
	          command: "SetSdkProfile",
	          type: "multi_channel"
	        };
	        return message;

	      case CHANNEL_MEDIA_RELAY_MESSAGE_TYPE.SetSourceChannel:
	        srcInfo = configuration && configuration.getSrcChannelMediaInfo();

	        if (!srcInfo) {
	          throw new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_ERROR, "can not find source config");
	        }

	        message.clientRequest = {
	          command: "SetSourceChannel",
	          uid: "0",
	          channelName: srcInfo.channelName,
	          token: srcInfo.token || this.joinInfo.appId
	        };
	        return message;

	      case CHANNEL_MEDIA_RELAY_MESSAGE_TYPE.SetSourceUserId:
	        srcInfo = configuration && configuration.getSrcChannelMediaInfo();

	        if (!srcInfo) {
	          throw new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_ERROR, "can not find source config");
	        }

	        message.clientRequest = {
	          command: "SetSourceUserId",
	          uid: srcInfo.uid + ""
	        };
	        return message;

	      case CHANNEL_MEDIA_RELAY_MESSAGE_TYPE.SetDestChannel:
	        destInfos = configuration && configuration.getDestChannelMediaInfo();

	        if (!destInfos) {
	          throw new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_ERROR, "can not find dest config");
	        }

	        forEach$3(destInfos).call(destInfos, function (value) {
	          cnames.push(value.channelName);
	          uids.push(value.uid + "");
	          tokens.push(value.token || _this.joinInfo.appId);
	        });

	        message.clientRequest = {
	          command: "SetDestChannel",
	          channelName: cnames,
	          uid: uids,
	          token: tokens
	        };
	        return message;

	      case CHANNEL_MEDIA_RELAY_MESSAGE_TYPE.StartPacketTransfer:
	        message.clientRequest = {
	          command: "StartPacketTransfer"
	        };
	        return message;

	      case CHANNEL_MEDIA_RELAY_MESSAGE_TYPE.Reconnect:
	        message.clientRequest = {
	          command: "Reconnect"
	        };
	        return message;

	      case CHANNEL_MEDIA_RELAY_MESSAGE_TYPE.StopPacketTransfer:
	        message.clientRequest = {
	          command: "StopPacketTransfer"
	        };
	        return message;

	      case CHANNEL_MEDIA_RELAY_MESSAGE_TYPE.UpdateDestChannel:
	        destInfos = configuration && configuration.getDestChannelMediaInfo();

	        if (!destInfos) {
	          throw new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_ERROR, "can not find dest config");
	        }

	        forEach$3(destInfos).call(destInfos, function (value) {
	          cnames.push(value.channelName);
	          uids.push(value.uid + "");
	          tokens.push(value.token || _this.joinInfo.appId);
	        });

	        message.clientRequest = {
	          command: "UpdateDestChannel",
	          channelName: cnames,
	          uid: uids,
	          token: tokens
	        };
	        return message;
	    }

	    return message;
	  };

	  return AgoraChannelMediaRelayClient;
	}(EventEmitter$1);

	var AgoraRTCRemoteUser =
	/** @class */
	function () {
	  function AgoraRTCRemoteUser(uid, uintid) {
	    /**
	     * @internal
	     * 每次当 WS 重连的时候，因为网关的设计我们无法判断一个用户到底是否真的还在房间内。
	     * 通过这个 flag，每次 WS 断开都将其置为 `false`。
	     * WS 重连之后，每次收到 `user-online` 之后将其置为 `true`，3 秒之后统计所有 flag 是 `false` 的 user。
	     * SDK 就认为这些 user 已经离开了 channel，执行相关的清理函数。
	     *
	     */
	    this._trust_in_room_ = true;
	    this._trust_audio_enabled_state_ = true;
	    this._trust_video_enabled_state_ = true;
	    this._trust_audio_mute_state_ = true;
	    this._trust_video_mute_state_ = true;
	    this._trust_stream_added_state_ = true;
	    this._audio_muted_ = false;
	    this._video_muted_ = false;
	    this._audio_enabled_ = true;
	    this._video_enabled_ = true;
	    this._audio_added_ = false;
	    this._video_added_ = false;
	    this.uid = uid;
	    this._uintid = uintid;
	  }

	  defineProperty$4(AgoraRTCRemoteUser.prototype, "hasVideo", {
	    get: function () {
	      return this._video_enabled_ && !this._video_muted_ && this._video_added_;
	    },
	    enumerable: true,
	    configurable: true
	  });

	  defineProperty$4(AgoraRTCRemoteUser.prototype, "hasAudio", {
	    get: function () {
	      return this._audio_enabled_ && !this._audio_muted_ && this._audio_added_;
	    },
	    enumerable: true,
	    configurable: true
	  });

	  defineProperty$4(AgoraRTCRemoteUser.prototype, "audioTrack", {
	    get: function () {
	      if (this.hasAudio) return this._audioTrack;
	    },
	    enumerable: true,
	    configurable: true
	  });

	  defineProperty$4(AgoraRTCRemoteUser.prototype, "videoTrack", {
	    get: function () {
	      if (this.hasVideo) return this._videoTrack;
	    },
	    enumerable: true,
	    configurable: true
	  });

	  return AgoraRTCRemoteUser;
	}();

	var __extends$q = undefined && undefined.__extends || function () {
	  var extendStatics = function (d, b) {
	    extendStatics = setPrototypeOf$2 || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    };

	    return extendStatics(d, b);
	  };

	  return function (d, b) {
	    extendStatics(d, b);

	    function __() {
	      this.constructor = d;
	    }

	    d.prototype = b === null ? create$4(b) : (__.prototype = b.prototype, new __());
	  };
	}();

	var __assign$d = undefined && undefined.__assign || function () {
	  __assign$d = assign$2 || function (t) {
	    for (var s, i = 1, n = arguments.length; i < n; i++) {
	      s = arguments[i];

	      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	    }

	    return t;
	  };

	  return __assign$d.apply(this, arguments);
	};

	var __awaiter$u = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = promise$3))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var __generator$u = undefined && undefined.__generator || function (thisArg, body) {
	  var _ = {
	    label: 0,
	    sent: function () {
	      if (t[0] & 1) throw t[1];
	      return t[1];
	    },
	    trys: [],
	    ops: []
	  },
	      f,
	      y,
	      t,
	      g;
	  return g = {
	    next: verb(0),
	    "throw": verb(1),
	    "return": verb(2)
	  }, typeof symbol$2 === "function" && (g[iterator$2] = function () {
	    return this;
	  }), g;

	  function verb(n) {
	    return function (v) {
	      return step([n, v]);
	    };
	  }

	  function step(op) {
	    if (f) throw new TypeError("Generator is already executing.");

	    while (_) try {
	      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	      if (y = 0, t) op = [op[0] & 2, t.value];

	      switch (op[0]) {
	        case 0:
	        case 1:
	          t = op;
	          break;

	        case 4:
	          _.label++;
	          return {
	            value: op[1],
	            done: false
	          };

	        case 5:
	          _.label++;
	          y = op[1];
	          op = [0];
	          continue;

	        case 7:
	          op = _.ops.pop();

	          _.trys.pop();

	          continue;

	        default:
	          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
	            _ = 0;
	            continue;
	          }

	          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
	            _.label = op[1];
	            break;
	          }

	          if (op[0] === 6 && _.label < t[1]) {
	            _.label = t[1];
	            t = op;
	            break;
	          }

	          if (t && _.label < t[2]) {
	            _.label = t[2];

	            _.ops.push(op);

	            break;
	          }

	          if (t[2]) _.ops.pop();

	          _.trys.pop();

	          continue;
	      }

	      op = body.call(thisArg, _);
	    } catch (e) {
	      op = [6, e];
	      y = 0;
	    } finally {
	      f = t = 0;
	    }

	    if (op[0] & 5) throw op[1];
	    return {
	      value: op[0] ? op[1] : void 0,
	      done: true
	    };
	  }
	};

	var AgoraRTCClient =
	/** @class */
	function (_super) {
	  __extends$q(AgoraRTCClient, _super);

	  function AgoraRTCClient(config) {
	    var _this = _super.call(this) || this;

	    _this._users = [];
	    /** @internal */

	    _this._sessionId = null;
	    _this._bindEnabledTracks = [];
	    /** 在 leave 的过程中不允许 join */

	    _this._leaveMutex = new PromiseMutex("client-leave");
	    _this._publishMutex = new PromiseMutex("client-publish");
	    _this._subscribeMutex = new map$2();
	    _this._remoteStream = new map$2();
	    _this._encryptionMode = "none";
	    _this._encryptionSecret = null;
	    _this._turnServer = {
	      servers: [],
	      mode: "auto"
	    };
	    /** 是否开启了云代理服务 */

	    _this._cloudProxyServerMode = "disabled";
	    /** @internal 是否开启了大小流 */

	    _this._isDualStreamEnabled = false;
	    _this._streamFallbackTypeCacheMap = new map$2();
	    _this._remoteStreamTypeCacheMap = new map$2();
	    _this._axiosCancelSource = axios$1.CancelToken.source();
	    _this._networkQualitySensitivity = "normal";

	    _this._handleLocalTrackEnable = function (track, resolve, reject) {
	      _this.publish(track, false).then(resolve).catch(reject);
	    };

	    _this._handleLocalTrackDisable = function (track, resolve, reject) {
	      _this.unpublish(track, false).then(resolve).catch(reject);
	    };

	    _this._handleUserOnline = function (message) {
	      var _context;

	      if (_this.isStringUID && typeof message.uid !== "string") {
	        logger.error("[" + _this._clientId + "] StringUID is Mixed with UintUID");
	      }

	      var user = find$2(_context = _this._users).call(_context, function (user) {
	        return user.uid === message.uid;
	      });

	      if (!user) {
	        var newUser = new AgoraRTCRemoteUser(message.uid, message.uint_id || message.uid);

	        _this._users.push(newUser);

	        logger.debug("[" + _this._clientId + "] user online", message.uid);

	        _this.emit(ClientEvents.USER_JOINED, newUser);
	      } else {
	        user._trust_in_room_ = true;
	      }
	    };

	    _this._handleUserOffline = function (message) {
	      var _context2;

	      var user = find$2(_context2 = _this._users).call(_context2, function (user) {
	        return user.uid === message.uid;
	      });

	      if (!user) return;

	      _this._handleRemoveStream(message);

	      removeItemFromList(_this._users, user);

	      _this._remoteStreamTypeCacheMap.delete(user.uid);

	      _this._streamFallbackTypeCacheMap.delete(user.uid);

	      logger.debug("[" + _this._clientId + "] user offline", message.uid, "reason:", message.reason);

	      _this.emit(ClientEvents.USER_LEAVED, user, message.reason);
	    };

	    _this._handleAddAudioOrVideoStream = function (mediaType, uid, uint_id) {
	      var _context3;

	      var user = find$2(_context3 = _this._users).call(_context3, function (user) {
	        return user.uid === uid;
	      });

	      if (!user) {
	        logger.error("[" + _this._clientId + "] can not find target user!(on_add_stream)");
	        return;
	      }

	      logger.debug("[" + _this._clientId + "] stream added with uid " + uid + ", type " + mediaType);
	      var lastHasMedia = mediaType === "audio" ? user.hasAudio : user.hasVideo;

	      if (!user._uintid) {
	        user._uintid = uint_id || uid;
	      }

	      user._trust_stream_added_state_ = true;

	      if (mediaType === "audio") {
	        user._audio_added_ = true;
	      } else {
	        user._video_added_ = true;
	      }

	      if ((mediaType === "audio" ? user.hasAudio : user.hasVideo) && !lastHasMedia) {
	        logger.info("[" + _this._clientId + "] remote user " + user.uid + " published " + mediaType);

	        _this.emit(ClientEvents.USER_PUBLISHED, user, mediaType);
	      }

	      if (mediaType === "video") {
	        report.onGatewayStream(_this._sessionId, AgoraRTCEvent.ON_ADD_VIDEO_STREAM, AgoraRTCEventUploadType.ON_ADD_VIDEO_STREAM, {
	          peer: uint_id || uid
	        });
	      } else {
	        report.onGatewayStream(_this._sessionId, AgoraRTCEvent.ON_ADD_AUDIO_STREAM, AgoraRTCEventUploadType.ON_ADD_AUDIO_STREAM, {
	          peer: uint_id || uid
	        });
	      }

	      var sc = _this._remoteStream.get(uid);

	      if (sc && sc.readyToReconnect && sc.connectionState === "connecting") {
	        sc.reconnectPC().catch(function (e) {
	          logger.error("[" + _this._clientId + "] resubscribe error", e.toString());
	        });
	      }
	    };

	    _this._handleRemoveStream = function (message) {
	      var _context4;

	      var user = find$2(_context4 = _this._users).call(_context4, function (user) {
	        return user.uid === message.uid;
	      });

	      if (!user) {
	        logger.warning("[" + _this._clientId + "] can not find target user!(on_remove_stream)");
	        return;
	      }

	      logger.debug("[" + _this._clientId + "] stream removed with uid " + message.uid);

	      var emitUnpublish = function () {};

	      if (user.hasAudio && user.hasVideo) {
	        emitUnpublish = function () {
	          logger.info("[" + _this._clientId + "] remote user " + user.uid + " unpublished audio track");

	          _this.emit(ClientEvents.USER_UNPUBLISHED, user, "audio");

	          logger.info("[" + _this._clientId + "] remote user " + user.uid + " unpublished video track");

	          _this.emit(ClientEvents.USER_UNPUBLISHED, user, "video");
	        };
	      } else if (user.hasVideo) {
	        emitUnpublish = function () {
	          logger.info("[" + _this._clientId + "] remote user " + user.uid + " unpublished video track");

	          _this.emit(ClientEvents.USER_UNPUBLISHED, user, "video");
	        };
	      } else if (user.hasAudio) {
	        emitUnpublish = function () {
	          logger.info("[" + _this._clientId + "] remote user " + user.uid + " unpublished audio track");

	          _this.emit(ClientEvents.USER_UNPUBLISHED, user, "audio");
	        };
	      }

	      user._trust_stream_added_state_ = true;
	      user._audio_added_ = false;
	      user._video_added_ = false;

	      var sc = _this._remoteStream.get(user.uid);

	      if (sc) {
	        sc.closeP2PConnection();

	        _this._remoteStream.delete(user.uid);
	      }

	      report.onGatewayStream(_this._sessionId, AgoraRTCEvent.ON_REMOVE_STREAM, AgoraRTCEventUploadType.ON_REMOVE_STREAM, {
	        peer: message.uint_id || message.uid
	      });
	      emitUnpublish();
	    };

	    _this._handleSetStreamLocalEnable = function (mediaType, uid, enabled) {
	      var _context5;

	      var user = find$2(_context5 = _this._users).call(_context5, function (user) {
	        return user.uid === uid;
	      });

	      if (!user) {
	        logger.error("[" + _this._clientId + "] can not find target user!(disable_local)");
	        return;
	      }

	      logger.debug("[" + _this._clientId + "] local " + mediaType + " " + (enabled ? "enabled" : "disabled") + " with uid " + uid);
	      var lastHasMedia = mediaType === "audio" ? user.hasAudio : user.hasVideo;

	      if (mediaType === "audio") {
	        user._trust_audio_enabled_state_ = true;
	        var lastEnabledState = user._audio_enabled_;
	        user._audio_enabled_ = enabled;

	        if (user._audio_enabled_ !== lastEnabledState) {
	          var msg = user._audio_enabled_ ? "enable-local-audio" : "disable-local-audio";
	          logger.debug("[" + _this._clientId + "] user-info-updated, uid: " + uid + ", msg: " + msg);

	          _this.emit(ClientEvents.USER_INFO_UPDATED, uid, msg);
	        } else {
	          return;
	        }
	      } else {
	        user._trust_video_enabled_state_ = true;
	        var lastEnabledState = user._video_enabled_;
	        user._video_enabled_ = enabled;

	        if (user._video_enabled_ !== lastEnabledState) {
	          var msg = user._video_enabled_ ? "enable-local-video" : "disable-local-video";
	          logger.debug("[" + _this._clientId + "] user-info-update, uid: " + uid + ", msg: " + msg);

	          _this.emit(ClientEvents.USER_INFO_UPDATED, uid, msg);
	        } else {
	          return;
	        }
	      }

	      var currentHasMedia = mediaType === "audio" ? user.hasAudio : user.hasVideo;
	      if (lastHasMedia === currentHasMedia) return;

	      if (!lastHasMedia && currentHasMedia) {
	        logger.info("[" + _this._clientId + "] remote user " + uid + " published " + mediaType);

	        _this.emit(ClientEvents.USER_PUBLISHED, user, mediaType);

	        return;
	      }

	      var sc = _this._remoteStream.get(uid);

	      if (sc) {
	        var subOptions = __assign$d({}, sc.subscribeOptions);

	        subOptions.audio = user.hasAudio ? subOptions.audio : false;
	        subOptions.video = user.hasVideo ? subOptions.video : false;

	        if (!subOptions.audio && !subOptions.video) {
	          sc.closeP2PConnection().catch(function (e) {
	            // 不抛出 close 的错误，没有意义
	            logger.warning("close sub pc error", e);
	          });

	          _this._remoteStream.delete(user.uid);
	        } else {
	          sc.setSubscribeOptions(subOptions);
	        }
	      }

	      logger.info("[" + _this._clientId + "] remote user " + user.uid + " unpublished " + mediaType);

	      _this.emit(ClientEvents.USER_UNPUBLISHED, user, mediaType);
	    };

	    _this._handleMuteStream = function (uid, mediaType, muted) {
	      var _context6;

	      logger.debug("[" + _this._clientId + "] receive mute message", uid, mediaType, muted);

	      var remoteUser = find$2(_context6 = _this._users).call(_context6, function (user) {
	        return user.uid === uid;
	      });

	      if (!remoteUser) {
	        logger.warning("[" + _this._clientId + "] can not find remote user, ignore mute event, uid: " + uid);
	        return;
	      }

	      var lastHasMedia = mediaType === "audio" ? remoteUser.hasAudio : remoteUser.hasVideo;

	      if (mediaType === "audio") {
	        remoteUser._trust_audio_mute_state_ = true;
	        var lastMuteState = remoteUser._audio_muted_;
	        remoteUser._audio_muted_ = muted;

	        if (remoteUser._audio_muted_ !== lastMuteState) {
	          var msg = remoteUser._audio_muted_ ? "mute-audio" : "unmute-audio";
	          logger.debug("[" + _this._clientId + "] user-info-update, uid: " + uid + ", msg: " + msg);

	          _this.emit(ClientEvents.USER_INFO_UPDATED, uid, msg);
	        } else {
	          return;
	        }
	      } else {
	        remoteUser._trust_video_mute_state_ = true;
	        var lastMuteState = remoteUser._video_muted_;
	        remoteUser._video_muted_ = muted;

	        if (remoteUser._video_muted_ !== lastMuteState) {
	          var msg = remoteUser._video_muted_ ? "mute-video" : "unmute-video";
	          logger.debug("[" + _this._clientId + "] user-info-update, uid: " + uid + ", msg: " + msg);

	          _this.emit(ClientEvents.USER_INFO_UPDATED, uid, msg);
	        } else {
	          return;
	        }
	      }

	      var currentHasMedia = mediaType === "audio" ? remoteUser.hasAudio : remoteUser.hasVideo;
	      if (lastHasMedia === currentHasMedia) return;

	      if (!lastHasMedia && currentHasMedia) {
	        logger.info("[" + _this._clientId + "] remote user " + uid + " published " + mediaType);

	        _this.emit(ClientEvents.USER_PUBLISHED, remoteUser, mediaType);

	        return;
	      }

	      var sc = _this._remoteStream.get(uid);

	      if (sc) {
	        var subOptions = __assign$d({}, sc.subscribeOptions);

	        subOptions.audio = remoteUser.hasAudio ? subOptions.audio : false;
	        subOptions.video = remoteUser.hasVideo ? subOptions.video : false;

	        if (!subOptions.audio && !subOptions.video) {
	          sc.closeP2PConnection().catch(function (e) {
	            // 不抛出 close 的错误，没有意义
	            logger.warning("close sub pc error", e);
	          });

	          _this._remoteStream.delete(remoteUser.uid);
	        } else {
	          sc.setSubscribeOptions(subOptions);
	        }
	      }

	      logger.info("[" + _this._clientId + "] remote user " + uid + " unpublished " + mediaType);

	      _this.emit(ClientEvents.USER_UNPUBLISHED, remoteUser, mediaType);
	    };

	    _this._handleP2PLost = function (message) {
	      logger.debug("[" + _this._clientId + "] receive p2p lost", message);
	      var sc = null;

	      if (_this._highStream && _this._highStream.pc.ID === message.p2pid) {
	        sc = _this._highStream;
	      } else if (_this._lowStream && _this._lowStream.pc.ID === message.p2pid) {
	        sc = _this._lowStream;
	      } else {
	        var _context7;

	        forEach$3(_context7 = _this._remoteStream).call(_context7, function (stream) {
	          if (stream.pc.ID === message.p2pid) {
	            sc = stream;
	          }
	        });
	      }

	      if (!sc) {
	        logger.warning("P2PLost stream not found", message);
	        return;
	      }

	      sc.emit(StreamConnectionEvents.GATEWAY_P2P_LOST, message.p2pid);
	    };

	    _this._handleTokenWillExpire = function () {
	      logger.debug("[" + _this._clientId + "] received message onTokenPrivilegeWillExpire");

	      _this.emit(ClientEvents.ON_TOKEN_PRIVILEGE_WILL_EXPIRE);
	    };
	    /** 当页面被刷新/关闭时触发 */


	    _this._handleBeforeUnload = function (e) {
	      /**
	       * 如果用户希望通过 beforeunload 实现二次确认，需要手动将 returnValue 设置为非空字符串来跳过 SDK 的自动 leave
	       */
	      if (e.returnValue !== undefined && e.returnValue !== "") {
	        return;
	      }

	      _this.leave();

	      logger.info("[" + _this._clientId + "] auto leave onbeforeunload");
	    };

	    _this._handleUpdateNetworkQuality = function () {
	      var _context8;

	      if (_this._networkQualitySensitivity === "normal") {
	        return;
	      }

	      if (navigator && navigator.onLine !== undefined && !navigator.onLine) {
	        _this.emit(ClientEvents.NETWORK_QUALITY, {
	          downlinkNetworkQuality: 6,
	          uplinkNetworkQuality: 6
	        });

	        return;
	      }

	      var quality = {
	        downlinkNetworkQuality: 0,
	        uplinkNetworkQuality: 0
	      };

	      if (_this._highStream && !_this._highStream.detecting) {
	        quality.uplinkNetworkQuality = _this._highStream.getNetworkQuality();
	      }

	      var downlinkQuality = 0;

	      forEach$3(_context8 = _this._remoteStream).call(_context8, function (sc) {
	        return downlinkQuality += sc.getNetworkQuality();
	      });

	      if (_this._remoteStream.size > 0) {
	        quality.downlinkNetworkQuality = Math.round(downlinkQuality / _this._remoteStream.size);
	      }

	      _this.emit(ClientEvents.NETWORK_QUALITY, quality);
	    };

	    _this._codec = config.codec;
	    _this._mode = config.mode;

	    if (config.proxyServer) {
	      _this._proxyServer = config.proxyServer;
	      report.setProxyServer(_this._proxyServer);
	      logger.setProxyServer(_this._proxyServer);
	    }

	    if (config.turnServer) {
	      _this._turnServer = __assign$d(__assign$d(__assign$d({}, _this._turnServer), {
	        mode: "manual"
	      }), config.turnServer);
	    }

	    _this._clientId = getRandomString(5, "client-");
	    logger.info("[" + _this._clientId + "] Initializing AgoraRTC client v" + VERSION + " build: " + BUILD + ", mode: " + _this._mode + ", codec: " + _this._codec);
	    _this._statsCollector = new AgoraRTCStatsCollector(_this._clientId);

	    _this._statsCollector.onStatsException = function (code, message, uid) {
	      logger.debug("[" + _this._clientId + "] receive exception msg, code: " + code + ", msg: " + message + ", uid: " + uid);

	      _this.emit(ClientEvents.EXCEPTION, {
	        code: code,
	        msg: message,
	        uid: uid
	      });
	    };

	    _this._statsCollector.onUploadPublishDuration = function (uid, audioDuration, videoDuration, subElapse) {
	      var _context9;

	      var user = find$2(_context9 = _this._users).call(_context9, function (user) {
	        return user.uid === uid;
	      });

	      user && report.peerPublishStatus(_this._sessionId, {
	        subscribeElapse: subElapse,
	        audioPublishDuration: audioDuration,
	        videoPublishDuration: videoDuration,
	        peer: user._uintid
	      });
	    };

	    _this._gateway = new AgoraRTCGateway({
	      clientId: _this._clientId,
	      mode: _this._mode,
	      codec: _this._codec,
	      websocketRetryConfig: config.websocketRetryConfig || DEFAULT_RETRY_CONFIG,
	      httpRetryConfig: config.httpRetryConfig || DEFAULT_RETRY_CONFIG,
	      forceWaitGatewayResponse: config.forceWaitGatewayResponse === undefined ? true : config.forceWaitGatewayResponse,
	      statsCollector: _this._statsCollector,
	      role: config.role
	    });
	    _this._config = config;
	    _this._configDistribute = new ConfigDistributeManager(_this);

	    _this._handleGatewayEvents();

	    CLIENT_LIST.push(_this);
	    return _this;
	  }

	  defineProperty$4(AgoraRTCClient.prototype, "connectionState", {
	    get: function () {
	      return this._gateway.state;
	    },
	    enumerable: true,
	    configurable: true
	  });

	  defineProperty$4(AgoraRTCClient.prototype, "remoteUsers", {
	    get: function () {
	      return this._users;
	    },
	    enumerable: true,
	    configurable: true
	  });

	  defineProperty$4(AgoraRTCClient.prototype, "localTracks", {
	    get: function () {
	      if (!this._highStream) return [];
	      return this._highStream.getAllTracks();
	    },
	    enumerable: true,
	    configurable: true
	  });

	  defineProperty$4(AgoraRTCClient.prototype, "uid", {
	    get: function () {
	      return this._uid;
	    },
	    enumerable: true,
	    configurable: true
	  });

	  defineProperty$4(AgoraRTCClient.prototype, "channelName", {
	    get: function () {
	      return this._channelName;
	    },
	    enumerable: true,
	    configurable: true
	  });

	  defineProperty$4(AgoraRTCClient.prototype, "isStringUID", {
	    get: function () {
	      return this._joinInfo ? !!this._joinInfo.stringUid : false;
	    },
	    enumerable: true,
	    configurable: true
	  });

	  AgoraRTCClient.prototype.join = function (appId, channel, token, uid, optionalInfo) {
	    return __awaiter$u(this, void 0, void 0, function () {
	      var executor, unlock, err, joinInfo, uid_1, serverInfo, gatewayUID, e_1;

	      var _this = this;

	      return __generator$u(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            executor = report.reportApiInvoke(this._sessionId, {
	              name: AgoraAPIName.JOIN,
	              options: [appId, channel, token, uid],
	              tag: AgoraAPITag.TRACER
	            });

	            try {
	              if (!token && token !== null) {
	                throw new AgoraRTCError(AgoraRTCErrorCode.INVALID_PARAMS, "Invalid token: " + token + ". If you don not use token, set it to null");
	              } else {
	                token && checkValidString(token, "token", 1, 2047);
	              }

	              checkValidChannelName(channel);
	              uid && checkValidUID(uid);
	              optionalInfo && checkValidString(optionalInfo, "optionalInfo", 1, 2047);
	            } catch (e) {
	              executor.onError(e);
	              throw e;
	            }

	            logger.info("[" + this._clientId + "] start join channel " + channel);
	            if (!this._leaveMutex.isLocked) return [3
	            /*break*/
	            , 2];
	            logger.debug("[" + this._clientId + "] join: waiting leave operation");
	            return [4
	            /*yield*/
	            , this._leaveMutex.lock()];

	          case 1:
	            unlock = _a.sent();
	            unlock();
	            logger.debug("[" + this._clientId + "] join: continue");
	            _a.label = 2;

	          case 2:
	            if (this.connectionState !== "DISCONNECTED") {
	              err = new AgoraRTCError(AgoraRTCErrorCode.INVALID_OPERATION, "[" + this._clientId + "] Client already in connecting/connected state");
	              executor.onError(err);
	              throw err;
	            }

	            this._sessionId = generateSessionID();
	            this._gateway.state = "CONNECTING";
	            joinInfo = {
	              clientId: this._clientId,
	              appId: appId,
	              sid: this._sessionId,
	              cname: channel,
	              uid: typeof uid !== "string" ? uid : null,
	              turnServer: this._turnServer,
	              proxyServer: this._proxyServer,
	              token: token || appId,
	              cloudProxyServer: this._cloudProxyServerMode,
	              optionalInfo: optionalInfo
	            };

	            if (typeof uid === "string") {
	              joinInfo.stringUid = uid;

	              if (this._uintUid) {
	                joinInfo.uid = this._uintUid;
	                this._uintUid = undefined;
	              } else {
	                joinInfo.uid = 0;
	              }
	            }

	            if (this._encryptionMode !== "none" && this._encryptionSecret) {
	              joinInfo.aesmode = this._encryptionMode;
	              joinInfo.aespassword = this._encryptionSecret;
	            }

	            report.sessionInit(this._sessionId, {
	              lts: new Date().getTime(),
	              cname: channel,
	              appid: appId,
	              mode: this._mode
	            });
	            /** 5s 后加入频道没有成功，上报事件 */

	            setTimeout$2(function () {
	              if (_this.connectionState !== "CONNECTING") return;
	              report.joinChannelTimeout(_this._sessionId, 5);
	            }, 5000);

	            _a.label = 3;

	          case 3:
	            _a.trys.push([3, 9,, 10]);

	            return [4
	            /*yield*/
	            , setCloudProxyServer(joinInfo, this._axiosCancelSource.token, this._config.httpRetryConfig || DEFAULT_RETRY_CONFIG)];

	          case 4:
	            _a.sent();

	            if (!(joinInfo.stringUid && !joinInfo.uid)) return [3
	            /*break*/
	            , 6];
	            return [4
	            /*yield*/
	            , getUserAccount(joinInfo.stringUid, joinInfo, this._axiosCancelSource.token, this._config.httpRetryConfig || DEFAULT_RETRY_CONFIG)];

	          case 5:
	            uid_1 = _a.sent();
	            logger.debug("getUserAccount Success " + joinInfo.stringUid + " => " + uid_1);
	            joinInfo.uid = uid_1;
	            _a.label = 6;

	          case 6:
	            return [4
	            /*yield*/
	            , getJoinChannelServerInfo(joinInfo, this._axiosCancelSource.token, this._config.httpRetryConfig || DEFAULT_RETRY_CONFIG)];

	          case 7:
	            serverInfo = _a.sent();

	            if (joinInfo.proxyServer) {
	              var _context10;

	              serverInfo.gatewayInfo.gatewayAddrs = map$5(_context10 = serverInfo.gatewayInfo.gatewayAddrs).call(_context10, function (host) {
	                var hostSplit = host.split(":");
	                return joinInfo.proxyServer + "/ws/?h=" + hostSplit[0] + "&p=" + hostSplit[1];
	              });
	            }

	            this._configDistribute.updateConfig(this._clientId, serverInfo.configDistribute);

	            this._key = token ? token : appId;
	            this._joinInfo = __assign$d(__assign$d({}, joinInfo), {
	              cid: serverInfo.gatewayInfo.cid,
	              uid: joinInfo.uid ? joinInfo.uid : serverInfo.gatewayInfo.uid,
	              vid: serverInfo.gatewayInfo.vid,
	              apResponse: serverInfo.gatewayInfo.res,
	              uni_lbs_ip: serverInfo.gatewayInfo.uni_lbs_ip,
	              gatewayAddrs: serverInfo.gatewayInfo.gatewayAddrs
	            });
	            return [4
	            /*yield*/
	            , this._gateway.join(this._joinInfo, this._key)];

	          case 8:
	            gatewayUID = _a.sent();
	            executor.onSuccess(gatewayUID);
	            this._appId = appId;
	            this._channelName = joinInfo.cname;
	            this._uid = gatewayUID;

	            if (this._networkQualityInterval) {
	              window.clearInterval(this._networkQualityInterval);
	            }

	            this._networkQualityInterval = window.setInterval(this._handleUpdateNetworkQuality, 2000);
	            window.addEventListener("beforeunload", this._handleBeforeUnload);
	            logger.info("[" + this._clientId + "] Joining channel success: " + channel);
	            return [2
	            /*return*/
	            , gatewayUID];

	          case 9:
	            e_1 = _a.sent();
	            logger.error("[" + this._clientId + "] Joining channel failed, rollback", e_1);

	            if (e_1.code !== AgoraRTCErrorCode.OPERATION_ABORTED) {
	              // rollback
	              this._gateway.state = "DISCONNECTED";

	              this._reset();
	            }

	            executor.onError(e_1);
	            throw e_1;

	          case 10:
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  AgoraRTCClient.prototype.leave = function () {
	    return __awaiter$u(this, void 0, void 0, function () {
	      var executor, unlock;
	      return __generator$u(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            executor = report.reportApiInvoke(this._sessionId, {
	              name: AgoraAPIName.LEAVE,
	              options: [],
	              tag: AgoraAPITag.TRACER
	            });
	            logger.info("[" + this._clientId + "] Leaving channel");
	            window.removeEventListener("beforeunload", this._handleBeforeUnload);

	            this._reset();

	            return [4
	            /*yield*/
	            , this._leaveMutex.lock()];

	          case 1:
	            unlock = _a.sent();

	            if (this.connectionState === "DISCONNECTED") {
	              logger.info("[" + this._clientId + "] Leaving channel repeated, success");
	              unlock();
	              return [2
	              /*return*/
	              , executor.onSuccess()];
	            }
	            /**
	             * 如果当前和网关不是 CONNECTED，离开时无需发送 leave message，直接关闭 ws 即可
	             */


	            return [4
	            /*yield*/
	            , this._gateway.leave(this.connectionState !== "CONNECTED")];

	          case 2:
	            /**
	             * 如果当前和网关不是 CONNECTED，离开时无需发送 leave message，直接关闭 ws 即可
	             */
	            _a.sent();

	            logger.info("[" + this._clientId + "] Leaving channel success");
	            unlock();
	            executor.onSuccess();
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  AgoraRTCClient.prototype.publish = function (tracks, isUserAction) {
	    if (isUserAction === void 0) {
	      isUserAction = true;
	    }

	    return __awaiter$u(this, void 0, void 0, function () {
	      var executor, err, _i, tracks_1, track, err, unlock, highConnection, aTrack, vTrack, e_2;

	      var _this = this;

	      return __generator$u(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            if (!isArray$3(tracks)) tracks = [tracks];
	            executor = report.reportApiInvoke(this._sessionId, {
	              name: AgoraAPIName.PUBLISH,
	              options: map$5(tracks).call(tracks, function (t) {
	                return t ? t.getTrackId() : "null";
	              }),
	              tag: AgoraAPITag.TRACER
	            });

	            if (tracks.length === 0) {
	              err = new AgoraRTCError(AgoraRTCErrorCode.INVALID_PARAMS, "track list is empty");
	              executor.onError(err);
	              return [2
	              /*return*/
	              , err.throw()];
	            }

	            for (_i = 0, tracks_1 = tracks; _i < tracks_1.length; _i++) {
	              track = tracks_1[_i]; // 不允许用户主动将 disable 的 track 发布，这个动作只能由 SDK 触发

	              if (!track._enabled && isUserAction) {
	                err = new AgoraRTCError(AgoraRTCErrorCode.TRACK_IS_DISABLED, "can not publish a disabled track: " + track.getTrackId());
	                executor.onError(err);
	                return [2
	                /*return*/
	                , err.throw()];
	              }
	            }

	            logger.info("[" + this._clientId + "] Publishing tracks, id " + map$5(tracks).call(tracks, function (t) {
	              return t.getTrackId() + " ";
	            }));
	            return [4
	            /*yield*/
	            , this._publishMutex.lock()];

	          case 1:
	            unlock = _a.sent();
	            _a.label = 2;

	          case 2:
	            _a.trys.push([2, 6,, 7]);

	            if (this._mode === "live" && this._gateway.role === "audience") {
	              unlock();
	              throw new AgoraRTCError(AgoraRTCErrorCode.INVALID_OPERATION, "audience can not publish stream");
	            }

	            return [4
	            /*yield*/
	            , this._publishHighStream(tracks)];

	          case 3:
	            highConnection = _a.sent();
	            aTrack = highConnection.audioTrack;
	            vTrack = highConnection.videoTrack;
	            if (!(this._isDualStreamEnabled && vTrack && !this._lowStream)) return [3
	            /*break*/
	            , 5];
	            return [4
	            /*yield*/
	            , this._publishLowStream(vTrack)];

	          case 4:
	            _a.sent();

	            _a.label = 5;

	          case 5:
	            isUserAction && forEach$3(tracks).call(tracks, function (track) {
	              var _context11;

	              if (indexOf$3(_context11 = _this._bindEnabledTracks).call(_context11, track) !== -1) return;
	              track.addListener(TrackInternalEvent.NEED_ADD_TRACK, _this._handleLocalTrackEnable);
	              track.addListener(TrackInternalEvent.NEED_REMOVE_TRACK, _this._handleLocalTrackDisable);

	              _this._bindEnabledTracks.push(track);
	            });
	            unlock();
	            executor.onSuccess();
	            return [3
	            /*break*/
	            , 7];

	          case 6:
	            e_2 = _a.sent();
	            unlock();
	            executor.onError(e_2);
	            logger.error("[" + this._clientId + "] publish error", e_2.toString());
	            throw e_2;

	          case 7:
	            logger.info("[" + this._clientId + "] Publish success, id " + map$5(tracks).call(tracks, function (t) {
	              return t.getTrackId() + " ";
	            }));
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  AgoraRTCClient.prototype.unpublish = function (tracks, isUserAction) {
	    if (isUserAction === void 0) {
	      isUserAction = true;
	    }

	    return __awaiter$u(this, void 0, void 0, function () {
	      var allTracks, isClosePC, executor, unlock, _a, e_3;

	      var _this = this;

	      return __generator$u(this, function (_b) {
	        switch (_b.label) {
	          case 0:
	            if (!this._highStream) {
	              logger.warning("[" + this._clientId + "] Could not find tracks to unpublish");
	              return [2
	              /*return*/
	              ];
	            }

	            allTracks = this._highStream.getAllTracks();

	            if (!tracks) {
	              tracks = this._highStream.getAllTracks();
	            } else if (!isArray$3(tracks)) {
	              tracks = [tracks];
	            }

	            isClosePC = compareArray(allTracks, tracks);
	            executor = report.reportApiInvoke(this._sessionId, {
	              name: AgoraAPIName.UNPUBLISH,
	              options: map$5(tracks).call(tracks, function (t) {
	                return t.getTrackId();
	              }),
	              tag: AgoraAPITag.TRACER
	            });
	            logger.info("[" + this._clientId + "] Unpublish tracks, tracks " + map$5(tracks).call(tracks, function (t) {
	              return t.getTrackId() + " ";
	            }) + ", isClosePC: " + isClosePC);
	            if (!isClosePC) return [3
	            /*break*/
	            , 1];
	            _a = undefined;
	            return [3
	            /*break*/
	            , 3];

	          case 1:
	            return [4
	            /*yield*/
	            , this._publishMutex.lock()];

	          case 2:
	            _a = _b.sent();
	            _b.label = 3;

	          case 3:
	            unlock = _a; // 解锁后需要再判断一次，因为发布可能会失败

	            if (!this._highStream) {
	              logger.warning("[" + this._clientId + "] Could not find tracks to unpublish");
	              unlock && unlock();
	              return [2
	              /*return*/
	              ];
	            }

	            _b.label = 4;

	          case 4:
	            _b.trys.push([4, 11,, 12]);

	            if (!(this._lowStream && filter$2(tracks).call(tracks, function (t) {
	              return t.trackMediaType === "video";
	            }).length > 0)) return [3
	            /*break*/
	            , 6];
	            return [4
	            /*yield*/
	            , this._lowStream.closeP2PConnection()];

	          case 5:
	            _b.sent();

	            this._lowStream = undefined;
	            _b.label = 6;

	          case 6:
	            if (!isClosePC) return [3
	            /*break*/
	            , 8];
	            return [4
	            /*yield*/
	            , this._highStream.closeP2PConnection()];

	          case 7:
	            _b.sent();

	            return [3
	            /*break*/
	            , 10];

	          case 8:
	            return [4
	            /*yield*/
	            , this._highStream.removeTracks(tracks, isUserAction)];

	          case 9:
	            _b.sent();

	            _b.label = 10;

	          case 10:
	            unlock && unlock();
	            return [3
	            /*break*/
	            , 12];

	          case 11:
	            e_3 = _b.sent(); // 取消发布单个 track 的过程中（此时为重协商），用户可能取消发布另一个 track 导致 PC 直接被关闭
	            // 此时第一次 unpublish 就会因为重协商被中止抛出 OPERATION_ABORTED
	            // 从原则上来说这个错误不影响，所以认为取消发布成功

	            if (e_3.code !== AgoraRTCErrorCode.OPERATION_ABORTED) {
	              executor.onError(e_3);
	              logger.error("[" + this._clientId + "] unpublish error", e_3.toString());
	              unlock && unlock();
	              throw e_3;
	            } else {
	              logger.debug("[" + this._clientId + "] ignore unpub operation abort");
	              unlock && unlock();
	            }

	            return [3
	            /*break*/
	            , 12];

	          case 12:
	            if (this._highStream && this._highStream.connectionState === "disconnected") {
	              this._highStream = undefined;
	              this._lowStream = undefined;
	            }

	            isUserAction && forEach$3(tracks).call(tracks, function (track) {
	              var _context12, _context13;

	              var index = indexOf$3(_context12 = _this._bindEnabledTracks).call(_context12, track);

	              if (index === -1) return;
	              track.off(TrackInternalEvent.NEED_ADD_TRACK, _this._handleLocalTrackEnable);
	              track.off(TrackInternalEvent.NEED_REMOVE_TRACK, _this._handleLocalTrackDisable);

	              splice$2(_context13 = _this._bindEnabledTracks).call(_context13, index, 1);
	            });
	            logger.info("[" + this._clientId + "] Unpublish success,tracks " + map$5(tracks).call(tracks, function (t) {
	              return "" + t.getTrackId();
	            }));
	            executor.onSuccess();
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  AgoraRTCClient.prototype.subscribe = function (user, mediaType) {
	    return __awaiter$u(this, void 0, void 0, function () {
	      var executor, err, err, userInChannel, err, err, subscribeOptions, err, mutex, unlock, subStreamConnection, e_4, e_5, remoteTrack, err;

	      var _this = this;

	      return __generator$u(this, function (_a) {
	        var _context14;

	        switch (_a.label) {
	          case 0:
	            checkValidEnum(mediaType, "mediaType", ["audio", "video"]);
	            executor = report.reportApiInvoke(this._sessionId, {
	              name: AgoraAPIName.SUBSCRIBE,
	              options: [user.uid, mediaType],
	              tag: AgoraAPITag.TRACER
	            });

	            if (!this._joinInfo) {
	              err = new AgoraRTCError(AgoraRTCErrorCode.INVALID_OPERATION, "Can't subscribe stream, not joined");
	              executor.onError(err);
	              throw err;
	            }

	            if (this.connectionState !== "CONNECTED" && this.connectionState !== "RECONNECTING") {
	              err = new AgoraRTCError(AgoraRTCErrorCode.INVALID_OPERATION, "Can't subscribe stream in " + this.connectionState + " state");
	              executor.onError(err);
	              throw err;
	            }

	            userInChannel = find$2(_context14 = this._users).call(_context14, function (u) {
	              return u === user;
	            });

	            if (!userInChannel) {
	              err = new AgoraRTCError(AgoraRTCErrorCode.INVALID_REMOTE_USER, "user is not in the channel");
	              logger.error("[" + this._clientId + "] can not subscribe " + user.uid + ", this user is not in the channel");
	              executor.onError(err);
	              throw err;
	            } else if (!user.hasAudio && !user.hasVideo) {
	              err = new AgoraRTCError(AgoraRTCErrorCode.INVALID_REMOTE_USER, "user is not published");
	              logger.error("[" + this._clientId + "] can not subscribe " + user.uid + ", user is not published");
	              executor.onError(err);
	              throw err;
	            }

	            subscribeOptions = {
	              audio: mediaType === "audio",
	              video: mediaType === "video"
	            };

	            if (!user.hasAudio && subscribeOptions.audio || !user.hasVideo && subscribeOptions.video) {
	              err = new AgoraRTCError(AgoraRTCErrorCode.REMOTE_USER_IS_NOT_PUBLISHED);
	              logger.error("[" + this._clientId + "] can not subscribe " + user.uid + " with mediaType " + mediaType + ", remote track is not published");
	              executor.onError(err);
	              throw err;
	            }

	            mutex = this._subscribeMutex.get(user.uid);

	            if (!mutex) {
	              mutex = new PromiseMutex("sub-" + user.uid);

	              this._subscribeMutex.set(user.uid, mutex);
	            }

	            logger.info("[" + this._clientId + "] subscribe user " + user.uid + ", mediaType: " + mediaType);
	            return [4
	            /*yield*/
	            , mutex.lock()];

	          case 1:
	            unlock = _a.sent();
	            subStreamConnection = this._remoteStream.get(user.uid);
	            _a.label = 2;

	          case 2:
	            _a.trys.push([2, 10,, 11]);

	            if (!!subStreamConnection) return [3
	            /*break*/
	            , 7];
	            subStreamConnection = new SubStreamConnection(user, this._statsCollector, this._joinInfo, subscribeOptions);

	            this._remoteStream.set(user.uid, subStreamConnection);

	            _a.label = 3;

	          case 3:
	            _a.trys.push([3, 5,, 6]);

	            return [4
	            /*yield*/
	            , this._gateway.subscribe(subStreamConnection)];

	          case 4:
	            _a.sent();

	            return [3
	            /*break*/
	            , 6];

	          case 5:
	            e_4 = _a.sent();

	            this._remoteStream.delete(user.uid);

	            throw e_4;

	          case 6:
	            subStreamConnection.on(StreamConnectionEvents.CONNECTION_STATE_CHANGE, function (current, prev) {
	              if (current === "connecting") {
	                _this.emit(ClientEvents.MEDIA_RECONNECT_START, user.uid);
	              } else if (current === "connected") {
	                _this.emit(ClientEvents.MEDIA_RECONNECT_END, user.uid);
	              }
	            });
	            return [3
	            /*break*/
	            , 9];

	          case 7:
	            subscribeOptions.audio = subscribeOptions.audio || subStreamConnection.subscribeOptions.audio;
	            subscribeOptions.video = subscribeOptions.video || subStreamConnection.subscribeOptions.video;
	            return [4
	            /*yield*/
	            , this._gateway.subscribeChange(subStreamConnection, subscribeOptions)];

	          case 8:
	            _a.sent();

	            _a.label = 9;

	          case 9:
	            unlock();
	            return [3
	            /*break*/
	            , 11];

	          case 10:
	            e_5 = _a.sent();
	            executor.onError(e_5);
	            unlock();
	            logger.error("[" + this._clientId + "] subscribe user " + user.uid + " error", e_5);
	            throw e_5;

	          case 11:
	            logger.info("[" + this._clientId + "] subscribe success user " + user.uid + ", mediaType: " + mediaType);

	            if (this._defaultStreamFallbackType) {
	              this.setStreamFallbackOption(user.uid, this._defaultStreamFallbackType).catch(function (e) {
	                logger.warning("[" + _this._clientId + "] auto set fallback failed", e);
	              });
	            }

	            remoteTrack = mediaType === "audio" ? user.audioTrack : user.videoTrack;

	            if (!remoteTrack) {
	              err = new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_ERROR, "can not find remote track in user object");
	              executor.onError(err);
	              return [2
	              /*return*/
	              , err.throw()];
	            }

	            executor.onSuccess(remoteTrack.getTrackId());
	            return [2
	            /*return*/
	            , remoteTrack];
	        }
	      });
	    });
	  };

	  AgoraRTCClient.prototype.unsubscribe = function (user, mediaType) {
	    return __awaiter$u(this, void 0, void 0, function () {
	      var executor, userInChannel, err, mutex, unlock, sc, subscribeOptions, e_6;
	      return __generator$u(this, function (_a) {
	        var _context15;

	        switch (_a.label) {
	          case 0:
	            mediaType && checkValidEnum(mediaType, "mediaType", ["audio", "video"]);
	            executor = report.reportApiInvoke(this._sessionId, {
	              name: AgoraAPIName.UNSUBSCRIBE,
	              options: [user.uid, mediaType],
	              tag: AgoraAPITag.TRACER
	            });
	            userInChannel = find$2(_context15 = this._users).call(_context15, function (u) {
	              return u === user;
	            });

	            if (!userInChannel) {
	              err = new AgoraRTCError(AgoraRTCErrorCode.INVALID_REMOTE_USER, "user is not in the channel");
	              logger.error("[" + this._clientId + "] can not subscribe " + user.uid + ", user is not in the channel");
	              executor.onError(err);
	              throw err;
	            }

	            logger.info("[" + this._clientId + "] unsubscribe uid: " + user.uid + ", mediaType: " + mediaType);
	            mutex = this._subscribeMutex.get(user.uid);

	            if (!mutex) {
	              mutex = new PromiseMutex("sub-" + user.uid);

	              this._subscribeMutex.set(user.uid, mutex);
	            }

	            return [4
	            /*yield*/
	            , mutex.lock()];

	          case 1:
	            unlock = _a.sent();
	            sc = this._remoteStream.get(user.uid);
	            /** 如果找不到保存在本地的 remote 连接，说明这个 RemoteStream 已经被 remove 掉了 */

	            if (!sc) {
	              logger.warning("[" + this._clientId + "]: you have not subscribe the remote user " + user.uid);
	              executor.onSuccess();
	              unlock();
	              return [2
	              /*return*/
	              ];
	            }

	            subscribeOptions = __assign$d({}, sc.subscribeOptions);

	            if (mediaType === "audio") {
	              subscribeOptions.audio = false;
	            } else if (mediaType === "video") {
	              subscribeOptions.video = false;
	            } else {
	              subscribeOptions.audio = false;
	              subscribeOptions.video = false;
	            }

	            _a.label = 2;

	          case 2:
	            _a.trys.push([2, 7,, 8]);

	            if (!(!subscribeOptions.audio && !subscribeOptions.video)) return [3
	            /*break*/
	            , 4];
	            return [4
	            /*yield*/
	            , sc.closeP2PConnection()];

	          case 3:
	            _a.sent();

	            this._remoteStream.delete(user.uid);

	            return [3
	            /*break*/
	            , 6];

	          case 4:
	            return [4
	            /*yield*/
	            , this._gateway.subscribeChange(sc, subscribeOptions)];

	          case 5:
	            _a.sent();

	            _a.label = 6;

	          case 6:
	            unlock();
	            return [3
	            /*break*/
	            , 8];

	          case 7:
	            e_6 = _a.sent();

	            if (e_6.code !== AgoraRTCErrorCode.OPERATION_ABORTED) {
	              executor.onError(e_6);
	              unlock();
	              logger.error("[" + this._clientId + "] unsubscribe user " + user.uid + " error", e_6.toString());
	              throw e_6;
	            } else {
	              unlock();
	              logger.debug("[" + this._clientId + "] ignore unsub operation abort");
	            }

	            return [3
	            /*break*/
	            , 8];

	          case 8:
	            logger.info("[" + this._clientId + "] unsubscribe success uid: " + user.uid + ", mediaType: " + mediaType);
	            executor.onSuccess();
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  AgoraRTCClient.prototype.setLowStreamParameter = function (streamParameter) {
	    isLowStreamParameter(streamParameter);
	    var executor = report.reportApiInvoke(this._sessionId, {
	      name: AgoraAPIName.SET_LOW_STREAM_PARAMETER,
	      options: [streamParameter],
	      tag: AgoraAPITag.TRACER
	    });

	    if (!streamParameter.width && streamParameter.height || streamParameter.width && !streamParameter.height) {
	      logger.warning("[" + this._clientId + "] The width and height parameters take effect only when both are set");
	    }

	    logger.info("[" + this._clientId + "] set low stream parameter to", stringify$2(streamParameter));
	    this._lowStreamParameter = streamParameter;
	    executor.onSuccess();
	  };

	  AgoraRTCClient.prototype.enableDualStream = function () {
	    return __awaiter$u(this, void 0, void 0, function () {
	      var executor, compat, err, err, e_7;
	      return __generator$u(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            executor = report.reportApiInvoke(this._sessionId, {
	              name: AgoraAPIName.ENABLE_DUAL_STREAM,
	              options: [],
	              tag: AgoraAPITag.TRACER
	            });
	            compat = getCompatibility();

	            if (!compat.supportDualStream) {
	              report.streamSwitch(this._sessionId, {
	                lts: now$2(),
	                isdual: true,
	                succ: false
	              });
	              err = new AgoraRTCError(AgoraRTCErrorCode.NOT_SUPPORTED, "Your browser is not support dual stream");
	              executor.onError(err);
	              throw err;
	            }

	            if (this._isDualStreamEnabled) {
	              err = new AgoraRTCError(AgoraRTCErrorCode.INVALID_OPERATION, "Dual stream is already enabled");
	              executor.onError(err);
	              throw err;
	            }

	            if (!(this._highStream && this._highStream.connectionState === "connected" && this._highStream.videoTrack)) return [3
	            /*break*/
	            , 4];
	            _a.label = 1;

	          case 1:
	            _a.trys.push([1, 3,, 4]);

	            return [4
	            /*yield*/
	            , this._publishLowStream(this._highStream.videoTrack)];

	          case 2:
	            _a.sent();

	            return [3
	            /*break*/
	            , 4];

	          case 3:
	            e_7 = _a.sent();
	            report.streamSwitch(this._sessionId, {
	              lts: now$2(),
	              isdual: true,
	              succ: false
	            });
	            executor.onError(e_7);
	            throw e_7;

	          case 4:
	            this._isDualStreamEnabled = true;
	            report.streamSwitch(this._sessionId, {
	              lts: now$2(),
	              isdual: true,
	              succ: true
	            });
	            logger.info("[" + this._clientId + "] enable dual stream");
	            executor.onSuccess();
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  AgoraRTCClient.prototype.disableDualStream = function () {
	    return __awaiter$u(this, void 0, void 0, function () {
	      var executor, e_8;
	      return __generator$u(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            executor = report.reportApiInvoke(this._sessionId, {
	              name: AgoraAPIName.DISABLE_DUAL_STREAM,
	              options: [],
	              tag: AgoraAPITag.TRACER
	            });
	            if (!this._lowStream) return [3
	            /*break*/
	            , 4];
	            _a.label = 1;

	          case 1:
	            _a.trys.push([1, 3,, 4]);

	            return [4
	            /*yield*/
	            , this._lowStream.closeP2PConnection()];

	          case 2:
	            _a.sent();

	            return [3
	            /*break*/
	            , 4];

	          case 3:
	            e_8 = _a.sent();
	            report.streamSwitch(this._sessionId, {
	              lts: now$2(),
	              isdual: false,
	              succ: false
	            });
	            executor.onError(e_8);
	            throw e_8;

	          case 4:
	            this._lowStream = undefined;
	            this._isDualStreamEnabled = false;

	            if (this._highStream) {
	              this._highStream.lowStreamConnection = undefined;
	            }

	            report.streamSwitch(this._sessionId, {
	              lts: now$2(),
	              isdual: false,
	              succ: true
	            });
	            logger.info("[" + this._clientId + "] disable dual stream");
	            executor.onSuccess();
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  AgoraRTCClient.prototype.setClientRole = function (role) {
	    return __awaiter$u(this, void 0, void 0, function () {
	      var executor, err, e_9;
	      return __generator$u(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            isClientRole(role);
	            executor = report.reportApiInvoke(this._sessionId, {
	              name: AgoraAPIName.SET_CLIENT_ROLE,
	              options: [role],
	              tag: AgoraAPITag.TRACER
	            });

	            if (this._mode === "rtc") {
	              logger.warning("rtc mode can not use setClientRole");
	              err = new AgoraRTCError(AgoraRTCErrorCode.INVALID_OPERATION, "rtc mode can not use setClientRole");
	              executor.onError(err);
	              return [2
	              /*return*/
	              , err.throw()];
	            }

	            _a.label = 1;

	          case 1:
	            _a.trys.push([1, 3,, 4]);

	            if (role === "audience" && this._highStream) {
	              throw new AgoraRTCError(AgoraRTCErrorCode.INVALID_OPERATION, "can not set client role to audience when publishing stream");
	            }

	            return [4
	            /*yield*/
	            , this._gateway.setClientRole(role)];

	          case 2:
	            _a.sent();

	            logger.info("[" + this._clientId + "] set client role to " + role);
	            executor.onSuccess();
	            return [3
	            /*break*/
	            , 4];

	          case 3:
	            e_9 = _a.sent();
	            executor.onError(e_9);
	            throw e_9;

	          case 4:
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  AgoraRTCClient.prototype.setProxyServer = function (proxyServer) {
	    checkValidString(proxyServer, "proxyServer");
	    var executor = report.reportApiInvoke(this._sessionId, {
	      name: AgoraAPIName.SET_PROXY_SERVER,
	      options: [proxyServer],
	      tag: AgoraAPITag.TRACER
	    });

	    if (this.connectionState !== "DISCONNECTED") {
	      throw new AgoraRTCError(AgoraRTCErrorCode.INVALID_OPERATION, "Set proxy server before join channel");
	    }

	    if (this._cloudProxyServerMode !== "disabled") {
	      throw new AgoraRTCError(AgoraRTCErrorCode.INVALID_OPERATION, "You have already set the proxy");
	    }

	    this._proxyServer = proxyServer;
	    report.setProxyServer(this._proxyServer);
	    logger.setProxyServer(this._proxyServer);
	    executor.onSuccess();
	  };

	  AgoraRTCClient.prototype.setTurnServer = function (turnServers) {
	    if (!isArray$3(turnServers)) {
	      turnServers = [turnServers];
	    }

	    forEach$3(turnServers).call(turnServers, function (turnServer) {
	      return isTurnServerConfig(turnServer);
	    });

	    var executor = report.reportApiInvoke(this._sessionId, {
	      name: AgoraAPIName.SET_TURN_SERVER,
	      options: turnServers,
	      tag: AgoraAPITag.TRACER
	    });

	    if (this.connectionState !== "DISCONNECTED") {
	      throw new AgoraRTCError(AgoraRTCErrorCode.INVALID_OPERATION, "Set turn server before join channel");
	    }

	    if (this._cloudProxyServerMode !== "disabled") {
	      throw new AgoraRTCError(AgoraRTCErrorCode.INVALID_OPERATION, "You have already set the proxy");
	    }

	    this._turnServer = {
	      servers: turnServers,
	      mode: "manual"
	    };
	    logger.info("[" + this._clientId + "] Set turnserver.");
	    executor.onSuccess();
	  };

	  AgoraRTCClient.prototype.startProxyServer = function (use443OnlyMode) {
	    var executor = report.reportApiInvoke(this._sessionId, {
	      name: AgoraAPIName.START_PROXY_SERVER,
	      options: [],
	      tag: AgoraAPITag.TRACER
	    });

	    if (this.connectionState !== "DISCONNECTED") {
	      throw new AgoraRTCError(AgoraRTCErrorCode.INVALID_OPERATION, "Start proxy server before join channel");
	    }

	    if (this._proxyServer || this._turnServer.mode === "manual") {
	      throw new AgoraRTCError(AgoraRTCErrorCode.INVALID_OPERATION, "You have already set the proxy");
	    }

	    this._cloudProxyServerMode = use443OnlyMode ? "443only" : "normal";
	    logger.info("[" + this._clientId + "] set cloud proxy server mode to", this._cloudProxyServerMode);
	    executor.onSuccess();
	  };

	  AgoraRTCClient.prototype.stopProxyServer = function () {
	    var executor = report.reportApiInvoke(this._sessionId, {
	      name: AgoraAPIName.STOP_PROXY_SERVER,
	      options: [],
	      tag: AgoraAPITag.TRACER
	    });

	    if (this.connectionState !== "DISCONNECTED") {
	      throw new AgoraRTCError(AgoraRTCErrorCode.INVALID_OPERATION, "Stop proxy server after leave channel");
	    }

	    report.setProxyServer();
	    logger.setProxyServer();
	    this._cloudProxyServerMode = "disabled";
	    logger.info("[" + this._clientId + "] set cloud proxy server mode to", this._cloudProxyServerMode);
	    this._proxyServer = undefined;
	    this._turnServer = {
	      mode: "auto",
	      servers: []
	    };
	    executor.onSuccess();
	  };

	  AgoraRTCClient.prototype.setRemoteVideoStreamType = function (uid, streamType) {
	    return __awaiter$u(this, void 0, void 0, function () {
	      var executor, e_10;
	      return __generator$u(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            checkValidEnum(streamType, "streamType", [0, 1]);
	            executor = report.reportApiInvoke(this._sessionId, {
	              name: AgoraAPIName.SET_REMOTE_VIDEO_STREAM_TYPE,
	              options: [uid, streamType],
	              tag: AgoraAPITag.TRACER
	            });
	            _a.label = 1;

	          case 1:
	            _a.trys.push([1, 3,, 4]);

	            return [4
	            /*yield*/
	            , this._gateway.setRemoteVideoStreamType(uid, streamType)];

	          case 2:
	            _a.sent();

	            return [3
	            /*break*/
	            , 4];

	          case 3:
	            e_10 = _a.sent();
	            executor.onError(e_10);
	            logger.error("[" + this._clientId + "] set remote video stream type error", e_10.toString());
	            throw e_10;

	          case 4:
	            logger.info("[" + this._clientId + "] set remote " + uid + " video stream type to " + streamType);

	            this._remoteStreamTypeCacheMap.set(uid, streamType);

	            executor.onSuccess();
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  AgoraRTCClient.prototype.setStreamFallbackOption = function (uid, fallbackType) {
	    return __awaiter$u(this, void 0, void 0, function () {
	      var executor, e_11;
	      return __generator$u(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            checkValidEnum(fallbackType, "fallbackType", [0, 1, 2]);
	            executor = report.reportApiInvoke(this._sessionId, {
	              name: AgoraAPIName.SET_STREAM_FALLBACK_OPTION,
	              options: ["too long to show", fallbackType],
	              tag: AgoraAPITag.TRACER
	            });
	            _a.label = 1;

	          case 1:
	            _a.trys.push([1, 3,, 4]);

	            return [4
	            /*yield*/
	            , this._gateway.setStreamFallbackOption(uid, fallbackType)];

	          case 2:
	            _a.sent();

	            return [3
	            /*break*/
	            , 4];

	          case 3:
	            e_11 = _a.sent();
	            executor.onError(e_11);
	            logger.error("[" + this._clientId + "] set stream fallback option", e_11.toString());
	            throw e_11;

	          case 4:
	            logger.info("[" + this._clientId + "] set remote " + uid + " stream fallback type to " + fallbackType);

	            this._streamFallbackTypeCacheMap.set(uid, fallbackType);

	            executor.onSuccess();
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  AgoraRTCClient.prototype.setEncryptionConfig = function (encryptionMode, secret) {
	    isEncryptionMode(encryptionMode);
	    checkValidString(secret, "secret");
	    var executor = report.reportApiInvoke(this._sessionId, {
	      name: AgoraAPIName.SET_ENCRYPTION_CONFIG,
	      options: [encryptionMode],
	      tag: AgoraAPITag.TRACER
	    });
	    this._encryptionMode = encryptionMode;
	    this._encryptionSecret = secret;
	    executor.onSuccess();
	  };

	  AgoraRTCClient.prototype.renewToken = function (token) {
	    return __awaiter$u(this, void 0, void 0, function () {
	      var executor, err, e_12;
	      return __generator$u(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            checkValidString(token, "token", 1, 2047);
	            executor = report.reportApiInvoke(this._sessionId, {
	              name: AgoraAPIName.RENEW_TOKEN,
	              options: [token],
	              tag: AgoraAPITag.TRACER
	            });

	            if (!this._key) {
	              err = new AgoraRTCError(AgoraRTCErrorCode.INVALID_OPERATION, "renewToken should not be called before user join");
	              executor.onError(err);
	              return [2
	              /*return*/
	              , err.throw()];
	            }

	            this._key = token;
	            _a.label = 1;

	          case 1:
	            _a.trys.push([1, 3,, 4]);

	            return [4
	            /*yield*/
	            , this._gateway.renewToken(token)];

	          case 2:
	            _a.sent();

	            return [3
	            /*break*/
	            , 4];

	          case 3:
	            e_12 = _a.sent();
	            executor.onError(e_12);
	            logger.error("[" + this._clientId + "] renewToken failed", e_12.toString());
	            throw e_12;

	          case 4:
	            logger.debug("[" + this._clientId + "] renewToken success");
	            executor.onSuccess();
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  AgoraRTCClient.prototype.enableAudioVolumeIndicator = function () {
	    var _this = this;

	    var executor = report.reportApiInvoke(this._sessionId, {
	      name: AgoraAPIName.ENABLE_AUDIO_VOLUME_INDICATOR,
	      options: [],
	      tag: AgoraAPITag.TRACER
	    });

	    if (this._audioVolumeIndicationInterval) {
	      logger.warning("you have already enabled audio volume indicator!");
	      return executor.onSuccess();
	    } // TODO: 识别说话者


	    this._audioVolumeIndicationInterval = window.setInterval(function () {
	      var _context16, _context17, _context18;

	      var results = sort$2(_context16 = map$5(_context17 = from_1$2(values$2(_context18 = _this._remoteStream).call(_context18))).call(_context17, function (sc) {
	        return {
	          level: sc.user.audioTrack ? sc.user.audioTrack._source.getAudioAvgLevel() * 100 : 0,
	          uid: sc.getUserId()
	        };
	      })).call(_context16, function (a, b) {
	        return a.level - b.level;
	      });

	      if (_this._highStream && _this._highStream.audioTrack) {
	        results.push({
	          level: _this._highStream.audioTrack._source.getAudioAvgLevel() * 100,
	          uid: _this._highStream._userId
	        });
	        results = sort$2(results).call(results, function (a, b) {
	          return a.level - b.level;
	        });
	      }

	      _this.emit(ClientEvents.VOLUME_INDICATOR, results);
	    }, getParameter("AUDIO_VOLUME_INDICATION_INTERVAL") || 2000);
	    executor.onSuccess();
	  };

	  AgoraRTCClient.prototype.getRTCStats = function () {
	    var stats = this._statsCollector.getRTCStats();

	    var inChannelInfo = this._gateway.getInChannelInfo();

	    stats.Duration = Math.round(inChannelInfo.duration / 1000);
	    return stats;
	  };

	  AgoraRTCClient.prototype.startLiveStreaming = function (url, isTranscoding) {
	    var executor = report.reportApiInvoke(this._sessionId, {
	      name: AgoraAPIName.START_LIVE_STREAMING,
	      options: [url, isTranscoding],
	      tag: AgoraAPITag.TRACER
	    }); // 非转码推流要求自己已经发布

	    if (!isTranscoding) {
	      if (this._codec !== "h264") {
	        var err = new AgoraRTCError(AgoraRTCErrorCode.LIVE_STREAMING_INVALID_RAW_STREAM, "raw streaming is only support h264");
	        executor.onError(err);
	        return promise$3.reject(err);
	      }

	      if (!this._highStream) {
	        var err = new AgoraRTCError(AgoraRTCErrorCode.LIVE_STREAMING_INVALID_RAW_STREAM, "can not find stream to raw streaming");
	        executor.onError(err);
	        return promise$3.reject(err);
	      }
	    }

	    if (this._liveRawStreamingClient && this._liveRawStreamingClient.hasUrl(url) || this._liveTranscodeStreamingClient && this._liveTranscodeStreamingClient.hasUrl(url)) {
	      var err = new AgoraRTCError(AgoraRTCErrorCode.LIVE_STREAMING_TASK_CONFLICT);
	      executor.onError(err);
	      return promise$3.reject(err);
	    }

	    var type = isTranscoding ? LiveStreamingServiceMode.TRANSCODE : LiveStreamingServiceMode.RAW;

	    var liveStreamingClient = this._createLiveStreamingClient(type);

	    return liveStreamingClient.startLiveStreamingTask(url, type).then(function () {
	      return executor.onSuccess();
	    }).catch(function (e) {
	      executor.onError(e);
	      throw e;
	    });
	  };

	  AgoraRTCClient.prototype.setLiveTranscoding = function (config) {
	    var executor = report.reportApiInvoke(this._sessionId, {
	      name: AgoraAPIName.SET_LIVE_TRANSCODING,
	      options: [config],
	      tag: AgoraAPITag.TRACER
	    });

	    var liveStreamingClient = this._createLiveStreamingClient(LiveStreamingServiceMode.TRANSCODE);

	    return liveStreamingClient.setTranscodingConfig(config).then(function () {
	      return executor.onSuccess();
	    }).catch(function (e) {
	      executor.onError(e);
	      throw e;
	    });
	  };

	  AgoraRTCClient.prototype.stopLiveStreaming = function (url) {
	    var _context19;

	    var executor = report.reportApiInvoke(this._sessionId, {
	      name: AgoraAPIName.STOP_LIVE_STREAMING,
	      options: [url],
	      tag: AgoraAPITag.TRACER
	    });

	    var clients = filter$2(_context19 = [this._liveRawStreamingClient, this._liveTranscodeStreamingClient]).call(_context19, function (client) {
	      return client && client.hasUrl(url);
	    });

	    if (!clients.length) {
	      var err = new AgoraRTCError(AgoraRTCErrorCode.INVALID_PARAMS, "can not find live streaming url to stop");
	      executor.onError(err);
	      return promise$3.reject(err);
	    }

	    return promise$3.all(map$5(clients).call(clients, function (client) {
	      return client && client.stopLiveStreamingTask(url);
	    })).then(function () {
	      return executor.onSuccess();
	    }).catch(function (e) {
	      executor.onError(e);
	      throw e;
	    });
	  };

	  AgoraRTCClient.prototype.addInjectStreamUrl = function (url, config) {
	    return __awaiter$u(this, void 0, void 0, function () {
	      var executor, client, e_13;
	      return __generator$u(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            executor = report.reportApiInvoke(this._sessionId, {
	              name: AgoraAPIName.ADD_INJECT_STREAM_URL,
	              options: [url, config],
	              tag: AgoraAPITag.TRACER
	            });
	            _a.label = 1;

	          case 1:
	            _a.trys.push([1, 3,, 4]);

	            if (!this._joinInfo) {
	              throw new AgoraRTCError(AgoraRTCErrorCode.INVALID_OPERATION, "can not addInjectStreamUrl, no joininfo");
	            }

	            client = this._createLiveStreamingClient(LiveStreamingServiceMode.INJECT);
	            client.setInjectStreamConfig(config, 0);
	            return [4
	            /*yield*/
	            , client.startLiveStreamingTask(url, LiveStreamingServiceMode.INJECT)];

	          case 2:
	            _a.sent();

	            return [3
	            /*break*/
	            , 4];

	          case 3:
	            e_13 = _a.sent();
	            executor.onError(e_13);
	            throw e_13;

	          case 4:
	            executor.onSuccess();
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  AgoraRTCClient.prototype.removeInjectStreamUrl = function () {
	    return __awaiter$u(this, void 0, void 0, function () {
	      var executor, client, streamTask, e_14;
	      return __generator$u(this, function (_a) {
	        var _context20, _context21;

	        switch (_a.label) {
	          case 0:
	            executor = report.reportApiInvoke(this._sessionId, {
	              name: AgoraAPIName.REMOVE_INJECT_STREAM_URL,
	              options: [],
	              tag: AgoraAPITag.TRACER
	            });
	            _a.label = 1;

	          case 1:
	            _a.trys.push([1, 3,, 4]);

	            client = this._createLiveStreamingClient(LiveStreamingServiceMode.INJECT);
	            streamTask = find$2(_context20 = from_1$2(values$2(_context21 = client.streamingTasks).call(_context21))).call(_context20, function (t) {
	              return t.mode === LiveStreamingServiceMode.INJECT;
	            });

	            if (!this._joinInfo || !streamTask) {
	              throw new AgoraRTCError(AgoraRTCErrorCode.INVALID_OPERATION, "can remove addInjectStreamUrl, no joininfo or inject task");
	            }

	            return [4
	            /*yield*/
	            , client.stopLiveStreamingTask(streamTask.url)];

	          case 2:
	            _a.sent();

	            return [3
	            /*break*/
	            , 4];

	          case 3:
	            e_14 = _a.sent();
	            executor.onError(e_14);
	            throw e_14;

	          case 4:
	            executor.onSuccess();
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  AgoraRTCClient.prototype.startChannelMediaRelay = function (config) {
	    return __awaiter$u(this, void 0, void 0, function () {
	      var executor, client, e_15;
	      return __generator$u(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            executor = report.reportApiInvoke(this._sessionId, {
	              name: AgoraAPIName.START_CHANNEL_MEDIA_RELAY,
	              options: [config],
	              tag: AgoraAPITag.TRACER
	            });
	            _a.label = 1;

	          case 1:
	            _a.trys.push([1, 3,, 4]);

	            checkValidChannelMediaRelayConfiguration(config);
	            client = this._createChannelMediaRelayClient();
	            return [4
	            /*yield*/
	            , client.startChannelMediaRelay(config)];

	          case 2:
	            _a.sent();

	            return [3
	            /*break*/
	            , 4];

	          case 3:
	            e_15 = _a.sent();
	            executor.onError(e_15);
	            return [2
	            /*return*/
	            , e_15.throw()];

	          case 4:
	            executor.onSuccess();
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  AgoraRTCClient.prototype.updateChannelMediaRelay = function (config) {
	    return __awaiter$u(this, void 0, void 0, function () {
	      var executor, client, e_16;
	      return __generator$u(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            executor = report.reportApiInvoke(this._sessionId, {
	              name: AgoraAPIName.UPDATE_CHANNEL_MEDIA_RELAY,
	              options: [config],
	              tag: AgoraAPITag.TRACER
	            });
	            _a.label = 1;

	          case 1:
	            _a.trys.push([1, 3,, 4]);

	            checkValidChannelMediaRelayConfiguration(config);
	            client = this._createChannelMediaRelayClient();
	            return [4
	            /*yield*/
	            , client.updateChannelMediaRelay(config)];

	          case 2:
	            _a.sent();

	            return [3
	            /*break*/
	            , 4];

	          case 3:
	            e_16 = _a.sent();
	            executor.onError(e_16);
	            return [2
	            /*return*/
	            , e_16.throw()];

	          case 4:
	            executor.onSuccess();
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  AgoraRTCClient.prototype.stopChannelMediaRelay = function () {
	    return __awaiter$u(this, void 0, void 0, function () {
	      var executor, client, e_17;
	      return __generator$u(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            executor = report.reportApiInvoke(this._sessionId, {
	              name: AgoraAPIName.STOP_CHANNEL_MEDIA_RELAY,
	              options: [],
	              tag: AgoraAPITag.TRACER
	            });
	            _a.label = 1;

	          case 1:
	            _a.trys.push([1, 3,, 4]);

	            client = this._createChannelMediaRelayClient();
	            return [4
	            /*yield*/
	            , client.stopChannelMediaRelay()];

	          case 2:
	            _a.sent();

	            return [3
	            /*break*/
	            , 4];

	          case 3:
	            e_17 = _a.sent();
	            executor.onError(e_17);
	            return [2
	            /*return*/
	            , e_17.throw()];

	          case 4:
	            executor.onSuccess();
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  AgoraRTCClient.prototype.sendStreamMessage = function (payload) {
	    if (!this._joinInfo) {
	      throw new AgoraRTCError(AgoraRTCErrorCode.INVALID_OPERATION, "can not send data stream, not joined");
	    }

	    if (typeof payload === "string") {
	      var enc = new TextEncoder();
	      payload = enc.encode(payload);
	    }

	    var payloadBlob = new Blob([payload]);

	    if (payloadBlob.size > 1024) {
	      throw new AgoraRTCError(AgoraRTCErrorCode.INVALID_PARAMS, "stream message out of range.");
	    }

	    return this._gateway.signal.request(SignalRequestType.DATA_STREAM, {
	      payload: uint8ArrayToBase64(payload)
	    });
	  };

	  AgoraRTCClient.prototype.sendMetadata = function (metadata) {
	    if (!this._joinInfo) {
	      throw new AgoraRTCError(AgoraRTCErrorCode.INVALID_OPERATION, "can not send metadata, not joined");
	    }

	    var metadataBlob = new Blob([metadata]);

	    if (metadataBlob.size > 1024) {
	      throw new AgoraRTCError(AgoraRTCErrorCode.METADATA_OUT_OF_RANGE);
	    }

	    return this._gateway.signal.request(SignalRequestType.SEND_METADATA, {
	      session_id: this._joinInfo.sid,
	      metadata: uint8ArrayToBase64(metadata)
	    });
	  };

	  AgoraRTCClient.prototype.sendCustomReportMessage = function (params) {
	    return __awaiter$u(this, void 0, void 0, function () {
	      var executor, err;
	      return __generator$u(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            if (!isArray$3(params)) params = [params];

	            forEach$3(params).call(params, isEventCustomReportParams);

	            executor = report.reportApiInvoke(this._sessionId, {
	              name: AgoraAPIName.SEND_CUSTOM_REPORT_MESSAGE,
	              options: [],
	              tag: AgoraAPITag.TRACER
	            });

	            if (!this._joinInfo) {
	              err = new AgoraRTCError(AgoraRTCErrorCode.INVALID_OPERATION, "can not send custom report, not joined");
	              executor.onError(err);
	              return [2
	              /*return*/
	              , err.throw()];
	            }

	            return [4
	            /*yield*/
	            , report.sendCustomReportMessage(this._joinInfo.sid, params)];

	          case 1:
	            _a.sent();

	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  AgoraRTCClient.prototype.getLocalAudioStats = function () {
	    if (!this._highStream) {
	      return DEFAULT_LOCAL_AUDIO_TRACK_STATS;
	    }

	    var stats = this._statsCollector.getLocalAudioTrackStats(this._highStream.connectionId);

	    return stats;
	  };

	  AgoraRTCClient.prototype.getRemoteAudioStats = function () {
	    var _context22;

	    var _this = this;

	    var stats = {};

	    forEach$3(_context22 = this._remoteStream).call(_context22, function (sc, uid) {
	      stats[uid] = _this._statsCollector.getRemoteAudioTrackStats(sc.connectionId);
	    });

	    return stats;
	  };

	  AgoraRTCClient.prototype.getLocalVideoStats = function () {
	    if (!this._highStream) {
	      return DEFAULT_LOCAL_VIDEO_TRACK_STATS;
	    }

	    var stats = this._statsCollector.getLocalVideoTrackStats(this._highStream.connectionId);

	    return stats;
	  };

	  AgoraRTCClient.prototype.getRemoteVideoStats = function () {
	    var _context23;

	    var _this = this;

	    var stats = {};

	    forEach$3(_context23 = this._remoteStream).call(_context23, function (sc, uid) {
	      stats[uid] = _this._statsCollector.getRemoteVideoTrackStats(sc.connectionId);
	    });

	    return stats;
	  };

	  AgoraRTCClient.prototype.getRemoteNetworkQuality = function () {
	    var _context24;

	    var _this = this;

	    var stats = {};

	    forEach$3(_context24 = this._remoteStream).call(_context24, function (sc, uid) {
	      stats[uid] = _this._statsCollector.getRemoteNetworkQualityStats(sc.connectionId);
	    });

	    return stats;
	  };

	  AgoraRTCClient.prototype._reset = function () {
	    var _context25, _context26, _context27;

	    var _this = this;

	    logger.debug("[" + this._clientId + "] reset client");

	    this._axiosCancelSource.cancel();

	    this._axiosCancelSource = axios$1.CancelToken.source();
	    this._streamFallbackTypeCacheMap = new map$2();
	    this._remoteStreamTypeCacheMap = new map$2();
	    this._joinInfo = undefined;
	    this._proxyServer = undefined;
	    this._defaultStreamFallbackType = undefined;
	    this._sessionId = null;

	    this._statsCollector.reset();

	    this._key = undefined;
	    this._appId = undefined;
	    this._uid = undefined;
	    this._channelName = undefined;

	    forEach$3(_context25 = this._users).call(_context25, function (user) {
	      if (user.audioTrack) {
	        user.audioTrack.stop();
	        user.audioTrack._isDestroyed = true;
	      }

	      if (user.videoTrack) {
	        user.videoTrack.stop();
	        user.videoTrack._isDestroyed = true;
	      }
	    });

	    this._users = [];

	    if (this._audioVolumeIndicationInterval) {
	      window.clearInterval(this._audioVolumeIndicationInterval);
	      this._audioVolumeIndicationInterval = undefined;
	    }

	    if (this._highStream) {
	      this._highStream.closeP2PConnection(true);

	      this._highStream = undefined;
	    }

	    forEach$3(_context26 = this._bindEnabledTracks).call(_context26, function (track) {
	      track.off(TrackInternalEvent.NEED_ADD_TRACK, _this._handleLocalTrackEnable);
	      track.off(TrackInternalEvent.NEED_REMOVE_TRACK, _this._handleLocalTrackDisable);
	    });

	    this._bindEnabledTracks = [];

	    if (this._lowStream) {
	      this._lowStream.closeP2PConnection(true);

	      this._lowStream = undefined;
	    }

	    forEach$3(_context27 = this._remoteStream).call(_context27, function (sc) {
	      sc.closeP2PConnection(true);
	    });

	    this._remoteStream = new map$2();
	    this._publishMutex = new PromiseMutex("client-publish");
	    this._subscribeMutex = new map$2();

	    if (this._networkQualityInterval) {
	      window.clearInterval(this._networkQualityInterval);
	      this._networkQualityInterval = undefined;
	    }

	    if (this._injectStreamingClient) {
	      this._injectStreamingClient.terminate();

	      this._injectStreamingClient.removeAllListeners();

	      this._injectStreamingClient = undefined;
	    }

	    if (this._liveRawStreamingClient) {
	      this._liveRawStreamingClient.terminate();

	      this._liveRawStreamingClient.removeAllListeners();

	      this._liveRawStreamingClient = undefined;
	    }

	    if (this._liveTranscodeStreamingClient) {
	      this._liveTranscodeStreamingClient.terminate();

	      this._liveTranscodeStreamingClient.removeAllListeners();

	      this._liveTranscodeStreamingClient = undefined;
	    }

	    if (this._channelMediaRelayClient) {
	      this._channelMediaRelayClient.dispose();

	      this._channelMediaRelayClient = undefined;
	    }
	  };

	  AgoraRTCClient.prototype._renewSession = function () {
	    var newSid = generateSessionID();
	    logger.debug("[" + this._clientId + "] renewSession " + this._sessionId + " => " + newSid);
	    this._sessionId = newSid;

	    if (this._joinInfo) {
	      this._joinInfo.sid = newSid;
	    }

	    if (this._gateway.joinInfo) {
	      this._gateway.joinInfo.sid = newSid;
	    }
	  };

	  AgoraRTCClient.prototype._publishHighStream = function (tracks) {
	    return __awaiter$u(this, void 0, void 0, function () {
	      var e_18;

	      var _this = this;

	      return __generator$u(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            if (!this._joinInfo) {
	              throw new AgoraRTCError(AgoraRTCErrorCode.INVALID_OPERATION, "Can't publish stream, haven't joined yet!");
	            }

	            if (this.connectionState !== "CONNECTED" && this.connectionState !== "RECONNECTING") {
	              throw new AgoraRTCError(AgoraRTCErrorCode.INVALID_OPERATION, "can not publish stream in " + this.connectionState + " state");
	            }

	            if (this._turnServer.mode === "auto" && getParameter("FORCE_TURN") && !getParameter("TURN_ENABLE_TCP") && !getParameter("TURN_ENABLE_UDP")) {
	              throw new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_ERROR, "force TURN With No TURN Configuration");
	            }

	            logger.debug("[" + this._clientId + "] publish high stream");
	            if (!this._highStream) return [3
	            /*break*/
	            , 2];
	            return [4
	            /*yield*/
	            , this._highStream.addTracks(tracks)];

	          case 1:
	            _a.sent();

	            return [2
	            /*return*/
	            , this._highStream];

	          case 2:
	            this._highStream = new PubStreamConnection(this._statsCollector, this._joinInfo, this._codec);
	            return [4
	            /*yield*/
	            , this._highStream.addTracks(tracks)];

	          case 3:
	            _a.sent();

	            _a.label = 4;

	          case 4:
	            _a.trys.push([4, 6,, 7]);

	            return [4
	            /*yield*/
	            , this._gateway.publish(this._highStream, "high")];

	          case 5:
	            _a.sent();

	            return [3
	            /*break*/
	            , 7];

	          case 6:
	            e_18 = _a.sent();
	            this._highStream = undefined;
	            throw e_18;

	          case 7:
	            this._highStream.on(StreamConnectionEvents.CONNECTION_STATE_CHANGE, function (state, prev) {
	              if (!_this._highStream) return;

	              if (state === "connected") {
	                _this.emit(ClientEvents.MEDIA_RECONNECT_END, _this._highStream.getUserId());
	              } else if (state === "connecting") {
	                _this.emit(ClientEvents.MEDIA_RECONNECT_START, _this._highStream.getUserId());
	              }
	            });

	            return [2
	            /*return*/
	            , this._highStream];
	        }
	      });
	    });
	  };

	  AgoraRTCClient.prototype._publishLowStream = function (track) {
	    return __awaiter$u(this, void 0, void 0, function () {
	      var err, e_19;
	      return __generator$u(this, function (_a) {
	        switch (_a.label) {
	          case 0:
	            if (!this._joinInfo) {
	              throw new AgoraRTCError(AgoraRTCErrorCode.INVALID_OPERATION, "Can't publish stream, haven't joined yet!");
	            }

	            if (this.connectionState !== "CONNECTED" && this.connectionState !== "RECONNECTING") {
	              throw new AgoraRTCError(AgoraRTCErrorCode.INVALID_OPERATION, "can not publish stream in " + this.connectionState + " state");
	            }

	            if (!this._highStream || this._highStream.connectionState !== "connected") {
	              throw new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_ERROR, "Could not find high stream");
	            }

	            if (this._lowStream) {
	              err = new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_ERROR, "[" + this._clientId + "] Can't publish low stream when stream already publish");
	              return [2
	              /*return*/
	              , err.throw()];
	            }

	            logger.debug("[" + this._clientId + "] publish low stream");
	            this._lowStream = new PubStreamConnection(this._statsCollector, this._joinInfo, this._codec, true);
	            this._lowStream.lowStreamParameter = this._lowStreamParameter;
	            return [4
	            /*yield*/
	            , this._lowStream.addTracks([track])];

	          case 1:
	            _a.sent();

	            _a.label = 2;

	          case 2:
	            _a.trys.push([2, 4,, 5]);

	            return [4
	            /*yield*/
	            , this._gateway.publish(this._lowStream, "low")];

	          case 3:
	            _a.sent();

	            return [3
	            /*break*/
	            , 5];

	          case 4:
	            e_19 = _a.sent();
	            this._lowStream = undefined;
	            throw e_19;

	          case 5:
	            this._highStream.lowStreamConnection = this._lowStream;
	            return [2
	            /*return*/
	            ];
	        }
	      });
	    });
	  };

	  AgoraRTCClient.prototype._createLiveStreamingClient = function (type) {
	    var _this = this;

	    if (!this._joinInfo || !this._appId) {
	      var err = new AgoraRTCError(AgoraRTCErrorCode.INVALID_OPERATION, "can not create live streaming client, please join channel first");
	      return err.throw();
	    }

	    var createNewClient = function () {
	      return new AgoraRTCLiveStreamingClient(_this._joinInfo, _this._config.websocketRetryConfig || DEFAULT_RETRY_CONFIG, _this._config.httpRetryConfig || DEFAULT_RETRY_CONFIG);
	    };

	    var setLiveStreamingEvents = function (liveStreamingClient) {
	      liveStreamingClient.onLiveStreamError = function (url, err) {
	        report.reportApiInvoke(_this._sessionId, {
	          name: AgoraAPIName.ON_LIVE_STREAM_ERROR,
	          options: [url, err],
	          tag: AgoraAPITag.TRACER
	        }).onSuccess();

	        _this.emit(ClientEvents.LIVE_STREAMING_ERROR, url, err);
	      };

	      liveStreamingClient.onLiveStreamWarning = function (url, err) {
	        report.reportApiInvoke(_this._sessionId, {
	          name: AgoraAPIName.ON_LIVE_STREAM_WARNING,
	          options: [url, err],
	          tag: AgoraAPITag.TRACER
	        }).onSuccess();

	        _this.emit(ClientEvents.LIVE_STREAMING_WARNING, url, err);
	      };

	      liveStreamingClient.on(LiveStreamingInternalEvents.REQUEST_WORKER_MANAGER_LIST, function (mode, resolve, reject) {
	        if (!_this._joinInfo) return reject(new AgoraRTCError(AgoraRTCErrorCode.INVALID_OPERATION, "can not find join info to get worker manager"));
	        getLiveStreamingWorkerMangerResult(mode, _this._joinInfo, _this._axiosCancelSource.token, DEFAULT_RETRY_CONFIG).then(resolve).catch(reject);
	      });
	    };

	    switch (type) {
	      case LiveStreamingServiceMode.RAW:
	        if (!this._liveRawStreamingClient) {
	          this._liveRawStreamingClient = createNewClient();
	          setLiveStreamingEvents(this._liveRawStreamingClient);
	        }

	        return this._liveRawStreamingClient;

	      case LiveStreamingServiceMode.TRANSCODE:
	        if (!this._liveTranscodeStreamingClient) {
	          this._liveTranscodeStreamingClient = createNewClient();
	          setLiveStreamingEvents(this._liveTranscodeStreamingClient);
	        }

	        return this._liveTranscodeStreamingClient;

	      case LiveStreamingServiceMode.INJECT:
	        if (!this._injectStreamingClient) {
	          this._injectStreamingClient = createNewClient();

	          this._injectStreamingClient.on(LiveStreamingInternalEvents.REQUEST_WORKER_MANAGER_LIST, function (mode, resolve, reject) {
	            if (!_this._joinInfo) return reject(new AgoraRTCError(AgoraRTCErrorCode.INVALID_OPERATION, "can not find join info to get worker manager"));
	            getLiveStreamingWorkerMangerResult(mode, _this._joinInfo, _this._axiosCancelSource.token, DEFAULT_RETRY_CONFIG).then(resolve).catch(reject);
	          });

	          this._injectStreamingClient.onInjectStatusChange = function (status, uid, url) {
	            _this.emit(ClientEvents.INJECT_STREAM_STATUS, status, uid, url);
	          };
	        }

	        return this._injectStreamingClient;
	    }
	  };

	  AgoraRTCClient.prototype._createChannelMediaRelayClient = function () {
	    var _this = this;

	    if (!this._joinInfo) {
	      var err = new AgoraRTCError(AgoraRTCErrorCode.INVALID_OPERATION, "can not create channel media relay client, please join channel first");
	      return err.throw();
	    }

	    if (!this._channelMediaRelayClient) {
	      this._channelMediaRelayClient = new AgoraChannelMediaRelayClient(this._joinInfo, this._clientId, this._config.websocketRetryConfig || DEFAULT_RETRY_CONFIG, this._config.httpRetryConfig || DEFAULT_RETRY_CONFIG);

	      this._channelMediaRelayClient.on("state", function (state) {
	        if (state === "RELAY_STATE_FAILURE"
	        /* RELAY_STATE_FAILURE */
	        ) {
	            _this._channelMediaRelayClient && _this._channelMediaRelayClient.dispose();
	          }

	        _this.emit(ClientEvents.CHANNEL_MEDIA_RELAY_STATE, state);
	      });

	      this._channelMediaRelayClient.on("event", function (event) {
	        _this.emit(ClientEvents.CHANNEL_MEDIA_RELAY_EVENT, event);
	      });
	    }

	    return this._channelMediaRelayClient;
	  };

	  AgoraRTCClient.prototype._handleGatewayEvents = function () {
	    var _this = this;

	    this._gateway.on(GatewayEvent.DISCONNECT_P2P, function () {
	      var _context28;

	      /**
	       * 当 Gateway 开始重连时，P2P 也需要强制重连
	       */
	      if (_this._highStream && _this._highStream.connectionState !== "disconnected") {
	        logger.debug("[" + _this._clientId + "] ready to reconnect high stream");

	        _this._highStream.readyToReconnectPC();
	      }

	      if (_this._lowStream && _this._lowStream.connectionState !== "disconnected") {
	        logger.debug("[" + _this._clientId + "] ready to reconnect low stream");

	        _this._lowStream.readyToReconnectPC();
	      }

	      forEach$3(_context28 = _this._remoteStream).call(_context28, function (sc, uid) {
	        logger.debug("[" + _this._clientId + "] ready to reconnect remote stream " + uid);
	        sc.readyToReconnectPC();
	      });
	    });

	    this._gateway.on(GatewayEvent.CONNECTION_STATE_CHANGE, function (cur, prev, reason) {
	      var emitEvent = function () {
	        _this.emit(ClientEvents.CONNECTION_STATE_CHANGE, cur, prev, reason);
	      };

	      logger.info("[" + _this._clientId + "] connection state change: " + prev + " -> " + cur);

	      if (cur === "DISCONNECTED") {
	        _this._reset();

	        _this._renewSession();

	        emitEvent();
	        return;
	      }

	      if (cur === "RECONNECTING") {
	        var _context29, _context30;

	        /**
	         * 当 Gateway 断开时对于已经处于断开状态的连接需要标记断线后重连
	         */
	        if (_this._highStream && _this._highStream.connectionState === "connecting") {
	          logger.debug("[" + _this._clientId + "] ready to reconnect high stream");

	          _this._highStream.readyToReconnectPC();
	        }

	        if (_this._lowStream && _this._lowStream.connectionState === "connecting") {
	          logger.debug("[" + _this._clientId + "] ready to reconnect low stream");

	          _this._lowStream.readyToReconnectPC();
	        }

	        forEach$3(_context29 = _this._remoteStream).call(_context29, function (sc, uid) {
	          if (sc.connectionState === "connecting") {
	            logger.debug("[" + _this._clientId + "] ready to reconnect remote stream " + uid);
	            sc.readyToReconnectPC();
	          }
	        });
	        /**
	         * 当 Gateway 断开时，重置所有 user/stream 的 `trust_in_room`
	         */


	        forEach$3(_context30 = _this._users).call(_context30, function (user) {
	          user._trust_in_room_ = false;
	          user._trust_audio_enabled_state_ = false;
	          user._trust_video_enabled_state_ = false;
	          user._trust_audio_mute_state_ = false;
	          user._trust_video_mute_state_ = false;
	          user._trust_stream_added_state_ = false;
	        });

	        _this._userOfflineTimeout && window.clearTimeout(_this._userOfflineTimeout);
	        _this._streamRemovedTimeout && window.clearTimeout(_this._streamRemovedTimeout);
	        _this._userOfflineTimeout = undefined;
	        _this._streamRemovedTimeout = undefined;
	      } else if (cur === "CONNECTED") {
	        var _context31, _context32;

	        /**
	         * Gateway 连接成功后，如果之前设置了远端大小流或者 auto fallback，需要再通知网关一次
	         */
	        forEach$3(_context31 = _this._streamFallbackTypeCacheMap).call(_context31, function (fallbackType, uid) {
	          _this._gateway.setStreamFallbackOption(uid, fallbackType).catch(function (e) {
	            return logger.warning("[" + _this._clientId + "] auto set stream fallback option failed", e);
	          });
	        });

	        forEach$3(_context32 = _this._remoteStreamTypeCacheMap).call(_context32, function (streamType, uid) {
	          _this._gateway.setRemoteVideoStreamType(uid, streamType).catch(function (e) {
	            return logger.warning("[" + _this._clientId + "] auto set remote stream type failed", e);
	          });
	        });
	        /**
	         * Gateway 连接成功后，判断是否需要重新发布
	         */


	        if (_this._highStream && _this._highStream.connectionState === "connecting") {
	          _this._highStream.reconnectPC().then(function () {
	            /** 大流发布后小流再发布 */
	            if (_this._lowStream && _this._lowStream.connectionState === "connecting") {
	              _this._lowStream.reconnectPC().catch(function (e) {
	                logger.error("[" + _this._clientId + "] republish low stream error", e.toString());

	                _this.emit(ClientEvents.ERROR, {
	                  reason: e
	                });
	              });
	            }
	          }).catch(function (e) {
	            logger.error("[" + _this._clientId + "] republish high stream error", e.toString());

	            _this.emit(ClientEvents.ERROR, {
	              reason: e
	            });
	          });
	        }
	        /**
	         * Gateway 连接成功后，利用 timeout 判断断线期间是否有流取消发布或者有用户退出
	         */


	        _this._userOfflineTimeout = window.setTimeout(function () {
	          var _context33;

	          if (_this.connectionState !== "CONNECTED") return;
	          _this._userOfflineTimeout = undefined;

	          var removedUsers = filter$2(_context33 = _this._users).call(_context33, function (user) {
	            return !user._trust_in_room_;
	          });

	          forEach$3(removedUsers).call(removedUsers, function (user) {
	            logger.debug("[" + _this._clientId + "] user offline timeout, emit user offline " + user.uid);

	            _this._handleUserOffline({
	              uid: user.uid
	            });
	          });
	        }, 3000);
	        _this._streamRemovedTimeout = window.setTimeout(function () {
	          var _context34;

	          if (_this.connectionState !== "CONNECTED") return;
	          _this._streamRemovedTimeout = undefined;
	          /**
	           * 如果收到 add stream 时内部缓存的 stream 的 mute 状态有变更，会有如下情况：
	           * - 如果断线这些 mute 状态没有改动，或者 mute 状态从 unmute -> mute 网关随即会下发 mute 事件。
	           *   此时，不需要做任何处理，待 mute 事件下发时处理即可
	           * - 但是如果在断线期间出现了 mute -> unmute，网关将不会下发任何事件。
	           *   此时，需要依赖客户端的超时逻辑来给用户下发 unmute 事件
	           */

	          forEach$3(_context34 = _this._users).call(_context34, function (user) {
	            /** 一旦 mute 状态不可信，说明 mute 状态就是 unmute */
	            if (!user._trust_audio_mute_state_) {
	              logger.debug("[" + _this._clientId + "] auto dispatch audio unmute event " + user.uid);

	              _this._handleMuteStream(user.uid, "audio", false);
	            }

	            if (!user._trust_video_mute_state_) {
	              logger.debug("[" + _this._clientId + "] auto dispatch video unmute event " + user.uid);

	              _this._handleMuteStream(user.uid, "video", false);
	            }
	            /** 一旦 enable 状态不可信，说明 enabled 状态就是 enable */


	            if (!user._trust_audio_enabled_state_) {
	              logger.debug("[" + _this._clientId + "] auto dispatch enable local audio " + user.uid);

	              _this._handleSetStreamLocalEnable("audio", user.uid, true);
	            }

	            if (!user._trust_video_enabled_state_ && user._video_enabled_) {
	              logger.debug("[" + _this._clientId + "] auto dispatch enable local video " + user.uid);

	              _this._handleSetStreamLocalEnable("video", user.uid, true);
	            }

	            if (!user._trust_stream_added_state_) {
	              logger.debug("[" + _this._clientId + "] auto dispatch stream remove " + user.uid);

	              _this._handleRemoveStream({
	                uid: user.uid,
	                uint_id: user._uintid
	              });
	            }
	          });
	        }, 1000);
	      }

	      emitEvent();
	    });

	    this._gateway.on(GatewayEvent.REQUEST_NEW_GATEWAY_LIST, function (resolve, reject) {
	      if (!_this._joinInfo) return reject(new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_ERROR, "can not recover, no join info"));
	      getJoinChannelServerInfo(_this._joinInfo, _this._axiosCancelSource.token, _this._config.httpRetryConfig || DEFAULT_RETRY_CONFIG).then(function (serverInfo) {
	        var _context35;

	        if (_this._joinInfo) {
	          _this._joinInfo.apResponse = serverInfo.gatewayInfo.res;
	        }

	        resolve(map$5(_context35 = serverInfo.gatewayInfo.gatewayAddrs).call(_context35, function (url) {
	          return "wss://" + url;
	        }));
	      }).catch(reject);
	    });

	    this._gateway.on(GatewayEvent.NETWORK_QUALITY, function (quality) {
	      if (_this._networkQualitySensitivity === "normal") {
	        _this.emit(ClientEvents.NETWORK_QUALITY, quality);
	      }
	    });

	    this._gateway.on(GatewayEvent.STREAM_TYPE_CHANGE, function (uid, streamType) {
	      _this.emit(ClientEvents.STREAM_TYPE_CHANGED, uid, streamType);

	      var executor = report.reportApiInvoke(_this._sessionId, {
	        name: AgoraAPIName.STREAM_TYPE_CHANGE,
	        options: [uid, streamType],
	        tag: AgoraAPITag.TRACER
	      });
	      executor.onSuccess(stringify$2({
	        uid: uid,
	        streamType: streamType
	      }));
	    });

	    this._gateway.on(GatewayEvent.IS_P2P_DISCONNECTED, function (callback) {
	      var _context36, _context37;

	      // 除非所有的 P2P 都断开，否则认为 P2P 连接正常
	      var streamConnections = [];
	      if (_this._highStream) streamConnections.push(_this._highStream);

	      forEach$3(_context36 = _this._remoteStream).call(_context36, function (sc) {
	        return streamConnections.push(sc);
	      }); // 没有建立 P2P 认为连接 p2p 断开


	      if (streamConnections.length === 0) return callback(true); // 所有连接处于未连接状态

	      if (filter$2(streamConnections).call(streamConnections, function (sc) {
	        return sc.connectionState === "connected";
	      }).length === 0) {
	        return callback(true);
	      }

	      logger.debug("[" + _this._clientId + "] " + map$5(_context37 = filter$2(streamConnections).call(streamConnections, function (sc) {
	        return sc.connectionState === "connected";
	      })).call(_context37, function (s) {
	        return s.connectionId;
	      }) + " is connected");
	      callback(false);
	    });

	    this._gateway.on(GatewayEvent.NEED_RENEW_SESSION, function () {
	      _this._renewSession();
	    });

	    this._gateway.signal.on(SignalNotifyType.ON_USER_ONLINE, this._handleUserOnline);

	    this._gateway.signal.on(SignalNotifyType.ON_USER_OFFLINE, this._handleUserOffline);

	    this._gateway.signal.on(SignalNotifyType.ON_ADD_AUDIO_STREAM, function (message) {
	      return _this._handleAddAudioOrVideoStream("audio", message.uid, message.uint_id);
	    });

	    this._gateway.signal.on(SignalNotifyType.ON_ADD_VIDEO_STREAM, function (message) {
	      return _this._handleAddAudioOrVideoStream("video", message.uid, message.uint_id);
	    });

	    this._gateway.signal.on(SignalNotifyType.ON_REMOVE_STREAM, this._handleRemoveStream);

	    this._gateway.signal.on(SignalNotifyType.ON_P2P_LOST, this._handleP2PLost);

	    this._gateway.signal.on(SignalNotifyType.MUTE_AUDIO, function (message) {
	      return _this._handleMuteStream(message.uid, "audio", true);
	    });

	    this._gateway.signal.on(SignalNotifyType.UNMUTE_AUDIO, function (message) {
	      return _this._handleMuteStream(message.uid, "audio", false);
	    });

	    this._gateway.signal.on(SignalNotifyType.MUTE_VIDEO, function (message) {
	      return _this._handleMuteStream(message.uid, "video", true);
	    });

	    this._gateway.signal.on(SignalNotifyType.UNMUTE_VIDEO, function (message) {
	      return _this._handleMuteStream(message.uid, "video", false);
	    });

	    this._gateway.signal.on(SignalNotifyType.RECEIVE_METADATA, function (message) {
	      var metadata = base64ToUint8Array(message.metadata);

	      _this.emit(ClientEvents.RECEIVE_METADATA, message.uid, metadata);
	    });

	    this._gateway.signal.on(SignalNotifyType.ON_DATA_STREAM, function (message) {
	      if (message.seq) {
	        delete message.seq;
	      }

	      message.payload = base64ToUint8Array(message.payload);

	      _this.emit(ClientEvents.STREAM_MESSAGE, message.uid, message.payload);

	      _this.onStreamMessage && _this.onStreamMessage(message);
	    });

	    this._gateway.signal.on(SignalNotifyType.ON_CRYPT_ERROR, function () {
	      runOnce(function () {
	        logger.warning("[" + _this._clientId + "] on crypt error");

	        _this.emit(ClientEvents.CRYPT_ERROR);
	      }, _this._sessionId);
	    });

	    this._gateway.signal.on(SignalNotifyType.ON_TOKEN_PRIVILEGE_WILL_EXPIRE, this._handleTokenWillExpire);

	    this._gateway.signal.on(SignalNotifyType.ON_TOKEN_PRIVILEGE_DID_EXPIRE, function () {
	      logger.warning("[" + _this._clientId + "] received message onTokenPrivilegeDidExpire, please get new token and join again");

	      _this._reset();

	      _this._gateway.leave(true);

	      _this.emit(ClientEvents.ON_TOKEN_PRIVILEGE_DID_EXPIRE);
	    });

	    this._gateway.signal.on(SignalNotifyType.ON_STREAM_FALLBACK_UPDATE, function (message) {
	      logger.debug("[" + _this._clientId + "] stream fallback peerId: " + message.stream_id + ", attr: " + message.stream_type);

	      _this.emit(ClientEvents.STREAM_FALLBACK, message.stream_id, message.stream_type === 1 ? "fallback" : "recover");
	    });

	    this._gateway.signal.on(SignalNotifyType.ENABLE_LOCAL_VIDEO, function (message) {
	      _this._handleSetStreamLocalEnable("video", message.uid, true);
	    });

	    this._gateway.signal.on(SignalNotifyType.DISABLE_LOCAL_VIDEO, function (message) {
	      _this._handleSetStreamLocalEnable("video", message.uid, false);
	    });

	    this._gateway.signal.on(SignalEvent.REQUEST_TIMEOUT, function (requestType, payload) {
	      if (!_this._joinInfo) return;

	      switch (requestType) {
	        case SignalRequestType.PUBLISH:
	          {
	            var _context38;

	            if (!payload) return;
	            var connection = payload.stream_type === "high" ? _this._highStream : _this._lowStream;
	            if (!connection) return;
	            payload.state === "offer" && report.publish(_this._joinInfo.sid, {
	              lts: connection.startTime,
	              succ: false,
	              ec: AgoraRTCErrorCode.TIMEOUT,
	              audio: payload.audio,
	              video: payload.video,
	              p2pid: payload.p2p_id,
	              publishRequestid: connection.ID,
	              screenshare: !!(connection.videoTrack && indexOf$3(_context38 = connection.videoTrack._hints).call(_context38, TrackHint.SCREEN_TRACK) !== -1),
	              audioName: connection.audioTrack && connection.audioTrack.getTrackLabel(),
	              videoName: connection.videoTrack && connection.videoTrack.getTrackLabel()
	            });
	            break;
	          }

	        case SignalRequestType.SUBSCRIBE:
	          {
	            var uid = payload.stream_id;

	            var connection = _this._remoteStream.get(uid);

	            if (!connection) return;
	            payload && report.subscribe(_this._joinInfo.sid, {
	              lts: connection.startTime,
	              succ: false,
	              ec: AgoraRTCErrorCode.TIMEOUT,
	              audio: !!payload.audio,
	              video: !!payload.video,
	              peerid: payload.stream_id,
	              subscribeRequestid: connection.ID,
	              p2pid: connection.pc.ID
	            });
	            break;
	          }
	      }
	    });
	  };

	  return AgoraRTCClient;
	}(EventEmitter$1);
	function createClient(config) {
	  if (config === void 0) {
	    config = {
	      codec: "vp8",
	      mode: "rtc"
	    };
	  }

	  var executor = report.reportApiInvoke(null, {
	    name: AgoraAPIName.CREATE_CLIENT,
	    options: [config],
	    tag: AgoraAPITag.TRACER
	  });

	  try {
	    isClientConfig(config);
	  } catch (e) {
	    executor.onError(e);
	    throw e;
	  }

	  executor.onSuccess();
	  return new AgoraRTCClient(__assign$d(__assign$d({
	    forceWaitGatewayResponse: true
	  }, config), {
	    role: config.mode === "rtc" ? "host" : config.role
	  }));
	}

	var __awaiter$v = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = promise$3))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var __generator$v = undefined && undefined.__generator || function (thisArg, body) {
	  var _ = {
	    label: 0,
	    sent: function () {
	      if (t[0] & 1) throw t[1];
	      return t[1];
	    },
	    trys: [],
	    ops: []
	  },
	      f,
	      y,
	      t,
	      g;
	  return g = {
	    next: verb(0),
	    "throw": verb(1),
	    "return": verb(2)
	  }, typeof symbol$2 === "function" && (g[iterator$2] = function () {
	    return this;
	  }), g;

	  function verb(n) {
	    return function (v) {
	      return step([n, v]);
	    };
	  }

	  function step(op) {
	    if (f) throw new TypeError("Generator is already executing.");

	    while (_) try {
	      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	      if (y = 0, t) op = [op[0] & 2, t.value];

	      switch (op[0]) {
	        case 0:
	        case 1:
	          t = op;
	          break;

	        case 4:
	          _.label++;
	          return {
	            value: op[1],
	            done: false
	          };

	        case 5:
	          _.label++;
	          y = op[1];
	          op = [0];
	          continue;

	        case 7:
	          op = _.ops.pop();

	          _.trys.pop();

	          continue;

	        default:
	          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
	            _ = 0;
	            continue;
	          }

	          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
	            _.label = op[1];
	            break;
	          }

	          if (op[0] === 6 && _.label < t[1]) {
	            _.label = t[1];
	            t = op;
	            break;
	          }

	          if (t && _.label < t[2]) {
	            _.label = t[2];

	            _.ops.push(op);

	            break;
	          }

	          if (t[2]) _.ops.pop();

	          _.trys.pop();

	          continue;
	      }

	      op = body.call(thisArg, _);
	    } catch (e) {
	      op = [6, e];
	      y = 0;
	    } finally {
	      f = t = 0;
	    }

	    if (op[0] & 5) throw op[1];
	    return {
	      value: op[0] ? op[1] : void 0,
	      done: true
	    };
	  }
	};
	function getSupportedCodec(stream) {
	  return __awaiter$v(this, void 0, void 0, function () {
	    var connection, offer, result;
	    return __generator$v(this, function (_a) {
	      switch (_a.label) {
	        case 0:
	          connection = null;

	          if (stream) {
	            connection = new PubRTCPeerConnection({});
	            connection.addStream(stream);
	          } else {
	            connection = new SubRTCPeerConnection({});
	          }

	          return [4
	          /*yield*/
	          , connection.createOfferSDP()];

	        case 1:
	          offer = _a.sent();
	          result = getSupportedCodecFromSDP(offer);
	          connection.close();
	          return [2
	          /*return*/
	          , result];
	      }
	    });
	  });
	}
	function checkSystemRequirements() {
	  var executor = report.reportApiInvoke(null, {
	    name: AgoraAPIName.CHECK_SYSTEM_REQUIREMENTS,
	    options: [],
	    tag: AgoraAPITag.TRACER
	  });
	  /**
	   * 代码运行到这里的时候 webrtc-adapter 肯定该替换的都替换了
	   * 所以直接检查标准写法
	   */

	  var PC = window.RTCPeerConnection;
	  var getUserMedia = navigator.mediaDevices && navigator.mediaDevices.getUserMedia;
	  var websocket = window.WebSocket;
	  var isAPISupport = PC && getUserMedia && websocket;
	  var isBrowserSupport = false;
	  var browserInfo = getBrowserInfo();

	  if (browserInfo.name === BrowserName.CHROME && Number(browserInfo.version) >= 58 && browserInfo.os !== BrowserOS.IOS) {
	    isBrowserSupport = true;
	  }

	  if (browserInfo.name === BrowserName.FIREFOX && Number(browserInfo.version) >= 56) {
	    isBrowserSupport = true;
	  }

	  if (browserInfo.name === BrowserName.OPERA && Number(browserInfo.version) >= 45) {
	    isBrowserSupport = true;
	  }

	  if (browserInfo.name === BrowserName.SAFARI && Number(browserInfo.version) >= 11) {
	    isBrowserSupport = true;
	  }

	  if (isWechatBrowser() || isQQBrowser()) {
	    if (browserInfo.os !== BrowserOS.IOS) {
	      isBrowserSupport = true;
	    }
	  }

	  logger.debug("checkSystemRequirements, api:", isAPISupport, "browser", isBrowserSupport);
	  var result = isAPISupport && isBrowserSupport;
	  executor.onSuccess(result);
	  return result;
	}

	var __extends$r = undefined && undefined.__extends || function () {
	  var extendStatics = function (d, b) {
	    extendStatics = setPrototypeOf$2 || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    };

	    return extendStatics(d, b);
	  };

	  return function (d, b) {
	    extendStatics(d, b);

	    function __() {
	      this.constructor = d;
	    }

	    d.prototype = b === null ? create$4(b) : (__.prototype = b.prototype, new __());
	  };
	}();

	var AudioSource =
	/** @class */
	function (_super) {
	  __extends$r(AudioSource, _super);

	  function AudioSource() {
	    var _this = _super.call(this) || this; // 表示这个音频源当前是否连接到了 WebAudio Output


	    _this.isPlayed = false;
	    _this.audioLevelBase = 0;
	    _this.audioOutputLevel = 0;
	    /** 历史实时音量的缓存，用于计算平均音量, 为 null 表示没有开始音量缓存 */

	    _this.audioOutputLevelCache = null;
	    _this.audioOutputLevelCacheMaxLength = getParameter("AUDIO_SOURCE_AVG_VOLUME_DURATION") / getParameter("AUDIO_SOURCE_VOLUME_UPDATE_INTERVAL") || 15;
	    _this.isDestroyed = false;
	    _this._noAudioInputCount = 0;
	    _this.context = getAudioContext();
	    _this.playNode = _this.context.destination;
	    _this.outputNode = _this.context.createGain();
	    polyfillAudioNode(_this.outputNode);
	    _this.analyserNode = _this.context.createAnalyser();
	    return _this;
	  }

	  defineProperty$4(AudioSource.prototype, "isNoAudioInput", {
	    /**
	     * 表示当前输入音频是否有问题
	     * 目前只会在 Safari 下判断这个情况
	     *
	     * 连续 3 帧出现数据为 0 的情况
	     */
	    get: function () {
	      return this.noAudioInputCount >= 3;
	    },
	    enumerable: true,
	    configurable: true
	  });

	  defineProperty$4(AudioSource.prototype, "noAudioInputCount", {
	    get: function () {
	      return this._noAudioInputCount;
	    },
	    set: function (count) {
	      if (this._noAudioInputCount < 3 && count >= 3) {
	        this.onNoAudioInput && this.onNoAudioInput();
	      } else if (this._noAudioInputCount >= 3 && this._noAudioInputCount % 10 === 0) {
	        this.onNoAudioInput && this.onNoAudioInput();
	      }

	      this._noAudioInputCount = count;
	    },
	    enumerable: true,
	    configurable: true
	  });

	  AudioSource.prototype.startGetAudioBuffer = function (bufferSize) {
	    var _this = this;

	    if (this.audioBufferNode) return;
	    this.audioBufferNode = this.context.createScriptProcessor(bufferSize);
	    this.outputNode.connect(this.audioBufferNode);
	    this.audioBufferNode.connect(this.context.destination);

	    this.audioBufferNode.onaudioprocess = function (e) {
	      _this.emit(AudioSourceEvents.ON_AUDIO_BUFFER, silenceScriptProcessHandler(e));
	    };
	  };

	  AudioSource.prototype.stopGetAudioBuffer = function () {
	    if (!this.audioBufferNode) return;
	    this.audioBufferNode.onaudioprocess = null;
	    this.outputNode.disconnect(this.audioBufferNode);
	    this.audioBufferNode = undefined;
	  };

	  AudioSource.prototype.createOutputTrack = function () {
	    var compat = getCompatibility();

	    if (!compat.webAudioMediaStreamDest) {
	      throw new AgoraRTCError(AgoraRTCErrorCode.NOT_SUPPORTED, "your browser is not support audio processor");
	    }

	    if (this.destNode && this.outputTrack) return this.outputTrack;
	    this.destNode = this.context.createMediaStreamDestination();
	    this.outputNode.connect(this.destNode);
	    this.outputTrack = this.destNode.stream.getAudioTracks()[0];
	    return this.outputTrack;
	  };

	  AudioSource.prototype.play = function (dest) {
	    /**
	     * 说明此时 autoplay 还没有解锁
	     */
	    if (this.context.state !== "running") {
	      nextTick(function () {
	        audioContextStateChangeEmitter.emit("autoplay-failed");
	      });
	    }

	    this.isPlayed = true;
	    this.playNode = dest || this.context.destination;
	    this.outputNode.connect(this.playNode);
	  };

	  AudioSource.prototype.stop = function () {
	    if (this.isPlayed) {
	      try {
	        this.outputNode.disconnect(this.playNode);
	      } catch (e) {}
	    }

	    this.isPlayed = false;
	  };
	  /**
	   * 获取音源的实时音量（通过 AnalyserNode 计算得出的
	   * 范围是 [0, 1], 1 表示理论最大音量
	   */


	  AudioSource.prototype.getAudioLevel = function () {
	    return this.audioOutputLevel;
	  };
	  /**
	   * 获取音源在 `AUDIO_SOURCE_AVG_VOLUME_DURATION(3s)`内的平均音量。
	   * 首次调用会返回当前实时音量
	   * 范围是 [0, 1], 1 表示理论最大音量
	   */


	  AudioSource.prototype.getAudioAvgLevel = function () {
	    var _context;

	    if (this.audioOutputLevelCache === null) {
	      this.audioOutputLevelCache = [this.audioOutputLevel];
	    }

	    var levelSum = reduce$2(_context = this.audioOutputLevelCache).call(_context, function (a, b) {
	      return a + b;
	    });

	    return levelSum / this.audioOutputLevelCache.length;
	  };
	  /**
	   * 获取音源的设置音量（通过 GainNode 得出的
	   *  范围是 [0. Infinity], 1 表示原始音量
	   */


	  AudioSource.prototype.getAudioVolume = function () {
	    return this.outputNode.gain.value;
	  };

	  AudioSource.prototype.setVolume = function (level) {
	    this.outputNode.gain.setValueAtTime(level, this.context.currentTime);
	  };

	  AudioSource.prototype.setMute = function (isMuted) {
	    if (isMuted) {
	      this.disconnect();
	      this.audioLevelBase = 0;
	      this.audioOutputLevel = 0;
	    } else {
	      this.connect();
	    }
	  };

	  AudioSource.prototype.destroy = function () {
	    this.disconnect();
	    this.stop();
	    this.isDestroyed = true;
	    this.onNoAudioInput = undefined;
	  };

	  AudioSource.prototype.disconnect = function () {
	    this.sourceNode && this.sourceNode.disconnect();
	    this.outputNode && this.outputNode.disconnect();
	    window.clearInterval(this.updateAudioOutputLevelInterval);
	  };

	  AudioSource.prototype.connect = function () {
	    var _context2;

	    this.sourceNode && this.sourceNode.connect(this.outputNode);
	    this.outputNode.connect(this.analyserNode);
	    this.updateAudioOutputLevelInterval = window.setInterval(bind$3(_context2 = this.updateAudioOutputLevel).call(_context2, this), getParameter("AUDIO_SOURCE_VOLUME_UPDATE_INTERVAL") || 400);
	  };

	  AudioSource.prototype.updateAudioOutputLevel = function () {
	    if (this.context && this.context.state !== "running") {
	      this.context.resume();
	    }

	    if (!this.analyserNode) return;
	    var timeDomainData;

	    if (this.analyserNode.getFloatTimeDomainData) {
	      timeDomainData = new Float32Array(this.analyserNode.frequencyBinCount);
	      this.analyserNode.getFloatTimeDomainData(timeDomainData);
	    } else {
	      var _context3;

	      timeDomainData = new Uint8Array(this.analyserNode.frequencyBinCount);
	      this.analyserNode.getByteTimeDomainData(timeDomainData);
	      var isNoInput_1 = true;
	      timeDomainData = new Float32Array(map$5(_context3 = from_1$2(timeDomainData)).call(_context3, function (d) {
	        if (d !== 128) isNoInput_1 = false;
	        return (d - 128) * 0.0078125;
	      }));

	      if (isNoInput_1) {
	        this.noAudioInputCount += 1;
	      } else {
	        this.noAudioInputCount = 0;
	      }
	    }

	    for (var i = 0; i < timeDomainData.length; i += 1) {
	      if (Math.abs(timeDomainData[i]) > this.audioLevelBase) {
	        this.audioLevelBase = Math.abs(timeDomainData[i]);

	        if (this.audioLevelBase > 1) {
	          this.audioLevelBase = 1;
	        }
	      }
	    }

	    this.audioOutputLevel = this.audioLevelBase;
	    this.audioLevelBase = this.audioLevelBase / 4;

	    if (this.audioOutputLevelCache !== null) {
	      this.audioOutputLevelCache.push(this.audioOutputLevel);

	      if (this.audioOutputLevelCache.length > this.audioOutputLevelCacheMaxLength) {
	        this.audioOutputLevelCache.shift();
	      }
	    }
	  };

	  return AudioSource;
	}(EventEmitter$1);

	var __extends$s = undefined && undefined.__extends || function () {
	  var extendStatics = function (d, b) {
	    extendStatics = setPrototypeOf$2 || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    };

	    return extendStatics(d, b);
	  };

	  return function (d, b) {
	    extendStatics(d, b);

	    function __() {
	      this.constructor = d;
	    }

	    d.prototype = b === null ? create$4(b) : (__.prototype = b.prototype, new __());
	  };
	}();

	var __awaiter$w = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = promise$3))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var __generator$w = undefined && undefined.__generator || function (thisArg, body) {
	  var _ = {
	    label: 0,
	    sent: function () {
	      if (t[0] & 1) throw t[1];
	      return t[1];
	    },
	    trys: [],
	    ops: []
	  },
	      f,
	      y,
	      t,
	      g;
	  return g = {
	    next: verb(0),
	    "throw": verb(1),
	    "return": verb(2)
	  }, typeof symbol$2 === "function" && (g[iterator$2] = function () {
	    return this;
	  }), g;

	  function verb(n) {
	    return function (v) {
	      return step([n, v]);
	    };
	  }

	  function step(op) {
	    if (f) throw new TypeError("Generator is already executing.");

	    while (_) try {
	      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	      if (y = 0, t) op = [op[0] & 2, t.value];

	      switch (op[0]) {
	        case 0:
	        case 1:
	          t = op;
	          break;

	        case 4:
	          _.label++;
	          return {
	            value: op[1],
	            done: false
	          };

	        case 5:
	          _.label++;
	          y = op[1];
	          op = [0];
	          continue;

	        case 7:
	          op = _.ops.pop();

	          _.trys.pop();

	          continue;

	        default:
	          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
	            _ = 0;
	            continue;
	          }

	          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
	            _.label = op[1];
	            break;
	          }

	          if (op[0] === 6 && _.label < t[1]) {
	            _.label = t[1];
	            t = op;
	            break;
	          }

	          if (t && _.label < t[2]) {
	            _.label = t[2];

	            _.ops.push(op);

	            break;
	          }

	          if (t[2]) _.ops.pop();

	          _.trys.pop();

	          continue;
	      }

	      op = body.call(thisArg, _);
	    } catch (e) {
	      op = [6, e];
	      y = 0;
	    } finally {
	      f = t = 0;
	    }

	    if (op[0] & 5) throw op[1];
	    return {
	      value: op[0] ? op[1] : void 0,
	      done: true
	    };
	  }
	};

	var AudioBufferSource =
	/** @class */
	function (_super) {
	  __extends$s(AudioBufferSource, _super);

	  function AudioBufferSource(buffer, options) {
	    if (options === void 0) {
	      options = {};
	    }

	    var _this = _super.call(this) || this;
	    /**
	     * 开始播放的时间（context 时间）
	     */


	    _this.startPlayTime = 0;
	    /**
	     * 开始播放的时间 （buffer 时间）
	     */

	    _this.startPlayOffset = 0;
	    /**
	     * 暂停播放的时间 （buffer 时间）
	     */

	    _this.pausePlayTime = 0;
	    _this.currentLoopCount = 0;
	    _this._currentState = "stopped";
	    _this.audioBuffer = buffer;
	    _this.options = options;
	    _this.startPlayOffset = _this.options.startPlayTime || 0;
	    return _this;
	  }

	  defineProperty$4(AudioBufferSource.prototype, "currentState", {
	    get: function () {
	      return this._currentState;
	    },
	    set: function (state) {
	      if (state === this._currentState) {
	        return;
	      }

	      this._currentState = state;
	      this.emit(AudioSourceEvents.AUDIO_SOURCE_STATE_CHANGE, this._currentState);
	    },
	    enumerable: true,
	    configurable: true
	  });

	  AudioBufferSource.prototype.createWebAudioDiagram = function () {
	    return this.context.createGain();
	  };

	  defineProperty$4(AudioBufferSource.prototype, "duration", {
	    get: function () {
	      return this.audioBuffer.duration;
	    },
	    enumerable: true,
	    configurable: true
	  });

	  defineProperty$4(AudioBufferSource.prototype, "currentTime", {
	    /**
	     * 计算当前播放时间的公式是
	     * （当前时间 - 开始播放时间 + 开始播放的 offset）% 总时长
	     * 如果发现播放被暂停了，返回暂停那一刻记录的 currentTime
	     * 如果发现播放还没开始，返回 0
	     */
	    get: function () {
	      if (this.currentState === "stopped") {
	        return 0;
	      }

	      if (this.currentState === "paused") {
	        return this.pausePlayTime;
	      }

	      return (this.context.currentTime - this.startPlayTime + this.startPlayOffset) % this.audioBuffer.duration;
	    },
	    enumerable: true,
	    configurable: true
	  });

	  AudioBufferSource.prototype.updateOptions = function (options) {
	    if (this.currentState !== "stopped") {
	      logger.warning("can not set audio source options");
	      return;
	    }

	    this.options = options;
	    this.startPlayOffset = this.options.startPlayTime || 0;
	  };

	  AudioBufferSource.prototype.startProcessAudioBuffer = function () {
	    /**
	     * 如果重复调用 start，先 stop 再 start
	     */
	    if (this.sourceNode) {
	      this.stopProcessAudioBuffer();
	    }

	    this.sourceNode = this.createSourceNode();
	    this.startSourceNode();
	    this.currentState = "playing";
	  };
	  /**
	   * AudioSourceNode 并没有提供 pause 方法
	   * 一个 AudioSourceNode stop 后也不能再 start 了
	   * 所以只能删掉这个 AudioSourceNode 创建新的来实现
	   */


	  AudioBufferSource.prototype.pauseProcessAudioBuffer = function () {
	    if (!this.sourceNode || this.currentState !== "playing") return;
	    this.pausePlayTime = this.currentTime;
	    this.sourceNode.onended = null;
	    this.sourceNode.stop();
	    this.sourceNode.buffer = null;
	    this.sourceNode = this.createSourceNode();
	    this.currentState = "paused";
	  };
	  /**
	   * 同 pause，需要重新创建 AudioSourceNode
	   * @time 单位是秒
	   */


	  AudioBufferSource.prototype.seekAudioBuffer = function (time) {
	    if (!this.sourceNode) return;
	    this.sourceNode.onended = null;

	    if (this.currentState === "playing") {
	      this.sourceNode.stop();
	    }

	    this.sourceNode = this.createSourceNode();

	    if (this.currentState === "playing") {
	      this.startPlayOffset = time;
	      this.startSourceNode();
	    } else if (this.currentState === "paused") {
	      this.pausePlayTime = time;
	    }
	  };
	  /**
	   * 会从暂停的位置开始播放
	   */


	  AudioBufferSource.prototype.resumeProcessAudioBuffer = function () {
	    if (this.currentState !== "paused" || !this.sourceNode) return;
	    this.startPlayOffset = this.pausePlayTime;
	    this.pausePlayTime = 0;
	    this.startSourceNode();
	    this.currentState = "playing";
	  };

	  AudioBufferSource.prototype.stopProcessAudioBuffer = function () {
	    if (!this.sourceNode) return;
	    this.sourceNode.onended = null;

	    try {
	      this.sourceNode.stop(); // ignore stop error
	    } catch (e) {}

	    this.reset();
	  };

	  AudioBufferSource.prototype.startSourceNode = function () {
	    var _context;

	    if (!this.sourceNode || !this.sourceNode.buffer) return;
	    this.sourceNode.start(0, this.startPlayOffset);
	    this.startPlayTime = this.context.currentTime;
	    this.sourceNode.onended = bind$3(_context = this.handleSourceNodeEnded).call(_context, this);
	  };

	  AudioBufferSource.prototype.createSourceNode = function () {
	    var sourceNode = this.context.createBufferSource();
	    sourceNode.buffer = this.audioBuffer;
	    sourceNode.loop = !!this.options.loop;
	    sourceNode.connect(this.outputNode);
	    return sourceNode;
	  };

	  AudioBufferSource.prototype.handleSourceNodeEnded = function () {
	    this.currentLoopCount += 1;

	    if (this.options.cycle && this.options.cycle > this.currentLoopCount) {
	      this.startPlayOffset = 0;
	      this.sourceNode = undefined;
	      this.startProcessAudioBuffer();
	      return;
	    }

	    this.reset();
	  };

	  AudioBufferSource.prototype.reset = function () {
	    this.startPlayOffset = this.options.startPlayTime || 0;
	    this.currentState = "stopped";

	    if (this.sourceNode) {
	      this.sourceNode.disconnect();
	      this.sourceNode = undefined;
	    }

	    this.currentLoopCount = 0;
	  };

	  return AudioBufferSource;
	}(AudioSource);
	var onlineAudioBufferCache = new map$2();
	/**
	 * 接受 2 种输入，在线音频地址或者本地音频文件
	 */

	function createAudioBuffer(source, cached) {
	  return __awaiter$w(this, void 0, void 0, function () {
	    var arrayBuffer, cachedBuffer, res, e_1, readArrayBufferPromise, audioBuffer;
	    return __generator$w(this, function (_a) {
	      switch (_a.label) {
	        case 0:
	          arrayBuffer = null;
	          if (!(typeof source === "string")) return [3
	          /*break*/
	          , 5];
	          cachedBuffer = onlineAudioBufferCache.get(source);

	          if (cachedBuffer) {
	            logger.debug("use cached audio resource: ", source);
	            return [2
	            /*return*/
	            , cachedBuffer];
	          }

	          _a.label = 1;

	        case 1:
	          _a.trys.push([1, 3,, 4]);

	          return [4
	          /*yield*/
	          , retryable(function () {
	            return axios$1.get(source, {
	              responseType: "arraybuffer"
	            });
	          }, undefined, undefined, {
	            maxRetryCount: 3
	          })];

	        case 2:
	          res = _a.sent();
	          arrayBuffer = res.data;
	          return [3
	          /*break*/
	          , 4];

	        case 3:
	          e_1 = _a.sent();
	          throw new AgoraRTCError(AgoraRTCErrorCode.FETCH_AUDIO_FILE_FAILED, e_1.toString());

	        case 4:
	          return [3
	          /*break*/
	          , 7];

	        case 5:
	          readArrayBufferPromise = new promise$3(function (resolve, reject) {
	            var reader = new FileReader();

	            reader.onload = function (e) {
	              if (!e.target) {
	                reject(new AgoraRTCError(AgoraRTCErrorCode.READ_LOCAL_AUDIO_FILE_ERROR));
	                return;
	              }

	              resolve(e.target.result);
	            };

	            reader.onerror = function () {
	              reject(new AgoraRTCError(AgoraRTCErrorCode.READ_LOCAL_AUDIO_FILE_ERROR));
	            };

	            reader.readAsArrayBuffer(source);
	          });
	          return [4
	          /*yield*/
	          , readArrayBufferPromise];

	        case 6:
	          arrayBuffer = _a.sent();
	          _a.label = 7;

	        case 7:
	          return [4
	          /*yield*/
	          , decodeAudioData(arrayBuffer)];

	        case 8:
	          audioBuffer = _a.sent();

	          if (typeof source === "string" && cached) {
	            onlineAudioBufferCache.set(source, audioBuffer);
	          }

	          return [2
	          /*return*/
	          , audioBuffer];
	      }
	    });
	  });
	}

	var __assign$e = undefined && undefined.__assign || function () {
	  __assign$e = assign$2 || function (t) {
	    for (var s, i = 1, n = arguments.length; i < n; i++) {
	      s = arguments[i];

	      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	    }

	    return t;
	  };

	  return __assign$e.apply(this, arguments);
	};

	var __awaiter$x = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = promise$3))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var __generator$x = undefined && undefined.__generator || function (thisArg, body) {
	  var _ = {
	    label: 0,
	    sent: function () {
	      if (t[0] & 1) throw t[1];
	      return t[1];
	    },
	    trys: [],
	    ops: []
	  },
	      f,
	      y,
	      t,
	      g;
	  return g = {
	    next: verb(0),
	    "throw": verb(1),
	    "return": verb(2)
	  }, typeof symbol$2 === "function" && (g[iterator$2] = function () {
	    return this;
	  }), g;

	  function verb(n) {
	    return function (v) {
	      return step([n, v]);
	    };
	  }

	  function step(op) {
	    if (f) throw new TypeError("Generator is already executing.");

	    while (_) try {
	      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	      if (y = 0, t) op = [op[0] & 2, t.value];

	      switch (op[0]) {
	        case 0:
	        case 1:
	          t = op;
	          break;

	        case 4:
	          _.label++;
	          return {
	            value: op[1],
	            done: false
	          };

	        case 5:
	          _.label++;
	          y = op[1];
	          op = [0];
	          continue;

	        case 7:
	          op = _.ops.pop();

	          _.trys.pop();

	          continue;

	        default:
	          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
	            _ = 0;
	            continue;
	          }

	          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
	            _.label = op[1];
	            break;
	          }

	          if (op[0] === 6 && _.label < t[1]) {
	            _.label = t[1];
	            t = op;
	            break;
	          }

	          if (t && _.label < t[2]) {
	            _.label = t[2];

	            _.ops.push(op);

	            break;
	          }

	          if (t[2]) _.ops.pop();

	          _.trys.pop();

	          continue;
	      }

	      op = body.call(thisArg, _);
	    } catch (e) {
	      op = [6, e];
	      y = 0;
	    } finally {
	      f = t = 0;
	    }

	    if (op[0] & 5) throw op[1];
	    return {
	      value: op[0] ? op[1] : void 0,
	      done: true
	    };
	  }
	};
	function createCustomAudioTrack(config) {
	  var executor = report.reportApiInvoke(null, {
	    tag: AgoraAPITag.TRACER,
	    name: AgoraAPIName.CREATE_CUSTOM_AUDIO_TRACK,
	    options: [config]
	  });
	  var track = new LocalAudioTrack(config.mediaStreamTrack, config.encoderConfig ? getAudioEncoderConfiguration(config.encoderConfig) : {});
	  logger.info("create custom audio track success with config", config, "trackId", track.getTrackId());
	  executor.onSuccess(track.getTrackId());
	  return track;
	}
	function createMicrophoneAudioTrack(config) {
	  if (config === void 0) {
	    config = {};
	  }

	  return __awaiter$x(this, void 0, void 0, function () {
	    var executor, constraints, trackId, track, stream, e_1, err, micTrack;
	    return __generator$x(this, function (_a) {
	      switch (_a.label) {
	        case 0:
	          executor = report.reportApiInvoke(null, {
	            tag: AgoraAPITag.TRACER,
	            name: AgoraAPIName.CREATE_MIC_AUDIO_TRACK,
	            options: [config]
	          });
	          constraints = getConstraintsFromMicrophoneConfig(config);
	          trackId = getRandomString(8, "track-");
	          track = null;
	          logger.info("start create microphone audio track with config", stringify$2(config), "trackId", trackId);
	          _a.label = 1;

	        case 1:
	          _a.trys.push([1, 3,, 4]);

	          return [4
	          /*yield*/
	          , getLocalStream({
	            audio: constraints
	          }, trackId)];

	        case 2:
	          stream = _a.sent();
	          track = stream.getAudioTracks()[0] || null;
	          return [3
	          /*break*/
	          , 4];

	        case 3:
	          e_1 = _a.sent();
	          executor.onError(e_1);
	          throw e_1;

	        case 4:
	          if (!track) {
	            err = new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_ERROR, "can not find track in media stream");
	            executor.onError(err);
	            return [2
	            /*return*/
	            , err.throw()];
	          }

	          micTrack = new MicrophoneAudioTrack(track, config, constraints, trackId);
	          executor.onSuccess(micTrack.getTrackId());
	          logger.info("create microphone audio track success, trackId:", trackId);
	          return [2
	          /*return*/
	          , micTrack];
	      }
	    });
	  });
	}
	function createBufferSourceAudioTrack(config) {
	  return __awaiter$x(this, void 0, void 0, function () {
	    var executor, trackId, originSource, _a, e_2, audioBufferSource, track;

	    return __generator$x(this, function (_b) {
	      switch (_b.label) {
	        case 0:
	          executor = report.reportApiInvoke(null, {
	            tag: AgoraAPITag.TRACER,
	            name: AgoraAPIName.CREATE_BUFFER_AUDIO_TRACK,
	            options: [config]
	          });
	          trackId = getRandomString(8, "track-");
	          logger.info("start create buffer source audio track with config", stringify$2(config), "trackId", trackId);
	          originSource = config.source;
	          if (!!(config.source instanceof AudioBuffer)) return [3
	          /*break*/
	          , 4];
	          _b.label = 1;

	        case 1:
	          _b.trys.push([1, 3,, 4]);

	          _a = config;
	          return [4
	          /*yield*/
	          , createAudioBuffer(config.source, config.cacheOnlineFile)];

	        case 2:
	          _a.source = _b.sent();
	          return [3
	          /*break*/
	          , 4];

	        case 3:
	          e_2 = _b.sent();
	          executor.onError(e_2);
	          return [2
	          /*return*/
	          , e_2.throw()];

	        case 4:
	          audioBufferSource = new AudioBufferSource(config.source);
	          track = new BufferSourceAudioTrack(originSource, audioBufferSource, config.encoderConfig ? getAudioEncoderConfiguration(config.encoderConfig) : {}, trackId);
	          logger.info("create buffer source audio track success, trackId:", trackId);
	          executor.onSuccess(track.getTrackId());
	          return [2
	          /*return*/
	          , track];
	      }
	    });
	  });
	}
	function createCustomVideoTrack(config) {
	  var executor = report.reportApiInvoke(null, {
	    tag: AgoraAPITag.TRACER,
	    name: AgoraAPIName.CREATE_CUSTOM_VIDEO_TRACK,
	    options: [config]
	  });
	  var track = new LocalVideoTrack(config.mediaStreamTrack, {
	    bitrateMax: config.bitrateMax,
	    bitrateMin: config.bitrateMin
	  }, config.optimizationMode);
	  executor.onSuccess(track.getTrackId());
	  logger.info("create custom video track success with config", config, "trackId", track.getTrackId());
	  return track;
	}
	function createCameraVideoTrack(config) {
	  if (config === void 0) {
	    config = {};
	  }

	  return __awaiter$x(this, void 0, void 0, function () {
	    var executor, constraints, trackId, track, stream, e_3, err, camTrack;
	    return __generator$x(this, function (_a) {
	      switch (_a.label) {
	        case 0:
	          executor = report.reportApiInvoke(null, {
	            tag: AgoraAPITag.TRACER,
	            name: AgoraAPIName.CREATE_CAM_VIDEO_TRACK,
	            options: [__assign$e({}, config)]
	          });
	          constraints = getConstraintsFromCameraConfig(config);
	          trackId = getRandomString(8, "track-");
	          track = null;
	          logger.info("start create camera video track with config", stringify$2(config), "trackId", trackId);
	          _a.label = 1;

	        case 1:
	          _a.trys.push([1, 3,, 4]);

	          return [4
	          /*yield*/
	          , getLocalStream({
	            video: constraints
	          }, trackId)];

	        case 2:
	          stream = _a.sent();
	          track = stream.getVideoTracks()[0] || null;
	          return [3
	          /*break*/
	          , 4];

	        case 3:
	          e_3 = _a.sent();
	          executor.onError(e_3);
	          throw e_3;

	        case 4:
	          if (!track) {
	            err = new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_ERROR, "can not find track in media stream");
	            executor.onError(err);
	            return [2
	            /*return*/
	            , err.throw()];
	          }

	          if (config.optimizationMode) {
	            videoTrackOptimizationModeProcess(trackId, track, config, config.encoderConfig && getVideoEncoderConfiguration(config.encoderConfig));
	          }

	          camTrack = new CameraVideoTrack(track, config, constraints, config.optimizationMode, trackId);
	          executor.onSuccess(camTrack.getTrackId());
	          logger.info("create camera video success, trackId:", trackId);
	          return [2
	          /*return*/
	          , camTrack];
	      }
	    });
	  });
	}
	function createMicrophoneAndCameraTracks(audioConfig, videoConfig) {
	  if (audioConfig === void 0) {
	    audioConfig = {};
	  }

	  if (videoConfig === void 0) {
	    videoConfig = {};
	  }

	  return __awaiter$x(this, void 0, void 0, function () {
	    var executor, videoConstraints, audioConstraints, audioTrackId, videoTrackId, audioTrack, videoTrack, stream, e_4, err, micTrack, camTrack;
	    return __generator$x(this, function (_a) {
	      switch (_a.label) {
	        case 0:
	          executor = report.reportApiInvoke(null, {
	            tag: AgoraAPITag.TRACER,
	            name: AgoraAPIName.CREATE_MIC_AND_CAM_TRACKS,
	            options: [audioConfig, videoConfig]
	          });
	          videoConstraints = getConstraintsFromCameraConfig(videoConfig);
	          audioConstraints = getConstraintsFromMicrophoneConfig(audioConfig);
	          audioTrackId = getRandomString(8, "track-");
	          videoTrackId = getRandomString(8, "track-");
	          audioTrack = null;
	          videoTrack = null;
	          logger.info("start create camera video track(" + videoTrackId + ") and microphone audio track(" + audioTrackId + ") with config, audio: " + stringify$2(audioConfig) + ", video: " + stringify$2(videoConfig));
	          _a.label = 1;

	        case 1:
	          _a.trys.push([1, 3,, 4]);

	          return [4
	          /*yield*/
	          , getLocalStream({
	            audio: audioConstraints,
	            video: videoConstraints
	          }, audioTrackId + "-" + videoTrackId)];

	        case 2:
	          stream = _a.sent();
	          audioTrack = stream.getAudioTracks()[0];
	          videoTrack = stream.getVideoTracks()[0];
	          return [3
	          /*break*/
	          , 4];

	        case 3:
	          e_4 = _a.sent();
	          executor.onError(e_4);
	          throw e_4;

	        case 4:
	          if (!audioTrack || !videoTrack) {
	            err = new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_ERROR, "can not find tracks in media stream");
	            executor.onError(err);
	            return [2
	            /*return*/
	            , err.throw()];
	          }

	          if (videoConfig.optimizationMode) {
	            videoTrackOptimizationModeProcess(videoTrackId, videoTrack, videoConfig, videoConfig.encoderConfig && getVideoEncoderConfiguration(videoConfig.encoderConfig));
	          }

	          micTrack = new MicrophoneAudioTrack(audioTrack, audioConfig, audioConstraints, audioTrackId);
	          camTrack = new CameraVideoTrack(videoTrack, videoConfig, videoConstraints, videoConfig.optimizationMode, videoTrackId);
	          executor.onSuccess([micTrack.getTrackId(), camTrack.getTrackId()]);
	          logger.info("create camera video track(" + videoTrackId + ") and microphone audio track(" + audioTrackId + ") success");
	          return [2
	          /*return*/
	          , [micTrack, camTrack]];
	      }
	    });
	  });
	}
	function createScreenVideoTrack(config, withAudio) {
	  if (config === void 0) {
	    config = {};
	  }

	  if (withAudio === void 0) {
	    withAudio = "disable";
	  }

	  return __awaiter$x(this, void 0, void 0, function () {
	    var executor, constraints, trackId, track, audioTrack, compat, err, stream, e_5, err, err, videoTrack, screenAudioTrack;
	    return __generator$x(this, function (_a) {
	      switch (_a.label) {
	        case 0:
	          executor = report.reportApiInvoke(null, {
	            tag: AgoraAPITag.TRACER,
	            name: AgoraAPIName.CREATE_SCREEN_VIDEO_TRACK,
	            options: [__assign$e({}, config), withAudio]
	          });

	          if (!config.encoderConfig) {
	            config.encoderConfig = "1080p_2";
	          } else if (typeof config.encoderConfig !== "string" && (!config.encoderConfig.width || !config.encoderConfig.height)) {
	            config.encoderConfig.width = {
	              max: 1920
	            };
	            config.encoderConfig.height = {
	              max: 1080
	            };
	          }

	          constraints = getConstraintsFromScreenConfig(config);
	          trackId = getRandomString(8, "track-");
	          track = null;
	          audioTrack = null;
	          compat = getCompatibility();

	          if (!compat.supportShareAudio && withAudio === "enable") {
	            err = new AgoraRTCError(AgoraRTCErrorCode.NOT_SUPPORTED, "your browser or platform is not support share-screen with audio");
	            executor.onError(err);
	            return [2
	            /*return*/
	            , err.throw()];
	          }

	          logger.info("start create screen video track with config", config, "withAudio", withAudio, "trackId", trackId);
	          _a.label = 1;

	        case 1:
	          _a.trys.push([1, 3,, 4]);

	          return [4
	          /*yield*/
	          , getLocalStream({
	            screen: constraints,
	            screenAudio: withAudio === "auto" ? compat.supportShareAudio : withAudio === "enable"
	          }, trackId)];

	        case 2:
	          stream = _a.sent();
	          track = stream.getVideoTracks()[0] || null;
	          audioTrack = stream.getAudioTracks()[0] || null;
	          return [3
	          /*break*/
	          , 4];

	        case 3:
	          e_5 = _a.sent();
	          executor.onError(e_5);
	          throw e_5;

	        case 4:
	          if (!track) {
	            err = new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_ERROR, "can not find track in media stream");
	            executor.onError(err);
	            return [2
	            /*return*/
	            , err.throw()];
	          }

	          if (!audioTrack && withAudio === "enable") {
	            track && track.stop();
	            err = new AgoraRTCError(AgoraRTCErrorCode.SHARE_AUDIO_NOT_ALLOWED);
	            executor.onError(err);
	            return [2
	            /*return*/
	            , err.throw()];
	          }
	          /** 屏幕共享默认清晰优先 */


	          if (!config.optimizationMode) {
	            config.optimizationMode = "detail";
	          }

	          if (config.optimizationMode) {
	            videoTrackOptimizationModeProcess(trackId, track, config, config.encoderConfig && getScreenEncoderConfiguration(config.encoderConfig));

	            if (config.encoderConfig && typeof config.encoderConfig !== "string") {
	              config.encoderConfig.bitrateMin = config.encoderConfig.bitrateMax;
	            }
	          }

	          videoTrack = new LocalVideoTrack(track, config.encoderConfig ? getScreenEncoderConfiguration(config.encoderConfig) : {}, config.optimizationMode, trackId);

	          videoTrack._hints.push(TrackHint.SCREEN_TRACK);

	          if (!audioTrack) {
	            executor.onSuccess(videoTrack.getTrackId());
	            logger.info("create screen video track success", "video:", videoTrack.getTrackId());
	            return [2
	            /*return*/
	            , videoTrack];
	          }

	          screenAudioTrack = new LocalAudioTrack(audioTrack);
	          executor.onSuccess([videoTrack.getTrackId(), screenAudioTrack.getTrackId()]);
	          logger.info("create screen video track success", "video:", videoTrack.getTrackId(), "audio:", screenAudioTrack.getTrackId());
	          return [2
	          /*return*/
	          , [videoTrack, screenAudioTrack]];
	      }
	    });
	  });
	}

	function videoTrackOptimizationModeProcess(trackId, track, config, encoderConfig) {
	  if (!config.optimizationMode) return;

	  if (encoderConfig && encoderConfig.width && encoderConfig.height) {
	    var bitrateConfig = getBestBitrateFromEncoderConfig(config.optimizationMode, encoderConfig);
	    config.encoderConfig = __assign$e(__assign$e({}, encoderConfig), {
	      bitrateMin: bitrateConfig.min,
	      bitrateMax: bitrateConfig.max
	    });
	    /**
	     * 将 contentHint 设置成 detail 会导致正常网络情况下帧率也会降低
	     * 所以之后 fps < 10 时才设置这个值
	     */

	    if (config.optimizationMode === "motion" || config.optimizationMode === "detail" && encoderConfig.frameRate && constrainLongToNumber(encoderConfig.frameRate) < 10) {
	      // @ts-ignore
	      track.contentHint = config.optimizationMode; // @ts-ignore

	      if (track.contentHint === config.optimizationMode) {
	        logger.debug("[" + trackId + "] set content hint to", config.optimizationMode);
	      } else {
	        logger.debug("[" + trackId + "] set content hint failed");
	      }
	    }
	  } else {
	    logger.warning("[" + trackId + "] can not apply optimization mode bitrate config, no encoderConfig");
	  }
	}

	var setInterval = path.setInterval;

	var setInterval$1 = setInterval;

	var __awaiter$y = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = promise$3))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var __generator$y = undefined && undefined.__generator || function (thisArg, body) {
	  var _ = {
	    label: 0,
	    sent: function () {
	      if (t[0] & 1) throw t[1];
	      return t[1];
	    },
	    trys: [],
	    ops: []
	  },
	      f,
	      y,
	      t,
	      g;
	  return g = {
	    next: verb(0),
	    "throw": verb(1),
	    "return": verb(2)
	  }, typeof symbol$2 === "function" && (g[iterator$2] = function () {
	    return this;
	  }), g;

	  function verb(n) {
	    return function (v) {
	      return step([n, v]);
	    };
	  }

	  function step(op) {
	    if (f) throw new TypeError("Generator is already executing.");

	    while (_) try {
	      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	      if (y = 0, t) op = [op[0] & 2, t.value];

	      switch (op[0]) {
	        case 0:
	        case 1:
	          t = op;
	          break;

	        case 4:
	          _.label++;
	          return {
	            value: op[1],
	            done: false
	          };

	        case 5:
	          _.label++;
	          y = op[1];
	          op = [0];
	          continue;

	        case 7:
	          op = _.ops.pop();

	          _.trys.pop();

	          continue;

	        default:
	          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
	            _ = 0;
	            continue;
	          }

	          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
	            _.label = op[1];
	            break;
	          }

	          if (op[0] === 6 && _.label < t[1]) {
	            _.label = t[1];
	            t = op;
	            break;
	          }

	          if (t && _.label < t[2]) {
	            _.label = t[2];

	            _.ops.push(op);

	            break;
	          }

	          if (t[2]) _.ops.pop();

	          _.trys.pop();

	          continue;
	      }

	      op = body.call(thisArg, _);
	    } catch (e) {
	      op = [6, e];
	      y = 0;
	    } finally {
	      f = t = 0;
	    }

	    if (op[0] & 5) throw op[1];
	    return {
	      value: op[0] ? op[1] : void 0,
	      done: true
	    };
	  }
	};
	var browserName = getBrowserInfo().name;
	function checkVideoTrackIsActive(track, timeout) {
	  if (timeout === void 0) {
	    timeout = 5000;
	  }

	  return __awaiter$y(this, void 0, void 0, function () {
	    var executor, err, endCount, deviceLabel, mediaStreamTrack, videoEl, canvasEl, changedPicNum, duration, startTime, e_1, result, uploadReport;
	    return __generator$y(this, function (_a) {
	      switch (_a.label) {
	        case 0:
	          executor = report.reportApiInvoke(null, {
	            tag: AgoraAPITag.TRACER,
	            name: AgoraAPIName.CHECK_VIDEO_TRACK_IS_ACTIVE,
	            options: [timeout]
	          });

	          if (!(track instanceof LocalVideoTrack) && !(track instanceof RemoteVideoTrack)) {
	            err = new AgoraRTCError(AgoraRTCErrorCode.INVALID_TRACK, "the parameter is not a video track");
	            executor.onError(err);
	            return [2
	            /*return*/
	            , err.throw()];
	          }

	          endCount = 4; // 超时时间最少1秒。

	          if (timeout && timeout < 1000) {
	            timeout = 1000;
	          }

	          deviceLabel = track instanceof LocalVideoTrack ? track.getTrackLabel() : "remote_track";
	          mediaStreamTrack = track.getMediaStreamTrack();
	          videoEl = document.createElement("video");
	          videoEl.style.width = "1px";
	          videoEl.style.height = "1px";
	          videoEl.setAttribute("muted", "");
	          videoEl.muted = true;
	          videoEl.setAttribute("playsinline", "");
	          videoEl.controls = false;

	          if (browserName === BrowserName.SAFARI) {
	            videoEl.style.opacity = "0.01";
	            videoEl.style.position = "fixed";
	            videoEl.style.left = "0";
	            videoEl.style.top = "0";
	            document.body.appendChild(videoEl);
	          }

	          videoEl.srcObject = new MediaStream([mediaStreamTrack]);
	          videoEl.play();
	          canvasEl = document.createElement("canvas");
	          canvasEl.width = 160;
	          canvasEl.height = 120;
	          changedPicNum = 0;
	          duration = 0;
	          _a.label = 1;

	        case 1:
	          _a.trys.push([1, 3,, 4]);

	          startTime = now$2();
	          return [4
	          /*yield*/
	          , videoObjectiveDetect(videoEl, timeout, canvasEl, endCount)];

	        case 2:
	          changedPicNum = _a.sent();
	          duration = now$2() - startTime;
	          return [3
	          /*break*/
	          , 4];

	        case 3:
	          e_1 = _a.sent();
	          executor.onError(e_1);
	          throw e_1;

	        case 4:
	          if (browserName === BrowserName.SAFARI) {
	            videoEl.pause();
	            videoEl.remove();
	          }

	          videoEl.srcObject = null;
	          result = changedPicNum > endCount;
	          uploadReport = {
	            duration: duration,
	            changedPicNum: changedPicNum,
	            deviceLabel: deviceLabel,
	            result: result
	          };
	          logger.info("[track-" + track.getTrackId() + "] check video track active completed. " + stringify$2(uploadReport));
	          executor.onSuccess(uploadReport);
	          return [2
	          /*return*/
	          , result];
	      }
	    });
	  });
	}
	/**
	 * 使用Canvas捕获视频帧，并统计当前帧与上一帧rgba不同的帧数目。
	 *
	 * @param videoEl HTMLVideoElement
	 * @param countTime 检测超时时间。
	 * @param canvas HTMLCanvasElement
	 * @param endCount 预定的视频图像变换次数，超过之后完成检测。
	 */

	function videoObjectiveDetect(videoEl, countTime, canvas, endCount) {
	  var cancelLoop;
	  var changedPicNum = 0;
	  var tempVideoFrame = null;
	  return new promise$3(function (resolve, reject) {
	    function _captureVideoFrame() {
	      // 检测到视频图像变换次数大于预定停止次数，完成检测。
	      if (changedPicNum > endCount) {
	        if (cancelLoop) {
	          cancelLoop();
	          resolve(changedPicNum);
	        }
	      }

	      var ctx = canvas.getContext("2d");

	      if (!ctx) {
	        var err = new AgoraRTCError(AgoraRTCErrorCode.UNEXPECTED_ERROR, "can not get canvas 2d context.");
	        logger.error(err.toString());
	        reject(err);
	        return;
	      }

	      ctx.drawImage(videoEl, 0, 0, 160, 120);
	      var frame = ctx.getImageData(0, 0, canvas.width, canvas.height);
	      var l = Math.floor(frame.data.length / 3);

	      if (!tempVideoFrame) {
	        tempVideoFrame = frame.data;
	        return;
	      }

	      for (var i = 0; i < l; i += 3) {
	        if (frame.data[i] !== tempVideoFrame[i]) {
	          changedPicNum += 1;
	          tempVideoFrame = frame.data;
	          return;
	        }
	      }

	      tempVideoFrame = frame.data;
	      return;
	    } // 检测超时，停止检测。


	    setTimeout$2(function () {
	      if (cancelLoop) {
	        cancelLoop();
	        resolve(changedPicNum);
	      }
	    }, countTime);

	    cancelLoop = audioTimerLoop(function () {
	      _captureVideoFrame();
	    }, 30);
	  });
	}

	function checkAudioTrackIsActive(track, timeout) {
	  if (timeout === void 0) {
	    timeout = 5000;
	  }

	  return __awaiter$y(this, void 0, void 0, function () {
	    var executor, err, deviceLabel, tempVolumeLevel, maxVolumeLevel, minVolumeLevel, startTime;
	    return __generator$y(this, function (_a) {
	      executor = report.reportApiInvoke(null, {
	        tag: AgoraAPITag.TRACER,
	        name: AgoraAPIName.CHECK_AUDIO_TRACK_IS_ACTIVE,
	        options: [timeout]
	      });

	      if (!(track instanceof LocalAudioTrack) && !(track instanceof RemoteAudioTrack)) {
	        err = new AgoraRTCError(AgoraRTCErrorCode.INVALID_TRACK, "the parameter is not a audio track");
	        executor.onError(err);
	        return [2
	        /*return*/
	        , err.throw()];
	      } // 超时时间最少1秒。


	      if (timeout && timeout < 1000) {
	        timeout = 1000;
	      }

	      deviceLabel = track instanceof LocalAudioTrack ? track.getTrackLabel() : "remote_track";
	      tempVolumeLevel = track.getVolumeLevel();
	      maxVolumeLevel = tempVolumeLevel;
	      minVolumeLevel = tempVolumeLevel;
	      startTime = now$2();
	      return [2
	      /*return*/
	      , new promise$3(function (resolve) {
	        var interval = setInterval$1(function () {
	          var volumeLevel = track.getVolumeLevel();
	          maxVolumeLevel = volumeLevel > maxVolumeLevel ? volumeLevel : maxVolumeLevel;
	          minVolumeLevel = volumeLevel < minVolumeLevel ? volumeLevel : minVolumeLevel;
	          /**
	           * 远端流静音时获取到的音量约是 0.000034 - 0.000035。这里设置音量等级变动大于0.0001时认为音频活跃。
	           * 如果极为安静的环境可能检测失败（所以开发者使用该接口的时候要提示用户发出声响）。
	           */

	          var volumeChanged = maxVolumeLevel - minVolumeLevel > 0.0001;
	          var duration = now$2() - startTime;

	          if (volumeChanged || duration > timeout) {
	            clearInterval(interval);
	            var result = volumeChanged;
	            var uploadReport = {
	              duration: duration,
	              deviceLabel: deviceLabel,
	              maxVolumeLevel: maxVolumeLevel,
	              result: result
	            };
	            logger.info("[track-" + track.getTrackId() + "] check audio track active completed. " + stringify$2(uploadReport));
	            executor.onSuccess(uploadReport);
	            resolve(result);
	          }
	        }, 200);
	      })];
	    });
	  });
	}

	setParameter("PROCESS_ID", generateProcessID());
	updateAgoraRTCCompatibility();

	function getDevices(skipPermissionCheck) {
	  return deviceManager.enumerateDevices(true, true, skipPermissionCheck);
	}

	function getMicrophones(skipPermissionCheck) {
	  return deviceManager.getRecordingDevices(skipPermissionCheck);
	}

	function getCameras(skipPermissionCheck) {
	  return deviceManager.getCamerasDevices(skipPermissionCheck);
	}

	function getPlaybackDevices(skipPermissionCheck) {
	  return deviceManager.getSpeakers(skipPermissionCheck);
	}

	function createChannelMediaRelayConfiguration() {
	  return new ChannelMediaRelayConfiguration();
	}

	function setLogLevel(level) {
	  logger.setLogLevel(level);
	}

	function enableLogUpload() {
	  logger.enableLogUpload();
	}

	function disableLogUpload() {
	  logger.disableLogUpload();
	}

	var AgoraRTC = {
	  VERSION: VERSION,
	  BUILD: BUILD,
	  setParameter: setParameter,
	  getSupportedCodec: getSupportedCodec,
	  checkSystemRequirements: checkSystemRequirements,
	  getDevices: getDevices,
	  getMicrophones: getMicrophones,
	  getCameras: getCameras,
	  getElectronScreenSources: getElectronScreenSources,
	  getPlaybackDevices: getPlaybackDevices,
	  createClient: createClient,
	  createCameraVideoTrack: createCameraVideoTrack,
	  createCustomVideoTrack: createCustomVideoTrack,
	  createScreenVideoTrack: createScreenVideoTrack,
	  createMicrophoneAndCameraTracks: createMicrophoneAndCameraTracks,
	  createMicrophoneAudioTrack: createMicrophoneAudioTrack,
	  createCustomAudioTrack: createCustomAudioTrack,
	  createBufferSourceAudioTrack: createBufferSourceAudioTrack,
	  setLogLevel: setLogLevel,
	  enableLogUpload: enableLogUpload,
	  disableLogUpload: disableLogUpload,
	  createChannelMediaRelayConfiguration: createChannelMediaRelayConfiguration,
	  checkAudioTrackIsActive: checkAudioTrackIsActive,
	  checkVideoTrackIsActive: checkVideoTrackIsActive,
	  setArea: setArea
	};
	deviceManager.on(DeviceManagerEvent.CAMERA_DEVICE_CHANGED, function (info) {
	  logger.info("camera device changed", stringify$2(info));
	  AgoraRTC.onCameraChanged && AgoraRTC.onCameraChanged(info);
	});
	deviceManager.on(DeviceManagerEvent.RECORDING_DEVICE_CHANGED, function (info) {
	  logger.info("microphone device changed", stringify$2(info));
	  AgoraRTC.onMicrophoneChanged && AgoraRTC.onMicrophoneChanged(info);
	});
	deviceManager.on(DeviceManagerEvent.PLAYOUT_DEVICE_CHANGED, function (info) {
	  logger.debug("playout device changed", stringify$2(info));
	  AgoraRTC.onPlaybackDeviceChanged && AgoraRTC.onPlaybackDeviceChanged(info);
	});

	audioElementPlayCenter.onAutoplayFailed = function () {
	  logger.info("detect audio element autoplay failed");
	  AgoraRTC.onAudioAutoplayFailed && AgoraRTC.onAudioAutoplayFailed();
	};

	audioContextStateChangeEmitter.on("autoplay-failed", function () {
	  logger.info("detect webaudio autoplay failed");
	  AgoraRTC.onAudioAutoplayFailed && AgoraRTC.onAudioAutoplayFailed();
	});

	return AgoraRTC;

})));
//# sourceMappingURL=AgoraRTC_N-production.js.map
